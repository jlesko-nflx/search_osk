

// -- msl.js
/**
* @param {undefined=} undefined
*/
(function (window, undefined) {

    // Note: do not use variable named "crypto", it gets overriden when running in global scope in chrome
    var nfCrypto = window['nfCrypto'] || window['msCrypto'] || window['webkitCrypto'] || window['crypto'],
        cryptoSubtle = nfCrypto && (nfCrypto['webkitSubtle'] || nfCrypto['subtle']),
        cryptokeys = window['nfCryptokeys'] || window['msCryptokeys'] || window['webkitCryptokeys'] || window['cryptokeys'];

// -- javascript/lib/asnjwk.concat.js
(function (global) {
/** @const */
var DEBUG=false;
//================================================================================
// util.js

/** @const */
//var DEBUG_BREAK_ON_ERROR = true;
var DEBUG_BREAK_ON_ERROR = false;

function debugLog(message) {
  console.log(message);
};

function debugAssert(b, message) {
  if (!b) {
    if (DEBUG_BREAK_ON_ERROR) {
      debugger;
    }
    debugLog(message || 'Assertion failed');
  }
};

function hexDump(abv, idx, len) {
    var hexDigits = "0123456789ABCDEF";
    function hexByte(b) {
        return hexDigits.charAt((b >> 4) & 0xF) + hexDigits.charAt(b & 0xF);
    };
    var start = idx || 0;
    var end = len ? start + len : abv.length;
    var s = "";
    if (end > abv.length) return s;
    for (var i = start; i < end; ++i) {
        s += hexByte(abv[i]);
    }
    return s;
};

//================================================================================
// abvStream.js

/** @type {{Util:Object}} */

var AbvStream = (function () {
"use strict";

function My(input, position) {
    if (input instanceof AbvStream) {
        DEBUG && debugAssert(!position);
        this.abv = input.abv;
        this.position = input.position;
    } else {
        this.abv = input;
        this.position = position || 0;
    }
};

My.prototype = {
    readByte: function () {
        return this.abv[this.position++];
    },
    
    writeByte: function (byte) {
        DEBUG && debugAssert(this.getRemaining() >= 1);
        this.abv[this.position++] = byte;
    },
    
    peekByte: function (position) {
        DEBUG && debugAssert(position >= 0 && position <= this.abv.length);
        return this.abv[position];
    },
    
    copyBytes: function(srcAbv, srcOffset, nBytes) {
        DEBUG && debugAssert(this.getRemaining() >= nBytes);
        var dstU8 = new Uint8Array(this.abv.buffer, this.position, nBytes);
        var srcU8 = new Uint8Array(srcAbv.buffer, srcOffset, nBytes);
        dstU8.set(srcU8);
        this.position += nBytes;
    },
    
    seek: function (position) {
        DEBUG && debugAssert(position >= 0 && position <= this.abv.length);
        this.position = position;
    },

    skip: function (bytesToSkip) {
        DEBUG && debugAssert(bytesToSkip <= this.getRemaining());
        this.position += bytesToSkip;
    },

    getPosition: function () {
        return this.position;
    },
    
    setPosition: function (position) {
        DEBUG && debugAssert(position <= this.abv.length);
        this.position = position;
    },

    getRemaining: function () {
        return this.abv.length - this.position;
    },

    getLength: function () {
        return this.abv.length;
    },

    isEndOfStream: function () {
        return this.position >= this.abv.length;
    },
    
    show: function () {
        var output = "AbvStream: pos ";
        output += this.getPosition().toString() + " of " + this.getLength().toString();
        return output;
    }
};

return My;

}());
//================================================================================
// asn1.js

var ASN1 = {};

(function () {
"use strict";

/** @enum {number} */
var tagClass = {
        UNIVERSAL: 0,
        APPLICATION: 1,
        CONTEXT_SPECIFIC: 2,
        PRIVATE: 3,
    };

/** @enum {number} */
var tagVal = {
        BER: 0,
        BOOLEAN: 1,
        INTEGER: 2,
        BIT_STRING: 3,
        OCTET_STRING: 4,
        NULL: 5,
        OBJECT_IDENTIFIER: 6,
        OBJECT_DESCRIPTOR: 7,
        INSTANCE_OF_EXTERNAL: 8,
        REAL: 9,
        ENUMERATED: 10,
        EMBEDDED_PPV: 11,
        UTF8_STRING: 12,
        RELATIVE_OID: 13,
        // 14 & 15 undefined
        SEQUENCE: 16,
        SET: 17,
        NUMERIC_STRING: 18,
        PRINTABLE_STRING: 19,
        TELETEX_STRING: 20,
        T61_STRING: 20,
        VIDEOTEX_STRING: 21,
        IA5_STRING: 22,
        UTC_TIME: 23,
        GENERALIZED_TIME: 24,
        GRAPHIC_STRING: 25,
        VISIBLE_STRING: 26,
        ISO64_STRING: 26,
        GENERAL_STRING: 27,
        UNIVERSAL_STRING: 28,
        CHARACTER_STRING: 29,
        BMP_STRING: 30
    };

/** @const */
var tagText = [];
tagText[tagVal.BER                 ] = 'BER';
tagText[tagVal.BOOLEAN             ] = 'BOOLEAN';
tagText[tagVal.INTEGER             ] = 'INTEGER';
tagText[tagVal.BIT_STRING          ] = 'BIT STRING';
tagText[tagVal.OCTET_STRING        ] = 'OCTET STRING';
tagText[tagVal.NULL                ] = 'NULL';
tagText[tagVal.OBJECT_IDENTIFIER   ] = 'OBJECT IDENTIFIER';
tagText[tagVal.OBJECT_DESCRIPTOR   ] = 'ObjectDescriptor';
tagText[tagVal.INSTANCE_OF_EXTERNAL] = 'INSTANCE OF, EXTERNAL';
tagText[tagVal.REAL                ] = 'REAL';
tagText[tagVal.ENUMERATED          ] = 'ENUMERATED';
tagText[tagVal.EMBEDDED_PPV        ] = 'EMBEDDED PPV';
tagText[tagVal.UTF8_STRING         ] = 'UTF8String';
tagText[tagVal.RELATIVE_OID        ] = 'RELATIVE-OID';
tagText[tagVal.SEQUENCE            ] = 'SEQUENCE';
tagText[tagVal.SET                 ] = 'SET, SET OF';
tagText[tagVal.NUMERIC_STRING      ] = 'NumericString';
tagText[tagVal.PRINTABLE_STRING    ] = 'PrintableString';
tagText[tagVal.TELETEX_STRING      ] = 'TeletexString, T61String';
tagText[tagVal.VIDEOTEX_STRING     ] = 'VideotexString';
tagText[tagVal.IA5_STRING          ] = 'IA5String';
tagText[tagVal.UTC_TIME            ] = 'UTCTime';
tagText[tagVal.GENERALIZED_TIME    ] = 'GeneralizedTime';
tagText[tagVal.GRAPHIC_STRING      ] = 'GraphicString';
tagText[tagVal.VISIBLE_STRING      ] = 'VisibleString, ISO64String';
tagText[tagVal.GENERAL_STRING      ] = 'GeneralString';
tagText[tagVal.UNIVERSAL_STRING    ] = 'UniversalString';
tagText[tagVal.CHARACTER_STRING    ] = 'CHARACTER STRING';
tagText[tagVal.BMP_STRING          ] = 'BMPString';

/**
 * Asn1Token
 * @param {ArrayBufferView=} abv The backing store.
 * @param {Object=} parent The parent token (optional).
 * @param {boolean=} constr bit 6 of the identifier byte (optional).
 * @param {?number=} tag bits 1-5 of the identifier byte (optional).
 * @param {?number=} didx index of the token's data in the source Uint8Array (optional).
 * @param {?number=} dlen length the data in bytes (optional).
 * @constructor
 */
var Asn1Token = function(abv, parent, constr, tag, didx, dlen) {
    this._data = abv;                    // the backing data store
    this._parent = parent || undefined;  // the parent token
    this._constructed = constr || false; // bit 6 of the identifier byte
    this._tagClass = tagClass.UNIVERSAL; // bits 7-8 of the identifier byte                    
    this._tag = tag || 0;                // bits 1-5 of the identifier byte                    
    this._dataIdx = didx || 0;           // index of the token's data in the source Uint8Array 
    this._dataLen = dlen || 0;           // length the data in bytes
};
Asn1Token.prototype = {
    _child: undefined,    // the first child of the current token, if present   
    _next: undefined,     // the next sibling of the current token, if present  

    get data() {
        DEBUG && debugAssert(this._data);
        return new Uint8Array(
            this._data.buffer.slice(this._dataIdx, this._dataIdx + this._dataLen)
        );
    },
    
    get backingStore() {return this._data;},
    
    get constructed() {return this._constructed;},
    set constructed(c) {this._constructed =  c !=0 ? true : false;},
    
    get tagClass() {return this._tagClass;},
    set tagClass(c) {this._tagClass = c;},
    
    get tag() {return this._tag;},
    set tag(c) {this._tag = c;},
    
    get dataIdx() {return this._dataIdx;},
    set dataIdx(c) {this._dataIdx = c;},
    
    get dataLen() {return this._dataLen;},
    set dataLen(c) {this._dataLen = c;},
    
    get child() {return this._child;},
    set child(c) {
        this._child = c;
        this._child.parent = this;
    },
    
    get next() {return this._next;},
    set next(c) {this._next = c;},
    
    get parent() {return this._parent;},
    set parent(c) {this._parent = c;},
    
    // Returns the payload size of the eventual encoding of this asn1token.
    get payloadLen() {
        var payloadLen = 0;
        if (this._child) {
            var child = this._child;
            while (child) {
                payloadLen += child.length;
                child = child.next;
            }
            // Special handling for bit string. In X.509 they always have a zero
            // padding byte prepended.
            if (this._tag == tagVal.BIT_STRING) {
                payloadLen++;
            }
        } else {  // no children
            switch (this._tag) {
                case tagVal.INTEGER:  {
                    // NOTE: NOT handling negative integers or non-byte multiple
                    payloadLen = this._dataLen;
                    // If the MSBit of the fitst byte is set, an extra zero byte
                    // will be prepended to the data.
                    if (this._data[this._dataIdx] >> 7)
                        payloadLen++;
                    break;
                }
                case tagVal.BIT_STRING:  {
                    // For X.509 bit strings are always a byte-multiple, and
                    // always have a zero padding byte prepended.
                    payloadLen = this._dataLen + 1;
                    break;
                }
                case tagVal.OCTET_STRING:  {
                    payloadLen = this._dataLen;
                    break;
                }
                case tagVal.NULL:  {
                    payloadLen = 0;
                    break;
                }
                case tagVal.OBJECT_IDENTIFIER:  {
                    // Only handling RSA Encryption OID.
                    if (oidIsRsaEncryption(this._data, this._dataIdx, this._dataLen)) {
                        payloadLen = 9;
                    } else {
                        DEBUG && debugAssert("Non RSA OID found");
                    }
                    break;
                }
                case tagVal.SET:
                case tagVal.SEQUENCE: {
                    DEBUG && debugAssert(false, "found constructed type " + tagText[this._tag] + " with no children");
                    break;
                }
                default: {
                    DEBUG && debugAssert(false, "unhandled type " + tagText[this._tag]);
                    break;
                }
            }
        }
        return payloadLen;
    },
    
    // Returns the total size of the eventual encoding of this asn1token.
    get length() {
        return derLength(this.payloadLen);
    },
    
    // Returns a Uint8Array representing the DER encoding of this asn1token.
    get der() {
        var encodingLength = this.length;
        if (!encodingLength) {
            DEBUG && debugLog("der: found zero length");
            return undefined;
        }
        var output = new Uint8Array(encodingLength);
        DEBUG && debugLog("created abv of length " + encodingLength);
        var stream = new AbvStream(output);
        if (!buildDer(this, stream)) {
            DEBUG && debugLog("der: buildDer failed");
            return undefined;
        }
        return output;
    },
    
    get nChildren() {
        var nChildren = 0;
        var token = this._child;
        while (token) {
            nChildren++;
            token = token.next;
        }
        return nChildren;
    }
    
};

// Returns the size of the eventual encoding of an Asn1Token with the given
// payload length. The returned size counts the header byte, length bytes,
// and payload.
function derLength(payloadLength) {
    var x;
    if (payloadLength > 127) {
        x = payloadLength;
        while (x) {
            x >>= 8;
            ++payloadLength;
        }
    }
    return payloadLength + 2;
}

// Writes an ASN.1 header byte and encoded length to a stream
function writeDerHeaderAndLength(asn1node, stream) {
    var tagByte = (asn1node.tagClass << 6) | (asn1node.constructed << 5) | asn1node.tag;
    stream.writeByte(tagByte);
    var payloadLen = asn1node.payloadLen;
    if (payloadLen < 128) {
        stream.writeByte(payloadLen);
    } else {
        // find length of length and write it
        var x = payloadLen;
        var nBytesInLen = 0;
        while (x) {
            ++nBytesInLen;
            x >>= 8;
        }
        stream.writeByte(0x80 | nBytesInLen);
        // write the multi-byte length
        for (var i=0; i < nBytesInLen; ++i) {
            var byteShift = nBytesInLen-i-1;
            stream.writeByte((payloadLen >> (byteShift * 8)) & 0xff);
        }
    }
}

// Builds a DER encoding of an Asn1Token, writing the bytes to the current
// position of the input stream.
function buildDer(node, stream) {
    writeDerHeaderAndLength(node, stream);
    if (node.child) {
        // Special handling for bit string, prepend a zero byte.
        if (node.tag == tagVal.BIT_STRING) {
            stream.writeByte(0);
        }
        var child = node._child;
        while (child) {
            if (!buildDer(child, stream)) {
                return false;
            }
            child = child.next;
        }
    }
    else {  // primitive node
        switch (node.tag) {
            case tagVal.INTEGER:  {
                // If the MSBit of the fitst byte is set, an extra zero byte
                // will be prepended to the data.
                if (node.backingStore[node.dataIdx] >> 7) {
                    stream.writeByte(0);
                }
                stream.copyBytes(node.backingStore, node.dataIdx, node.dataLen);
                break;
            }
            case tagVal.BIT_STRING:  {
                // For X.509 bit strings are always a byte-multiple, and
                // always have a zero padding byte prepended.
                stream.writeByte(0);
                stream.copyBytes(node.backingStore, node.dataIdx, node.dataLen);
                break;
            }
            case tagVal.OCTET_STRING:  {
                stream.copyBytes(node.backingStore, node.dataIdx, node.dataLen);
                break;
            }
            case tagVal.NULL:  {
                break;
            }
            case tagVal.OBJECT_IDENTIFIER:  {
                // We only handle RSA Encryption OID.
                DEBUG && debugAssert(oidIsRsaEncryption(node.backingStore, node.dataIdx, node.dataLen));
                stream.copyBytes(node.backingStore, node.dataIdx, node.dataLen);
                break;
            }
            case tagVal.SET:
            case tagVal.SEQUENCE: {
                DEBUG && debugAssert(false, "found constructed type " + tagText[node.tag] + " with no children");
                break;
            }
            default: {
                DEBUG && debugAssert(false, "unhandled type " + tagText[node.tag]);
                break;
            }
        }
    }
    return true;
};


//  var Asn1Token = function(abv, parent, constr, tag, didx, dlen)

var NodeFactory = {
    createSequenceNode: function() {
        return new Asn1Token(null, null, true, tagVal.SEQUENCE, null, null);
    },
    createOidNode: function(data) {
        return new Asn1Token(data, null, false, tagVal.OBJECT_IDENTIFIER, 0, data ? data.length : 0);
    },
    createNullNode: function() {
        return new Asn1Token(null, null, false, tagVal.NULL, null, null);
    },
    createBitStringNode: function(data) {
        return new Asn1Token(data, null, false, tagVal.BIT_STRING, 0, data ? data.length : 0);
        // might need to set constructed later
    },
    createIntegerNode: function(data) {
        return new Asn1Token(data, null, false, tagVal.INTEGER, 0, data ? data.length : 0);
    },
    createOctetStringNode: function(data) {
        return new Asn1Token(data, null, false, tagVal.OCTET_STRING, 0, data ? data.length : 0);
    }
};

/**
 * Builder
 * @param {Object} rootNode The root node.
 * @constructor
 */
var Builder = function(rootNode) {
    this._rootNode = rootNode;
    this._currentNode = rootNode;
};
Builder.prototype = {
    addChild: function(childNode) {
        this.addTo(this._currentNode, childNode);
    },
    addSibling: function(siblingNode) {
        this.addTo(this._currentNode.parent, siblingNode);
    },
    addTo: function(parentNode, childNode) {
        this._currentNode = childNode;
        this._currentNode.parent = parentNode;
        if (!parentNode.child) {
            parentNode.child = childNode;
        }
        else {
            var node = parentNode.child;
            while (node.next) {
                node = node.next;
            }
            node.next = childNode;
        }
    },
    addToParent: function(parentNode, childNode) {
        if (this.findNode(parentNode)) {
            this.addTo(parentNode, childNode);
        }
    },
    findNode: function(node) {
        var parentNode = this._currentNode;
        while (parentNode) {
            if (node == parentNode) {
                return true;
            }
            parentNode = parentNode.parent;
        }
        return false;
    }
};

function decodeTagByte(stream) {
    var tag = stream.readByte();
    if ((tag & 0x1F) == 0x1F) {
        var newTag = 0;
        while (tag & 0x80) {
            newTag <<= 8;
            newTag |= tag & 0x7F;
        }
        tag = newTag;
    }
    return tag;
}

function decodeLength(stream) {
    var buf = stream.readByte(),
        len = buf & 0x7F;
    if (len == buf)
        return len;
    // Refuse encoded lengths > 3 bytes and ensure encoded length is nonzero.
    if ( (len > 3) || (len === 0) ) {
        return -1;
    }
    buf = 0;
    for (var i = 0; i < len; ++i)
        buf = (buf << 8) | stream.readByte();
    return buf;
};

function hasContent(stream, tag, len) {
    if (tag & 0x20)
        return true; // constructed
    if ((tag < tagVal.BIT_STRING) || (tag > tagVal.OCTET_STRING))
        return false;
    var s = new AbvStream(stream);
    if (tag == tagVal.BIT_STRING)
        s.skip(1); // BitString unused bits, must be in [0, 7]
    var subTag = s.readByte();
    if ((subTag >> 6) & 0x01)
        return false; // not (universal or context)
    var subLength = decodeLength(s);
    var isContent = ((s.getPosition() - stream.getPosition()) + subLength == len);
    return isContent;
};

var asn1ParseRecursionDepth = 0,
    asn1ParseMaxRecursionDepth = 8;

function asn1Parse(rootToken, start, len) {
    var abv = rootToken.backingStore,
        stream = new AbvStream(abv, start),
        tokenEndIdx = start + len,
        token = rootToken,
        tagByte,
        tokenTag,
        tokenLength,
        tokenStartIdx,
        subIdx,
        subLength,
        curIdx;
    
    if (asn1ParseRecursionDepth++ > asn1ParseMaxRecursionDepth) {
        DEBUG && debugLog("asn1Parse max recursion depth exceeded");
        return undefined;
    }
    
    DEBUG && debugLog("==================== asn1Parse ENTER ====================");
    DEBUG && debugLog(stream.show() + ", len = " + len);
    
    while (stream.getPosition() < tokenEndIdx) {
        
        DEBUG && debugAssert(!stream.isEndOfStream());
        
        DEBUG && debugLog("---- token ----");
        DEBUG && debugLog(stream.show());
        
        tokenStartIdx = stream.getPosition();

        // The first byte of the token is the tagByte.
        tagByte = decodeTagByte(stream);
        tokenTag = tagByte & 0x1F;
        if (tokenTag < 0 || tokenTag > 30) {
            DEBUG && debugLog("Invalid tag found at position " + (stream.getPosition() - 1));
            return undefined;
        }
        
        // The next few bytes are the data length (vle).
        tokenLength = decodeLength(stream);
        if ( (tokenLength < 0) || (tokenLength > stream.getRemaining()) ) {
            DEBUG && debugLog("Invalid length found at position " + (stream.getPosition() - 1));
            return undefined;
        }
        
        // The remaining bytes are the payload. We have enough info now to fill
        // in the token object.
        token.constructed = tagByte & 0x20;;
        token.tagClass = (tagByte & 0xC0) >> 6;
        token.tag = tokenTag;
        token.dataLen = tokenLength;
        token.dataIdx = stream.getPosition();
        DEBUG && debugLog(tagText[token.tag] + " (" + token.dataIdx + "," + token.dataLen + ")");
        
        // If the current token has content, its data is another ASN.1 object.
        if (hasContent(stream, tagByte, tokenLength)) {
            
            DEBUG && debugLog("(has content)");
            
            // Move the token data pointer back and adjust the token length to,
            // include the entire item, since we've already advanced into it.
            //token.dataIdx = tokenStartIdx;
            //token.dataLen = tokenLength + (stream['getPosition']() - tokenStartIdx);
            
            // Prepare to parse the first subtoken.
            subIdx = stream.getPosition();
            subLength = tokenLength;
            
            // Special case for bit string: The first byte of a bit string is
            // the number of unused (padding) bits at the end. For X.509 this is
            // always zero, so just ignore it. To do this, we need to adjust
            // index and length of the current token, and since we are about to
            // recurse into it, the first subtoken to be parsed as well.
            if (token.tag == tagVal.BIT_STRING) {
                token.dataIdx++;
                token.dataLen--;
                subIdx++;
                subLength--;
            }
            
            // Append a new child to the current token and recurse.
            token.child = new Asn1Token(abv, token);
            asn1Parse(token.child, subIdx, subLength);
        }
        
        // Special handling for INTEGER token.
        if (token.tag == tagVal.INTEGER) {
            // In DER integer encoding, if the high-order bit of the actual
            // content is set, a leading 0x00 is added to the content to
            // indicate that the number is not negative. X.509 does not use
            // negative numbers, so we just need to exclude this byte from the
            // current token's data.
            curIdx = stream.getPosition();
            if (stream.peekByte(curIdx) == 0 && stream.peekByte(curIdx + 1) >> 7) {
                token.dataIdx++;
                token.dataLen--;
            }
        }

        // Move forward to the start of the next token.
        stream.skip(tokenLength);

        DEBUG && debugLog("tokenLength = " + (stream.getPosition() - tokenStartIdx));

        if (stream.getPosition() < tokenEndIdx) {
            token.next = new Asn1Token(abv, token.parent);
            token = token.next;
        }
    }
    
    asn1ParseRecursionDepth--;
    DEBUG && debugLog("==================== asn1Parse EXIT  ====================");
    return rootToken;
}

var rsaEncryptionOid = new Uint8Array([0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01]);

function oidIsRsaEncryption(abv, idx, len) {
    if (len != 9)
        return false;
    var i = idx;
    for (var j = 0; j < 9; ++j) {
        if (abv[i++] != rsaEncryptionOid[j]) {
            return false;
        }
    }
    return true;
};

function asn1Show(rootToken, rootDepth) {
    if (!DEBUG) {
      return;
    }

    var i;
    var token = rootToken;
    var abv = rootToken.backingStore;
    var output = "";
    var depth = rootDepth || 0;

    while (token) {
        for (i = 0; i < depth; i++) {
            output += "  ";
        }

        switch (token.tagClass) {
        case tagClass.UNIVERSAL:
            output += tagText[token.tag];
            break;
        case tagClass.APPLICATION:
            output +=  "application";
            break;
        case tagClass.CONTEXT_SPECIFIC:
            output += "context";
            break;
        case tagClass.PRIVATE:
            output += "private";
            break;
        }

        output += " (" + token.dataIdx + ":" + token.dataLen + ") ";
        
        if (token.tagClass == tagClass.UNIVERSAL) {
            switch (token.tag) {
                case tagVal.BIT_STRING:
                case tagVal.OCTET_STRING:
                    break;
                case tagVal.INTEGER:
                    output += "(" + token.dataLen * 8 + " bit) ";
                    // intentional fallthru
                case tagVal.UTF8_STRING:
                    output += hexDump(abv, token.dataIdx, token.dataLen);
                    // intentional fallthru
                case tagVal.OBJECT_IDENTIFIER:
                    if (oidIsRsaEncryption(abv, token.dataIdx, token.dataLen)) {
                        output += " (rsaEncryption)";
                    }
                    break;
                case tagVal.NUMERIC_STRING:
                case tagVal.PRINTABLE_STRING:
                case tagVal.TELETEX_STRING:
                case tagVal.VIDEOTEX_STRING:
                case tagVal.IA5_STRING:
                case tagVal.UTC_TIME:
                case tagVal.GENERALIZED_TIME:
                case tagVal.GRAPHIC_STRING:
                case tagVal.VISIBLE_STRING:
                case tagVal.GENERAL_STRING:
                case tagVal.UNIVERSAL_STRING:
                case tagVal.CHARACTER_STRING:
                case tagVal.BMP_STRING:
                default:
                    break;
            }
        }
        
        output += " payloadLen = " + token.length;

        output += "\n";

        if (token.child) {
            output += asn1Show(token.child, depth + 1);
        }

        token = token.next;
    }
    
    return output;
}

function isRsaSpki(asn1token) {
    if (!asn1token ||
        !asn1token.child ||
        !asn1token.child.next ||
        !asn1token.child.child ||
        !asn1token.child.next.child) {
        return false;
        }
    var oid = asn1token.child.child;
    if (!oidIsRsaEncryption(oid.backingStore, oid.dataIdx, oid.dataLen)) {
        return false;
    }
    if (asn1token.nChildren != 2 ||
        asn1token.child.nChildren != 2 ||
        asn1token.child.next.child.nChildren != 2) {
        return false;
    }
    return true;
}

function isRsaPkcs8(asn1token) {
    if (!asn1token ||
        !asn1token.child ||
        !asn1token.child.next ||
        !asn1token.child.next.child ||
        !asn1token.child.next.next ||
        !asn1token.child.next.next.child) {
        return false;
    }
    var oid = asn1token.child.next.child;
    if (!oidIsRsaEncryption(oid.backingStore, oid.dataIdx, oid.dataLen)) {
        return false;
    }
    if (asn1token.nChildren != 3 ||
        asn1token.child.next.nChildren != 2 ||
        asn1token.child.next.next.child.nChildren != 9) {
        return false;
    }
    return true;
}

/**
 * RsaPublicKey
 * @param {Object} n
 * @param {Object} e
 * @param {Object} ext
 * @param {Object} keyOps
 * @constructor
 */
var RsaPublicKey = function(n, e, ext, keyOps) {
    this.n = n;
    this.e = e;
    this.ext = ext;
    this.keyOps = keyOps;
};

/**
 * RsaPrivateKey
 * @param {Object} n
 * @param {Object} e
 * @param {Object} d
 * @param {Object} p
 * @param {Object} q
 * @param {Object} dp
 * @param {Object} dq
 * @param {Object} qi
 * @param {Object=} alg
 * @param {Object=} ext
 * @param {Object=} keyOps
 * @constructor
 */
var RsaPrivateKey = function(n, e, d, p, q, dp, dq, qi, alg, keyOps, ext) {
    this.n = n;
    this.e = e;
    this.d = d;
    this.p = p;
    this.q = q;
    this.dp = dp;
    this.dq = dq;
    this.qi = qi;
    this.alg = alg;
    this.keyOps = keyOps;
    this.ext = ext;
};

function buildRsaSpki(rsaPublicKey) {
    var rootNode = NodeFactory.createSequenceNode();
    var builder = new Builder(rootNode);
      builder.addChild(NodeFactory.createSequenceNode());
        builder.addChild(NodeFactory.createOidNode(rsaEncryptionOid));
        builder.addSibling(NodeFactory.createNullNode());
      builder.addToParent(rootNode, NodeFactory.createBitStringNode(null));
        builder.addChild(NodeFactory.createSequenceNode());
          builder.addChild(NodeFactory.createIntegerNode(rsaPublicKey.n));
          builder.addSibling(NodeFactory.createIntegerNode(rsaPublicKey.e));
    return rootNode;
};

function parseRsaSpki(spkiDer) {
    var spkiAsn = ASN1.parse(spkiDer);
    if (!isRsaSpki) {
        return undefined;
    }
    return extractRsaSpkiParams(spkiAsn);
}

function extractRsaSpkiParams(spkiAsn) {
    var parm = spkiAsn.child.next.child.child;
    var n = parm.data;
    parm = parm.next;
    var e = parm.data;
    return new RsaPublicKey(n, e, null, null);
}

function buildRsaPkcs8(rsaPrivateKey) {
    var rootNode = NodeFactory.createSequenceNode();
    var builder = new Builder(rootNode);
      builder.addChild(NodeFactory.createIntegerNode(new Uint8Array([0])));
      builder.addSibling(NodeFactory.createSequenceNode());
        builder.addChild(NodeFactory.createOidNode(rsaEncryptionOid));
        builder.addSibling(NodeFactory.createNullNode());
      builder.addToParent(rootNode, NodeFactory.createOctetStringNode(null));
        builder.addChild(NodeFactory.createSequenceNode());
          builder.addChild(NodeFactory.createIntegerNode(new Uint8Array([0])));
          builder.addSibling(NodeFactory.createIntegerNode(rsaPrivateKey.n));
          builder.addSibling(NodeFactory.createIntegerNode(rsaPrivateKey.e));
          builder.addSibling(NodeFactory.createIntegerNode(rsaPrivateKey.d));
          builder.addSibling(NodeFactory.createIntegerNode(rsaPrivateKey.p));
          builder.addSibling(NodeFactory.createIntegerNode(rsaPrivateKey.q));
          builder.addSibling(NodeFactory.createIntegerNode(rsaPrivateKey.dp));
          builder.addSibling(NodeFactory.createIntegerNode(rsaPrivateKey.dq));
          builder.addSibling(NodeFactory.createIntegerNode(rsaPrivateKey.qi));
    return rootNode;
}

function parseRsaPkcs8(pkcs8Der) {
    var pkcs8Asn1 = ASN1.parse(pkcs8Der);
    if (!isRsaPkcs8(pkcs8Asn1)) {
        return undefined;
    }
    return extractRsaPkcs8Params(pkcs8Asn1);
}

function extractRsaPkcs8Params(pkcs8Asn1) {
    var parmData = [];
    var parm = pkcs8Asn1.child.next.next.child.child.next;
    for (var i = 0; i < 8; i++) {
        parmData.push(parm.data);
        parm = parm.next;
    }
    return new RsaPrivateKey(
        parmData[0],
        parmData[1],
        parmData[2],
        parmData[3],
        parmData[4],
        parmData[5],
        parmData[6],
        parmData[7]
    );
}

var jwkKeyOps = ['sign', 'verify', 'encrypt', 'decrypt', 'wrapKey', 'unwrapKey', 'deriveKey', 'deriveBits'];

function buildRsaJwk(rsaKey, alg, keyOps, ext) {
    if (!(rsaKey instanceof RsaPublicKey) && !(rsaKey instanceof RsaPrivateKey) ) {
        return undefined;
    }
    if (keyOps) {
        for (var i = 0; i < keyOps.length; ++i) {
            if (jwkKeyOps.indexOf(keyOps[i]) == -1) {
                return undefined;
            }
        }
    }
    var jwk = {
        'kty': 'RSA',
        'alg': alg,
        'key_ops' : keyOps || [],
        'ext': ext == undefined ? false : ext,
        'n': base64$encode(rsaKey.n, true),
        'e': base64$encode(rsaKey.e, true)
    };
    if (rsaKey instanceof RsaPrivateKey) {
        jwk['d']  = base64$encode(rsaKey.d, true);
        jwk['p']  = base64$encode(rsaKey.p, true);
        jwk['q']  = base64$encode(rsaKey.q, true);
        jwk['dp'] = base64$encode(rsaKey.dp, true);
        jwk['dq'] = base64$encode(rsaKey.dq, true);
        jwk['qi'] = base64$encode(rsaKey.qi, true);
    }
    return jwk;
}

function parseRsaJwk(jwk) {
    if (!jwk['kty'] || jwk['kty'] != 'RSA' || !jwk['n'] || !jwk['e']) {
        return undefined;
    }
    var allowedAlg = ['RSA1_5', 'RSA-OAEP', 'RSA-OAEP-256', 'RSA-OAEP-384', 'RSA-OAEP-512', 'RS256', 'RS384', 'RS512'];
    if (jwk['alg']) {
        if (allowedAlg.indexOf(jwk['alg']) == -1) {
            return undefined;
        }
    }
    var keyOps = [];
    if (jwk['use']) {
        if (jwk['use'] == 'enc') {
            keyOps = ['encrypt', 'decrypt', 'wrap', 'unwrap'];
        } else if (jwk['use'] == 'sig') {
            keyOps = ['sign', 'verify'];
        }
    } else {
        keyOps = jwk['key_ops'];
    }
    var ext = jwk['ext'];
    var n = base64$decode(jwk['n'], true);
    var e = base64$decode(jwk['e'], true);
    if (!jwk['d']) {
        return new RsaPublicKey(n, e, ext, keyOps);
    } else {
        var d = base64$decode(jwk['d'], true);
        var p = base64$decode(jwk['p'], true);
        var q = base64$decode(jwk['q'], true);
        var dp = base64$decode(jwk['dp'], true);
        var dq = base64$decode(jwk['dq'], true);
        var qi = base64$decode(jwk['qi'], true);
        return new RsaPrivateKey(n, e, d, p, q, dp, dq, qi, jwk['alg'], keyOps, ext);
    }
}

function rsaDerToJwk(der, alg, keyOps, extractable) {
    var asn = ASN1.parse(der);
    if (!asn) {
        return undefined;
    }
    var rsaKey;
    if (isRsaSpki(asn)) {
        rsaKey = extractRsaSpkiParams(asn);
    } else if (isRsaPkcs8(asn)) {
        rsaKey = extractRsaPkcs8Params(asn);
    } else {
        return undefined;
    }
    return buildRsaJwk(rsaKey, alg, keyOps, extractable);
}

/**
 * RsaDer
 * @param {Object} der
 * @param {string} type
 * @param {Object=} keyOps
 * @param {Object=} extractable
 * @constructor
 */
function RsaDer(der, type, keyOps, extractable) {
    this.der = der;
    this.type = type;
    this.keyOps = keyOps;
    this.extractable = extractable;
}
RsaDer.prototype['getDer'] = function() {
  return this.der;
};
RsaDer.prototype['getType'] = function() {
  return this.type;
};
RsaDer.prototype['getKeyOps'] = function() {
  return this.keyOps;
};
RsaDer.prototype['getExtractable'] = function() {
  return this.extractable;
};

function jwkToRsaDer(jwk) {
    var rsaKey = parseRsaJwk(jwk);
    if (!rsaKey) {
        return undefined;
    }
    var type;
    var der;
    if (rsaKey instanceof RsaPublicKey) {
        type = 'spki';
        der = buildRsaSpki(rsaKey).der;
    } else if (rsaKey instanceof RsaPrivateKey) {
        type = 'pkcs8';
        der = buildRsaPkcs8(rsaKey).der;
    } else {
        return undefined;
    }
    return new RsaDer(der, type, rsaKey.keyOps, rsaKey.ext);
}

function webCryptoUsageToJwkKeyOps(webCryptoUsage) {
    var keyOps = webCryptoUsage.map(function(x) {
        if (x == 'wrapKey')
            return 'wrap';
        if (x == 'unwrapKey')
            return 'unwrap';
        return x;
    });
    return keyOps;
}

function webCryptoAlgorithmToJwkAlg(webCryptoAlgorithm) {
    if (webCryptoAlgorithm.name == 'RSAES-PKCS1-v1_5') {
        return 'RSA1_5';
    }
    else if (webCryptoAlgorithm.name == 'RSASSA-PKCS1-v1_5') {
        if (webCryptoAlgorithm.hash.name == 'SHA-256') {
            return 'RS256';
        }
        else if (webCryptoAlgorithm.hash.name == 'SHA-384') {
            return 'RS384';
        }
        else if (webCryptoAlgorithm.hash.name == 'SHA-512') {
            return 'RS512';
        }
        else {
            return undefined;
        }
    }
    else {
        return undefined;
    }
}

// external interface

// Debug builds include these named symbols plus the Release symbols below. The
// symbols here get renamed in Release builds.
ASN1.parse = function(abv) {
    asn1ParseRecursionDepth = 0;
    return asn1Parse(new Asn1Token(abv), 0, abv.length);
};
ASN1.show = asn1Show;
ASN1.isRsaSpki = isRsaSpki;
ASN1.isRsaPkcs8 = isRsaPkcs8;
ASN1.NodeFactory = NodeFactory;
ASN1.Builder = Builder;
ASN1.tagVal = tagVal;
ASN1.RsaPublicKey = RsaPublicKey;
ASN1.RsaPrivateKey = RsaPrivateKey;
ASN1.buildRsaSpki = buildRsaSpki;
ASN1.parseRsaSpki = parseRsaSpki;
ASN1.buildRsaPkcs8 = buildRsaPkcs8;
ASN1.parseRsaPkcs8 = parseRsaPkcs8;
ASN1.buildRsaJwk = buildRsaJwk;
ASN1.parseRsaJwk = parseRsaJwk;
ASN1.RsaDer = RsaDer;

// Release builds export only these named symbols.
ASN1['rsaDerToJwk'] = rsaDerToJwk;
ASN1['jwkToRsaDer'] = jwkToRsaDer;
ASN1['webCryptoAlgorithmToJwkAlg'] = webCryptoAlgorithmToJwkAlg;
ASN1['webCryptoUsageToJwkKeyOps'] = webCryptoUsageToJwkKeyOps;

}());
//================================================================================
// module.js

(function (global) {
"use strict";

global['ASN1'] = ASN1;

}(global));
}(this));



// -- javascript/lib/base64.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */
var base64$encode,
    base64$decode;

(function () {
    "use strict";

    var map =    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        urlmap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
        padchar =    '=',
        charNumber1 = { },
        charNumber2 = { },
        charNumber3 = { '=': 0, '.': 0 },
        charNumber4 = { '=': 0, '.': 0 },
        prepRegex = /\s+/g,
        checkRegex = new RegExp('^[' + map + '_-]*[' + padchar + ']{0,2}$');

    var i = map.length;
    while (i--) {
        // pre-calculate values for each of quad-s
        charNumber1[map[i]] = i * 0x40000;
        charNumber2[map[i]] = i * 0x1000;
        charNumber3[map[i]] = i * 0x40;
        charNumber4[map[i]] = i;
    }
    var j = urlmap.length;
    while (j--) {
        // stop once we've already seen this character
        if (map[j] == urlmap[j]) break;
        // pre-calculate values for each of quad-s
        charNumber1[urlmap[j]] = j * 0x40000;
        charNumber2[urlmap[j]] = j * 0x1000;
        charNumber3[urlmap[j]] = j * 0x40;
        charNumber4[urlmap[j]] = j;
    }

    /**
     * Base64 encode a byte array.
     *
     * @param {Uint8Array} a the data to encode.
     * @param {?boolean} urlSafe true if unpadded URL-safe Base64 encoding
     *        should be used (http://tools.ietf.org/html/rfc4648#section-5)
     * @return {String} the Base64 string representation of the data.
     */
    base64$encode = function (a, urlSafe) {
        var s = '',
            i = 0,
            l = a.length,
            lMinus2 = l - 2,
            triplet;

        var table = (!urlSafe) ? map : urlmap;
        var pad = (!urlSafe) ? padchar : '';

        while (i < lMinus2) {
            triplet =
                (a[i++] * 0x10000) +
                (a[i++] * 0x100) +
                (a[i++]);

            s +=
                table[(triplet >>> 18)] +
                table[(triplet >>> 12) & 0x3F] +
                table[(triplet >>> 6) & 0x3F] +
                table[(triplet) & 0x3F];
        }

        if (i == lMinus2) {
            triplet =
                (a[i++] * 0x10000) +
                (a[i++] * 0x100);

            s +=
                table[(triplet >>> 18)] +
                table[(triplet >>> 12) & 0x3F] +
                table[(triplet >>> 6) & 0x3F] +
                pad;

        } else if (i == l - 1) {
            triplet =
                (a[i++] * 0x10000);

            s +=
                table[(triplet >>> 18)] +
                table[(triplet >>> 12) & 0x3F] +
                pad + pad;

        }

        return s;
    };

    /**
     * Base64 decode a string.
     *
     * @param {String} a Base64 string representation of data.
     * @param {?boolean} urlSafe true if unpadded URL-safe Base64 decoding
     *        should be used (http://tools.ietf.org/html/rfc4648#section-5)
     * @return {Uint8Array} the decoded data.
     * @throws Error if the Base64 string is the wrong length or is not Base64
     *         encoded data.
     */
    base64$decode = function (s, urlSafe) {
        s = s.replace(prepRegex, '');
        
        // Pad out urlsafe data so we can treat padded and unpadded incoming
        // data the same below.
        if (urlSafe) {
            var overhang = s.length % 4;
            if (overhang) {
                var toPad = 4 - overhang;
                for (var i = 0; i < toPad; ++i) {
                    s += padchar;
                };
            }
        }

        var l = s.length,
            triplet;

        if (l % 4 != 0 || !checkRegex.test(s))
            throw new Error('bad base64: ' + s);

        var aLength = (l / 4) * 3 -
                (s[l - 1] == padchar ? 1 : 0) -
                (s[l - 2] == padchar ? 1 : 0),
            a = new Uint8Array(aLength),
            si = 0,
            ai = 0;

        while (si < l) {
            triplet =
                charNumber1[s[si++]] +
                charNumber2[s[si++]] +
                charNumber3[s[si++]] +
                charNumber4[s[si++]];

            a[ai++] = (triplet >>> 16);
            if (ai < aLength) {
                a[ai++] = (triplet >>> 8) & 0xFF;
                if (ai < aLength) {
                    a[ai++] = (triplet) & 0xFF;
                }
            }
        }

        return a;
    };
})();



// -- javascript/lib/textEncoding.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * @param {Uint8Array} bytes encoded data
 * @param {string=} encoding "utf-8", "utf-16" (default="utf-8")
 *
 * @returns {string}
 */
function textEncoding$getString(bytes, encoding) {
    if (!encoding || encoding === "utf-8") {
        return utf8$getString(bytes);
    }
    throw new Error("unsupported encoding");
};

/**
 * @param {string} str string to encode
 * @param {string=} encoding "utf-8", "utf-16" (default="utf-8")
 *
 * @returns {Uint8Array}
 */
function textEncoding$getBytes(str, encoding) {
    if (!encoding || encoding === "utf-8") {
        return utf8$getBytes(str);
    }
    throw new Error("unsupported encoding");
};

/**
 * @param {Uint8Array} bytes encoded data
 *
 * @returns {string}
 */
function utf8$getString(bytes) {
    var i = 0,
        charCode,
        bytesLength = bytes.length,
        str = "";

    while(i < bytesLength) {
        charCode = bytes[i++];

        // check the first flag, which indicates that this is a multi-byte character
        if (charCode & 0x80) {
            // 1xxxxxxx
            if ((charCode & 0xE0) === 0xC0) {
                // 110xxxxx	10xxxxxx
                charCode = ((charCode & 0x1F) << 6) + (bytes[i++] & 0x3F);
            } else if ((charCode & 0xF0) === 0xE0) {
                // 1110xxxx	10xxxxxx 10xxxxxx
                charCode = ((charCode & 0x0F) << 12) + ((bytes[i++] & 0x3F) << 6) + (bytes[i++] & 0x3F);
            } else {
                // 1111xxxx	10xxxxxx 10xxxxxx 10xxxxxx (or more)
                // JavaScript only rupports 2 byte characters
                throw new Error("unsupported character");
            }
        }

        str += String.fromCharCode(charCode);
    }

    return str;
};

/**
 * @param {string} str string to encode
 *
 * @returns {Uint8Array}
 */
function utf8$getBytes(str) {
    var strLength = str.length,
        bytes,
        bytesLength = 0,
        i,
        j = 0,
        charCode;

    // Note: JavaScript only rupports 2 byte characters, so the charCode can never be more than 0xFFFF

    // first pass to calculate the size, which we need to allocate the bytesay
    i = strLength;
    while (i--) {
        charCode = str.charCodeAt(i);
        if (charCode < 0x0080) {
            bytesLength++;
        } else if (charCode < 0x0800) {
            bytesLength += 2;
        } else {
            bytesLength += 3;
        }
    }

    // second pass, allocate the bytesay and do actual encoding
    bytes = new Uint8Array(bytesLength);
    for (i = 0; i < strLength; i++) {
        charCode = str.charCodeAt(i);
        if (charCode < 0x0080) {
            // 0xxxxxxx
            bytes[j++] = charCode;
        } else if (charCode < 0x0800) {
            // 110xxxxx	10xxxxxx
            bytes[j++] = 0xC0 | (charCode >>> 6);
            bytes[j++] = 0x80 | (charCode & 0x3F);
        } else {
            // 1110xxxx 10xxxxxx 10xxxxxx
            bytes[j++] = 0xE0 | (charCode >>> 12);
            bytes[j++] = 0x80 | ((charCode >>> 6) & 0x3F);
            bytes[j++] = 0x80 | (charCode & 0x3F);
        }
    }

    return bytes;
};



// -- javascript/lib/clarinet.js
// original work copyright isaacs z schlueter, MIT licensed
//
// copyright 2011 nuno job <nunojob.com> (oO)--',--
//
// licensed under the apache license, version 2.0 (the "license");
// you may not use this file except in compliance with the license.
// you may obtain a copy of the license at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// unless required by applicable law or agreed to in writing, software
// distributed under the license is distributed on an "as is" basis,
// without warranties or conditions of any kind, either express or implied.
// see the license for the specific language governing permissions and
// limitations under the license.

/* global window: false, process: false, FastList: false, require: false */

var clarinet = {};
(function () {
  var fastlist = Array;

  clarinet.parser            = function (opt) { return new CParser(opt);};
  clarinet.CParser           = CParser;
  clarinet.MAX_BUFFER_LENGTH = 64 * 1024;
  clarinet.DEBUG             = false;
  clarinet.INFO              = false;
  clarinet.EVENTS            =
    [ "value"
    , "string"
    , "key"
    , "openobject"
    , "closeobject"
    , "openarray"
    , "closearray"
    , "error"
    , "end"
    , "ready"
    ];

  var buffers     = [ "textNode", "numberNode" ]
    , streamWraps = clarinet.EVENTS.filter(function (ev) {
          return ev !== "error" && ev !== "end";
        })
    , S           = 0
    , Stream
    ;

  clarinet.STATE =
    { BEGIN                             : S++
    , VALUE                             : S++ // general stuff
    , OPEN_OBJECT                       : S++ // {
    , CLOSE_OBJECT                      : S++ // }
    , OPEN_ARRAY                        : S++ // [
    , CLOSE_ARRAY                       : S++ // ]
    , TEXT_ESCAPE                       : S++ // \ stuff
    , STRING                            : S++ // ""
    , BACKSLASH                         : S++
    , END                               : S++ // No more stack
    , OPEN_KEY                          : S++ // , "a"
    , CLOSE_KEY                         : S++ // :
    , TRUE                              : S++ // r
    , TRUE2                             : S++ // u
    , TRUE3                             : S++ // e
    , FALSE                             : S++ // a
    , FALSE2                            : S++ // l
    , FALSE3                            : S++ // s
    , FALSE4                            : S++ // e
    , NULL                              : S++ // u
    , NULL2                             : S++ // l
    , NULL3                             : S++ // l
    , NUMBER_DECIMAL_POINT              : S++ // .
    , NUMBER_DIGIT                      : S++ // [0-9]
    };

  for (var s_ in clarinet.STATE) clarinet.STATE[clarinet.STATE[s_]] = s_;

  // switcharoo
  S = clarinet.STATE;

  if (!Object.getPrototypeOf) {
    Object.getPrototypeOf = function (o) {
      return o["__proto__"];
    };
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(clarinet.MAX_BUFFER_LENGTH, 10)
      , maxActual = 0
      // , closeText = function() {} // FIXME: ppissanetzky: Where does this function come from?
      ;
    for (var i = 0, l = buffers.length; i < l; i ++) {
      var len = parser[buffers[i]].length;
      if (len > maxAllowed) {
        switch (buffers[i]) {
          case "text":
            // closeText(parser); // FIXME: ppissanetzky: Where does this function come from?
          break;

          default:
            error(parser, "Max buffer length exceeded: "+ buffers[i]);
        }
      }
      maxActual = Math.max(maxActual, len);
    }
    parser.bufferCheckPosition = (clarinet.MAX_BUFFER_LENGTH - maxActual)
                               + parser.position;
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i ++) {
      parser[buffers[i]] = "";
    }
  }

  var stringTokenPattern = /[\\"\n]/g;
  
  /**
  * @constructor
  */
  function CParser (opt) {
    if (!(this instanceof CParser)) return new CParser (opt);

    var parser = this;
    clearBuffers(parser);
    parser.bufferCheckPosition = clarinet.MAX_BUFFER_LENGTH;
    parser.q        = parser.c = parser.p = "";
    parser.opt      = opt || {};
    parser.closed   = parser.closedRoot = parser.sawRoot = false;
    parser.tag      = parser.error = null;
    parser.state    = S.BEGIN;
    parser.stack    = new fastlist();
    // mostly just for error reporting
    parser.index = parser.position = parser.column = 0;
    parser.line     = 1;
    parser.slashed  = false;
    parser.unicodeI = 0;
    parser.unicodeS = null;
    emit(parser, "onready");
  }

  CParser.prototype =
    { end    : function () { end(this); }
    , write  : write
    , resume : function () { this.error = null; return this; }
    , close  : function () { return this.write(null); }
    };

  /**
  * @param {*=} data
  */
  function emit(parser, event, data) {
    // if(clarinet.INFO) console.log('-- emit', event, data);
    if (parser[event]) parser[event](data);
  }

  /**
  * @param {*=} data
  */
  function emitNode(parser, event, data) {
    closeValue(parser);
    emit(parser, event, data);
  }

  /**
  * @param {string=} event
  */
  function closeValue(parser, event) {
    parser.textNode = textopts(parser.opt, parser.textNode);
    if (parser.textNode) {
      emit(parser, (event ? event : "onvalue"), parser.textNode);
    }
    parser.textNode = "";
  }

  function closeNumber(parser) {
    if (parser.numberNode)
      emit(parser, "onvalue", parseFloat(parser.numberNode));
    parser.numberNode = "";
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim();
    if (opt.normalize) text = text.replace(/\s+/g, " ");
    return text;
  }

  function error (parser, er) {
    closeValue(parser);
    er += "\nLine: "+parser.line+
          "\nColumn: "+parser.column+
          "\nChar: "+parser.c;
    er = new Error(er);
    parser.error = er;
    emit(parser, "onerror", er);
    return parser;
  }

  function end(parser) {
    if (parser.state !== S.VALUE) error(parser, "Unexpected end");
    closeValue(parser);
    parser.c      = "";
    parser.closed = true;
    emit(parser, "onend");
    CParser.call(parser, parser.opt);
    return parser;
  }

  function write (chunk) {
    var parser = this;
    if (this.error) throw this.error;
    if (parser.closed) return error(parser,
      "Cannot write after close. Assign an onready handler.");
    if (chunk === null) return end(parser);
    var c = chunk[0], p = parser.p;
    // if (clarinet.DEBUG) console.log('write -> [' + chunk + ']');
    while (c) {
      p = c;
      parser.c = c = chunk.charAt(parser.index++);
      // if chunk doesnt have next, like streaming char by char
      // this way we need to check if previous is really previous
      // if not we need to reset to what the parser says is the previous
      // from buffer
      if(p !== c ) parser.p = p;
      else p = parser.p;

      if(!c) break;

      // if (clarinet.DEBUG) console.log(parser.index,c,clarinet.STATE[parser.state]);
      parser.position ++;
      if (c === "\n") {
        parser.line ++;
        parser.column = 0;
      } else parser.column ++;
      switch (parser.state) {

        case S.BEGIN:
          if (c === "{") parser.state = S.OPEN_OBJECT;
          else if (c === "[") parser.state = S.OPEN_ARRAY;
          else if (c !== '\r' && c !== '\n' && c !== ' ' && c !== '\t')
            error(parser, "Non-whitespace before {[.");
        continue;

        case S.OPEN_KEY:
        case S.OPEN_OBJECT:
          if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
          if(parser.state === S.OPEN_KEY) parser.stack.push(S.CLOSE_KEY);
          else {
            if(c === '}') {
              emit(parser, 'onopenobject');
              emit(parser, 'oncloseobject');
              parser.state = parser.stack.pop() || S.VALUE;
              continue;
            } else  parser.stack.push(S.CLOSE_OBJECT);
          }
          if(c === '"') parser.state = S.STRING;
          else error(parser, "Malformed object key should start with \"");
        continue;

        case S.CLOSE_KEY:
        case S.CLOSE_OBJECT:
          if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
          var event = (parser.state === S.CLOSE_KEY) ? 'key' : 'object';
          if(c===':') {
            if(parser.state === S.CLOSE_OBJECT) {
              parser.stack.push(S.CLOSE_OBJECT);
              closeValue(parser, 'onopenobject');
            } else closeValue(parser, 'onkey');
            parser.state  = S.VALUE;
          } else if (c==='}') {
            emitNode(parser, 'oncloseobject');
            parser.state = parser.stack.pop() || S.VALUE;
          } else if(c===',') {
            if(parser.state === S.CLOSE_OBJECT)
              parser.stack.push(S.CLOSE_OBJECT);
            closeValue(parser);
            parser.state  = S.OPEN_KEY;
          } else error(parser, 'Bad object');
        continue;

        case S.OPEN_ARRAY: // after an array there always a value
        case S.VALUE:
          if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
          if(parser.state===S.OPEN_ARRAY) {
            emit(parser, 'onopenarray');
            parser.state = S.VALUE;
            if(c === ']') {
              emit(parser, 'onclosearray');
              parser.state = parser.stack.pop() || S.VALUE;
              continue;
            } else {
              parser.stack.push(S.CLOSE_ARRAY);
            }
          }
               if(c === '"') parser.state = S.STRING;
          else if(c === '{') parser.state = S.OPEN_OBJECT;
          else if(c === '[') parser.state = S.OPEN_ARRAY;
          else if(c === 't') parser.state = S.TRUE;
          else if(c === 'f') parser.state = S.FALSE;
          else if(c === 'n') parser.state = S.NULL;
          else if(c === '-') { // keep and continue
            parser.numberNode += c;
          } else if(c==='0') {
            parser.numberNode += c;
            parser.state = S.NUMBER_DIGIT;
          } else if('123456789'.indexOf(c) !== -1) {
            parser.numberNode += c;
            parser.state = S.NUMBER_DIGIT;
          } else               error(parser, "Bad value");
        continue;

        case S.CLOSE_ARRAY:
          if(c===',') {
            parser.stack.push(S.CLOSE_ARRAY);
            closeValue(parser, 'onvalue');
            parser.state  = S.VALUE;
          } else if (c===']') {
            emitNode(parser, 'onclosearray');
            parser.state = parser.stack.pop() || S.VALUE;
          } else if (c === '\r' || c === '\n' || c === ' ' || c === '\t')
              continue;
          else error(parser, 'Bad array');
        continue;

        case S.STRING:
          // thanks thejh, this is an about 50% performance improvement.
          var starti              = parser.index-1
            , slashed = parser.slashed
            , unicodeI = parser.unicodeI
            ;
          STRING_BIGLOOP: while (true) {
            if (clarinet.DEBUG)
              // console.log(parser.index,c,clarinet.STATE[parser.state]
              //           ,slashed);
            // zero means "no unicode active". 1-4 mean "parse some more". end after 4.
            while (unicodeI > 0) {
              parser.unicodeS += c;
              c = chunk.charAt(parser.index++);
              if (unicodeI === 4) {
                // TODO this might be slow? well, probably not used too often anyway
                parser.textNode += String.fromCharCode(parseInt(parser.unicodeS, 16));
                unicodeI = 0;
                starti = parser.index-1;
              } else {
                unicodeI++;
              }
              // we can just break here: no stuff we skipped that still has to be sliced out or so
              if (!c) break STRING_BIGLOOP;
            }
            if (c === '"' && !slashed) {
              parser.state = parser.stack.pop() || S.VALUE;
              parser.textNode += chunk.substring(starti, parser.index-1);
              if(!parser.textNode) {
                 emit(parser, "onvalue", "");
              }
              break;
            }
            if (c === '\\' && !slashed) {
              slashed = true;
              parser.textNode += chunk.substring(starti, parser.index-1);
              c = chunk.charAt(parser.index++);
              if (!c) break;
            }
            if (slashed) {
              slashed = false;
                   if (c === 'n') { parser.textNode += '\n'; }
              else if (c === 'r') { parser.textNode += '\r'; }
              else if (c === 't') { parser.textNode += '\t'; }
              else if (c === 'f') { parser.textNode += '\f'; }
              else if (c === 'b') { parser.textNode += '\b'; }
              else if (c === 'u') {
                // \uxxxx. meh!
                unicodeI = 1;
                parser.unicodeS = '';
              } else {
                parser.textNode += c;
              }
              c = chunk.charAt(parser.index++);
              starti = parser.index-1;
              if (!c) break;
              else continue;
            }

            stringTokenPattern.lastIndex = parser.index;
            var reResult = stringTokenPattern.exec(chunk);
            if (reResult === null) {
              parser.index = chunk.length+1;
              parser.textNode += chunk.substring(starti, parser.index-1);
              break;
            }
            parser.index = reResult.index+1;
            c = chunk.charAt(reResult.index);
            if (!c) {
              parser.textNode += chunk.substring(starti, parser.index-1);
              break;
            }
          }
          parser.slashed = slashed;
          parser.unicodeI = unicodeI;
        continue;

        case S.TRUE:
          if (c==='')  continue; // strange buffers
          if (c==='r') parser.state = S.TRUE2;
          else error(parser, 'Invalid true started with t'+ c);
        continue;

        case S.TRUE2:
          if (c==='')  continue;
          if (c==='u') parser.state = S.TRUE3;
          else error(parser, 'Invalid true started with tr'+ c);
        continue;

        case S.TRUE3:
          if (c==='') continue;
          if(c==='e') {
            emit(parser, "onvalue", true);
            parser.state = parser.stack.pop() || S.VALUE;
          } else error(parser, 'Invalid true started with tru'+ c);
        continue;

        case S.FALSE:
          if (c==='')  continue;
          if (c==='a') parser.state = S.FALSE2;
          else error(parser, 'Invalid false started with f'+ c);
        continue;

        case S.FALSE2:
          if (c==='')  continue;
          if (c==='l') parser.state = S.FALSE3;
          else error(parser, 'Invalid false started with fa'+ c);
        continue;

        case S.FALSE3:
          if (c==='')  continue;
          if (c==='s') parser.state = S.FALSE4;
          else error(parser, 'Invalid false started with fal'+ c);
        continue;

        case S.FALSE4:
          if (c==='')  continue;
          if (c==='e') {
            emit(parser, "onvalue", false);
            parser.state = parser.stack.pop() || S.VALUE;
          } else error(parser, 'Invalid false started with fals'+ c);
        continue;

        case S.NULL:
          if (c==='')  continue;
          if (c==='u') parser.state = S.NULL2;
          else error(parser, 'Invalid null started with n'+ c);
        continue;

        case S.NULL2:
          if (c==='')  continue;
          if (c==='l') parser.state = S.NULL3;
          else error(parser, 'Invalid null started with nu'+ c);
        continue;

        case S.NULL3:
          if (c==='') continue;
          if(c==='l') {
            emit(parser, "onvalue", null);
            parser.state = parser.stack.pop() || S.VALUE;
          } else error(parser, 'Invalid null started with nul'+ c);
        continue;

        case S.NUMBER_DECIMAL_POINT:
          if(c==='.') {
            parser.numberNode += c;
            parser.state       = S.NUMBER_DIGIT;
          } else error(parser, 'Leading zero not followed by .');
        continue;

        case S.NUMBER_DIGIT:
          if('0123456789'.indexOf(c) !== -1) parser.numberNode += c;
          else if (c==='.') {
            if(parser.numberNode.indexOf('.')!==-1)
              error(parser, 'Invalid number has two dots');
            parser.numberNode += c;
          } else if (c==='e' || c==='E') {
            if(parser.numberNode.indexOf('e')!==-1 ||
               parser.numberNode.indexOf('E')!==-1 )
               error(parser, 'Invalid number has two exponential');
            parser.numberNode += c;
          } else if (c==="+" || c==="-") {
            if(!(p==='e' || p==='E'))
              error(parser, 'Invalid symbol in number');
            parser.numberNode += c;
          } else {
            closeNumber(parser);
            parser.index--; // go back one
            parser.state = parser.stack.pop() || S.VALUE;
          }
        continue;

        default:
          error(parser, "Unknown state: " + parser.state);
      }
    }
    if (parser.position >= parser.bufferCheckPosition)
      checkBufferLength(parser);
    return parser;
  }

})();


// -- javascript/lib/lzw.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */
var lzw$compress;
var lzw$uncompress;

(function() {
    "use strict";

    /**
     * Byte size in bits.
     * @const
     * @type {number}
     */
    var BYTE_SIZE = 8;
    /**
     * Maximum number of values represented by a byte.
     * @const
     * @type {number}
     */
    var BYTE_RANGE = 256;
    /**
     * The initial compression dictionary.
     * @type {Object.<string,number>}
     */
    var COMPRESS_DICTIONARY = {};
    for (var i = 0; i < BYTE_RANGE; ++i) {
        var key = createKey([i]);
        COMPRESS_DICTIONARY[key] = i;
    }
    /**
     * The initial compression dictionary length.
     * @const
     * @type {number}
     */
    var COMPRESS_DICTIONARY_LENGTH = Object['keys'](COMPRESS_DICTIONARY)['length'];
    /**
     * The initial decompression dictionary.
     * @type {Array.<Array.<number>>}
     */
    var UNCOMPRESS_DICTIONARY = [];
    for (var i = 0; i < BYTE_RANGE; ++i) {
        UNCOMPRESS_DICTIONARY[i] = [i];
    }

    /**
     * Construct a compression map key value from the given byte array.
     *
     * @param {Array.<number>} bytes the byte array.
     * @param {number=} count the number of bytes to create the key from.
     * @return {string} the key value.
     */
    function createKey(bytes, count) {
        if (!count)
            count = bytes.length;
        return bytes.reduce(function(previousValue, currentValue, index) {
            if (index < count)
                return previousValue + String.fromCharCode(currentValue);
            return previousValue;
        }, '');
    }

    /**
     * @param {Uint8Array} data the data to compress.
     * @param {object} empty dictionary to use to build keys.  Pass as argument to work arround a bug in 
     *         the Microsoft WWAHost code with large objects.  This forces it to be allocated on the heap 
     *         rather than the stack.
     * @return {?Uint8Array} the compressed data or null if the compressed data
     *         would be larger than the original data.
     */
    lzw$compress = function (data, dictionary) {
        for (var key in COMPRESS_DICTIONARY)
            dictionary[key] = COMPRESS_DICTIONARY[key];
        var dictlen = COMPRESS_DICTIONARY_LENGTH;

        // Working symbols.
        var symbols = [];
        // Current bit length.
        var bits = 8;
        // Compressed data. If it exceeds the data length then we abort.
        var compressed = new Uint8Array(data.length);
        // Compressed data current byte index.
        var index = 0;
        // Bits available in the current byte.
        var available = BYTE_SIZE;

        // Compress all the data.
        for (var i = 0; i < data.length; ++i) {
            // Add a byte to the input.
            var c = data[i];
            symbols.push(c);

            // Check if the input is in the dictionary.
            var key = createKey(symbols);
            var value = dictionary[key];

            // If the value is not in the dictionary, then...
            if (!value) {
                // emit the previous input's code...
                var prevkey = createKey(symbols, symbols.length - 1);
                var prevvalue = dictionary[prevkey];
                if (!emit(prevvalue, bits))
                    return null;

                // and add the new input to the dictionary.
                //
                // The bit width increases from p to p + 1 when the new code is
                // the first code requiring p + 1 bits.
                if (dictlen >> bits != 0)
                    ++bits;
                dictionary[key] = dictlen++;

                // Remove the emitted symbol from the current input.
                symbols = [c];
            }
        }

        // If there are any symbols left we have to emit those codes now.
        if (symbols.length > 0) {
            var key = createKey(symbols);
            var value = dictionary[key];
            if (!emit(value, bits))
                return null;
        }

        function emit(code, bits) {
            // Write the current code bits MSB-first.
            while (bits > 0) {
                // If we've run out of compressed storage return false.
                if (index >= compressed.length)
                    return false;

                // If the code has more bits than available, shift right to get
                // the most significant bits. This finishes off the current
                // byte.
                if (bits > available) {
                    var msbits = code;
                    msbits >>>= bits - available;
                    compressed[index] |= (msbits & 0xff);

                    // We've written 'available' bits of the current code. The
                    // next byte is completely available so reset the values.
                    bits -= available;
                    available = BYTE_SIZE;
                    ++index;
                }

                // If the code has less then or equal bits available, shift
                // left to pack against the previous bits.
                else if (bits <= available) {
                    // First shift left to erase the most significant bits then
                    // shift right to start at the correct offset.
                    var msbits = code;
                    msbits <<= available - bits;
                    msbits &= 0xff;
                    msbits >>>= BYTE_SIZE - available;
                    compressed[index] |= (msbits & 0xff);

                    // We've written 'bits' bits into the current byte. There
                    // are no more bits to write for the current code.
                    available -= bits;
                    bits = 0;

                    // If this finished the current byte then write it and
                    // reset the values.
                    if (available == 0) {
                        available = BYTE_SIZE;
                        ++index;
                    }
                }
            }

            // Success.
            return true;
        }

        // Return the compressed data. We have to include the current byte if
        // the number of bits available is less than the byte size (meaning
        // some bits have been placed into it).
        var length = (available < BYTE_SIZE) ? index + 1 : index;
        return compressed.subarray(0, length);
    };

    /**
     * @param {Uint8Array} data the data to uncompress.
     * @return {Uint8Array} the uncompressed data or null if there is no data
     *         to uncompress.
     */
    lzw$uncompress = function (data) {
        // Populate the initial dictionary by copying the initial dictionary
        var dictionary = UNCOMPRESS_DICTIONARY.slice();

        // Current code byte index.
        var codeIndex = 0;
        // Current code byte bit offset.
        var codeOffset = 0;
        // Current bit length.
        var bits = BYTE_SIZE;
        // Uncompressed data. Start off with 50% more than the data length.
        var uncompressed = new Uint8Array(Math.ceil(data.length * 1.5));
        // Uncompressed data current byte index.
        var index = 0;
        // Uncompressed data next byte index.
        var nextIndex = 0;
        // Previously buffered decoded bytes for building the dictionary.
        var prevvalue = [];

        // Uncompress the data.
        while (codeIndex < data.length) {
            // If there are not enough bits available for the next code then
            // stop.
            var bitsAvailable = (data.length - codeIndex) * BYTE_SIZE - codeOffset;
            if (bitsAvailable < bits)
                break;

            // Decode the next code.
            var code = 0;
            var bitsDecoded = 0;
            while (bitsDecoded < bits) {
                // Read the next batch of bits.
                var bitlen = Math.min(bits - bitsDecoded, BYTE_SIZE - codeOffset);
                var msbits = data[codeIndex];

                // First shift left to erase the most significant bits then
                // shift right to get the correct number of bits.
                msbits <<= codeOffset;
                msbits &= 0xff;
                msbits >>>= BYTE_SIZE - bitlen;

                // If we read to the end of this byte then zero the code bit
                // offset and remove the byte.
                bitsDecoded += bitlen;
                codeOffset += bitlen;
                if (codeOffset == BYTE_SIZE) {
                    codeOffset = 0;
                    ++codeIndex;
                }

                // Shift left by the number of bits remaining to decode and add
                // the current bits to the value.
                code |= (msbits & 0xff) << (bits - bitsDecoded);
            }

            // Grab the bytes for this code.
            var value = dictionary[code];

            // This is the first iteration. The next code will have a larger
            // bit length.
            if (prevvalue.length == 0) {
                ++bits;
            }

            // If there is previous data then add the previous data plus this
            // data's first character to the dictionary.
            else {
                // If the code was not in the dictionary then we have
                // encountered the code that we are going to enter into the
                // dictionary right now.
                //
                // This is the odd case where the decoder is one code behind
                // the encoder in populating the dictionary and the byte that
                // will be added to create the sequence is equal to the first
                // byte of the previous sequence.
                if (!value) {
                    prevvalue.push(prevvalue[0]);
                } else {
                    prevvalue.push(value[0]);
                }

                // Add the dictionary entry.
                dictionary[dictionary.length] = prevvalue;
                prevvalue = [];

                // If we just generated the code for 2^p - 1 then increment the
                // code bit length.
                if (dictionary.length == (1 << bits))
                    ++bits;

                // If the code was not in the dictionary before, it should be
                // now. Grab the data.
                if (!value)
                    value = dictionary[code];
            }

            nextIndex = index + value.length;

            // Expand the uncompressed data container if necessary.
            if (nextIndex >= uncompressed.length) {
                var u = new Uint8Array(Math.ceil(nextIndex * 1.5));
                u.set(uncompressed);
                uncompressed = u;
            }

            // Append the decoded bytes to the uncompressed data.
            uncompressed.set(value, index);
            index = nextIndex;

            // Save this data for the next iteration.
            prevvalue = prevvalue.concat(value);
        }

        // Return the uncompressed data which may be empty.
        return uncompressed.subarray(0, index);
    };
})();



// -- javascript/MslConstants.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Message security layer constants.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslConstants$DEFAULT_CHARSET;
var MslConstants$MAX_LONG_VALUE;
var MslConstants$CompressionAlgorithm;
var MslConstants$CompressionAlgorithm$getPreferredAlgorithm;
var MslConstants$CipherSpec;
var MslConstants$CipherSpec$fromString;
var MslConstants$SignatureAlgo;
var MslConstants$SignatureAlgo$fromString;
var MslConstants$ResponseCode;

(function() {
    "use strict";
    
    /** RFC-4327 defines UTF-8 as the default encoding. */
    MslConstants$DEFAULT_CHARSET = "utf-8";
    
    /** Maximum long integer value (2^53 limited by JavaScript). */
    MslConstants$MAX_LONG_VALUE = 9007199254740992;
    
    /**
     * Compression algorithm.
     * @enum {string}
     */
    var CompressionAlgorithm = MslConstants$CompressionAlgorithm = {
        // In order of most preferred to least preferred.
        // Keep in-sync with getPreferredAlgorithm().
        /** GZIP */
        GZIP : "GZIP",
        /** LZW */
        LZW : "LZW",
    };
    Object.freeze(MslConstants$CompressionAlgorithm);
    
    /**
     * Returns the most preferred compression algorithm from the provided
     * set of algorithms.
     * 
     * @param {Array.<MslConstants$CompressionAlgorithm>} algos the set of algorithms to choose from.
     * @return {?MslConstants$CompressionAlgorithm>} the most preferred compression algorithm or {@code null} if
     *         the algorithm set is empty.
     */
    MslConstants$CompressionAlgorithm$getPreferredAlgorithm = function MslConstants$CompressionAlgorithm$getPreferredAlgorithm(algos) {
        var preferredAlgos = [ CompressionAlgorithm.GZIP, CompressionAlgorithm.LZW ];
        for (var i = 0; i < preferredAlgos.length && algos.length > 0; ++i) {
            var preferredAlgo = preferredAlgos[i];
            for (var j = 0; j < algos.length; ++j) {
                if (algos[j] == preferredAlgo)
                    return preferredAlgo;
            }
        }
        return null;
    };
    
    /** Cipher specifications. */
    var CipherSpec = MslConstants$CipherSpec = {
        /** AES/CBC/PKCS5Padding */
        AES_CBC_PKCS5Padding : "AES/CBC/PKCS5Padding",
        /** AESWrap */
        AESWrap : "AESWrap",
        /** RSA/ECB/PKCS1Padding */
        RSA_ECB_PKCS1Padding : "RSA/ECB/PKCS1Padding",
    };
    Object.freeze(MslConstants$CipherSpec);
    
    /**
     * @param {string} value the string value of the cipher specification.
     * @return {?MslConstants$CipherSpec} the cipher specification associated
     *         with the string value or undefined if there is none.
     */
    MslConstants$CipherSpec$fromString = function MslConstants$CipherSpec$fromString(value) {
        if (CipherSpec.AES_CBC_PKCS5Padding == value)
            return CipherSpec.AES_CBC_PKCS5Padding;
        if (CipherSpec.RSA_ECB_PKCS1Padding == value)
            return CipherSpec.RSA_ECB_PKCS1Padding;
        return CipherSpec[value];
    };
    
    /** Signature algorithms. */
    var SignatureAlgo = MslConstants$SignatureAlgo = {
        /** HmacSHA256 */
        HmacSHA256 : "HmacSHA256",
        /** SHA256withRSA */
        SHA256withRSA : "SHA256withRSA",
    };
    Object.freeze(MslConstants$SignatureAlgo);
    
    /**
     * @param {string} value the string value of the signature algorithm.
     * @return {?MslConstants$SignatureAlgo} the signature algorithm associated
     *         with the string value or undefined if there is none.
     */
    MslConstants$SignatureAlgo$fromString = function MslConstants$SignatureAlgo$fromString(value) {
        return SignatureAlgo[value];
    };
    
    /**
     * Error response codes.
     * @enum {number}
     */
    MslConstants$ResponseCode = {
        /** The message is erroneous and will continue to fail if retried. */
        FAIL: 1,
        /** The message is expected to succeed if retried after a delay. */
        TRANSIENT_FAILURE: 2,
        /** The message is expected to succeed post entity re-authentication. */
        ENTITY_REAUTH: 3,
        /** The message is expected to succeed post user re-authentication. */
        USER_REAUTH: 4,
        /** The message is expected to succeed post key exchange. */
        KEYX_REQUIRED: 5,
        /** The message is expected to succeed with new entity authentication data. */
        ENTITYDATA_REAUTH: 6,
        /** The message is expected to succeed with new user authentication data. */
        USERDATA_REAUTH: 7,
        /** The message is expected to succeed if retried with a renewed master token or renewable message. */
        EXPIRED: 8,
        /** The non-replayable message is expected to succeed if retried with the newest master token. */
        REPLAYED: 9,
        /** The message is expected to succeed with new user authentication data containing a valid single-sign-on token. */
        SSOTOKEN_REJECTED: 10
    };
    Object.freeze(MslConstants$ResponseCode);
})();


// -- javascript/util/Arrays.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Utility methods for arrays.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
/**
 * @param {Uint8Array|Array.<number>} a first array.
 * @param {Uint8Array|Array.<number>} b second array.
 * @return {boolean} true if the two arrays are equal.
 */
function Arrays$equal(a, b) {
    if (a === b) return true;
    if (!a || !b || a.length != b.length) return false;
    for (var i = 0; i < a.length; ++i) {
        if (a[i] != b[i])
            return false;
    }
    return true;
}

/**
 * @param o {*} object to test.
 * @returns {Boolean} true if the object is a Uint8Array.
 */
function Arrays$isUint8Array(o) {
    return o && o.constructor == Uint8Array;
};

/**
 * @param {Uint8Array|Array.<number>} a the array to copy.
 * @param {number=} off optional offset into a to start the copy from. If omitted
 *        the copy will begin at the start of a. If negative the offset is
 *        computed from the end of the array.
 * @param {number=} len optional number of bytes to copy. If omitted the copy will
 *        proceed until the end of a is hit. If larger than the number of bytes
 *        in a, the result will be padded with zeros.
 * @return {Uint8Array|Array.<number>} a shallow copy of the array.
 */
function Arrays$copyOf(a, off, len) {
    var b;

    // The offset is not less than the length then throw an exception.
    if (off >= a.length)
        throw new RangeError('Array offset (' + off + ') must be less than array length (' + a.length + ').');

    // If the offset is negative, the real offset is equal to the array length
    // minus the offset.
    if (off === undefined || off === null)
        off = 0;
    if (off < 0)
        off = Math.max(0, a.length - off);

    // Clamp the length based on the offset.
    if (len === undefined || len === null)
        len = a.length;

    // Create the copy.
    if (Arrays$isUint8Array(a))
        b = new Uint8Array(len);
    else if (Array.isArray(a))
        b = new Array(len);
    else
        throw new TypeError('Cannot create an array copy of ' + a);

    // Perform the copy.
    var count = Math.min(len, a.length - off);
    for (var i = 0; i < count; ++i)
        b[i] = a[i + off];
    return b;
}

/**
 * @param {Uint8Array|Array.<number>} a the array to compute a hash code for.
 * @return {number} the computed hash code.
 */
function Arrays$hashCode(a) {
    if (!(Arrays$isUint8Array(a)) && !(Array.isArray(a)))
        throw new TypeError('Cannot compute the hash code of ' + a);
    var result = 1;
    for (var i = 0; i < a.length; ++i) {
        var element = a[i];
        if (typeof element !== 'number')
            throw new TypeError('Cannot compute the hash code over non-numeric elements: ' + element);
        result = (31 * result + element) & 0xFFFFFFFF;
    }
    return result;
}

/**
 * Returns true if the first array contains all the elements of the second
 * array, or the specified element. If b or the elements of b have a property
 * {@code equals()} then that method will be used to check if an element in a
 * is equal.
 *
 * @param {Array} a first array.
 * @param {Array} b second array or single element.
 * @return {boolean} true if a contains all the elements of b.
 */
function Arrays$contains(a, b) {
    if (a === b) return true;
    if (!a || !b) return false;
    if (!(b instanceof Array))
        b = [b];
    for (var i = 0; i < b.length; ++i) {
        var bElem = b[i];
        var found = false;
        for (var j = 0; j < a.length; ++j) {
            var aElem = a[j];
            if ((bElem.equals && typeof bElem.equals === 'function' && bElem.equals(aElem)) ||
                bElem == aElem)
            {
                found = true;
                break;
            }
        }
        if (!found)
            return false;
    }
    return true;
}

/**
 * Returns true if both arrays contain all the elements of the other array,
 * irrespective of ordering. If the elements of have a property
 * {@code equals()} then that method will be used to check if the elements are
 * equal.
 *
 * @param {Array.<*>} a first array.
 * @param {Array.<*>} b second array.
 * @return {boolean} true if a contains all the elements of b and vice versa.
 */
function Arrays$containEachOther(a, b) {
    return Arrays$contains(a, b) && (a.length == b.length || Arrays$contains(b, a));
}

/**
 * Returns a new array containing the tokens of a plus the tokens of b,
 * replacing and tokens in a with equal tokens in b.
 *
 * If a filter function is provided then only elements of b for which the
 * function returns true will be included in the returned array. The filter
 * function receives a single argument which is the element of b.
 *
 * @param {Array.<MasterToken>|Array.<UserIdToken>|Array.<ServiceToken>} a first array.
 * @param {Array.<MasterToken>|Array.<UserIdToken>|Array.<ServiceToken>} b second array.
 * @param {Function=} f optional filter function for adding elements of b.
 * @returns {Array.<MasterToken>|Array.<UserIdToken>|Array.<ServiceToken>} combined array.
 */
function Arrays$combineTokens(a, b, f) {
    if (!f) f = function(e) { return true; };
    var map = {};
    a.forEach(function(e) {
        map[e.uniqueKey()] = e;
    }, this);
    b.forEach(function(e) {
        if (f(e))
            map[e.uniqueKey()] = e;
    }, this);
    var arr = [];
    for (var key in map)
        arr.push(map[key]);
    return arr;
}

/**
 * Concatenates array of Uint8Arrays into a new Uint8Array
 *
 * @param {Array.<Uint8Array>} arrays array of Uint8Array to merge
 * @returns {Uint8Array} concatenated array
 */
function Arrays$concat(arrays) {
    var result,
        i,
        current,
        l = arrays.length,
        position = 0,
        totalLength = 0;

    for (i = 0; i < l; i++) {
        totalLength += arrays[i].length;
    }
    result = new Uint8Array(totalLength);
    for (i = 0; i < l; i++) {
        current = arrays[i];
        result.set(current, position);
        position += current.length;
    }
    return result;
};



// -- javascript/util/AsyncExecutor.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Executes a function (synchronously).</p>
 *
 * <p>If the function returns anything other than undefined the return value is
 * delivered to the callback's result function. Any errors thrown by the
 * function are delivered to the callback's error function.</p>
 *
 * <p>If the function returns undefined and does not throw any error, the
 * callback is not used; it is the function's responsibility to ensure the
 * callback receives a result. The callback is passed as an argument to the
 * function for this purpose.</p>
 *
 * <p>For example:
 * {@code
 * function syncOp() {
 *   return 5;
 * }
 *
 * function asyncOp(callback) {
 *   setTimeout(function() { AsyncExecutor(callback, function() { return 7; }); }, 1000);
 * }
 *
 * function noOp() {}
 *
 * var x = 0;
 * var callback = {
 *   result: function(num) { x = num; },
 *   error: function(err) { alert(err); },
 * };
 *
 * AsyncExecutor(callback, noOp); // x is still zero
 * AsyncExecutor(callback, syncOp); // x is now 5
 * AsyncExecutor(callback, asyncOp); // x is still 5
 * setTimeout(function() { // x is now 7 }, 2000);
 * </p>
 *
 * @param {{result:Function, error: function(Error)}} callback the callback
 *        functions that will receive the result or any thrown errors.
 * @param {function({result: Function, error: function(Error)}): *=} func
 *        the function to execute.
 * @param {Object=} thisArg object to use as this when executing the function.
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
function AsyncExecutor(callback, func, thisArg) {
    var T;
    if (thisArg)
        T = thisArg;

    // Make sure the callback is correct.
    if (typeof callback !== 'object' ||
        typeof callback.result !== 'function' ||
        typeof callback.error !== 'function')
    {
        throw new TypeError("callback must be an object with function properties 'result' and 'error'.");
    }

    // Wrap the function in a try/catch block to catch any thrown errors.
    try {
        var result = func.call(T, callback);

        // Only deliver the result if it was not undefined. It's possible the
        // function is itself asynchronous and is not returning any result.
        if (result !== undefined)
            callback.result(result);
    } catch (e) {
        // Don't propagate exceptions from the callback
        try {
            callback.error(e);
        } catch (f) {
        }
    }
}

/**
 * <p>Executes a function (synchronously) that may timeout.</p>
 *
 * <p>This is identical to AsyncExecutor except it also enforces the existence
 * of a timeout callback.</p>
 *
 * @param {{result:Function, error:function(Error)}} callback the callback
 *        functions that will receive the result or any thrown errors.
 * @param {function({result: Function, error: function(Error)}): *=} func
 *        the function to execute.
 * @param {Object=} thisArg object to use as this when executing the function.
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
function InterruptibleExecutor(callback, func, thisArg) {
    // Make sure the callback is correct.
    if (typeof callback !== 'object' ||
        typeof callback.timeout !== 'function')
    {
        throw new TypeError("callback must be an object with function properties 'result', 'timeout', and 'error'.");
    }
    AsyncExecutor(callback, func, thisArg);
}



// -- javascript/util/Class.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */
var util = {};

/**
 * Gets whether the argument obj is a direct instance of Object
 * @param obj {*}
 * @return {Boolean}
 */
util.isObjectLiteral = function (obj) {

    //If the object is not null, it's of type object
    //and its constructor is the Object constructor.
    //This will return false for an instance created via var inst = new util.Class.create();
    //Since the instance's constructor will be set to its actual constructor
    //Also for HTML Elements since their constructor will be of type HTMLElement
    return obj !== null &&
        typeof obj === 'object' &&
        obj.constructor === Object;
};

/**
 * Extend an object with other objects like util.extend but if properties are also objects in both recursively extend them as well
 *
 * @param {Boolean} arg0 onlyIfNew Optional; true to copy a property only if it doesn't already exist on the target
 * @param {Object} arg0|arg1 Target object (arg1 if onlyIfNew passed in)
 * @param {Object} arg1|arg2...argN Objects to extend target object with
 */
util.extendDeep = function() {
    var target = arguments[0],
        i = 1,
        length = arguments.length,
        onlyIfNew = false,
        options, name, src, copy
    ;

    if (typeof target === "boolean") {
        onlyIfNew = target;
        target = arguments[1];
        i = 2;
    }

    for ( ; i < length; i++ ) {

        if ( (options = arguments[ i ]) != null ) {
            // Only deal with non-null/undefined values

            // Extend the base object
            for ( name in options ) {
                if (onlyIfNew && name in target) {
                    // Property already in target
                    continue;
                }

                copy = options[ name ];

                if ( target === copy ) {
                    // Prevent never-ending loop
                    continue;

                } else if ( copy !== undefined ) {
                    // Don't bring in undefined values

                    src = target[ name ];

                    //typeof null returns 'object', so if one is null instead of overwriting with
                    //null it overwrites with a new object
                    if (src !== null &&
                        copy !== null &&
                        typeof src === 'object' &&
                        typeof copy === 'object') {
                        target[ name ] = util.extendDeep(onlyIfNew, {}, src, copy);
                    } else {
                        target[ name ] = copy;
                    }
                }
            }
        }
    }

    // Return the modified object
    return target;
};

// Dependencies
// @depend preamble.js
// @depend ../globals.js
// @depend isObjectLiteral.js
// @depend map/extendDeep.js
// depend log.js  --> Causes Circular Dependency


/**
 * @class util.Class Provides simple class creation and inheritance
 *
 * Based on work from John Resig, base2, and Prototype. Class uses namespace
 * safe method access allowing renaming of util.Class.
 *
 * Create an empty Class:
 *
 * var MyEmptyClass = util.Class.create();
 *
 * Create a typical Class instance:
 *
 * var MyClass = util.Class.create({
 *     init: function () {
 *         // This method serves as the constructor
 *     },
 *     aPrototypeMethod: function () {
 *         // All methods and properties are assigned to MyClass.prototype
 *     }
 * });
 *
 * Extend a Class instance:
 *
 * var YourClass = MyClass.extend({
 *     init: function init() {
 *         // Base class properties are overwritten. Base methods can be invoked
 *         // using <funcname>.base.
 *         init.base.call(this, arg1, arg2);
 *     },
 *     f: function f() {
 *         f.base.call(this, arg1, arg2);
 *     },
 * });
 *
 */

(function () {

    var _doNotInit = {},
        propertiesSafeToExtend = {
            actions: true
        },
        baseDefault = function (){};

    //All functions get a base property
    //"All your base are belong to us"... :)
    Function.prototype.base = baseDefault;

    /**
     * This hack is here because a mixin can't be applied to
     * 2 different classes as it would overwrite the base property.
     * For the most part, this is not a common scenario.
     * If you're worried about the performance
     * aspect, it won't be horribly slow, to make faster have the mixin
     * be returned from a factory.
     *
     * @param derivedFn
     * @param baseFn
     * @returns {Function}
     */
    function mixinBaseHack(derivedFn, baseFn){
        return function mixinWrapper(){
            var base = derivedFn.base,
                result;

            derivedFn.base = baseFn;
            result = derivedFn.apply(this, arguments);
            derivedFn.base = base;
            return result;
        };
    }

    /**
     * Mixin the properties of source into the receiver
     * @param receiver  {Object} the object to receive new properties/methods
     * @param source    {Object} the source of the new properties/methods
     * @param objectPropertiesToExtend      {Object} key to boolean map of object properties that are ok to extend
     * @param objectPropertiesToExtend.extendAll    {Boolean} *optional. Defaults to false.  Pass in true and all object properties get deeply extended.
     */
    function mixin(receiver, source, objectPropertiesToExtend) {

        var fnType = 'function', name, getter, setter, value, currentValue, extendAllObjectProperties;

        //provide a default
        objectPropertiesToExtend = objectPropertiesToExtend || propertiesSafeToExtend;
        extendAllObjectProperties = !!objectPropertiesToExtend.extendAll;

        // Copy the properties over onto the new receiver
        for (name in source) {

            getter = source.__lookupGetter__(name);
            setter = source.__lookupSetter__(name);

            if (getter || setter) {
                getter && receiver.__defineGetter__(name, getter);
                setter && receiver.__defineSetter__(name, setter);
            }
            else {
                value = source[name];
                currentValue = receiver[name];

                if (typeof value === fnType &&
                    typeof currentValue === fnType &&
                    value !== currentValue) {

                    //if value already has a base then we need to wrap it
                    if (value.base !== Function.prototype.base){
                        value = mixinBaseHack(value, currentValue);
                    }

                    value.base = currentValue;


                }
                //By default extending all object properties almost worked but ran into some hairy issues
                //with bowser jr.  When a class is extended, and the derived properties contain references to
                //class instances this gets sticky and can fail.  For now a case by case basis is the safe way.
                else if ((extendAllObjectProperties || objectPropertiesToExtend[name]) &&
                    util.isObjectLiteral(value) &&
                    util.isObjectLiteral(currentValue)) {

                    //extend this object into the receiver
                    value = util.extendDeep({}, currentValue, value);
                }

                receiver[name] = value;
            }
        }
    }

    /**
     * Overrides the Function.bind contract to ensure that another class
     * constructor is emitted when called instead of a wrapper function.
     *
     * Normally bind just creates a wrapper function around an inner function.
     * This behavior is undesirable though as class methods like extend are
     * lost.
     *
     * @public
     * @returns {Function} A Class instance
     */
    function _bind() {
        var slice = Array.prototype.slice,
            bindArgs = slice.call(arguments, 1);
        return this.extend({
            init: function init() {
                var args = slice.call(arguments, 0);
                init.base.apply(this, bindArgs.concat(args));
            }
        });
    }


    /**
     * Extends a Class instance with properties to create a sub-class. Executes
     * in scope of a Class instance.
     * @public
     * @param {Object} props Object descriptor with key/value pairs
     * @param {Object} objectPropertiesToExtend object properties you want extended.
     * @returns {Function} A Class instance
     */
    function _extend(props, objectPropertiesToExtend) {
        var prototype = new this(_doNotInit);

        mixin(prototype, props, objectPropertiesToExtend);

        return _create(prototype);
    }

    /**
     * Extends a Class's prototype with properties.  Executes in the scope of a
     * Class instance
     * @public
     * @param props {Object}
     * @param objectPropertiesToExtend {Object} a key/boolean mapping of object properties to extend
     * @return {Function} the Class instance
     */
    function _mixin(props, objectPropertiesToExtend) {
        mixin(this.prototype, props, objectPropertiesToExtend);
        return this;
    }

    /**
     * Creates a new Class instance, optionally including a prototype
     * object.  This method is not applied to returned Class instances;
     * use Class.extend to sub-class Class instances.
     * @public
     * @param {Object} props Object descriptor with key/value pairs
     * @returns {Function} A Class instance
     */
    function _create(props) {
        var Class = function () {
            var init = this.init;

            // All construction is actually done in the init method
            if (init && arguments[0] !== _doNotInit) {
                init.apply(this, arguments);
            }
        };

        // Ensure that the Chrome profiler shows relevant class names, instead
        // of 'Class' when memory debugging is enabled.  eval the className as
        // the function of the dummy class constructor.

        //var className = props && props.classId || "UNKNOWN";
        //eval("var " + className + " = function() { var init = this.init; if (init && arguments[0] !== _doNotInit) { init.apply(this, arguments); } }; Class = " + className + ";");

        // Populate our constructed prototype object
        if (props) {
            Class.prototype = props;
        }

        // Enforce the constructor to be what we expect
        //if you don't do this then all instance's constructor will be the native object
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = _extend;

        // And overload the bind function to create a subclass
        Class.bind = _bind;

        //add in mixin functionality
        Class.mixin = _mixin;

        return Class;
    }

    // Reveal _class publicly

    util.Class = {
        create:_create,
        mixin: mixin,

        /**
         * Create a new extendable Class instance from a super Class
         * that wasn't created through util.Class
         * @param {Function} superClass
         * @param {Object} prototype Class prototype
         * @return {Function} A Class instance
         */
        extend: function(superClass, prototype) {
            var subClass = _create();
            subClass.prototype = new superClass();
            return subClass.extend(prototype);
        }
    };

    //In order to reduce friction with merging into other projects this definition of util.mixin is here.
    util.mixin = function(){

        //Can't directly depend on util.log due to circular dependency.
        if (util.log){
            util.log.warn('util.mixin is deprecated.  Please change your code to use util.Class.mixin()');
        }

        mixin.apply(null, arguments);
    };

}());// Dependencies
// @depend preamble.js
// @depend ../globals.js
// @depend isObjectLiteral.js
// @depend map/extendDeep.js
// depend log.js  --> Causes Circular Dependency


/**
 * @class util.Class Provides simple class creation and inheritance
 *
 * Based on work from John Resig, base2, and Prototype. Class uses namespace
 * safe method access allowing renaming of util.Class.
 *
 * Create an empty Class:
 *
 * var MyEmptyClass = util.Class.create();
 *
 * Create a typical Class instance:
 *
 * var MyClass = util.Class.create({
 *     init: function () {
 *         // This method serves as the constructor
 *     },
 *     aPrototypeMethod: function () {
 *         // All methods and properties are assigned to MyClass.prototype
 *     }
 * });
 *
 * Extend a Class instance:
 *
 * var YourClass = MyClass.extend({
 *     init: function init() {
 *         // Base class properties are overwritten. Base methods can be invoked
 *         // using the _super() method.
 *         init.uber();
 *     }
 * });
 *
 */

(function () {

    var _doNotInit = {},
        propertiesSafeToExtend = {
            actions: true
        },
        baseDefault = function (){};

    //All functions get a base property
    //"All your base are belong to us"... :)
    Function.prototype.base = baseDefault;

    /**
     * This hack is here because a mixin can't be applied to
     * 2 different classes as it would overwrite the base property.
     * For the most part, this is not a common scenario.
     * If you're worried about the performance
     * aspect, it won't be horribly slow, to make faster have the mixin
     * be returned from a factory.
     *
     * @param derivedFn
     * @param baseFn
     * @returns {Function}
     */
    function mixinBaseHack(derivedFn, baseFn){
        return function mixinWrapper(){
            var base = derivedFn.base,
                result;

            derivedFn.base = baseFn;
            result = derivedFn.apply(this, arguments);
            derivedFn.base = base;
            return result;
        };
    }

    /**
     * Mixin the properties of source into the receiver
     * @param receiver  {Object} the object to receive new properties/methods
     * @param source    {Object} the source of the new properties/methods
     * @param objectPropertiesToExtend      {Object} key to boolean map of object properties that are ok to extend
     * @param objectPropertiesToExtend.extendAll    {Boolean} *optional. Defaults to false.  Pass in true and all object properties get deeply extended.
     */
    function mixin(receiver, source, objectPropertiesToExtend) {

        var fnType = 'function', name, getter, setter, value, currentValue, extendAllObjectProperties;

        //provide a default
        objectPropertiesToExtend = objectPropertiesToExtend || propertiesSafeToExtend;
        extendAllObjectProperties = !!objectPropertiesToExtend.extendAll;

        // Copy the properties over onto the new receiver
        for (name in source) {

            getter = source.__lookupGetter__(name);
            setter = source.__lookupSetter__(name);

            if (getter || setter) {
                getter && receiver.__defineGetter__(name, getter);
                setter && receiver.__defineSetter__(name, setter);
            }
            else {
                value = source[name];
                currentValue = receiver[name];

                if (typeof value === fnType &&
                    typeof currentValue === fnType &&
                    value !== currentValue) {

                    //if value already has a base then we need to wrap it
                    if (value.base !== baseDefault){
                        value = mixinBaseHack(value, currentValue);
                    }

                    value.base = currentValue;


                }
                //By default extending all object properties almost worked but ran into some hairy issues
                //with bowser jr.  When a class is extended, and the derived properties contain references to
                //class instances this gets sticky and can fail.  For now a case by case basis is the safe way.
                else if ((extendAllObjectProperties || objectPropertiesToExtend[name]) &&
                    util.isObjectLiteral(value) &&
                    util.isObjectLiteral(currentValue)) {

                    //extend this object into the receiver
                    value = util.extendDeep({}, currentValue, value);
                }

                receiver[name] = value;
            }
        }
    }

    /**
     * Overrides the Function.bind contract to ensure that another class
     * constructor is emitted when called instead of a wrapper function.
     *
     * Normally bind just creates a wrapper function around an inner function.
     * This behavior is undesirable though as class methods like extend are
     * lost.
     *
     * @public
     * @returns {Function} A Class instance
     */
    function _bind() {
        var slice = Array.prototype.slice,
            bindArgs = slice.call(arguments, 1);
        return this.extend({
            init: function init() {
                var args = slice.call(arguments, 0);
                init.base.apply(this, bindArgs.concat(args));
            }
        });
    }


    /**
     * Extends a Class instance with properties to create a sub-class. Executes
     * in scope of a Class instance.
     * @public
     * @param {Object} props Object descriptor with key/value pairs
     * @param {Object} objectPropertiesToExtend object properties you want extended.
     * @returns {Function} A Class instance
     */
    function _extend(props, objectPropertiesToExtend) {
        var prototype = new this(_doNotInit);

        mixin(prototype, props, objectPropertiesToExtend);

        return _create(prototype);
    }

    /**
     * Extends a Class's prototype with properties.  Executes in the scope of a
     * Class instance
     * @public
     * @param props {Object}
     * @param objectPropertiesToExtend {Object} a key/boolean mapping of object properties to extend
     * @return {Function} the Class instance
     */
    function _mixin(props, objectPropertiesToExtend) {
        mixin(this.prototype, props, objectPropertiesToExtend);
        return this;
    }

    /**
     * Creates a new Class instance, optionally including a prototype
     * object.  This method is not applied to returned Class instances;
     * use Class.extend to sub-class Class instances.
     * @public
     * @param {Object} props Object descriptor with key/value pairs
     * @returns {Function} A Class instance
     */
    function _create(props) {
        var Class = function () {
            var init = this.init;

            // All construction is actually done in the init method
            if (init && arguments[0] !== _doNotInit) {
                init.apply(this, arguments);
            }
        };

        // Ensure that the Chrome profiler shows relevant class names, instead
        // of 'Class' when memory debugging is enabled.  eval the className as
        // the function of the dummy class constructor.

        //var className = props && props.classId || "UNKNOWN";
        //eval("var " + className + " = function() { var init = this.init; if (init && arguments[0] !== _doNotInit) { init.apply(this, arguments); } }; Class = " + className + ";");

        // Populate our constructed prototype object
        if (props) {
            Class.prototype = props;
        }

        // Enforce the constructor to be what we expect
        //if you don't do this then all instance's constructor will be the native object
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = _extend;

        // And overload the bind function to create a subclass
        Class.bind = _bind;

        //add in mixin functionality
        Class.mixin = _mixin;

        return Class;
    }

    // Reveal _class publicly

    util.Class = {
        create:_create,
        mixin: mixin,

        /**
         * Create a new extendable Class instance from a super Class
         * that wasn't created through util.Class
         * @param {Function} superClass
         * @param {Object} prototype Class prototype
         * @return {Function} A Class instance
         */
        extend: function(superClass, prototype) {
            var subClass = _create();
            subClass.prototype = new superClass();
            return subClass.extend(prototype);
        }
    };

    //In order to reduce friction with merging into other projects this definition of util.mixin is here.
    util.mixin = function(){

        //Can't directly depend on util.log due to circular dependency.
        if (util.log){
            util.log.warn('util.mixin is deprecated.  Please change your code to use util.Class.mixin()');
        }

        mixin.apply(null, arguments);
    };

}());



// -- javascript/util/BlockingQueue.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A queue that supports waiting for an element.</p>
 */
var BlockingQueue;
(function() {
    "use strict";

    /**
     * @param {number} number the ticket number.
     * @return the next larger ticket number, wrapped around.
     */
    function incrementTicket(number) {
        return (number == MslConstants$MAX_LONG_VALUE) ? 1 : number + 1;
    }

    /**
     * Return the provided queue's next waiter ticket number.
     *
     * @param {BlockingQueue} queue the blocking queue.
     * @return {number} the next waiter ticket number.
     */
    function nextWaiter(queue) {
        // If there are no more waiters then we're done.
        if (Object.keys(queue._waiters).length === 0) {
            return 0;
        }

        // Otherwise update the next waiter number.
        var next = incrementTicket(queue._nextWaiter);
        while (!queue._waiters[next])
            next = incrementTicket(next);
        return next;
    }

    BlockingQueue = util.Class.create({
        /**
         * Create a new blocking queue.
         */
        init: function init() {
            // The properties.
            var props = {
                /**
                 * Queue of elements.
                 * @type {Array.<*>}
                 */
                _queue: { value: [], writable: false, enumerable: false, configurable: false },
                /**
                 * Queue of readers waiting for an element.
                 * @type {Object.<number,Function>}
                 */
                _waiters: { value: {}, writable: false, enumerable: false, configurable: false },
                /**
                 * Next waiter number. [1,2^53] or 0 indicating no waiter.
                 * @type {number}
                 */
                _nextWaiter: { value: 0, writable: true, enumerable: false, configurable: false },
                /**
                 * Last added waiter number. [1,2^53] or 0 indicating no waiter.
                 * @type {number}
                 */
                _lastWaiter: { value: 0, writable: true, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /**
         * Cancel the waiter identified by the given ticket.
         *
         * @param {number} ticket the ticket identifying the operation to
         *        cancel.
         */
        cancel: function cancel(ticket) {
            // Do nothing if the waiter is no longer waiting.
            if (!this._waiters[ticket]) return;

            // Grab the deliver function but do not execute it until after
            // updating the next waiter number in case deliver triggers a
            // callback to the queue.
            var deliver = this._waiters[ticket];
            delete this._waiters[ticket];
            if (ticket == this._nextWaiter)
                this._nextWaiter = nextWaiter(this);

            // Deliver undefined to the identified waiter.
            deliver.call(this, undefined);
        },

        /**
         * Cancel all waiters.
         */
        cancelAll: function cancelAll() {
            while (this._nextWaiter !== 0)
                this.cancel(this._nextWaiter);
        },

        /**
         * Retrieve and remove the head of the queue, waiting until an element
         * is available.
         *
         * @param {number} timeout timeout in milliseconds or -1 for no
         *        timeout.
         * @param {{result: function(?), timeout: function(), error: function(Error)}}
         *        callback the callback that will receive the next element from
         *        the queue or undefined if cancelled, be notified of timeout,
         *        or receive any thrown exceptions.
         * @return {number} a ticket with which the operation can be cancelled.
         */
        poll: function poll(timeout, callback) {
            var self = this;

            var number = incrementTicket(this._lastWaiter);
            this._lastWaiter = number;

            InterruptibleExecutor(callback, function() {
                // If there is something available then return it immediately.
                // This has to be done via a timeout to try and be fair to
                // waiters that have had their callbacks triggered.
                if (this._queue.length > 0) {
                    var elem = this._queue.shift();
                    // The actual delay will be clamped.
                    setTimeout(function() { callback.result(elem); }, 0);
                    return;
                }

                // Otherwise start the timeout and stick the waiter onto the
                // waiter queue. The timeout cannot execute before we return so
                // there is no chance of a race condition.
                var timeoutId;
                if (timeout != -1) {
                    timeoutId = setTimeout(function() {
                        // Trigger the timeout after we update the next waiter
                        // in case the timeout triggers a callback to the
                        // queue.
                        delete self._waiters[number];
                        if (number == self._nextWaiter)
                            self._nextWaiter = nextWaiter(self);
                        callback.timeout();
                    }, timeout);
                }
                this._waiters[number] = function(elem) {
                    clearTimeout(timeoutId);
                    // The actual delay will be clamped.
                    setTimeout(function() { callback.result(elem); }, 0);
                };
                if (!this._nextWaiter)
                    this._nextWaiter = number;
            }, self);

            // Return the cancellation ticket.
            return number;
        },

        /**
         * Add an element to the end of the queue.
         *
         * @param {*} elem the element.
         */
        add: function add(elem) {
            // If there is a waiter deliver the element directly.
            if (this._nextWaiter) {
                // Grab the deliver function but do not execute it until after
                // updating the next waiter number in case delivery triggers
                // a callback to the queue.
                var deliver = this._waiters[this._nextWaiter];
                delete this._waiters[this._nextWaiter];
                this._nextWaiter = nextWaiter(this);

                // Deliver the element.
                deliver.call(this, elem);
                return;
            }

            // Otherwise stick the element on the queue.
            this._queue.push(elem);
        }
    });
})();



// -- javascript/util/Random.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */
var Random;

(function() {
    "use strict";
    
    // Shift multiplication.
    var SHIFT_24 = 0x1000000;
    // Minimum integer.
    var MIN_LONG_VALUE = 0 - MslConstants$MAX_LONG_VALUE;
    
    /**
     * @param min minimum value.
     * @param max maximum value.
     * @returns a random (JavaScript) integer between min and max inclusive.
     */
    function random(min, max) {
        var b = new Uint8Array(4);
        nfCrypto.getRandomValues(b);
        var r = ((b[3] & 0x7f) << 24) | (b[2] << 16) |( b[1] << 8) | b[0];
        var factor = r / (0x7fffffff + 1);
        return Math.floor(factor * (max - min + 1) + min);
    }

    Random = util.Class.create({
        /**
         * @return {boolean} a random boolean value.
         */
        nextBoolean: function nextBoolean() {
            var b = new Uint8Array(1);
            nfCrypto.getRandomValues(b);
            return (b[0] & 0x1) ? true : false;
        },

        /**
         * Return a random number from [-2<sup>31</sup>,2<sup>31</sup>-1].
         *
         * @param {number=} if specified a random number between [0,n) is
         *        generated instead.
         * @return {number} a random number.
         */
        nextInt: function nextInt(n) {
            // Currently, n is only passed in by unit tests. Therefore any
            // potential randomness skew associated with the private random
            // function is unimportant.
            if (n !== null && n !== undefined) {
                if (typeof n !== 'number')
                    throw new TypeError('n must be of type number');
                if (n < 1)
                    throw new RangeError('n must be greater than zero');
                return random(0, n - 1);
            }
            
            var b = new Uint8Array(4);
            nfCrypto.getRandomValues(b);
            var abs = ((b[3] & 0x7f) << 24) | (b[2] << 16) | (b[1] << 8) | b[0];
            return (b[3] & 0x80) ? -abs : abs;
        },

        /**
         * @return {number} a random number from [-2<sup>63</sup>,2<sup>63</sup>-1].
         */
        nextLong: function nextLong() {
            // Discard the maximum negative value as a result to avoid bias of
            // it happening twice.
            var result = MIN_LONG_VALUE;
            while (result == MIN_LONG_VALUE) {
                // We will actually clamp at 2^53 due to JavaScript limitations. If
                // we assume each bit is equally random then truncating does not
                // reduce the randomness.
                var b = new Uint8Array(7);
                nfCrypto.getRandomValues(b);
                // We have to do some strange bit math because JavaScript will only
                // shift < 32 bits.
                var highbits = ((b[6] & 0x1f) << 24) | (b[5] << 16) | (b[4] << 8) | b[3];
                var lowbits = (b[2] << 16) | (b[1] << 8) | b[0];
                var abs = SHIFT_24 * highbits + lowbits;
                result = (b[6] & 0x80) ? -abs - 1 : abs;
            }
            return result;
        },

        /**
         * Generates random bytes and places them into a user-supplied array.
         * The number of random bytes produced is equal to the length of the
         * array.
         *
         * @param {Uint8Array} buffer the array in which to put the random
         *        bytes.
         */
        nextBytes: function nextBytes(buffer) {
            nfCrypto.getRandomValues(buffer);
        }
    });
})();



// -- javascript/util/ReadWriteLock.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A read-write lock allows multiple readers to simultaneously acquire the
 * lock and a single writer to exclusively acquire the lock. A writer will
 * block until there are no readers and then acquire the lock. Readers will
 * block if there is a writer waiting to acquire the lock.</p>
 *
 * <p>This lock is not reentrant, so while a reader can recursively acquire the
 * lock multiple times a writer cannot. A reader also cannot acquire the write
 * lock recursively.</p>
 */
var ReadWriteLock;
(function() {
    /**
     * @param {number} the ticket number.
     * @return the next larger ticket number, wrapped around.
     */
    function incrementTicket(number) {
        return (number == MslConstants$MAX_LONG_VALUE) ? 1 : number + 1;
    }
    
    /**
     * Return the provided read-write lock's next waiting reader's ticket
     * number.
     * 
     * @param {ReadWriteLock} rwlock the read-write lock.
     * @return {number} the next waiting reader's ticket number.
     */
    function nextReader(rwlock) {
        // If there are no more readers then we're done.
        if (Object.keys(rwlock._waitingReaders).length === 0) {
            return 0;
        }

        // Otherwise update the next reader number.
        var next = incrementTicket(rwlock._nextReader);
        while (!rwlock._waitingReaders[next])
            next = incrementTicket(next);
        return next;
    }
    
    /**
     * Return the provided read-write lock's next waiting writer's ticket
     * number.
     * 
     * @param {ReadWriteLock} rwlock the read-write lock.
     * @return {number} the next waiting writer's ticket number.
     */
    function nextWriter(rwlock) {
        // If there are no more writers then we're done.
        if (Object.keys(rwlock._waitingWriters).length === 0) {
            return 0;
        }

        // Otherwise update the next writer number.
        var next = incrementTicket(rwlock._nextWriter);
        while (!rwlock._waitingWriters[next])
            next = incrementTicket(next);
        return next;
    }

    ReadWriteLock = util.Class.create({
        /**
         * Create a new read-write lock.
         */
        init: function init() {
            // The properties.
            var props = {
                /**
                 * List of readers who have acquired the lock.
                 * @type {Object.<number,boolean>}
                 */
                _readers: { value: {}, writable: false, enumerable: false, configurable: false },
                /**
                 * Queue of readers waiting to acquire the lock.
                 * @type {Object.<number,Function>}
                 */
                _waitingReaders: { value: {}, writable: false, enumerable: false, configurable: false },
                /**
                 * Writer who has acquired the lock.
                 * @type {number}
                 */
                _writer: { value: null, writable: true, enumerable: false, configurable: false },
                /**
                 * Queue of writers waiting to acquire the lock.
                 * @type {Object.<number,Function>}
                 */
                _waitingWriters: { value: {}, writable: false, enumerable: false, configurable: false },
                /**
                 * Next waiting reader number. [1,2^53] or 0 indicating no next reader.
                 * @type {number}
                 */
                _nextReader: { value: 0, writable: true, enumerable: false, configurable: false },
                /**
                 * Next waiting writer number. [1,2^53] or 0 indicating no next writer.
                 * @type {number}
                 */
                _nextWriter: { value: 0, writable: true, enumerable: false, configurable: false },
                /**
                 * Last added reader/writer number. [1,2^53] or 0 indicating no
                 * reader or writer.
                 * @type {number}
                 */
                _lastNumber: { value: 0, writable: true, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /**
         * Cancel the waiter identifed by the given ticket.
         *
         * @param {number} ticket the ticket identifying the operation to
         *        cancel.
         */
        cancel: function cancel(ticket) {
            // Deliver undefined to a waiting reader after updating the next
            // reader number in case deliver triggers a callback to the read-
            // write lock.
            if (this._waitingReaders[ticket]) {
                var deliver = this._waitingReaders[ticket];
                delete this._waitingReaders[ticket];
                if (ticket == this._nextReader)
                    this._nextReader = nextReader(this);
                deliver.call(this, true);
            }

            // Deliver undefined to a waiting writer after updating the next
            // writer number in case deliver triggers a callback to the read-
            // write lock.
            if (this._waitingWriters[ticket]) {
                var deliver = this._waitingWriters[ticket];
                delete this._waitingWriters[ticket];
                if (ticket == this._nextWriter)
                    this._nextWriter = nextWriter(this);
                deliver.call(this, true);
            }
        },

        /**
         * Cancel all waiting readers and writers.
         */
        cancelAll: function cancelAll() {
            while (this._nextWriter !== 0)
                this.cancel(this._nextWriter);
            while (this._nextReader !== 0)
                this.cancel(this._nextReader);
        },

        /**
         * Acquire the read lock. A ticket number will be returned which must
         * be used to release the lock.
         *
         * @param {number} timeout lock acquisition timeout in milliseconds or
         *        -1 for no timeout.
         * @param {{result: function(number), timeout: function(), error: function(Error)}}
         *        callback the callback that will receive the lock ticket
         *        number or undefined if cancelled, timeout, or any thrown
         *        exceptions.
         * @return {number} a ticket with which the operation can be cancelled.
         */
        readLock: function readLock(timeout, callback) {
            var self = this;

            var number = incrementTicket(this._lastNumber);
            this._lastNumber = number;

            InterruptibleExecutor(callback, function() {
                // If there is no writer grab the lock immediately.
                if (!this._writer && Object.keys(this._waitingWriters).length === 0) {
                    this._readers[number] = true;
                    return number;
                }

                // Otherwise, start the timeout and stick the reader onto the
                // reader queue. The timeout cannot execute before we return so
                // there is no chance of a race condition.
                var timeoutId;
                if (timeout != -1) {
                    timeoutId = setTimeout(function() {
                        // Trigger the timeout after we update the next reader
                        // in case the timeout triggers a callback to the read-
                        // write lock.
                        delete self._waitingReaders[number];
                        if (number == self._nextReader)
                            self._nextReader = nextReader(self);
                        callback.timeout();
                    }, timeout);
                }
                this._waitingReaders[number] = function(cancelled) {
                    clearTimeout(timeoutId);
                    // The actual delay will be clamped.
                    if (!cancelled) {
                        self._readers[number] = true;
                        setTimeout(function() { callback.result(number); }, 0);
                    } else {
                        setTimeout(function() { callback.result(undefined); }, 0);
                    }
                };
                if (!this._nextReader)
                    this._nextReader = number;
            }, self);

            // Return the cancellation ticket.
            return number;
        },

        /**
         * Acquire the write lock. A ticket number will be returned which must
         * be used to release the lock.
         *
         * @param {number} timeout lock acquisition timeout in milliseconds or
         *        -1 for no timeout.
         * @param {{result: function(number), timeout: function(), error: function(Error)}}
         *        callback the callback that will receive the lock ticket
         *        number or undefined if cancelled, timeout, or any thrown
         *        exceptions.
         * @return {number} a ticket with which the operation can be cancelled.
         */
        writeLock: function writeLock(timeout, callback) {
            var self = this;

            var number = incrementTicket(this._lastNumber);
            this._lastNumber = number;

            InterruptibleExecutor(callback, function() {
                // If there are no readers or writer then grab the lock
                // immediately.
                if (Object.keys(this._readers).length === 0 &&
                    Object.keys(this._waitingReaders).length === 0 &&
                    !this._writer)
                {
                    this._writer = number;
                    return number;
                }

                // Otherwise, start the timeout and stick the writer onto the
                // writer queue. The timeout cannot execute before we return so
                // there is no chance of a race condition.
                var timeoutId;
                if (timeout != -1) {
                    timeoutId = setTimeout(function() {
                        // Trigger the timeout after we update the next writer
                        // in case the timeout triggers a callback to the read-
                        // write lock.
                        delete self._waitingWriters[number];
                        if (number == self._nextWriter)
                            self._nextWriter = nextWriter(self);
                        callback.timeout();
                    }, timeout);
                }
                this._waitingWriters[number] = function(cancelled) {
                    clearTimeout(timeoutId);
                    // The actual delay will be clamped.
                    if (!cancelled) {
                        self._writer = number;
                        setTimeout(function() { callback.result(number); }, 0);
                    } else {
                        setTimeout(function() { callback.result(undefined); }, 0);
                    }
                };
                if (!this._nextWriter)
                    this._nextWriter = number;
            }, self);

            // Return the cancellation ticket.
            return number;
        },

        /**
         * Release the read or write lock using the ticket number received when
         * the lock was acquired.
         *
         * @param {number} number the ticket number.
         */
        unlock: function unlock(number) {
            // Remove the reader or writer from the active set.
            if (number == this._writer) {
                this._writer = null;
            } else {
                if (!this._readers[number])
                    throw new MslInternalException("There is no reader or writer with ticket number " + number + ".");
                delete this._readers[number];
            }

            // If there is a waiting writer...
            if (this._nextWriter) {
                // If there are active readers then don't activate anyone. The
                // waiting writer will be activated once the last active reader
                // releases the lock.
                if (Object.keys(this._readers).length > 0)
                    return;
                
                // Grab the activation function but do not execute it until
                // after updating the next writer number in case activating
                // triggers a callback to the read-write lock.
                var activate = this._waitingWriters[this._nextWriter];
                delete this._waitingWriters[this._nextWriter];
                this._nextWriter = nextWriter(this);

                // Activate the waiting writer.
                activate.call(this, false);
                return;
            }

            // Otherwise if there are waiting readers then activate them.
            for (var next = this._nextReader; Object.keys(this._waitingReaders).length > 0; next = incrementTicket(next)) {
                if (!this._waitingReaders[next])
                    continue;

                // Activate the waiting reader after deleting it from the list
                // of waiting readers.
                var activate = this._waitingReaders[next];
                delete this._waitingReaders[next];
                activate.call(this, false);
            }

            // All readers were activated.
            this._nextReader = 0;
        }
    });
})();



// -- javascript/MslError.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Message Security Layer error codes and descriptions.</p>
 *
 * <p>Errors are defined with an internal and a response error code. The
 * internal error code is specific to this implementation. The response error
 * codes are sent in error messages to inform the remote entity, who should use
 * it to decide on the correct error handling behavior.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */

/**
 * Construct a MSL error with the specified internal and response error
 * internalCodes and message.
 *
 * @param {number} internalCode internal error code.
 * @param {number} responseCode response error code.
 * @param {string} message developer-consumable error message.
 * @constructor
 */
function MslError(internalCode, responseCode, message) {
    /** Internal error code base value. */
    var BASE = 100000;

    // There is no way to make the constructor private, so only add BASE if the
    // internal error code is less than BASE, as a safety check. In this way a
    // MslError could be created directly that is not one of the defined
    // constants.
    if (internalCode < BASE){
        internalCode = BASE + internalCode;
    }

    // The properties.
    var props = {
        internalCode: { value: internalCode, writable: false, configurable: false },
        responseCode: { value: responseCode, writable: false, configurable: false },
        message: { value: message, writable: false, configurable: false }
    };

    Object.defineProperties(this, props);
};

util.Class.mixin(MslError,
/** @lends {MslError} */
({
    // 0 Message Security Layer
    JSON_PARSE_ERROR : new MslError(0, MslConstants$ResponseCode.FAIL, "Error parsing JSON."),
    JSON_ENCODE_ERROR : new MslError(1, MslConstants$ResponseCode.FAIL, "Error encoding JSON."),
    ENVELOPE_HASH_MISMATCH : new MslError(2, MslConstants$ResponseCode.FAIL, "Computed hash does not match envelope hash."),
    INVALID_PUBLIC_KEY : new MslError(3, MslConstants$ResponseCode.FAIL, "Invalid public key provided."),
    INVALID_PRIVATE_KEY : new MslError(4, MslConstants$ResponseCode.FAIL, "Invalid private key provided."),
    PLAINTEXT_ILLEGAL_BLOCK_SIZE : new MslError(5, MslConstants$ResponseCode.FAIL, "Plaintext is not a multiple of the block size."),
    PLAINTEXT_BAD_PADDING : new MslError(6, MslConstants$ResponseCode.FAIL, "Plaintext contains incorrect padding."),
    CIPHERTEXT_ILLEGAL_BLOCK_SIZE : new MslError(7, MslConstants$ResponseCode.FAIL, "Ciphertext is not a multiple of the block size."),
    CIPHERTEXT_BAD_PADDING : new MslError(8, MslConstants$ResponseCode.FAIL, "Ciphertext contains incorrect padding."),
    ENCRYPT_NOT_SUPPORTED : new MslError(9, MslConstants$ResponseCode.FAIL, "Encryption not supported."),
    DECRYPT_NOT_SUPPORTED : new MslError(10, MslConstants$ResponseCode.FAIL, "Decryption not supported."),
    ENVELOPE_KEY_ID_MISMATCH : new MslError(11, MslConstants$ResponseCode.FAIL, "Encryption envelope key ID does not match crypto context key ID."),
    CIPHERTEXT_ENVELOPE_PARSE_ERROR : new MslError(12, MslConstants$ResponseCode.FAIL, "Error parsing ciphertext envelope."),
    CIPHERTEXT_ENVELOPE_ENCODE_ERROR : new MslError(13, MslConstants$ResponseCode.FAIL, "Error encoding ciphertext envelope."),
    SIGN_NOT_SUPPORTED : new MslError(14, MslConstants$ResponseCode.FAIL, "Sign not supported."),
    VERIFY_NOT_SUPPORTED : new MslError(15, MslConstants$ResponseCode.FAIL, "Verify not suppoprted."),
    SIGNATURE_ERROR : new MslError(16, MslConstants$ResponseCode.FAIL, "Signature not initialized or unable to process data/signature."),
    HMAC_ERROR : new MslError(17, MslConstants$ResponseCode.FAIL, "Error computing HMAC."),
    ENCRYPT_ERROR : new MslError(18, MslConstants$ResponseCode.FAIL, "Error encrypting plaintext."),
    DECRYPT_ERROR : new MslError(19, MslConstants$ResponseCode.FAIL, "Error decrypting ciphertext."),
    INSUFFICIENT_CIPHERTEXT : new MslError(20, MslConstants$ResponseCode.FAIL, "Insufficient ciphertext for decryption."),
    SESSION_KEY_CREATION_FAILURE : new MslError(21, MslConstants$ResponseCode.FAIL, "Error when creating session keys."),
    ASN1_PARSE_ERROR : new MslError(22, MslConstants$ResponseCode.FAIL, "Error parsing ASN.1."),
    ASN1_ENCODE_ERROR : new MslError(23, MslConstants$ResponseCode.FAIL, "Error encoding ASN.1."),
    INVALID_SYMMETRIC_KEY : new MslError(24, MslConstants$ResponseCode.FAIL, "Invalid symmetric key provided."),
    INVALID_ENCRYPTION_KEY : new MslError(25, MslConstants$ResponseCode.FAIL, "Invalid encryption key."),
    INVALID_HMAC_KEY : new MslError(26, MslConstants$ResponseCode.FAIL, "Invalid HMAC key."),
    WRAP_NOT_SUPPORTED : new MslError(27, MslConstants$ResponseCode.FAIL, "Wrap not supported."),
    UNWRAP_NOT_SUPPORTED : new MslError(28, MslConstants$ResponseCode.FAIL, "Unwrap not supported."),
    UNIDENTIFIED_JWK_TYPE : new MslError(29, MslConstants$ResponseCode.FAIL, "Unidentified JSON web key type."),
    UNIDENTIFIED_JWK_USAGE : new MslError(30, MslConstants$ResponseCode.FAIL, "Unidentified JSON web key usage."),
    UNIDENTIFIED_JWK_ALGORITHM : new MslError(31, MslConstants$ResponseCode.FAIL, "Unidentified JSON web key algorithm."),
    WRAP_ERROR : new MslError(32, MslConstants$ResponseCode.FAIL, "Error wrapping plaintext."),
    UNWRAP_ERROR : new MslError(33, MslConstants$ResponseCode.FAIL, "Error unwrapping ciphertext."),
    INVALID_JWK : new MslError(34, MslConstants$ResponseCode.FAIL, "Invalid JSON web key."),
    INVALID_JWK_KEYDATA : new MslError(35, MslConstants$ResponseCode.FAIL, "Invalid JSON web key keydata."),
    UNSUPPORTED_JWK_ALGORITHM : new MslError(36, MslConstants$ResponseCode.FAIL, "Unsupported JSON web key algorithm."),
    WRAP_KEY_CREATION_FAILURE : new MslError(37, MslConstants$ResponseCode.FAIL, "Error when creating wrapping key."),
    INVALID_WRAP_CIPHERTEXT : new MslError(38, MslConstants$ResponseCode.FAIL, "Invalid wrap ciphertext."),
    UNSUPPORTED_JWE_ALGORITHM : new MslError(39, MslConstants$ResponseCode.FAIL, "Unsupported JSON web encryption algorithm."),
    JWE_ENCODE_ERROR : new MslError(40, MslConstants$ResponseCode.FAIL, "Error encoding JSON web encryption header."),
    JWE_PARSE_ERROR : new MslError(41, MslConstants$ResponseCode.FAIL, "Error parsing JSON web encryption header."),
    INVALID_ALGORITHM_PARAMS : new MslError(42, MslConstants$ResponseCode.FAIL, "Invalid algorithm parameters."),
    JWE_ALGORITHM_MISMATCH : new MslError(43, MslConstants$ResponseCode.FAIL, "JSON web encryption header algorithms mismatch."),
    KEY_IMPORT_ERROR : new MslError(44, MslConstants$ResponseCode.FAIL, "Error importing key."),
    KEY_EXPORT_ERROR : new MslError(45, MslConstants$ResponseCode.FAIL, "Error exporting key."),
    DIGEST_ERROR : new MslError(46, MslConstants$ResponseCode.FAIL, "Error in digest."),
    UNSUPPORTED_KEY : new MslError(47, MslConstants$ResponseCode.FAIL, "Unsupported key type or algorithm."),
    UNSUPPORTED_JWE_SERIALIZATION : new MslError(48, MslConstants$ResponseCode.FAIL, "Unsupported JSON web encryption serialization."),
    XML_PARSE_ERROR : new MslError(49, MslConstants$ResponseCode.FAIL, "Error parsing XML."),
    XML_ENCODE_ERROR : new MslError(50, MslConstants$ResponseCode.FAIL, "Error encoding XML."),
    INVALID_WRAPPING_KEY : new MslError(51, MslConstants$ResponseCode.FAIL, "Invalid wrapping key."),
    UNIDENTIFIED_CIPHERTEXT_ENVELOPE : new MslError(52, MslConstants$ResponseCode.FAIL, "Unidentified ciphertext envelope version."),
    UNIDENTIFIED_SIGNATURE_ENVELOPE : new MslError(53, MslConstants$ResponseCode.FAIL, "Unidentified signature envelope version."),
    UNSUPPORTED_CIPHERTEXT_ENVELOPE : new MslError(54, MslConstants$ResponseCode.FAIL, "Unsupported ciphertext envelope version."),
    UNSUPPORTED_SIGNATURE_ENVELOPE : new MslError(55, MslConstants$ResponseCode.FAIL, "Unsupported signature envelope version."),
    UNIDENTIFIED_CIPHERSPEC : new MslError(56, MslConstants$ResponseCode.FAIL, "Unidentified cipher specification."),
    UNIDENTIFIED_ALGORITHM : new MslError(57, MslConstants$ResponseCode.FAIL, "Unidentified algorithm."),
    SIGNATURE_ENVELOPE_PARSE_ERROR : new MslError(58, MslConstants$ResponseCode.FAIL, "Error parsing signature envelope."),
    SIGNATURE_ENVELOPE_ENCODE_ERROR : new MslError(59, MslConstants$ResponseCode.FAIL, "Error encoding signature envelope."),
    INVALID_SIGNATURE : new MslError(60, MslConstants$ResponseCode.FAIL, "Invalid signature."),
    WRAPKEY_FINGERPRINT_NOTSUPPORTED : new MslError(61, MslConstants$ResponseCode.FAIL, "Wrap key fingerprint not supported"),
    UNIDENTIFIED_JWK_KEYOP : new MslError(62, MslConstants$ResponseCode.FAIL, "Unidentified JSON web key key operation."),

    // 1 Master Token
    MASTERTOKEN_UNTRUSTED : new MslError(1000, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token is not trusted."),
    MASTERTOKEN_KEY_CREATION_ERROR : new MslError(1001, MslConstants$ResponseCode.ENTITY_REAUTH, "Unable to construct symmetric keys from master token."),
    MASTERTOKEN_EXPIRES_BEFORE_RENEWAL : new MslError(1002, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token expiration timestamp is before the renewal window opens."),
    MASTERTOKEN_SESSIONDATA_MISSING : new MslError(1003, MslConstants$ResponseCode.ENTITY_REAUTH, "No master token session data found."),
    MASTERTOKEN_SEQUENCE_NUMBER_OUT_OF_RANGE : new MslError(1004, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token sequence number is out of range."),
    MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE : new MslError(1005, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token serial number is out of range."),
    MASTERTOKEN_TOKENDATA_INVALID : new MslError(1006, MslConstants$ResponseCode.ENTITY_REAUTH, "Invalid master token data."),
    MASTERTOKEN_SIGNATURE_INVALID : new MslError(1007, MslConstants$ResponseCode.ENTITY_REAUTH, "Invalid master token signature."),
    MASTERTOKEN_SESSIONDATA_INVALID : new MslError(1008, MslConstants$ResponseCode.ENTITY_REAUTH, "Invalid master token session data."),
    MASTERTOKEN_SEQUENCE_NUMBER_OUT_OF_SYNC : new MslError(1009, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token sequence number does not have the expected value."),
    MASTERTOKEN_TOKENDATA_MISSING : new MslError(1010, MslConstants$ResponseCode.ENTITY_REAUTH, "No master token data found."),
    MASTERTOKEN_TOKENDATA_PARSE_ERROR : new MslError(1011, MslConstants$ResponseCode.ENTITY_REAUTH, "Error parsing master token data."),
    MASTERTOKEN_SESSIONDATA_PARSE_ERROR : new MslError(1012, MslConstants$ResponseCode.ENTITY_REAUTH, "Error parsing master token session data."),
    MASTERTOKEN_IDENTITY_REVOKED : new MslError(1013, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token entity identity is revoked."),
    MASTERTOKEN_REJECTED_BY_APP : new MslError(1014, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token is rejected by the application."),

    // 2 User ID Token
    USERIDTOKEN_MASTERTOKEN_MISMATCH : new MslError(2000, MslConstants$ResponseCode.USER_REAUTH, "User ID token master token serial number does not match master token serial number."),
    USERIDTOKEN_NOT_DECRYPTED : new MslError(2001, MslConstants$ResponseCode.USER_REAUTH, "User ID token is not decrypted or verified."),
    USERIDTOKEN_MASTERTOKEN_NULL : new MslError(2002, MslConstants$ResponseCode.USER_REAUTH, "User ID token requires a master token."),
    USERIDTOKEN_EXPIRES_BEFORE_RENEWAL : new MslError(2003, MslConstants$ResponseCode.USER_REAUTH, "User ID token expiration timestamp is before the renewal window opens."),
    USERIDTOKEN_USERDATA_MISSING : new MslError(2004, MslConstants$ResponseCode.USER_REAUTH, "No user ID token user data found."),
    USERIDTOKEN_MASTERTOKEN_NOT_FOUND : new MslError(2005, MslConstants$ResponseCode.USER_REAUTH, "User ID token is bound to an unknown master token."),
    USERIDTOKEN_MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE : new MslError(2006, MslConstants$ResponseCode.USER_REAUTH, "User ID token master token serial number is out of range."),
    USERIDTOKEN_SERIAL_NUMBER_OUT_OF_RANGE : new MslError(2007, MslConstants$ResponseCode.USER_REAUTH, "User ID token serial number is out of range."),
    USERIDTOKEN_TOKENDATA_INVALID : new MslError(2008, MslConstants$ResponseCode.USER_REAUTH, "Invalid user ID token data."),
    USERIDTOKEN_SIGNATURE_INVALID : new MslError(2009, MslConstants$ResponseCode.USER_REAUTH, "Invalid user ID token signature."),
    USERIDTOKEN_USERDATA_INVALID : new MslError(2010, MslConstants$ResponseCode.USER_REAUTH, "Invalid user ID token user data."),
    USERIDTOKEN_IDENTITY_INVALID : new MslError(2011, MslConstants$ResponseCode.USER_REAUTH, "Invalid user ID token user identity."),
    RESERVED_2012 : new MslError(2012, MslConstants$ResponseCode.USER_REAUTH, "The entity is not associated with the user."),
    USERIDTOKEN_IDENTITY_NOT_FOUND : new MslError(2013, MslConstants$ResponseCode.USER_REAUTH, "The user identity was not found."),
    USERIDTOKEN_PASSWORD_VERSION_CHANGED : new MslError(2014, MslConstants$ResponseCode.USER_REAUTH, "The user identity must be reauthenticated because the password version changed."),
    USERIDTOKEN_USERAUTH_DATA_MISMATCH : new MslError(2015, MslConstants$ResponseCode.USER_REAUTH, "The user ID token and user authentication data user identities do not match."),
    USERIDTOKEN_TOKENDATA_MISSING : new MslError(2016, MslConstants$ResponseCode.USER_REAUTH, "No user ID token data found."),
    USERIDTOKEN_TOKENDATA_PARSE_ERROR : new MslError(2017, MslConstants$ResponseCode.USER_REAUTH, "Error parsing user ID token data."),
    USERIDTOKEN_USERDATA_PARSE_ERROR : new MslError(2018, MslConstants$ResponseCode.USER_REAUTH, "Error parsing user ID token user data."),
    USERIDTOKEN_REVOKED : new MslError(2019, MslConstants$ResponseCode.USER_REAUTH, "User ID token is revoked."),
    USERIDTOKEN_REJECTED_BY_APP : new MslError(2020, MslConstants$ResponseCode.USER_REAUTH, "User ID token is rejected by the application."),

    // 3 Service Token
    SERVICETOKEN_MASTERTOKEN_MISMATCH : new MslError(3000, MslConstants$ResponseCode.FAIL, "Service token master token serial number does not match master token serial number."),
    SERVICETOKEN_USERIDTOKEN_MISMATCH : new MslError(3001, MslConstants$ResponseCode.FAIL, "Service token user ID token serial number does not match user ID token serial number."),
    SERVICETOKEN_SERVICEDATA_INVALID : new MslError(3002, MslConstants$ResponseCode.FAIL, "Service token data invalid."),
    SERVICETOKEN_MASTERTOKEN_NOT_FOUND : new MslError(3003, MslConstants$ResponseCode.FAIL, "Service token is bound to an unknown master token."),
    SERVICETOKEN_USERIDTOKEN_NOT_FOUND : new MslError(3004, MslConstants$ResponseCode.FAIL, "Service token is bound to an unknown user ID token."),
    SERVICETOKEN_MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE : new MslError(3005, MslConstants$ResponseCode.FAIL, "Service token master token serial number is out of range."),
    SERVICETOKEN_USERIDTOKEN_SERIAL_NUMBER_OUT_OF_RANGE : new MslError(3006, MslConstants$ResponseCode.FAIL, "Service token user ID token serial number is out of range."),
    SERVICETOKEN_TOKENDATA_INVALID : new MslError(3007, MslConstants$ResponseCode.FAIL, "Invalid service token data."),
    SERVICETOKEN_SIGNATURE_INVALID : new MslError(3008, MslConstants$ResponseCode.FAIL, "Invalid service token signature."),
    SERVICETOKEN_TOKENDATA_MISSING : new MslError(3009, MslConstants$ResponseCode.FAIL, "No service token data found."),

    // 4 Entity Authentication
    UNIDENTIFIED_ENTITYAUTH_SCHEME : new MslError(4000, MslConstants$ResponseCode.FAIL, "Unable to identify entity authentication scheme."),
    ENTITYAUTH_FACTORY_NOT_FOUND : new MslError(4001, MslConstants$ResponseCode.FAIL, "No factory registered for entity authentication scheme."),
    X509CERT_PARSE_ERROR : new MslError(4002, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Error parsing X.509 certificate data."),
    X509CERT_ENCODE_ERROR : new MslError(4003, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Error encoding X.509 certificate data."),
    X509CERT_VERIFICATION_FAILED : new MslError(4004, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "X.509 certificate verification failed."),
    ENTITY_NOT_FOUND : new MslError(4005, MslConstants$ResponseCode.FAIL, "Entity not recognized."),
    INCORRECT_ENTITYAUTH_DATA : new MslError(4006, MslConstants$ResponseCode.FAIL, "Entity used incorrect entity authentication data type."),
    RSA_PUBLICKEY_NOT_FOUND : new MslError(4007, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "RSA public key not found."),
    NPTICKET_GRACE_PERIOD_EXCEEDED : new MslError(4008, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Fake NP-Tickets cannot be used after the grace period when the Playstation Network is up."),
    NPTICKET_SERVICE_ID_MISSING : new MslError(4009, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "NP-Ticket service ID is missing."),
    NPTICKET_SERVICE_ID_DISALLOWED : new MslError(4010, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "NP-Ticket service ID is not allowed."),
    NPTICKET_NOT_YET_VALID : new MslError(4011, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "NP-Ticket issuance date is in the future."),
    NPTICKET_EXPIRED : new MslError(4012, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "NP-Ticket has expired."),
    NPTICKET_PRIVATE_KEY_NOT_FOUND : new MslError(4013, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "No private key found for NP-Ticket GUID."),
    NPTICKET_COOKIE_VERIFICATION_FAILED : new MslError(4014, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "NP-Ticket cookie signature verification failed."),
    NPTICKET_INCORRECT_COOKIE_VERSION : new MslError(4015, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Incorrect NP-Ticket cookie version."),
    NPTICKET_BROKEN : new MslError(4016, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "NP-Ticket broken."),
    NPTICKET_VERIFICATION_FAILED : new MslError(4017, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "NP-Ticket signature verification failed."),
    NPTICKET_ERROR : new MslError(4018, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Unknown NP-Ticket TCM error."),
    NPTICKET_CIPHER_INFO_NOT_FOUND : new MslError(4019, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "No cipher information found for NP-Ticket."),
    NPTICKET_INVALID_CIPHER_INFO : new MslError(4020, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Cipher information for NP-Ticket is invalid."),
    NPTICKET_UNSUPPORTED_VERSION : new MslError(4021, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Unsupported NP-Ticket version."),
    NPTICKET_INCORRECT_KEY_LENGTH : new MslError(4022, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Incorrect NP-Ticket public key length."),
    UNSUPPORTED_ENTITYAUTH_DATA : new MslError(4023, MslConstants$ResponseCode.FAIL, "Unsupported entity authentication data."),
    CRYPTEX_RSA_KEY_SET_NOT_FOUND : new MslError(4024, MslConstants$ResponseCode.FAIL, "Cryptex RSA key set not found."),
    ENTITY_REVOKED : new MslError(4025, MslConstants$ResponseCode.FAIL, "Entity is revoked."),
    ENTITY_REJECTED_BY_APP : new MslError(4026, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Entity is rejected by the application."),

    // 5 User Authentication
    FORCE_LOGIN : new MslError(5000, MslConstants$ResponseCode.USERDATA_REAUTH, "User must login again."),
    NETFLIXID_COOKIES_EXPIRED : new MslError(5001, MslConstants$ResponseCode.USERDATA_REAUTH, "Netflix ID cookie identity has expired."),
    NETFLIXID_COOKIES_BLANK : new MslError(5002, MslConstants$ResponseCode.USERDATA_REAUTH, "Netflix ID or Secure Netflix ID cookie is blank."),
    UNIDENTIFIED_USERAUTH_SCHEME : new MslError(5003, MslConstants$ResponseCode.FAIL, "Unable to identify user authentication scheme."),
    USERAUTH_FACTORY_NOT_FOUND : new MslError(5004, MslConstants$ResponseCode.FAIL, "No factory registered for user authentication scheme."),
    EMAILPASSWORD_BLANK : new MslError(5005, MslConstants$ResponseCode.USERDATA_REAUTH, "Email or password is blank."),
    AUTHMGR_COMMS_FAILURE : new MslError(5006, MslConstants$ResponseCode.TRANSIENT_FAILURE, "Error communicating with authentication manager."),
    EMAILPASSWORD_INCORRECT : new MslError(5007, MslConstants$ResponseCode.USERDATA_REAUTH, "Email or password is incorrect."),
    UNSUPPORTED_USERAUTH_DATA : new MslError(5008, MslConstants$ResponseCode.FAIL, "Unsupported user authentication data."),
    SSOTOKEN_BLANK : new MslError(5009, MslConstants$ResponseCode.SSOTOKEN_REJECTED, "SSO token is blank."),
    SSOTOKEN_NOT_ASSOCIATED : new MslError(5010, MslConstants$ResponseCode.USERDATA_REAUTH, "SSO token is not associated with a Netflix user."),
    USERAUTH_USERIDTOKEN_INVALID : new MslError(5011, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication data user ID token is invalid."),
    PROFILEID_BLANK : new MslError(5012, MslConstants$ResponseCode.USERDATA_REAUTH, "Profile ID is blank."),
    UNIDENTIFIED_USERAUTH_MECHANISM : new MslError(5013, MslConstants$ResponseCode.FAIL, "Unable to identify user authentication mechanism."),
    UNSUPPORTED_USERAUTH_MECHANISM : new MslError(5014, MslConstants$ResponseCode.FAIL, "Unsupported user authentication mechanism."),
    SSOTOKEN_INVALID : new MslError(5015, MslConstants$ResponseCode.SSOTOKEN_REJECTED, "SSO token invalid."),
    USERAUTH_MASTERTOKEN_MISSING : new MslError(5016, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication required master token is missing."),
    ACCTMGR_COMMS_FAILURE : new MslError(5017, MslConstants$ResponseCode.TRANSIENT_FAILURE, "Error communicating with the account manager."),
    SSO_ASSOCIATION_FAILURE : new MslError(5018, MslConstants$ResponseCode.TRANSIENT_FAILURE, "SSO user association failed."),
    SSO_DISASSOCIATION_FAILURE : new MslError(5019, MslConstants$ResponseCode.TRANSIENT_FAILURE, "SSO user disassociation failed."),
    MDX_USERAUTH_VERIFICATION_FAILED : new MslError(5020, MslConstants$ResponseCode.USERDATA_REAUTH, "MDX user authentication data verification failed."),
    USERAUTH_USERIDTOKEN_NOT_DECRYPTED : new MslError(5021, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication data user ID token is not decrypted or verified."),
    MDX_USERAUTH_ACTION_INVALID : new MslError(5022, MslConstants$ResponseCode.USERDATA_REAUTH, "MDX user authentication data action is invalid."),
    CTICKET_DECRYPT_ERROR : new MslError(5023, MslConstants$ResponseCode.USERDATA_REAUTH, "CTicket decryption failed."),
    USERAUTH_MASTERTOKEN_INVALID : new MslError(5024, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication data master token is invalid."),
    USERAUTH_MASTERTOKEN_NOT_DECRYPTED : new MslError(5025, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication data master token is not decrypted or verified."),
    CTICKET_CRYPTOCONTEXT_ERROR : new MslError(5026, MslConstants$ResponseCode.USERDATA_REAUTH, "Error creating CTicket crypto context."),
    MDX_PIN_BLANK : new MslError(5027, MslConstants$ResponseCode.USERDATA_REAUTH, "MDX controller or target PIN is blank."),
    MDX_PIN_MISMATCH : new MslError(5028, MslConstants$ResponseCode.USERDATA_REAUTH, "MDX controller and target PIN mismatch."),
    MDX_USER_UNKNOWN : new MslError(5029, MslConstants$ResponseCode.USERDATA_REAUTH, "MDX controller user ID token or CTicket is not decrypted or verified."),
    USERAUTH_USERIDTOKEN_MISSING : new MslError(5030, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication required user ID token is missing."),
    MDX_CONTROLLERDATA_INVALID : new MslError(5031, MslConstants$ResponseCode.USERDATA_REAUTH, "MDX controller authentication data is invalid."),
    USERAUTH_ENTITY_MISMATCH : new MslError(5032, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication data does not match entity identity."),
    USERAUTH_INCORRECT_DATA : new MslError(5033, MslConstants$ResponseCode.FAIL, "Entity used incorrect key request data type"),
    SSO_ASSOCIATION_WITH_NONMEMBER : new MslError(5034, MslConstants$ResponseCode.USERDATA_REAUTH, "SSO user association failed because the customer is not a member."),
    SSO_ASSOCIATION_WITH_FORMERMEMBER : new MslError(5035, MslConstants$ResponseCode.USERDATA_REAUTH, "SSO user association failed because the customer is a former member."),
    SSO_ASSOCIATION_CONFLICT : new MslError(5036, MslConstants$ResponseCode.USERDATA_REAUTH, "SSO user association failed because the token identifies a different member."),
    USER_REJECTED_BY_APP : new MslError(5037, MslConstants$ResponseCode.USERDATA_REAUTH, "User is rejected by the application."),
    PROFILE_SWITCH_DISALLOWED : new MslError(5038, MslConstants$ResponseCode.TRANSIENT_FAILURE, "Unable to switch user profile."),
    MEMBERSHIPCLIENT_COMMS_FAILURE : new MslError(5039, MslConstants$ResponseCode.TRANSIENT_FAILURE, "Error communicating with the membership manager."),
    USERIDTOKEN_IDENTITY_NOT_ASSOCIATED_WITH_ENTITY : new MslError(5040, MslConstants$ResponseCode.USER_REAUTH, "The entity is not associated with the user."),

    // 6 Message
    UNSUPPORTED_COMPRESSION : new MslError(6000, MslConstants$ResponseCode.FAIL, "Unsupported compression algorithm."),
    COMPRESSION_ERROR : new MslError(6001, MslConstants$ResponseCode.FAIL, "Error compressing data."),
    UNCOMPRESSION_ERROR : new MslError(6002, MslConstants$ResponseCode.FAIL, "Error uncompressing data."),
    MESSAGE_ENTITY_NOT_FOUND : new MslError(6003, MslConstants$ResponseCode.FAIL, "Message header entity authentication data or master token not found."),
    PAYLOAD_MESSAGE_ID_MISMATCH : new MslError(6004, MslConstants$ResponseCode.FAIL, "Payload chunk message ID does not match header message ID ."),
    PAYLOAD_SEQUENCE_NUMBER_MISMATCH : new MslError(6005, MslConstants$ResponseCode.FAIL, "Payload chunk sequence number does not match expected sequence number."),
    PAYLOAD_VERIFICATION_FAILED : new MslError(6006, MslConstants$ResponseCode.FAIL, "Payload chunk payload signature verification failed."),
    MESSAGE_DATA_MISSING : new MslError(6007, MslConstants$ResponseCode.FAIL, "No message data found."),
    MESSAGE_FORMAT_ERROR : new MslError(6008, MslConstants$ResponseCode.FAIL, "Malformed message data."),
    MESSAGE_VERIFICATION_FAILED : new MslError(6009, MslConstants$ResponseCode.FAIL, "Message header/error data signature verification failed."),
    HEADER_DATA_MISSING : new MslError(6010, MslConstants$ResponseCode.FAIL, "No header data found."),
    PAYLOAD_DATA_MISSING : new MslError(6011, MslConstants$ResponseCode.FAIL, "No payload data found in non-EOM payload chunk."),
    PAYLOAD_DATA_CORRUPT : new MslError(6012, MslConstants$ResponseCode.FAIL, "Corrupt payload data found in non-EOM payload chunk."),
    UNIDENTIFIED_COMPRESSION : new MslError(6013, MslConstants$ResponseCode.FAIL, "Unidentified compression algorithm."),
    MESSAGE_EXPIRED : new MslError(6014, MslConstants$ResponseCode.EXPIRED, "Message expired and not renewable. Rejected."),
    MESSAGE_ID_OUT_OF_RANGE : new MslError(6015, MslConstants$ResponseCode.FAIL, "Message ID is out of range."),
    INTERNAL_CODE_NEGATIVE : new MslError(6016, MslConstants$ResponseCode.FAIL, "Error header internal code is negative."),
    UNEXPECTED_RESPONSE_MESSAGE_ID : new MslError(6017, MslConstants$ResponseCode.FAIL, "Unexpected response message ID. Possible replay."),
    RESPONSE_REQUIRES_ENCRYPTION : new MslError(6018, MslConstants$ResponseCode.KEYX_REQUIRED, "Message response requires encryption."),
    PAYLOAD_SEQUENCE_NUMBER_OUT_OF_RANGE : new MslError(6019, MslConstants$ResponseCode.FAIL, "Payload chunk sequence number is out of range."),
    PAYLOAD_MESSAGE_ID_OUT_OF_RANGE : new MslError(6020, MslConstants$ResponseCode.FAIL, "Payload chunk message ID is out of range."),
    MESSAGE_REPLAYED : new MslError(6021, MslConstants$ResponseCode.REPLAYED, "Non-replayable message replayed."),
    INCOMPLETE_NONREPLAYABLE_MESSAGE : new MslError(6022, MslConstants$ResponseCode.FAIL, "Non-replayable message sent non-renewable or without key request data or without a master token."),
    HEADER_SIGNATURE_INVALID : new MslError(6023, MslConstants$ResponseCode.FAIL, "Invalid Header signature."),
    HEADER_DATA_INVALID : new MslError(6024, MslConstants$ResponseCode.FAIL, "Invalid header data."),
    PAYLOAD_INVALID : new MslError(6025, MslConstants$ResponseCode.FAIL, "Invalid payload."),
    PAYLOAD_SIGNATURE_INVALID : new MslError(6026, MslConstants$ResponseCode.FAIL, "Invalid payload signature."),
    RESPONSE_REQUIRES_MASTERTOKEN : new MslError(6027, MslConstants$ResponseCode.KEYX_REQUIRED, "Message response requires a master token."),
    RESPONSE_REQUIRES_USERIDTOKEN : new MslError(6028, MslConstants$ResponseCode.USER_REAUTH, "Message response requires a user ID token."),
    REQUEST_REQUIRES_USERAUTHDATA : new MslError(6029, MslConstants$ResponseCode.FAIL, "User-associated message requires user authentication data."),
    UNEXPECTED_MESSAGE_SENDER : new MslError(6030, MslConstants$ResponseCode.FAIL, "Message sender is equal to the local entity or not the master token entity."),
    NONREPLAYABLE_MESSAGE_REQUIRES_MASTERTOKEN : new MslError(6031, MslConstants$ResponseCode.FAIL, "Non-replayable message requires a master token."),
    NONREPLAYABLE_ID_OUT_OF_RANGE : new MslError(6032, MslConstants$ResponseCode.FAIL, "Non-replayable message non-replayable ID is out of range."),
    MESSAGE_SERVICETOKEN_MISMATCH : new MslError(6033, MslConstants$ResponseCode.FAIL, "Service token master token or user ID token serial number does not match the message token serial numbers."),
    MESSAGE_PEER_SERVICETOKEN_MISMATCH : new MslError(6034, MslConstants$ResponseCode.FAIL, "Peer service token master token or user ID token serial number does not match the message peer token serial numbers."),
    RESPONSE_REQUIRES_INTEGRITY_PROTECTION : new MslError(6035, MslConstants$ResponseCode.KEYX_REQUIRED, "Message response requires integrity protection."),
    HANDSHAKE_DATA_MISSING : new MslError(6036, MslConstants$ResponseCode.FAIL, "Handshake message is not renewable or does not contain key request data."),
    MESSAGE_RECIPIENT_MISMATCH : new MslError(6037, MslConstants$ResponseCode.FAIL, "Message recipient does not match local identity."),

    // 7 Key Exchange
    UNIDENTIFIED_KEYX_SCHEME : new MslError(7000, MslConstants$ResponseCode.FAIL, "Unable to identify key exchange scheme."),
    KEYX_FACTORY_NOT_FOUND : new MslError(7001, MslConstants$ResponseCode.FAIL, "No factory registered for key exchange scheme."),
    KEYX_REQUEST_NOT_FOUND : new MslError(7002, MslConstants$ResponseCode.FAIL, "No key request found matching header key response data."),
    UNIDENTIFIED_KEYX_KEY_ID : new MslError(7003, MslConstants$ResponseCode.FAIL, "Unable to identify key exchange key ID."),
    UNSUPPORTED_KEYX_KEY_ID : new MslError(7004, MslConstants$ResponseCode.FAIL, "Unsupported key exchange key ID."),
    UNIDENTIFIED_KEYX_MECHANISM : new MslError(7005, MslConstants$ResponseCode.FAIL, "Unable to identify key exchange mechanism."),
    UNSUPPORTED_KEYX_MECHANISM : new MslError(7006, MslConstants$ResponseCode.FAIL, "Unsupported key exchange mechanism."),
    KEYX_RESPONSE_REQUEST_MISMATCH : new MslError(7007, MslConstants$ResponseCode.FAIL, "Key exchange response does not match request."),
    KEYX_PRIVATE_KEY_MISSING : new MslError(7008, MslConstants$ResponseCode.FAIL, "Key exchange private key missing."),
    UNKNOWN_KEYX_PARAMETERS_ID : new MslError(7009, MslConstants$ResponseCode.FAIL, "Key exchange parameters ID unknown or invalid."),
    KEYX_MASTER_TOKEN_MISSING : new MslError(7010, MslConstants$ResponseCode.FAIL, "Master token required for key exchange is missing."),
    KEYX_INVALID_PUBLIC_KEY : new MslError(7011, MslConstants$ResponseCode.FAIL, "Key exchange public key is invalid."),
    KEYX_PUBLIC_KEY_MISSING : new MslError(7012, MslConstants$ResponseCode.FAIL, "Key exchange public key missing."),
    KEYX_WRAPPING_KEY_MISSING : new MslError(7013, MslConstants$ResponseCode.FAIL, "Key exchange wrapping key missing."),
    KEYX_WRAPPING_KEY_ID_MISSING : new MslError(7014, MslConstants$ResponseCode.FAIL, "Key exchange wrapping key ID missing."),
    KEYX_INVALID_WRAPPING_KEY : new MslError(7015, MslConstants$ResponseCode.FAIL, "Key exchange wrapping key is invalid."),
    KEYX_INCORRECT_DATA : new MslError(7016, MslConstants$ResponseCode.FAIL, "Entity used incorrect wrapping key data type"),

    // 8 Service Errors
    CRYPTEX_ENCRYPTION_ERROR : new MslError(8000, MslConstants$ResponseCode.FAIL, "Error encrypting data with cryptex."),
    CRYPTEX_DECRYPTION_ERROR : new MslError(8001, MslConstants$ResponseCode.FAIL, "Error decrypting data with cryptex."),
    CRYPTEX_MAC_ERROR : new MslError(8002, MslConstants$ResponseCode.FAIL, "Error computing MAC with cryptex."),
    CRYPTEX_VERIFY_ERROR : new MslError(8003, MslConstants$ResponseCode.FAIL, "Error verifying MAC with cryptex."),
    CRYPTEX_CONTEXT_CREATION_FAILURE : new MslError(8004, MslConstants$ResponseCode.FAIL, "Error creating cryptex cipher or MAC context."),
    DATAMODEL_DEVICE_ACCESS_ERROR : new MslError(8005, MslConstants$ResponseCode.TRANSIENT_FAILURE, "Error accessing data model device."),
    DATAMODEL_DEVICETYPE_NOT_FOUND : new MslError(8006, MslConstants$ResponseCode.FAIL, "Data model device type not found."),
    CRYPTEX_KEYSET_UNSUPPORTED : new MslError(8007, MslConstants$ResponseCode.FAIL, "Cryptex key set not supported."),
    CRYPTEX_PRIVILEGE_EXCEPTION : new MslError(8008, MslConstants$ResponseCode.FAIL, "Insufficient privileges for cryptex operation."),
    CRYPTEX_WRAP_ERROR : new MslError(8009, MslConstants$ResponseCode.FAIL, "Error wrapping data with cryptex."),
    CRYPTEX_UNWRAP_ERROR : new MslError(8010, MslConstants$ResponseCode.FAIL, "Error unwrapping data with cryptex."),
    CRYPTEX_COMMS_FAILURE : new MslError(8011, MslConstants$ResponseCode.TRANSIENT_FAILURE, "Error comunicating with cryptex."),
    CRYPTEX_SIGN_ERROR : new MslError(8012, MslConstants$ResponseCode.FAIL, "Error computing signature with cryptex."),

    // 9 Internal Errors
    INTERNAL_EXCEPTION : new MslError(9000, MslConstants$ResponseCode.TRANSIENT_FAILURE, "Internal exception."),
    MSL_COMMS_FAILURE : new MslError(9001, MslConstants$ResponseCode.FAIL, "Error communicating with MSL entity."),
    NONE : new MslError(9999, MslConstants$ResponseCode.FAIL, "Special unit test error.")
}));
Object.freeze(MslError);


// -- javascript/MslException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when an exception occurs within the Message Security Layer.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslException;

(function() {
    MslException = util.Class.create(new Error());

    var proto = {
        /**
         * Construct a new MSL exception with the specified error, details, and
         * cause.
         *
         * @param {MslError} error the error.
         * @param {string} details the details text. May be null or undefined.
         * @param {Error} cause the cause. May be null or undefined.
         * @constructor
         */
        init: function init(error, details, cause) {
            // Fix my stack trace.
            if (Error.captureStackTrace)
                Error.captureStackTrace(this, this.constructor);

            // Construct the message.
            var message = error.message;
            if (details)
                message += " [" + details + "]";

            // Hide the message ID inside this scope.
            var messageId;
            /**
             * Set the message ID of the message associated with the exception. This
             * does nothing if the message ID is already set.
             *
             * @param id message ID of the message associated with this error.
             */
            function setMessageId(id) {
                if (id < 0 || id > MslConstants$MAX_LONG_VALUE)
                    throw new RangeError("Message ID " + id + " is outside the valid range.");
                if (!getMessageId())
                    messageId = id;
            }

            /**
             * Returns the message ID of the message associated with the exception. May
             * be null if there is no message associated or the exception was thrown
             * before extracting the message ID.
             *
             * @return the message ID or null/undefined.
             */
            function getMessageId() {
                if (messageId)
                    return messageId;
                if (this.cause && this.cause instanceof MslException)
                    return this.cause.messageId;
                return undefined;
            }

            // Construct a better stack trace.
            var originalStack = this.stack;
            function getStack() {
                var trace = this.toString();
                if (originalStack)
                    trace += "\n" + originalStack;
                if (cause && cause.stack)
                    trace += "\nCaused by " + cause.stack;
                return trace;
            }

            // The properties.
            var props = {
                message: { value: message, writable: false, configurable: true },
                error: { value: error, writable: false, configurable: true },
                cause: { value: cause, writable: false, configurable: true },
                name: { value: "MslException", writable: false, configurable: true },
                masterToken: { value: null, writable: true, configurable: false },
                entityAuthenticationData: { value: null, writable: true, configurable: false },
                userIdToken: { value: null, writable: true, configurable: false },
                userAuthenticationData: { value: null, writable: true, configurable: false },
                messageId: { get: getMessageId, set: setMessageId, configurable: true },
                stack: { get: getStack, configurable: true }
            };
            Object.defineProperties(this, props);
        },
        
        /**
         * Set the entity associated with the exception. This does nothing if the
         * entity is already set.
         * 
         * @param {?MasterToken|?EntityAuthenticationData} entity entity associated with the error. May be null.
         * @return {MslException} this.
         */
        setEntity: function setEntity(entity) {
            if (entity && !this.masterToken && !this.entityAuthenticationData) {
                if (entity instanceof MasterToken)
                    this.masterToken = entity;
                else if (entity instanceof EntityAuthenticationData)
                    this.entityAuthenticationData = entity;
            }
            return this;
        },
        
        /**
         * Set the user associated with the exception. This does nothing if the
         * user is already set.
         * 
         * @param {?UserIdToken|?UserAuthenticationData} user user associated with the error. May be null.
         * @return {MslException} this.
         */
        setUser: function setUser(user) {
            if (user && !this.userIdToken && !this.userAuthenticationData) {
                if (user instanceof UserIdToken)
                    this.userIdToken = user;
                else if (user instanceof UserAuthenticationData)
                    this.userAuthenticationData = user;
            }
            return this;
        },

        /**
         * Set the message ID of the message associated with the exception. This
         * does nothing if the message ID is already set.
         *
         * @param {number} id message ID of the message associated with this error.
         * @return {MslException} this.
         */
        setMessageId: function setMessageId(id) {
            this.messageId = id;
            return this;
        },

        /**
         * @return a string containing the exception type and message.
         */
        toString: function toString() {
            return this.name + ': ' + this.message;
        }
    };

    // Attach methods.
    MslException.mixin(proto);
})();



// -- javascript/MslCryptoException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when a crypto exception occurs within the Message Security
 * Layer.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslCryptoException = MslException.extend({
    /**
     * Construct a new MSL crypto exception with the specified error, details, and
     * cause.
     *
     * @param {MslError} error the error.
     * @param {string} details the details text. May be null or undefined.
     * @param {Error} cause the cause. May be null or undefined.
     */
    init: function init(error, details, cause) {
        init.base.call(this, error, details, cause);

        // The properties.
        var props = {
            name: { value: "MslCryptoException", writable: false, configurable: true }
        };
        Object.defineProperties(this, props);
    }
});



// -- javascript/MslEncodingException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when an encoding exception occurs within the Message Security Layer.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslEncodingException = MslException.extend({
    /**
     * Construct a new MSL encoding exception with the specified error, details,
     * and cause.
     *
     * @param {MslError} error the error.
     * @param {string} details the details text. May be null or undefined.
     * @param {Error} cause the cause. May be null or undefined.
     * @constructor
     */
    init: function init(error, details, cause) {
        init.base.call(this, error, details, cause);

        // The properties.
        var props = {
            name: { value: "MslEncodingException", writable: false, configurable: true }
        };
        Object.defineProperties(this, props);
    },
});



// -- javascript/MslEntityAuthException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when an entity authentication exception occurs within the Message
 * Security Layer.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslEntityAuthException = MslException.extend({
    /**
     * Construct a new MSL encoding exception with the specified error, details,
     * and cause.
     *
     * @param {MslError} error the error.
     * @param {string} details the details text. May be null or undefined.
     * @param {Error} cause the cause. May be null or undefined.
     * @constructor
     */
    init: function init(error, details, cause) {
        init.base.call(this, error, details, cause);

        // The properties.
        var props = {
            name: { value: "MslEntityAuthException", writable: false, configurable: true }
        };
        Object.defineProperties(this, props);
    },
});



// -- javascript/MslErrorResponseException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Thrown when an exception occurs while attempting to create and send an
 * automatically generated error response.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslErrorResponseException;

(function() {
    MslErrorResponseException = util.Class.create(new Error());

    var proto = {
        /**
         * <p>Construct a new MSL error response exception with the specified detail
         * message, cause, and the original exception thrown by the request that
         * prompted an automatic error response.</p>
         * 
         * <p>The detail message should describe the error that triggered the
         * automatically generated error response.</p>
         *
         * @param message the detail message.
         * @param cause the cause.
         * @param requestCause the original request exception.
         */
        init: function init(message, cause, requestCause) {
            // Fix my stack trace.
            if (Error.captureStackTrace)
                Error.captureStackTrace(this, this.constructor);

            // Construct a better stack trace.
            var originalStack = this.stack;
            function getStack() {
                var trace = this.toString();
                if (originalStack)
                    trace += "\n" + originalStack;
                if (cause && cause.stack)
                    trace += "\nCaused by " + cause.stack;
                return trace;
            }

            // The properties.
            var props = {
                message: { value: message, writable: false, configurable: false },
                cause: { value: cause, writable: false, configurable: false },
                requestCause: { value: requestCause, writable: false, configurable: false},
                name: { value: "MslErrorResponseException", writable: false, configurable: true },
                stack: { get: getStack, configurable: true },
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return a string containing the exception type and message.
         */
        toString: function toString() {
            return this.name + ': ' + this.message;
        },
    };

    // Attach methods.
    MslErrorResponseException.mixin(proto);
})();



// -- javascript/MslIoException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when an I/O exception occurs.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslIoException;

(function() {
    MslIoException = util.Class.create(new Error());

    var proto = {
        /**
         * Construct a new MSL I/O exception with the specified detail message
         * and cause.
         *
         * @param {string} message the detail message.
         * @param {Error} cause the cause.
         * @constructor
         */
        init: function init(message, cause) {
            // Fix my stack trace.
            if (Error.captureStackTrace)
                Error.captureStackTrace(this, this.constructor);

            // Construct a better stack trace.
            var originalStack = this.stack;
            function getStack() {
                var trace = this.toString();
                if (originalStack)
                    trace += "\n" + originalStack;
                if (cause && cause.stack)
                    trace += "\nCaused by " + cause.stack;
                return trace;
            }

            // The properties.
            var props = {
                message: { value: message, writable: false, configurable: false },
                cause: { value: cause, writable: false, configurable: false },
                name: { value: "MslIoException", writable: false, configurable: true },
                stack: { get: getStack, configurable: true },
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return a string containing the exception type and message.
         */
        toString: function toString() {
            return this.name + ': ' + this.message;
        }
    };

    // Attach methods.
    MslIoException.mixin(proto);
})();



// -- javascript/MslInternalException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when an exception occurs that should not happen except due to an
 * internal error (e.g. incorrectly written code).
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslInternalException;

(function() {
    MslInternalException = util.Class.create(new Error());

    var proto = {
        /**
         * Construct a new MSL internal exception with the specified detail
         * message and cause.
         *
         * @param {string} message the detail message.
         * @param {Error} cause the cause.
         * @constructor
         */
        init: function init(message, cause) {
            // Fix my stack trace.
            if (Error.captureStackTrace)
                Error.captureStackTrace(this, this.constructor);

            // Construct a better stack trace.
            var originalStack = this.stack;
            function getStack() {
                var trace = this.toString();
                if (originalStack)
                    trace += "\n" + originalStack;
                if (cause && cause.stack)
                    trace += "\nCaused by " + cause.stack;
                return trace;
            }

            // The properties.
            var props = {
                message: { value: message, writable: false, configurable: false },
                cause: { value: cause, writable: false, configurable: false },
                name: { value: "MslInternalException", writable: false, configurable: true },
                stack: { get: getStack, configurable: true },
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return a string containing the exception type and message.
         */
        toString: function toString() {
            return this.name + ': ' + this.message;
        },
    };

    // Attach methods.
    MslInternalException.mixin(proto);
})();



// -- javascript/MslInterruptedException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when the operation has been cancelled/interrupted.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslInterruptedException;

(function() {
    MslInterruptedException = util.Class.create(new Error());

    var proto = {
        /**
         * Construct a new MSL interrupted exception with the specified detail
         * message and cause.
         *
         * @param {string} message the detail message.
         * @param {Error} cause the cause.
         * @constructor
         */
        init: function init(message, cause) {
            // Fix my stack trace.
            if (Error.captureStackTrace)
                Error.captureStackTrace(this, this.constructor);

            // Construct a better stack trace.
            var originalStack = this.stack;
            function getStack() {
                var trace = this.toString();
                if (originalStack)
                    trace += "\n" + originalStack;
                if (cause && cause.stack)
                    trace += "\nCaused by " + cause.stack;
                return trace;
            }

            // The properties.
            var props = {
                message: { value: message, writable: false, configurable: false },
                cause: { value: cause, writable: false, configurable: false },
                name: { value: "MslInterruptedException", writable: false, configurable: true },
                stack: { get: getStack, configurable: true },
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return a string containing the exception type and message.
         */
        toString: function toString() {
            return this.name + ': ' + this.message;
        },
    };

    // Attach methods.
    MslInterruptedException.mixin(proto);
})();



// -- javascript/MslKeyExchangeException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when a key exchange exception occurs within the Message Security
 * Layer.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslKeyExchangeException = MslException.extend({
    /**
     * Construct a new MSL key exchange exception with the specified error,
     * details, and cause.
     *
     * @param {MslError} error the error.
     * @param {string} details the details text. May be null or undefined.
     * @param {Error} cause the cause. May be null or undefined.
     * @constructor
     */
    init: function init(error, details, cause) {
        init.base.call(this, error, details, cause);

        // The properties.
        var props = {
            name: { value: "MslKeyExchangeException", writable: false, configurable: true }
        };
        Object.defineProperties(this, props);
    },
});



// -- javascript/MslMasterTokenException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when there is a problem with a master token, but the token was
 * successfully parsed.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslMasterTokenException = MslException.extend({
    /**
     * Construct a new MSL master token exception with the specified error and
     * master token.
     *
     * @param {MslError} error the error.
     * @param {MasterToken} masterToken the master token. May be null or undefined.
     */
    init: function init(error, masterToken) {
        init.base.call(this, error);

        // The properties.
        var props = {
            masterToken: { value: masterToken, writable: false, configurable: false},
            name: { value: "MslMasterTokenException", writable: false, configurable: true }
        };
        Object.defineProperties(this, props);
    },
});



// -- javascript/MslMessageException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when a key exchange exception occurs within the Message Security
 * Layer.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslMessageException = MslException.extend({
    /**
     * Construct a new MSL message exception with the specified error, details, and
     * cause.
     *
     * @param {MslError} error the error.
     * @param {string} details the details text. May be null or undefined.
     * @param {Error} cause the cause. May be null or undefined.
     * @constructor
     */
    init: function init(error, details, cause) {
        init.base.call(this, error, details, cause);

        // The properties.
        var props = {
            name: { value: "MslMessageException", writable: false, configurable: true }
        };
        Object.defineProperties(this, props);
    },
});



// -- javascript/MslUserAuthException.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Thrown when a user authentication exception occurs within the Message
 * Security Layer.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslUserAuthException = MslException.extend({
    /**
     * Construct a new MSL user authentication exception with the specified error,
     * details, and cause.
     *
     * @param {MslError} error the error.
     * @param {string} details the details text. May be null or undefined.
     * @param {Error} cause the cause. May be null or undefined.
     */
    init: function init(error, details, cause) {
        init.base.call(this, error, details, cause);

        // The properties.
        var props = {
            name: { value: "MslUserAuthException", writable: false, configurable: true }
        };
        Object.defineProperties(this, props);
    },
});



// -- javascript/crypto/WebCryptoAdapter.js
/**
 * Copyright (c) 2014 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>The MSL crypto abstraction provides support for multiple versions of the
 * Web Crypto specification.</p>
 * 
 * @author Kevin Gallagher <keving@netflix.com>
 */
var mslCrypto;
var mslCrypto$version;
var MslCrypto$WebCryptoVersion;

/**
 * <p>Set the Web Crypto version that should be used by MSL. This method must
 * be called before Web Crypto will work.</p>
 * 
 * @param {MslCrypto$WebCryptoVersion} version Web Crypto version to use.
 */
function MslCrypto$setWebCryptoVersion(version) {
    mslCrypto$version = version;
}

(function(){
    "use strict";
    
    /**
     * Web Crypto API version.
     * @enum {number}
     */
    var WebCryptoVersion = MslCrypto$WebCryptoVersion = {
        /** Legacy version with JWE+JWK wrap/unwrap. */
        LEGACY: 1,
        /** 2014.01 version with JWK decrypt+import wrap/unwrap. */
        V2014_01: 2,
        /** 2014.02 version for Chromecast; same as 2014.01 except contains a
         * workaround for errors in Chromecast's definition of keyusage
         * identifiers.
         */
        V2014_02: 3,
        /** Latest version. */
        LATEST: 3,
    };
    Object.freeze(MslCrypto$WebCryptoVersion);
    
    // Default to the latest Web Crypto version.
    mslCrypto$version = WebCryptoVersion.LATEST;

    // If extractable is not specified, default to false
    function normalizeExtractable(extractable) {
        return typeof(extractable) === "undefined" ? false : extractable;
    }

    // If key usage is not specified, default to all
    function normalizeKeyUsage(keyUsage) {
        if (keyUsage && keyUsage.length) {
            if (mslCrypto$version === WebCryptoVersion.V2014_02) {
                // workaround for Chromecast's non-spec key usage definitions
                keyUsage = keyUsage.map(function(x) {
                    if (x == 'wrap')
                        return 'wrapKey';
                    if (x == 'unwrap')
                        return 'unwrapKey';
                    return x;
                });
            }
            return keyUsage;
        } else {
            // Note: 'deriveBits' is not currently handled by some implementations.
            // We don't use it, but it should be entered here eventually.
            if (mslCrypto$version === WebCryptoVersion.V2014_02) {
                return ["encrypt", "decrypt", "sign", "verify",
                    "deriveKey", "wrapKey", "unwrapKey"];
            } else {
                return ["encrypt", "decrypt", "sign", "verify",
                        "deriveKey", "wrap", "unwrap"];
            }
        }
    }
    
    // Wrapper for importKey. Safari does not support importing of ASN.1 types
    // spki and pkcs8. Try the import first, but if it fails with one of these
    // formats, try again using JWK format.
    // Applies to WebCryptoVersion.V2014_01/2 only.
    function importKey(format, data, algorithm, extractable, usage) {
        return Promise.resolve()
        .then(function(){
           return cryptoSubtle.importKey(format, data, algorithm, extractable, usage);
        })
        .catch(function(e) {
            if (format !== 'spki' && format !== 'pkcs8') {
                throw e;
            }
            var alg = ASN1.webCryptoAlgorithmToJwkAlg(algorithm);
            var keyOps = ASN1.webCryptoUsageToJwkKeyOps(usage);
            var jwkObj = ASN1.rsaDerToJwk(data, alg, keyOps, extractable);
            if (!jwkObj) {
                throw new Error("Could not make valid JWK from DER input");
            }
            var jwk = JSON.stringify(jwkObj);
            return cryptoSubtle.importKey('jwk', utf8$getBytes(jwk), algorithm, extractable, usage)
        });
    }
    
    // Wrapper for exportKey. Safari does not support exporting of ASN.1 types
    // spki and pkcs8. Try the export first, but if it fails with one of these
    // formats, try again using JWK format.
    // Applies to WebCryptoVersion.V2014_01/2 only.
    function exportKey(format, key) {
        return Promise.resolve()
        .then(function(){
            return cryptoSubtle.exportKey(format, key);
        })
        .catch(function(e) {
            if (format !== 'spki' && format !== 'pkcs8') {
                throw e;
            }
            return cryptoSubtle.exportKey('jwk', key)
            .then(function (result) {
                var jwkObj = JSON.parse(utf8$getString(new Uint8Array(result)));
                var rsaKey = ASN1.jwkToRsaDer(jwkObj);
                if (!rsaKey) {
                    throw new Error("Could not make valid DER from JWK input");
                }
                return rsaKey.getDer().buffer;
            });
        });
    }
    
    mslCrypto = {
        'encrypt': function(algorithm, key, buffer) {
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.encrypt(algorithm, key, buffer);
                        op.oncomplete = function(e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    // Return an ArrayBufferView instead of the ArrayBuffer as a workaround for
                    // MSL-164.
                    return cryptoSubtle.encrypt(algorithm, key, buffer).then(function(arrayBuffer) {
                        return new Uint8Array(arrayBuffer);
                });
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },

        'decrypt': function(algorithm, key, buffer) {
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.decrypt(algorithm, key, buffer);
                        op.oncomplete = function(e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return cryptoSubtle.decrypt(algorithm, key, buffer).then(function(arrayBuffer) {
                        return new Uint8Array(arrayBuffer);
                    });
               default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },

        'sign': function(algorithm, key, buffer) {
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.sign(algorithm, key, buffer);
                        op.oncomplete = function(e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return cryptoSubtle.sign(algorithm, key, buffer).then(function(arrayBuffer) {
                        return new Uint8Array(arrayBuffer);
                    });
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },

        'verify': function(algorithm, key, signature, buffer) {
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.verify(algorithm, key, signature, buffer);
                        op.oncomplete = function(e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return cryptoSubtle.verify(algorithm, key, signature, buffer);
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },

        'digest': function(algorithm, buffer) {
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.digest(algorithm, buffer);
                        op.oncomplete = function(e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return cryptoSubtle.digest(algorithm, buffer).then(function(arrayBuffer) {
                        return new Uint8Array(arrayBuffer);
                    });
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },

        'generateKey': function(algorithm, extractable, keyUsage) {
            var ext = normalizeExtractable(extractable);
            var ku = normalizeKeyUsage(keyUsage);
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.generateKey(algorithm, ext, ku);
                        op.oncomplete = function(e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return cryptoSubtle.generateKey(algorithm, ext, ku);
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },

        'deriveKey': function(algorithm, baseKey, derivedKeyAlgorithm, extractable, keyUsage) {
            var ext = normalizeExtractable(extractable);
            var ku = normalizeKeyUsage(keyUsage);
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.deriveKey(algorithm, baseKey, derivedKeyAlgorithm, ext, ku);
                        op.oncomplete = function(e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return cryptoSubtle.deriveKey(algorithm, baseKey, derivedKeyAlgorithm, ext, ku);
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },

        'importKey': function(format, keyData, algorithm, extractable, keyUsage) {
            var ext = normalizeExtractable(extractable);
            var ku = normalizeKeyUsage(keyUsage);
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.importKey(format, keyData, algorithm, ext, ku);
                        op.oncomplete = function(e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return importKey(format, keyData, algorithm, ext, ku);
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },

        'exportKey': function(format, key) {
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.exportKey(format, key);
                        op.oncomplete = function(e) {
                            var res = e.target.result;
                            resolve(res);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return exportKey(format, key).then(function(arrayBuffer) {
                        return new Uint8Array(arrayBuffer);
                    });
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },

        'wrapKey': function(format, keyToWrap, wrappingKey, wrappingAlgorithm) {
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.wrapKey(keyToWrap, wrappingKey, wrappingAlgorithm);
                        op.oncomplete = function(e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return cryptoSubtle.wrapKey(format, keyToWrap, wrappingKey, wrappingAlgorithm).then(function(arrayBuffer) {
                        return new Uint8Array(arrayBuffer);
                    });
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },

        'unwrapKey': function(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, usage) {
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function(resolve, reject) {
                        var op = cryptoSubtle.unwrapKey(wrappedKey, unwrappedKeyAlgorithm, unwrappingKey);
                        op.oncomplete = function(e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function(e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return cryptoSubtle.unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, normalizeExtractable(extractable), normalizeKeyUsage(usage));
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        },
    };

    // if there is a key discovery, translate that as well
    // if there is none, don't add the method to mslCrypto, so the code can utilize feature detection
    if (cryptokeys && cryptokeys.getKeyByName) {

        mslCrypto['getKeyByName'] = function (keyName) {
            switch (mslCrypto$version) {
                case WebCryptoVersion.LEGACY:
                    return new Promise(function (resolve, reject) {
                        var op = cryptokeys.getKeyByName(keyName);
                        op.oncomplete = function (e) {
                            resolve(e.target.result);
                        };
                        op.onerror = function (e) {
                            reject(e);
                        };
                    });
                case WebCryptoVersion.V2014_01:
                case WebCryptoVersion.V2014_02:
                    return cryptokeys.getKeyByName(keyName);
                default:
                    throw new Error("Unsupported Web Crypto version " + WEB_CRYPTO_VERSION + ".");
            }
        };
    }

    window['netflix'] = window['netflix'] || {};
    window['netflix']['crypto'] = mslCrypto;

})();



// -- javascript/crypto/WebCryptoAlgorithm.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * MSL algorithms mapped onto Web Crypto algorithms.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var WebCryptoAlgorithm = {
    /** generate/wrap/unwrap */
    A128KW: { 'name': 'AES-KW' },
    /** generate/encrypt/decrypt */
    AES_CBC: { 'name': 'AES-CBC' },
    /** generate */
    DIFFIE_HELLMAN: { 'name': 'DH' },
    /** generate/sign/verify */
    HMAC_SHA256: { 'name': 'HMAC', 'hash': { 'name': 'SHA-256' } },
    /** generate/encrypt/decrypt/wrap/unwrap */
    RSA_OAEP: { 'name': 'RSA-OAEP', 'hash': { 'name': 'SHA-1' } },
    /** generate/encrypt/decrypt */
    RSAES: { 'name': 'RSAES-PKCS1-v1_5' },
    /** generate */
    RSASSA: { 'name': 'RSASSA-PKCS1-v1_5' },
    /** sign/verify */
    RSASSA_SHA256: { 'name': 'RSASSA-PKCS1-v1_5', 'hash': { 'name': 'SHA-256' } },
    RSASSA_SHA1: { 'name': 'RSASSA-PKCS1-v1_5', 'hash': { 'name': 'SHA-1' } },
};



// -- javascript/crypto/WebCryptoUsage.js
/**
 * Copyright (c) 2014 Netflix, Inc.  All rights reserved.
 */

/**
 * MSL key usages mapped onto Web Crypto key usages.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var WebCryptoUsage = {
    /** encrypt/decrypt */
    ENCRYPT_DECRYPT: [ 'encrypt', 'decrypt' ],
    /** wrap/unwrap */
    WRAP_UNWRAP: [ 'wrap', 'unwrap' ],
    /** sign/verify */
    SIGN_VERIFY: [ 'sign', 'verify' ],
    /** derive key */
    DERIVE_KEY: [ 'deriveKey' ],
};



// -- javascript/crypto/CipherKey.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Symmetric crypto key.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var CipherKey;
var CipherKey$create;
var CipherKey$import;

(function () {
    "use strict";

    CipherKey = util.Class.create({
        /**
         * Create a new cipher key from an original symmetric key.
         *
         * If the raw key data is not provided the key data will be
         * extracted if possible.
         *
         * @param {Object} rawKey cryptoSubtle key.
         * @param {{result: function(CipherKey), error: function(Error)}}
         *        callback the callback will receive the new cipher key
         *        or any thrown exceptions.
         * @param {Uint8Array=} keyData optional raw key data.
         * @throws MslCryptoException if the key is extractable but
         *         extraction fails
         */
        init: function init(rawKey, callback, keyData) {
            var self = this;

            AsyncExecutor(callback, function () {
                if (!rawKey || typeof rawKey != "object")
                    throw new MslCryptoException(MslError.INVALID_SYMMETRIC_KEY);

                if (!keyData && rawKey['extractable']) {
                    var oncomplete = function(result) {
                        createKey(new Uint8Array(result));
                    };
                    var onerror = function(e) {
                        callback.error(new MslCryptoException(MslError.KEY_EXPORT_ERROR, "raw"));
                    };
                    mslCrypto.exportKey("raw", rawKey)
                        .then(oncomplete, onerror);

                } else {
                    createKey(keyData);
                }
            }, self);

            function createKey(keyData) {
                AsyncExecutor(callback, function() {
                    var keyDataB64 = (keyData) ? base64$encode(keyData) : undefined;

                    // The properties.
                    var props = {
                        rawKey: { value: rawKey, writable: false, configurable: false },
                        keyData: { value: keyData, writable: false, configurable: false },
                        keyDataB64: { value: keyDataB64, writable: false, configurable: false }
                    };
                    Object.defineProperties(self, props);
                    return this;
                }, self);
            }
        },

        /**
         * @return the key size in bytes.
         */
        size: function size() {
            return this.keyData.length;
        },

        /**
         * @return {Uint8Array} the raw key bytes.
         */
        toByteArray: function toByteArray() {
            return this.keyData;
        },

        /**
         * @return {string} the key Base64 encoded.
         */
        toBase64: function toBase64() {
            return this.keyDataB64;
        }
    });

    /**
     * Create a new cipher key from an original symmetric key.
     *
     * @param {Object} cryptoSubtle rawKey.
     * @param {{result: function(CipherKey), error: function(Error)}}
     *        callback the callback will receive the new cipher key
     *        or any thrown exceptions.
     * @throws MslCryptoException if the rawKey is invalid.
     */
    CipherKey$create = function CipherKey$create(rawKey, callback) {
        new CipherKey(rawKey, callback);
    };

    /**
     * Creates a cipher key from the provided key data. The key's byte
     * encoding will be available.
     *
     * @param {string|Uint8Array} keydata Base64-encoded or raw key data.
     * @param {WebCryptoAlgorithm} algo Web Crypto algorithm.
     * @param {WebCryptoUsage} usages Web Crypto key usages.
     * @param {{result: function(CipherKey), error: function(Error)}}
     *        callback the callback will receive the new cipher key
     *        or any thrown exceptions.
     * @throws MslCryptoException if the key data is invalid.
     */
    CipherKey$import = function CipherKey$import(keydata, algo, usages, callback) {
        AsyncExecutor(callback, function() {
            try {
                keydata = (typeof keydata == "string") ? base64$decode(keydata) : keydata;
            } catch (e) {
                throw new MslCryptoException(MslError.INVALID_SYMMETRIC_KEY, "keydata " + keydata, e);
            }

            var oncomplete = function(result) {
                new CipherKey(result, callback, keydata);
            };
            var onerror = function(e) {
                callback.error(new MslCryptoException(MslError.INVALID_SYMMETRIC_KEY));
            };
            mslCrypto.importKey("raw", keydata, algo, true, usages)
                .then(oncomplete, onerror);
        });
    };
})();



// -- javascript/crypto/PublicKey.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>An ECC, RSA, or Diffie-Hellman public key.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var PublicKey;
var PublicKey$create;
var PublicKey$import;

(function () {
    "use strict";

    PublicKey = util.Class.create({
        /**
         * Create a new public key from an original public key.
         *
         * If the raw key encoding is not provided the encoding will be
         * extracted if possible.
         *
         * @param rawKey {Object} the original crypto public key
         * @param {{result: function(PublicKey), error: function(Error)}}
         *        callback the callback will receive the new public key
         *        or any thrown exceptions.
         * @param {Uint8Array=} encoded optional raw key encoding.
         * @throws MslCryptoException if the rawKey is invalid.
         */
        init: function init(rawKey, callback, encoded) {
            var self = this;

            AsyncExecutor(callback, function () {
                if (!rawKey || typeof rawKey != 'object' || rawKey.type != 'public')
                    throw new TypeError('Only original public crypto keys are supported.');

                if (!encoded && rawKey['extractable']) {
                    var oncomplete = function(result) {
                        createKey(new Uint8Array(result));
                    };
                    var onerror = function(e) {
                        callback.error(new MslCryptoException(MslError.KEY_EXPORT_ERROR, "spki"));
                    };
                    mslCrypto['exportKey']("spki", rawKey)
                        .then(oncomplete, onerror);
                } else {
                    createKey(encoded);
                }
            });

            function createKey(encoded) {
                AsyncExecutor(callback, function() {
                    // The properties.
                    var props = {
                        rawKey: { value: rawKey, writable: false, configurable: false },
                        encoded: { value: encoded, writable: false, configurable: false }
                    };
                    Object.defineProperties(self, props);
                    return this;
                }, self);
            };
        },

        /**
         * Returns the standard encoding of the public key.
         *
         * RSA keys are returned in SubjectPublicKeyInfo DER format.
         * ECC keys are not yet supported.
         * Diffie-Hellman keys are not yet supported.
         *
         * @return {Uint8Array} the encoded public key.
         */
        getEncoded: function getEncoded() {
            return this.encoded;
        },
    });

    /**
     * Create a new public key from an original public key.
     *
     * @param {Object} cryptoSubtle rawKey.
     * @param {{result: function(PublicKey), error: function(Error)}}
     *        callback the callback will receive the new public key
     *        or any thrown exceptions.
     */
    PublicKey$create = function PublicKey$create(rawKey, callback) {
        new PublicKey(rawKey, callback);
    };

    /**
     * Creates a public key from the provided key data. The key's
     * byte encoding will be available.
     *
     * @param {string|Uint8Array} spki Base64-encoded or raw SPKI.
     * @param {WebCryptoAlgorithm} algo Web Crypto algorithm.
     * @param {WebCryptoUsage} usages Web Crypto key usages.
     * @param {{result: function(PublicKey), error: function(Error)}}
     *        callback the callback will receive the new public key
     *        or any thrown exceptions.
     * @throws MslCryptoException if the key data is invalid.
     */
    PublicKey$import = function PublicKey$import(spki, algo, usages, callback) {
        AsyncExecutor(callback, function() {
            try {
                spki = (typeof spki == "string") ? base64$decode(spki) : spki;
            } catch (e) {
                throw new MslCryptoException(MslError.INVALID_PUBLIC_KEY, "spki " + spki, e);
            }
            var oncomplete = function(result) {
                new PublicKey(result, callback, spki);
            };
            var onerror = function(e) {
                callback.error(new MslCryptoException(MslError.INVALID_PUBLIC_KEY));
            };
            mslCrypto['importKey']("spki", spki, algo, true, usages)
                .then(oncomplete, onerror);
        });
    };
})();



// -- javascript/crypto/PrivateKey.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>An ECC, RSA, or Diffie-Hellman private key.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var PrivateKey;
var PrivateKey$create;
var PrivateKey$import;

(function () {
    "use strict";

    PrivateKey = util.Class.create({
        /**
         * Create a new private key from an original private key.
         *
         * If the raw key encoding is not provided the encoding will be
         * extracted if possible.
         *
         * @param rawKey {Object} the original crypto private key
         * @param {{result: function(PrivateKey), error: function(Error)}}
         *        callback the callback will receive the new private key
         *        or any thrown exceptions.
         * @param {Uint8Array=} encopded optional raw key encoding.
         * @throws MslCryptoException if the key is extractable but
         *         extraction fails.
         */
        init: function init(rawKey, callback, encoded) {
            var self = this;

            AsyncExecutor(callback, function () {
                if (!rawKey || typeof rawKey != 'object' || rawKey.type != 'private')
                    throw new TypeError('Only original private crypto keys are supported.');

                if (!encoded && rawKey['extractable']) {
                    var oncomplete = function(result) {
                        createKey(new Uint8Array(result));
                    };
                    var onerror = function(e) {
                        callback.error(new MslCryptoException(MslError.KEY_EXPORT_ERROR, "pkcs8"));
                    };
                    mslCrypto['exportKey']("pkcs8", rawKey)
                        .then(oncomplete, onerror);
                } else {
                    createKey(encoded);
                }
            });

            function createKey(encoded) {
                AsyncExecutor(callback, function() {
                    // The properties.
                    var props = {
                        rawKey: { value: rawKey, writable: false, configurable: false },
                        encoded: { value: encoded, writable: false, configurable: false }
                    };
                    Object.defineProperties(self, props);
                    return this;
                }, self);
            };
        },

        /**
         * Returns the standard encoding of the private key.
         *
         * RSA keys are returned in pkcs#8 format.
         * ECC keys are not yet supported.
         * Diffie-Hellman keys are not yet supported.
         *
         * @return {Uint8Array} the encoded private key.
         */
        getEncoded: function getEncoded() {
            return this.encoded;
        },
    });

    /**
     * Create a new private key from an original private key.
     *
     * @param {Object} cryptoSubtle rawKey.
     * @param {{result: function(PrivateKey), error: function(Error)}}
     *        callback the callback will receive the new private key
     *        or any thrown exceptions.
     * @throws MslCryptoException if the key is extractable but
     *         extraction fails
     */
    PrivateKey$create = function PrivateKey$create(rawKey, callback) {
        new PrivateKey(rawKey, callback);
    };

    /**
     * Creates a private key from the provided key data. The key's
     * byte encoding will be available.
     *
     * @param {string|Uint8Array} pkcs8 Base64-encoded or raw PKCS#8.
     * @param {WebCryptoAlgorithm} algo Web Crypto algorithm.
     * @param {WebCryptoUsage} usages Web Crypto key usages.
     * @param {{result: function(PrivateKey), error: function(Error)}}
     *        callback the callback will receive the new public key
     *        or any thrown exceptions.
     * @throws MslCryptoException if the key data is invalid.
     */
    PrivateKey$import = function PrivateKey$import(pkcs8, algo, usages, callback) {
        AsyncExecutor(callback, function() {
            try {
                pkcs8 = (typeof pkcs8 == "string") ? base64$decode(pkcs8) : pkcs8;
            } catch (e) {
                throw new MslCryptoException(MslError.INVALID_PRIVATE_KEY, "pkcs8 " + pkcs8, e);
            }
            var oncomplete = function(result) {
                new PrivateKey(result, callback, pkcs8);
            };
            var onerror = function(e) {
                callback.error(new MslCryptoException(MslError.INVALID_PRIVATE_KEY));
            };
            mslCrypto["importKey"]("pkcs8", pkcs8, algo, true, usages)
                .then(oncomplete, onerror);
        });
    };
})();



// -- javascript/crypto/MslCiphertextEnvelope.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>MSL encryption envelopes contain all of the information necessary for
 * decrypting and verifying the integrity of its data payload.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslCiphertextEnvelope;
var MslCiphertextEnvelope$create;
var MslCiphertextEnvelope$parse;
var MslCiphertextEnvelope$Version;

(function() {
    /**
     * JSON key version.
     * @const
     * @type {string}
     */
    var KEY_VERSION = "version";
    /**
     * JSON key key ID.
     * @const
     * @type {string}
     */
    var KEY_KEY_ID = "keyid";
    /**
     * JSON key cipherspec.
     * @const
     * @type {string}
     */
    var KEY_CIPHERSPEC = "cipherspec";
    /**
     * JSON key initialization vector.
     * @const
     * @type {string}
     */
    var KEY_IV = "iv";
    /**
     * JSON key ciphertext.
     * @const
     * @type {string}
     */
    var KEY_CIPHERTEXT = "ciphertext";
    /**
     * JSON key SHA-256.
     * @const
     * @type {string} 
     */
    var KEY_SHA256 = "sha256";

    /** Versions. */
    var Version = MslCiphertextEnvelope$Version = {
        /**
         * <p>Version 1.</p>
         * 
         * {@code {
         *   "#mandatory" : [ "keyid", "iv", "ciphertext", "sha256" ],
         *   "keyid" : "string",
         *   "iv" : "base64",
         *   "ciphertext" : "base64",
         *   "sha256" : "base64",
         * }} where:
         * <ul>
         * <li>{@code keyid} is the encryption key ID</li>
         * <li>{@code iv} is the Base64-encoded initialization vector</li>
         * <li>{@code ciphertext} is the Base64-encoded ciphertext</li>
         * <li>{@code sha256} is the Base64-encoded SHA-256 of the encryption envelope</li>
         * </ul>
         * 
         * <p>The SHA-256 is computed over the concatenation of {@code key ID ||
         * IV || ciphertext}.</p>
         */
        V1 : 1,
        /**
         * <p>Version 2.</p>
         * 
         * {@code {
         *   "#mandatory" : [ "version", "cipherspec", "ciphertext" ],
         *   "version" : "number",
         *   "cipherspec" : "string",
         *   "iv" : "base64",
         *   "ciphertext" : "base64",
         * }} where:
         * <ul>
         * <li>{@code version} is the number '2'</li>
         * <li>{@code cipherspec} is one of the recognized cipher specifications</li>
         * <li>{@code iv} is the optional Base64-encoded initialization vector</li>
         * <li>{@code ciphertext} is the Base64-encoded ciphertext</li>
         * </ul>
         * 
         * <p>Supported cipher specifications:
         * <table>
         * <tr><th>Cipher Spec</th><th>Description</th></tr>
         * <tr><td>AES/CBC/PKCS5Padding</td><td>AES CBC w/PKCS#5 Padding</td></tr>
         * </table></p>
         */
        V2 : 2
    };
    
    MslCiphertextEnvelope = util.Class.create({
        /**
         * <p>Create a new encryption envelope with the provided details.</p>
         *
         * @param {string|MslConstants$CipherSpec} keyIdOrSpec the key
         *        identifier or cipher specification.
         * @param {?Uint8Array} iv the initialization vector. May be null.
         * @param {Uint8Array} ciphertext the ciphertext.
         * @param {{result: function(MslCiphertextEnvelope), error: function(Error)}}
         *        callback the callback functions that will receive the envelope
         *        or any thrown exceptions.
         * @constructor
         */
        init: function init(keyIdOrSpec, iv, ciphertext, callback) {
            AsyncExecutor(callback, function() {
                // Determine envelope version from first parameter.
                var version = Version.V1,
                    keyId   = keyIdOrSpec,
                    cipherSpec = null;
                for (var key in MslConstants$CipherSpec) {
                    if (MslConstants$CipherSpec[key] == keyIdOrSpec) {
                        version = Version.V2;
                        keyId = null;
                        cipherSpec = keyIdOrSpec;
                        break;
                    }
                }
                
                // The properties.
                var props = {
                    version: { value: version, writable: false, enumerable: false, configurable: false },
                    keyId: { value: keyId, writable: false, configurable: false },
                    cipherSpec: { value: cipherSpec, writable: false, configurable: false },
                    iv: { value: iv, writable: false, configurable: false },
                    ciphertext: { value: ciphertext, writable: false, configurable: false },
                };
                Object.defineProperties(this, props);
                return this;
            }, this);
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            // Construct the JSON.
            var result = {};
            switch (this.version) {
                case Version.V1:
                    result[KEY_KEY_ID] = this.keyId;
                    if (this.iv)
                        result[KEY_IV] = base64$encode(this.iv);
                    result[KEY_CIPHERTEXT] = base64$encode(this.ciphertext);
                    result[KEY_SHA256] = "AA==";
                    break;
                case Version.V2:
                    result[KEY_VERSION] = this.version;
                    result[KEY_CIPHERSPEC] = this.cipherSpec;
                    if (this.iv)
                        result[KEY_IV] = base64$encode(this.iv);
                    result[KEY_CIPHERTEXT] = base64$encode(this.ciphertext);
                    break;
                default:
                    throw new MslInternalException("Ciphertext envelope version " + this.version + " encoding unsupported.");
            }
            return result;
        }
    });

    /**
     * <p>Create a new encryption envelope with the provided details.</p>
     *
     * @param {string|CipherSpec} keyIdOrSpec the key identifier or cipher
     *        specification.
     * @param {Uint8Array} iv the initialization vector. May be null.
     * @param {Uint8Array} ciphertext the ciphertext.
     * @param {{result: function(MslCiphertextEnvelope), error: function(Error)}}
     *        callback the callback functions that will receive the envelope
     *        or any thrown exceptions.
     */
    MslCiphertextEnvelope$create = function MslCiphertextEnvelope$create(keyIdOrCipherSpec, iv, ciphertext, callback) {
        new MslCiphertextEnvelope(keyIdOrCipherSpec, iv, ciphertext, callback);
    };

    /**
     * Create a new encryption envelope from the provided JSON object. If an
     * envelope version is provided then the JSON object is parsed accordingly.
     *
     * @param {Object} jsonObj the JSON object.
     * @param {?MslCiphertextEnvelope$Version} version the envelope version.
     *        May be null.
     * @param {{result: function(MslCiphertextEnvelope), error: function(Error)}}
     *        callback the callback functions that will receive the envelope
     *        or any thrown exceptions.
     * @throws MslCryptoException if there is an error processing the
     *         encryption envelope.
     * @throws MslEncodingException if there is an error parsing the JSON.
     */
    MslCiphertextEnvelope$parse = function MslCiphertextEnvelope$parse(jsonObj, version, callback) {
        AsyncExecutor(callback, function() {
            // Extract values.
            var keyId        = jsonObj[KEY_KEY_ID],
                cipherSpec   = jsonObj[KEY_CIPHERSPEC],
                iv           = jsonObj[KEY_IV],
                ciphertext   = jsonObj[KEY_CIPHERTEXT],
                sha256       = jsonObj[KEY_SHA256];
            
            // If a version was not specified, determine the envelope version.
            if (!version) {
                version = jsonObj[KEY_VERSION];
                if (!version || typeof version !== 'number' || version !== version) {
                    // If anything fails to parse, treat this as a version 1 envelope.
                    version = Version.V1;
                } else {
                    var identified = false;
                    for (var v in Version) {
                        if (Version[v] == version) {
                            identified = true;
                            break;
                        }
                    }
                    if (!identified)
                        throw new MslCryptoException(MslError.UNIDENTIFIED_CIPHERTEXT_ENVELOPE, "ciphertext envelope " + JSON.stringify(jsonObj));
                }
            }
            
            // Parse envelope.
            var keyIdOrSpec;
            switch (version) {
                case Version.V1:
                    // Verify values.
                    if (typeof keyId !== 'string' ||
                        (iv && typeof iv !== 'string') ||
                        typeof ciphertext !== 'string' ||
                        typeof sha256 !== 'string')
                    {
                        throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "ciphertext envelope " + JSON.stringify(jsonObj));
                    }
                    
                    // Version 1 envelopes use the key ID.
                    keyIdOrSpec = keyId;
                    break;
                case Version.V2:
                    // Verify values.
                    var v = jsonObj[KEY_VERSION];
                    if (v != Version.V2)
                        throw new MslCryptoException(MslError.UNIDENTIFIED_CIPHERTEXT_ENVELOPE, "ciphertext envelope " + JSON.stringify(jsonObj));
                    if (typeof cipherSpec !== 'string' ||
                        (iv && typeof iv !== 'string') ||
                        typeof ciphertext !== 'string')
                    {
                        throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "ciphertext envelope " + JSON.stringify(jsonObj));
                    }
                    
                    // Version 2 envelopes use the cipher specification.
                    cipherSpec = MslConstants$CipherSpec$fromString(cipherSpec);
                    if (!cipherSpec)
                        throw new MslCryptoException(MslError.UNIDENTIFIED_CIPHERSPEC, "ciphertext envelope " + JSON.stringify(jsonObj));
                    keyIdOrSpec = cipherSpec;
                    break;
                default:
                    throw new MslCryptoException(MslError.UNSUPPORTED_CIPHERTEXT_ENVELOPE, "ciphertext envelope " + JSON.stringify(jsonObj));
            }
            
            // Convert Base64-encoded values to Uint8Array.
            try {
                if (iv)
                    iv = base64$decode(iv);
                ciphertext = base64$decode(ciphertext);
            } catch (e) {
                throw new MslCryptoException(MslError.CIPHERTEXT_ENVELOPE_PARSE_ERROR, "encryption envelope " + JSON.stringify(jsonObj), e);
            }
            
            // Return envelope.
            new MslCiphertextEnvelope(keyIdOrSpec, iv, ciphertext, callback);
        });
    };
})();




// -- javascript/crypto/MslSignatureEnvelope.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>MSL signature envelopes contain all of the information necessary for
 * verifying data using a known key.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslSignatureEnvelope;
var MslSignatureEnvelope$create;
var MslSignatureEnvelope$parse;
var MslSignatureEnvelope$Version;

(function() {
    /**
     * JSON key version.
     * @const
     * @type {string}
     */
    var KEY_VERSION = "version";
    /**
     * JSON key algorithm.
     * @const
     * @type {string}
     */
    var KEY_ALGORITHM = "algorithm";
    /**
     * JSON key signature.
     * @const
     * @type {string}
     */
    var KEY_SIGNATURE = "signature";

    /** Versions. */
    var Version = MslSignatureEnvelope$Version = {
        /**
         * <p>Version 1.</p>
         *
         * {@code signature}
         *
         * <p>The signature is represented as raw bytes.</p>
         */
        V1 : 1,
        /**
         * <p>Version 2.</p>
         *
         * {@code {
         *   "#mandatory" : [ "version", "algorithm", "signature" ],
         *   "version" : "number",
         *   "algorithm" : "string",
         *   "signature" : "base64"
         * }} where:
         * <ul>
         * <li>{@code version} is the number '2'</li>
         * <li>{@code algorithm} is one of the recognized signature algorithms</li>
         * <li>{@code signature} is the Base64-encoded signature</li>
         * </ul>
         *
         * <p>Supported algorithms:
         * <table>
         * <tr><th>Algorithm</th><th>Description</th>
         * <tr><td>HmacSHA256</td><td>HMAC w/SHA-256</td></tr>
         * <tr><td>SHA256withRSA</td><td>RSA signature w/SHA-256</td></tr>
         * </table></p>
         */
        V2 : 2,
    };

    MslSignatureEnvelope = util.Class.create({
        /**
         * Create a new signature envelope with the provided data.
         *
         * @param {Version} version the envelope version.
         * @param {?MslConstants$SignatureAlgo} algorithm the signature algorithm. May be null.
         * @param {Uint8Array} signature the signature.
         */
        init: function init(version, algorithm, signature) {
            // Create the byte representation.
            var bytes;
            switch (version) {
                case Version.V1:
                    bytes = signature;
                    break;
                case Version.V2:
                    var jsonObj = {};
                    jsonObj[KEY_VERSION] = version;
                    jsonObj[KEY_ALGORITHM] = algorithm;
                    jsonObj[KEY_SIGNATURE] = base64$encode(signature);
                    bytes = textEncoding$getBytes(JSON.stringify(jsonObj), MslConstants$DEFAULT_CHARSET);
                    break;
                default:
                    throw new MslInternalException("Signature envelope version " + version + " encoding unsupported.");
            }

            // The properties.
            var props = {
                version: { value: version, writable: false, enumerable: false, configurable: false },
                algorithm: { value: algorithm, writable: false, configurable: false },
                signature: { value: signature, writable: false, configurable: false },
                bytes: { value: bytes, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        }
    });

    /**
     * <p>This method has two acceptable parameter lists.</p>
     *
     * <p>The first form creates a version 1 signature envelope.</p>
     *
     * @param {Uint8Array} signature the signature.
     * @param {{result: function(MslSignatureEnvelope), error: function(Error)}}
     *        callback the callback functions that will receive the envelope
     *        or any thrown exceptions.
     *
     * <p>The second form creates a version 2 signature envelope.</p>
     *
     * @param {MslConstants$SignatureAlgo} algorithm the signature algorithm.
     * @param {Uint8Array} signature the signature.
     * @param {{result: function(MslSignatureEnvelope), error: function(Error)}}
     *        callback the callback functions that will receive the envelope
     *        or any thrown exceptions.
     */
    MslSignatureEnvelope$create = function MslSignatureEnvelope$create(/* variable arguments */) {
        var version,
            signature,
            algorithm,
            callback;

        // Handle the first form.
        if (arguments.length == 2) {
            version = Version.V1;
            signature = arguments[0];
            algorithm = null;
            callback = arguments[1];
        }

        // Handle the second form.
        else if (arguments.length == 3) {
            version = Version.V2;
            algorithm = arguments[0];
            signature = arguments[1];
            callback = arguments[2];
        }

        // Malformed arguments are not explicitly handled, just as with any
        // other function.

        AsyncExecutor(callback, function() {
            return new MslSignatureEnvelope(version, algorithm, signature);
        });
    };

    /**
     * Create a new signature envelope from the provided envelope bytes. If a
     * signature version is provided then the JSON object is parsed accordingly.
     *
     * @param {Uint8Array} envelope the raw envelope bytes.
     * @param {?MslSignatureEnvelope$Version} version the envelope version.
     *        May be null.
     * @param {{result: function(MslSignatureEnvelope), error: function(Error)}}
     *        callback the callback functions that will receive the envelope
     *        or any thrown exceptions.
     * @throws MslCryptoException if there is an error processing the signature
     *         envelope.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @see #getBytes()
     */
    MslSignatureEnvelope$parse = function MslSignatureEnvelope$parse(envelope, version, callback) {
        AsyncExecutor(callback, function() {
            if (version) {
                switch (version) {
                    case Version.V1:
                        return new MslSignatureEnvelope(Version.V1, null, envelope);
                    case Version.V2:
                        try {
                            // We expect the byte representation to be a JSON string.
                            var json = textEncoding$getString(envelope, MslConstants$DEFAULT_CHARSET);
                            var envelopeJo = JSON.parse(json);

                            // Extract values.
                            var v             = parseInt(envelopeJo[KEY_VERSION]),
                                algorithmName = envelopeJo[KEY_ALGORITHM],
                                signatureB64  = envelopeJo[KEY_SIGNATURE];
                            if (!v || typeof v !== 'number' || v != v ||
                                typeof algorithmName !== 'string' ||
                                typeof signatureB64 !== 'string')
                            {
                                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "signature envelope " + base64$encode(envelope));
                            }

                            // Verify version.
                            if (Version.V2 != v)
                                throw new MslCryptoException(MslError.UNSUPPORTED_SIGNATURE_ENVELOPE, "signature envelope " + base64$encode(envelope));

                            // Grab algorithm.
                            var algorithm = MslConstants$SignatureAlgo$fromString(algorithmName);
                            if (!algorithm)
                                throw new MslCryptoException(MslError.UNIDENTIFIED_ALGORITHM, "signature envelope " + base64$encode(envelope));

                            // Grab signature.
                            var signature = base64$decode(signatureB64);
                            if (!signature)
                                throw new MslCryptoException(MslError.INVALID_SIGNATURE, "signature envelope " + Base64Util.encode(envelope));

                            // Return the envelope.
                            return new MslSignatureEnvelope(Version.V2, algorithm, signature);
                        } catch (e) {
                            if (e instanceof SyntaxError)
                                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "signature envelope " + base64$encode(envelope), e);
                            throw e;
                        }
                    default:
                        throw new MslCryptoException(MslError.UNSUPPORTED_SIGNATURE_ENVELOPE, "signature envelope " + base64$encode(envelope));
                }
            }

            // Attempt to convert this to a JSON object.
            var envelopeJo;
            try {
                // If this is a JSON object, we expect the byte representation to
                // be a Base64-encoding of the JSON string.
                var json = textEncoding$getString(envelope, MslConstants$DEFAULT_CHARSET);
                envelopeJo = JSON.parse(json);
            } catch (e) {
                envelopeJo = null;
            }

            // Determine the envelope version.
            //
            // If there is no JSON object, or there is no version field (as the
            // binary signature may coincidentally parse into JSON), then this is a
            // version 1 envelope.
            var envelopeVersion;
            if (!envelopeJo || !envelopeJo[KEY_VERSION]) {
                envelopeVersion = Version.V1;
            } else {
                envelopeVersion = envelopeJo[KEY_VERSION];
                if (typeof envelopeVersion !== 'number' || envelopeVersion !== envelopeVersion) {
                    // There is a possibility that this is a version 1 envelope.
                    envelopeVersion = Version.V1;
                }
            }

            // Parse envelope.
            switch (envelopeVersion) {
                case Version.V1:
                    return new MslSignatureEnvelope(envelopeVersion, null, envelope);
                case Version.V2:
                    // Extract envelope data.
                    var algorithm = envelopeJo[KEY_ALGORITHM];
                    var signatureB64 = envelopeJo[KEY_SIGNATURE];

                    // Verify data.
                    if (typeof algorithm !== 'string' ||
                            typeof signatureB64 !== 'string')
                    {
                        // It is extremely unlikely but possible that this is a
                        // version 1 envelope.
                        return new MslSignatureEnvelope(Version.V1, null, envelope);
                    }

                    // Verify algorithm.
                    algorithm = MslConstants$SignatureAlgo$fromString(algorithm);
                    if (!algorithm) {
                        // It is extremely unlikely but possible that this is a
                        // version 1 envelope.
                        return new MslSignatureEnvelope(Version.V1, null, envelope);
                    }

                    // If the signature fails to decode then it is extremely
                    // unlikely but possible that this is a version 1 envelope.
                    //
                    // A zero-length signature is OK and does not indicate an
                    // error.
                    try {
                        signature = base64$decode(signatureB64);
                    } catch (e) {
                        return new MslSignatureEnvelope(Version.V1, null, envelope);
                    }

                    // Return the version 2 envelope.
                    return new MslSignatureEnvelope(envelopeVersion, algorithm, signature);
                default:
                    throw new MslCryptoException(MslError.UNSUPPORTED_SIGNATURE_ENVELOPE, "signature envelope " + envelope);
            }
        });
    };
})();


// -- javascript/crypto/ICryptoContext.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * A generic cryptographic context suitable for encryption/decryption,
 * wrap/unwrap, and sign/verify operations.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @interface
 */
var ICryptoContext = util.Class.create({
    /**
     * Encrypts some data.
     *
     * @param {Uint8Array} data the plaintext.
     * @param {{result: function(Uint8Array), error: function(Error)}}
     *        callback the callback functions that will receive the ciphertext
     *        or any thrown exceptions.
     * @throws MslCryptoException if there is an error encrypting the data.
     */
    encrypt: function(data, callback) {},

    /**
     * Decrypts some data.
     *
     * @param {Uint8Array} data the ciphertext.
     * @param {{result: function(Uint8Array), error: function(Error)}}
     *        callback the callback functions that will receive the plaintext
     *        or any thrown exceptions.
     * @throws MslCryptoException if there is an error decrypting the data.
     */
    decrypt: function(data, callback) {},

    /**
     * Wraps a key.
     *
     * @param {CipherKey|PublicKey|PrivateKey} key the key to wrap.
     * @return {result: function(Uint8Array), error: function(Error)}
     *         callback the callback functions that will receive the wrapped
     *         data or any thrown exceptions.
     * @throws MslCryptoException if there is an error wrapping the key.
     */
    wrap: function(key, callback) {},

    /**
     * Unwraps a key.
     *
     * @param {Uint8Array} data the wrapped data.
     * @param {WebCryptoAlgorithm} algo for the wrapped key.
     * @param {WebCryptoUsage} usages the key usages for the wrapped key.
     * @return {result: function({CipherKey|PublicKey|PrivateKey}), error: function(Error)}
     *         callback the callback functions that will receive the unwrapped
     *         key or any thrown exceptions.
     * @throws MslCryptoException if there is an error unwrapping the key.
     */
    unwrap: function(data, algo, usages, callback) {},

    /**
     * Computes the signature for some data. The signature may not be a
     * signature proper, but the name suits the concept.
     *
     * @param {Uint8Array} data the data.
     * @param {{result: function(Uint8Array), error: function(Error)}}
     *        callback the callback functions that will receive the signature
     *        or any thrown exceptions.
     * @throws MslCryptoException if there is an error computing the signature.
     */
    sign: function(data, callback) {},

    /**
     * Verifies the signature for some data. The signature may not be a
     * signature proper, but the name suits the concept.
     *
     * @param {Uint8Array} data the data.
     * @param {Uint8Array} signature the signature.
     * @param {{result: function(boolean), error: function(Error)}}
     *        callback the callback functions that will receive true if the
     *        data is verified, false if validation fails, or any thrown
     *        exceptions.
     * @throws MslCryptoException if there is an error verifying the signature.
     */
    verify: function(data, signature, callback) {},
});



// -- javascript/crypto/JsonWebEncryptionCryptoContext.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>This key exchange crypto context provides an implementation of the JSON
 * web encryption algorithm as defined in
 * {@link http://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-08}.
 * It supports a limited subset of the algorithms.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @implements {ICryptoContext}
 */
var JsonWebEncryptionCryptoContext;
var JsonWebEncryptionCryptoContext$Algorithm;
var JsonWebEncryptionCryptoContext$Encryption;

(function() {
    "use strict";

    /**
     * Supported content encryption key encryption algorithms. These are the
     * web crypto algorithm names.
     * @enum
     */
    var Algorithm = JsonWebEncryptionCryptoContext$Algorithm = {
        /** RSAES-OAEP */
        RSA_OAEP: WebCryptoAlgorithm.RSA_OAEP['name'],
        /** AES-128 Key Wrap */
        A128KW: WebCryptoAlgorithm.A128KW['name'],
    };

    /**
     * Supported plaintext encryption algorithms. These are the JSON crypto
     * algorithm names.
     * @enum
     */
    JsonWebEncryptionCryptoContext$Encryption = {
        /** AES-128 GCM */
        A128GCM: "A128GCM",
        /** AES-256 GCM */
        A256GCM: "A256GCM",
    };

    JsonWebEncryptionCryptoContext = util.Class.create({
        /**
         * Create a new JSON web encryption crypto context with the specified
         * content encryption key and plaintext encryption algorithms.
         *
         * @param {MslContext} ctx MSL context.
         * @param {Algorithm} algo content encryption key encryption algorithm.
         * @param {Encryption} enc plaintext encryption algorithm.
         * @param {?PrivateKey|CipherKey|cryptoSubtle rawKey} key content encryption key encryption
         *        private key for asymmetric encryption algorithms or secret key
         *        for symmetric encryption algorithms.
         * @param {PublicKey|cryptoSubtle rawKey=} publicKey content encryption key encryption
         *        public key for asymmetric encryption algorithms.
         * @throws MslInternalException if the content encryption key encryption
         *         algorithm is unsupported.
         */
        init: function init(ctx, algo, enc, key, publicKey) {
            var wrapKey, unwrapKey;
            switch (algo) {
                case Algorithm.RSA_OAEP:
                    wrapKey = publicKey && (publicKey.rawKey || publicKey);
                    unwrapKey = key && (key.rawKey || key);
                    break;
                case Algorithm.A128KW:
                    wrapKey = unwrapKey = key && (key.rawKey || key);
                    break;
                default:
                    throw new MslInternalException("Unsupported algorithm: " + algo);
            }

            // The properties.
            var props = {
                _ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                _algo: { value: algo, writable: false, enumerable: false, configurable: false },
                _enc: {value: enc, writable: false, enumerable: false, configurable: false },
                _wrapKey: { value: wrapKey, writable: false, enumerable: false, configurable: false },
                _unwrapKey: { value: unwrapKey, writable: false, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        encrypt: function encrypt(data, callback) {
            callback.error(new MslCryptoException(MslError.ENCRYPT_NOT_SUPPORTED));
        },

        /** @inheritDoc */
        decrypt: function decrypt(data, callback) {
            callback.error(new MslCryptoException(MslError.DECRYPT_NOT_SUPPORTED));
        },

        /** @inheritDoc */
        wrap: function wrap(key, callback) {
            AsyncExecutor(callback, function() {
                var oncomplete = function(result) {
                    callback.result(result);
                };
                var onerror = function(error) {
                    callback.error(new MslCryptoException(MslError.WRAP_ERROR));
                };
                mslCrypto['wrapKey']('jwe+jwk', key.rawKey, this._wrapKey, this._wrapKey.algorithm)
                    .then(oncomplete, onerror);
            }, this);
        },

        /** @inheritDoc */
        unwrap: function unwrap(data, algo, usages, callback) {
            AsyncExecutor(callback, function() {
                var oncomplete = function(result) {
                    constructKey(result);
                };
                var onerror = function() {
                    callback.error(new MslCryptoException(MslError.UNWRAP_ERROR));
                };
                mslCrypto['unwrapKey']('jwe+jwk', data, this._unwrapKey, this._unwrapKey.algorithm, algo, false, usages)
                    .then(oncomplete, onerror);
            }, this);

            function constructKey(rawKey) {
                AsyncExecutor(callback, function() {
                    switch (rawKey["type"]) {
                        case "secret":
                            CipherKey$create(rawKey, callback);
                            break;
                        case "public":
                            PublicKey$create(rawKey, callback);
                            break;
                        case "private":
                            PrivateKey$create(rawKey, callback);
                            break;
                        default:
                            throw new MslCryptoException(MslError.UNSUPPORTED_KEY, "type: " + rawKey["type"]);
                    }
                });
            }
        },

        /** @inheritDoc */
        sign: function sign(data, callback) {
            callback.error(new MslCryptoException(MslError.SIGN_NOT_SUPPORTED));
        },

        /** @inheritDoc */
        verify: function verify(data, signature, callback) {
            callback.error(new MslCryptoException(MslError.VERIFY_NOT_SUPPORTED));
        },
    });
})();



// -- javascript/crypto/NullCryptoContext.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * A crypto context where encryption/decryption are no-ops, signatures are
 * empty, and verification always returns true.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @implements {ICryptoContext}
 */
var NullCryptoContext = ICryptoContext.extend({
    /** @inheritDoc */
    encrypt: function encrypt(data, callback) {
        callback.result(data);
    },

    /** @inheritDoc */
    decrypt: function decrypt(data, callback) {
        callback.result(data);
    },

    /** @inheritDoc */
    wrap: function wrap(key, callback) {
        callback.result(key);
    },

    /** @inheritDoc */
    unwrap: function unwrap(data, algo, usages, callback) {
        callback.result(data);
    },

    /** @inheritDoc */
    sign: function sign(data, callback) {
        callback.result(new Uint8Array(0));
    },

    /** @inheritDoc */
    verify: function verify(data, signature, callback) {
        callback.result(true);
    },
});



// -- javascript/crypto/RsaCryptoContext.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>An RSA crypto context supports RSA/ECB/OAEPPadding or RSA/ECB/PKCS#1
 * encryption/decryption, or SHA-256 with RSA sign/verify.</p>
 * 
 * <p>The {@link OAEPParameterSpec#DEFAULT} parameters are used for OAEP
 * encryption and decryption.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @implements {ICryptoContext}
 */
var RsaCryptoContext;
var RsaCryptoContext$Mode;

(function() {
    "use strict";

    /**
     * Null transform or algorithm.
     * @const
     * @type {String}
     */
    var NULL_OP = "nullOp";

    /**
     * RSA crypto context mode.
     * @enum
     */
    RsaCryptoContext$Mode = {
        /** RSA-OAEP encrypt/decrypt */
        ENCRYPT_DECRYPT_OAEP: 1,
        /** RSA PKCS#1 encrypt/decrypt */
        ENCRYPT_DECRYPT_PKCS1: 2,
        /** RSA-OAEP wrap/unwrap */
        WRAP_UNWRAP_OAEP: 3,
        /** RSA PKCS#1 wrap/unwrap */
        WRAP_UNWRAP_PKCS1: 4,
        /** RSA-SHA256 sign/verify */
        SIGN_VERIFY: 5
    };

    var Mode = RsaCryptoContext$Mode;

    RsaCryptoContext = ICryptoContext.extend({
        /**
         * <p>Create a new RSA crypto context for encrypt/decrypt and sign/verify
         * using the provided public and private keys. The crypto context mode
         * identifies the operations to enable. All other operations are no-ops and
         * return the data unmodified. (Wrap/unwrap cannot return the data
         * unmodified and instead throws a {@link MslCryptoException} indicating
         * the operation is unsupported.</p>
         *
         * <p>If there is no private key decryption, unwrapping, and signing is
         * unsupported.</p>
         *
         * <p>If there is no public key encryption, wrapping, and verification is
         * unsupported.</p>
         *
         * @param {MslContext} ctx MSL context.
         * @param {String} id the key pair identity.
         * @param {PrivateKey} privateKey the private key. May be null.
         * @param {PublicKey} publicKey the public key. May be null.
         * @param {Mode} mode crypto context mode.
         * @constructor
         */
        init: function init(ctx, id, privateKey, publicKey, mode) {
            init.base.call(this);

            // Extract actual RSA keys.
            if (privateKey)
                privateKey = privateKey.rawKey;
            if (publicKey)
                publicKey = publicKey.rawKey;

            var transform;
            if (mode == Mode.ENCRYPT_DECRYPT_PKCS1) {
                transform = WebCryptoAlgorithm.RSAES;
            } else if (mode == Mode.ENCRYPT_DECRYPT_OAEP) {
                transform = WebCryptoAlgorithm.RSA_OAEP;
            } else {
                transform = NULL_OP;
            }
            var wrapTransform;
            if (mode == Mode.WRAP_UNWRAP_PKCS1) {
                wrapTransform = WebCryptoAlgorithm.RSAES;
            } else if (mode == Mode.WRAP_UNWRAP_OAEP) {
                wrapTransform = WebCryptoAlgorithm.RSA_OAEP;
            } else {
                wrapTransform = NULL_OP;
            }
            var algo = (mode == Mode.SIGN_VERIFY) ? WebCryptoAlgorithm.RSASSA_SHA256 : NULL_OP;

            // The properties.
            var props = {
                id: { value: id, writable: false, enumerable: false, configurable: false },
                privateKey: { value: privateKey, writable: false, enumerable: false, configurable: false },
                publicKey: { value: publicKey, writable: false, enumerable: false, configurable: false },
                transform: { value: transform, writable: false, enumerable: false, configurable: false },
                wrapTransform: { value: wrapTransform, writable: false, enumerable: false, configurable: false },
                algo: { value: algo, writable: false, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        encrypt: function encrypt(data, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                if (this.transform == NULL_OP)
                    return data;
                if (!this.publicKey)
                    throw new MslCryptoException(MslError.ENCRYPT_NOT_SUPPORTED, "no public key");
                if (data.length == 0)
                    return data;

                var oncomplete = function(ciphertext) {
                    // Return ciphertext envelope byte representation.
                    MslCiphertextEnvelope$create(self.id, null, ciphertext, {
                        result: function (envelope) {
                            try {
                                var json = JSON.stringify(envelope);
                                callback.result(textEncoding$getBytes(json, MslConstants$DEFAULT_CHARSET));
                            } catch (e) {
                                callback.error(new MslCryptoException(MslError.ENCRYPT_ERROR, null, e));
                            }
                        },
                        error: function(e) {
                            if (!(e instanceof MslException))
                                e = new MslCryptoException(MslError.ENCRYPT_ERROR, null, e);
                            callback.error(e);
                        }
                    });
                };
                var onerror = function(e) {
                    callback.error(new MslCryptoException(MslError.ENCRYPT_ERROR));
                };
                mslCrypto['encrypt'](self.transform, self.publicKey, data)
                    .then(oncomplete, onerror);
            }, this);
        },

        /** @inheritDoc */
        decrypt: function decrypt(data, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                if (this.transform == NULL_OP)
                    return data;
                if (!this.privateKey)
                    throw new MslCryptoException(MslError.DECRYPT_NOT_SUPPORTED, "no private key");
                if (data.length == 0)
                    return data;

                // Reconstitute ciphertext envelope.
                var jo;
                try {
                    var json = textEncoding$getString(data, MslConstants$DEFAULT_CHARSET);
                    jo = JSON.parse(json);
                } catch (e) {
                    if (e instanceof SyntaxError)
                        throw new MslCryptoException(MslError.CIPHERTEXT_ENVELOPE_PARSE_ERROR, null, e);
                    throw new MslCryptoException(MslError.DECRYPT_ERROR, null, e);
                }

                MslCiphertextEnvelope$parse(jo, MslCiphertextEnvelope$Version.V1, {
                    result: function(envelope) {
                        try {
                            // Verify key ID.
                            if (envelope.keyId != self.id)
                                throw new MslCryptoException(MslError.ENVELOPE_KEY_ID_MISMATCH);

                            // Decrypt ciphertext.
                            var oncomplete = callback.result;
                            var onerror = function(e) {
                                callback.error(new MslCryptoException(MslError.DECRYPT_ERROR));
                            };
                            mslCrypto['decrypt'](self.transform, self.privateKey, envelope.ciphertext)
                                .then(oncomplete, onerror);
                        } catch (e) {
                            if (!(e instanceof MslException))
                                callback.error(new MslCryptoException(MslError.DECRYPT_ERROR, null, e));
                            else
                                callback.error(e);
                        }
                    },
                    error: function(e) {
                        if (e instanceof MslEncodingException)
                            e = new MslCryptoException(MslError.CIPHERTEXT_ENVELOPE_ENCODE_ERROR, null, e);
                        if (!(e instanceof MslException))
                            e = new MslCryptoException(MslError.DECRYPT_ERROR, null, e);
                        callback.error(e);
                    }
                });
            }, this);
        },

        /** @inheritDoc */
        wrap: function wrap(key, callback) {
            AsyncExecutor(callback, function() {
                if (this.wrapTransform == NULL_OP || !this.publicKey)
                    throw new MslCryptoException(MslError.WRAP_NOT_SUPPORTED, "no public key");

                var oncomplete = callback.result;
                var onerror = function(e) {
                    callback.error(new MslCryptoException(MslError.WRAP_ERROR));
                };
                mslCrypto['wrapKey']('jwk', key.rawKey, this.publicKey, this.wrapTransform)
                    .then(oncomplete, onerror);
            }, this);
        },

        /** @inheritDoc */
        unwrap: function unwrap(data, algo, usages, callback) {
            AsyncExecutor(callback, function() {
                if (this.wrapTransform == NULL_OP || !this.privateKey)
                    throw new MslCryptoException(MslError.UNWRAP_NOT_SUPPORTED, "no private key");

                var oncomplete = constructKey;
                var onerror = function(e) {
                    callback.error(new MslCryptoException(MslError.UNWRAP_ERROR));
                };

                // Build a new wrapping key algorithm object and don't use the key algorithm.
                // Generation algorithm parameters differ from unwrap algorithm parameters as
                // defined by the spec.  This is currently only changed in this place and should
                // eventually be fixed in the DEPOT code.
                mslCrypto['unwrapKey']('jwk', data, this.privateKey, {name: this.privateKey.algorithm.name, hash: {name:'SHA-1'}}, algo, false, usages)
                    .then(oncomplete, onerror);
            }, this);

            function constructKey(rawKey) {
                AsyncExecutor(callback, function() {
                    switch (rawKey["type"]) {
                        case "secret":
                            CipherKey$create(rawKey, callback);
                            break;
                        case "public":
                            PublicKey$create(rawKey, callback);
                            break;
                        case "private":
                            PrivateKey$create(rawKey, callback);
                            break;
                        default:
                            throw new MslCryptoException(MslError.UNSUPPORTED_KEY, "type: " + rawKey["type"]);
                    }
                });
            }
        },

        /** @inheritDoc */
        sign: function sign(data, callback) {
            AsyncExecutor(callback, function() {
                if (this.algo == NULL_OP)
                    return new Uint8Array(0);
                if (!this.privateKey)
                    throw new MslCryptoException(MslError.SIGN_NOT_SUPPORTED, "no private key");

                var oncomplete = function(hash) {
                    // Return the signature envelope byte representation.
                    MslSignatureEnvelope$create(hash, {
                        result: function(envelope) {
                            callback.result(envelope.bytes);
                        },
                        error: callback.error
                    });
                };
                var onerror = function(e) {
                    callback.error(new MslCryptoException(MslError.SIGNATURE_ERROR));
                };
                mslCrypto['sign'](this.algo, this.privateKey, data)
                    .then(oncomplete, onerror);
            }, this);
        },

        /** @inheritDoc */
        verify: function verify(data, signature, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                if (this.algo == NULL_OP)
                    return true;
                if (!this.publicKey)
                    throw new MslCryptoException(MslError.VERIFY_NOT_SUPPORTED, "no public key");

                // Reconstitute the signature envelope.
                MslSignatureEnvelope$parse(signature, MslSignatureEnvelope$Version.V1, {
                    result: function(envelope) {
                        AsyncExecutor(callback, function() {
                            var oncomplete = callback.result;
                            var onerror = function(e) {
                                callback.error(new MslCryptoException(MslError.SIGNATURE_ERROR));
                            };
                            mslCrypto['verify'](this.algo, this.publicKey, envelope.signature, data)
                                .then(oncomplete, onerror);
                        }, self);
                    },
                    error: callback.error
                });
            }, this);
        }
    });
})();



// -- javascript/crypto/SymmetricCryptoContext.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * A symmetric crypto context performs AES-128 encryption/decryption, AES-128
 * key wrap/unwrap, and HMAC-SHA256 sign/verify.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var SymmetricCryptoContext;

(function() {
    SymmetricCryptoContext = ICryptoContext.extend({
        /**
         * Create a new symmetric crypto context using the provided keys.
         *
         * If there is no encryption key, encryption and decryption is unsupported.
         *
         * If there is no HMAC key, signing and verification is unsupported.
         *
         * If there is no wrap key, wrap and unwrap is unsupported.
         *
         * @param {MslContext} ctx MSL context.
         * @param {string} id the key set identity.
         * @param {CipherKey} encryptionKey the key used for encryption/decryption.
         * @param {CipherKey} hmacKey the key used for HMAC compuation.
         * @param {CipherKey} wrapKey the key used for wrap/unwrap.
         * @throws MslCryptoException if the encryption key length is unsupported.
         */
        init: function init(ctx, id, encryptionKey, hmacKey, wrapKey) {
            init.base.call(this);

            encryptionKey = encryptionKey && encryptionKey.rawKey;
            hmacKey = hmacKey && hmacKey.rawKey;
            wrapKey = wrapKey && wrapKey.rawKey;

            // The properties.
            var props = {
                ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                id: { value: id, writable: false, enumerable: false, configurable: false },
                encryptionKey: { value: encryptionKey, writable: false, enumerable: false, configurable: false },
                hmacKey: { value: hmacKey, writable: false, enumerable: false, configurable: false },
                wrapKey: { value: wrapKey, writable: false, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        encrypt: function encrypt(data, callback) {
            var self = this;

            AsyncExecutor(callback, function() {
                if (!this.encryptionKey)
                    throw new MslCryptoException(MslError.ENCRYPT_NOT_SUPPORTED, "no encryption/decryption key");
                if (data.length == 0)
                    return data;

                // Generate IV.
                var iv = new Uint8Array(16);
                this.ctx.getRandom().nextBytes(iv);

                var oncomplete = function(result) {
                    // Return ciphertext envelope byte representation.
                    var ciphertext = new Uint8Array(result);
                    MslCiphertextEnvelope$create(self.id, iv, ciphertext, {
                        result: function(envelope) {
                            try {
                                var envelopeJson = JSON.stringify(envelope);
                                callback.result(textEncoding$getBytes(envelopeJson, MslConstants$DEFAULT_CHARSET));
                            } catch (e) {
                                callback.error(new MslCryptoException(MslError.ENCRYPT_ERROR, null, e));
                            }
                        },
                        error: function(e) {
                            if (!(e instanceof MslException))
                                e = new MslCryptoException(MslError.ENCRYPT_ERROR, null, e);
                            callback.error(e);
                        }
                    });
                };
                var onerror = function(e) {
                    callback.error(new MslCryptoException(MslError.ENCRYPT_ERROR));
                };
                mslCrypto['encrypt']({ 'name': WebCryptoAlgorithm.AES_CBC['name'], 'iv': iv }, self.encryptionKey, data)
                    .then(oncomplete, onerror);
            }, this);
        },

        /** @inheritDoc */
        decrypt: function decrypt(data, callback) {
            var self = this;

            AsyncExecutor(callback, function() {
                if (!this.encryptionKey)
                    throw new MslCryptoException(MslError.DECRYPT_NOT_SUPPORTED, "no encryption/decryption key");
                if (data.length == 0)
                    return data;

                // Reconstitute ciphertext envelope.
                var jo;
                try {
                    var json = textEncoding$getString(data, MslConstants$DEFAULT_CHARSET);
                    jo = JSON.parse(json);
                } catch (e) {
                    if (e instanceof SyntaxError)
                        throw new MslCryptoException(MslError.CIPHERTEXT_ENVELOPE_PARSE_ERROR, null, e);
                    throw new MslCryptoException(MslError.DECRYPT_ERROR, null, e);
                }

                MslCiphertextEnvelope$parse(jo, MslCiphertextEnvelope$Version.V1, {
                    result: function(envelope) {
                        try {
                            // Verify key ID.
                            if (envelope.keyId != self.id)
                                throw new MslCryptoException(MslError.ENVELOPE_KEY_ID_MISMATCH);

                            // Decrypt ciphertext.
                            var oncomplete = function(result) {
                                var cleartext = new Uint8Array(result);
                                callback.result(cleartext);
                            };
                            var onerror = function() {
                                callback.error(new MslCryptoException(MslError.DECRYPT_ERROR));
                            };
                            mslCrypto['decrypt']({ 'name': WebCryptoAlgorithm.AES_CBC['name'], 'iv': envelope.iv }, self.encryptionKey, envelope.ciphertext)
                                .then(oncomplete, onerror);
                        } catch (e) {
                            if (!(e instanceof MslException))
                                callback.error(new MslCryptoException(MslError.DECRYPT_ERROR, null, e));
                            else
                                callback.error(e);
                        }
                    },
                    error: function(e) {
                        if (e instanceof MslEncodingException)
                            e = new MslCryptoException(MslError.CIPHERTEXT_ENVELOPE_ENCODE_ERROR, null, e);
                        if (!(e instanceof MslException))
                            e = new MslCryptoException(MslError.DECRYPT_ERROR, null, e);
                        callback.error(e);
                    },
                });
            }, this);
        },

        /** @inheritDoc */
        wrap: function wrap(key, callback) {
            AsyncExecutor(callback, function() {
                if (!this.wrapKey)
                    throw new MslCryptoException(MslError.WRAP_NOT_SUPPORTED, "no wrap/unwrap key");

                var oncomplete = function(result) {
                    callback.result(result);
                };
                var onerror = function(e) {
                    callback.error(new MslCryptoException(MslError.WRAP_ERROR));
                };
                mslCrypto['wrapKey']('raw', key.rawKey, this.wrapKey, this.wrapKey.algorithm)
                    .then(oncomplete, onerror);
            }, this);
        },

        /** @inheritDoc */
        unwrap: function unwrap(data, algo, usages, callback) {
            AsyncExecutor(callback, function() {
                if (!this.wrapKey)
                    throw new MslCryptoException(MslError.UNWRAP_NOT_SUPPORTED, "no wrap/unwrap key");
                var oncomplete = function(result) {
                    constructKey(result);
                };
                var onerror = function(e) {
                    callback.error(new MslCryptoException(MslError.UNWRAP_ERROR));
                };
                mslCrypto['unwrapKey']('raw', data, this.wrapKey, this.wrapKey.algorithm, algo, false, usages)
                    .then(oncomplete, onerror);
            }, this);

            function constructKey(rawKey) {
                AsyncExecutor(callback, function() {
                    switch (rawKey["type"]) {
                        case "secret":
                            CipherKey$create(rawKey, callback);
                            break;
                        case "public":
                            PublicKey$create(rawKey, callback);
                            break;
                        case "private":
                            PrivateKey$create(rawKey, callback);
                            break;
                        default:
                            throw new MslCryptoException(MslError.UNSUPPORTED_KEY, "type: " + rawKey["type"]);
                    }
                });
            }
        },

        /** @inheritDoc */
        sign: function sign(data, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                if (!this.hmacKey)
                    throw new MslCryptoException(MslError.SIGN_NOT_SUPPORTED, "no HMAC key.");
                
                // Compute the hash.
                var oncomplete = function(result) {
                    AsyncExecutor(callback, function() {
                        var hash = new Uint8Array(result);

                        // Return the signature envelope byte representation.
                        MslSignatureEnvelope$create(hash, {
                            result: function(envelope) {
                                callback.result(envelope.bytes);
                            },
                            error: callback.error,
                        });
                    }, self);
                };
                var onerror = function() {
                    callback.error(new MslCryptoException(MslError.HMAC_ERROR));
                };
                mslCrypto['sign'](WebCryptoAlgorithm.HMAC_SHA256, this.hmacKey, data)
                    .then(oncomplete, onerror);
            }, this);
        },

        /** inheritDoc */
        verify: function verify(data, signature, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                if (!this.hmacKey)
                    throw new MslCryptoException(MslError.VERIFY_NOT_SUPPORTED, "no HMAC key.");

                // Reconstitute the signature envelope.
                MslSignatureEnvelope$parse(signature, MslSignatureEnvelope$Version.V1, {
                    result: function(envelope) {
                        AsyncExecutor(callback, function() {
                            // Verify the hash.
                            var oncomplete = function(verified) {
                                callback.result(verified);
                            };
                            var onerror = function(e) {
                                callback.error(new MslCryptoException(MslError.HMAC_ERROR));
                            };
                            mslCrypto['verify'](WebCryptoAlgorithm.HMAC_SHA256, this.hmacKey, envelope.signature, data)
                                .then(oncomplete, onerror);
                        }, self);
                    },
                    error: callback.error
                });
            }, this);
        },
    });
})();



// -- javascript/crypto/SessionCryptoContext.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * This is a convenience class for constructing a symmetric crypto context from
 * a MSL session master token.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var SessionCryptoContext = SymmetricCryptoContext.extend({
    /**
     * Construct a new session crypto context from the provided master token.
     *
     * If an identity, encryption key, and HMAC key are provided then they are
     * assumed to be the same as what is inside the master token, which may be
     * untrusted.
     *
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken the master token. May be untrusted if
     *        the identity, encryption key, and HMAC key are provided.
     * @param {string=} identity entity identity.
     * @param {CipherKey=} encryptionKey encryption key.
     * @param {CipherKey=} hmacKey HMAC key.
     * @throws MslMasterTokenException if the master token is not trusted.
     * @throws MslCryptoException if the encryption key length is unsupported.
     */
    init: function init(ctx, masterToken, identity, encryptionKey, hmacKey) {
        if (identity || encryptionKey || hmacKey) {
            init.base.call(this, ctx, identity + '_' + masterToken.sequenceNumber, encryptionKey, hmacKey, null);
        } else {
            if (!masterToken.isDecrypted())
                throw new MslMasterTokenException(MslError.MASTERTOKEN_UNTRUSTED, masterToken);
            init.base.call(this, ctx, masterToken.identity + '_' + masterToken.sequenceNumber, masterToken.encryptionKey, masterToken.hmacKey, null);
        }
    },
});



// -- javascript/crypto/ClientMslCryptoContext.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * This class should be used by trusted network clients for the primary crypto
 * context used for master tokens and user ID tokens. It always fails to verify
 * and its other operations are no-ops.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @see MslContext#getMslCryptoContext()
 */
var ClientMslCryptoContext = ICryptoContext.extend({
    /** @inheritDoc */
    encrypt: function encrypt(data, callback) {
        callback.result(data);
    },

    /** @inheritDoc */
    decrypt: function decrypt(data, callback) {
        callback.result(data);
    },

    /** @inheritDoc */
    wrap: function wrap(key, callback) {
        // This should never be called.
        callback.error(new MslInternalException("Wrap is unsupported by the MSL token crypto context."));
    },

    /** @inheritDoc */
    unwrap: function wrap(data, algo, usages, callback) {
        // This should never be called.
        callback.error(new MslInternalException("Unwrap is unsupported by the MSL token crypto context."));
    },

    /** @inheritDoc */
    sign: function sign(data, callback) {
        callback.result(new Uint8Array(0));
    },

    /** inheritDoc */
    verify: function verify(data, signature, callback) {
        callback.result(false);
    },
});



// -- javascript/entityauth/EntityAuthenticationScheme.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Entity authentication schemes.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @enum {string}
 */
var EntityAuthenticationScheme = {
    /** Pre-shared keys. */
    PSK: "PSK",
    /** Model group keys. */
    MGK: "MGK",
    /** X.509 public/private key pair. */
    X509: "X509",
    /** RSA public/private key pair. */
    RSA: "RSA",
    /** NP-Ticket public/private key pair. */
    NPTICKET: "NPTICKET",
    /** ECC public/private key pair. */
    ECC: "ECC",
    /** Unauthenticated. */
    NONE: "NONE",
};
Object.freeze(EntityAuthenticationScheme);

/**
 * Only certain entity authentication schemes support encryption. This
 * method identifies the schemes that do.
 *
 * @param {EntityAuthenticationScheme} scheme the entity authentication scheme.
 * @return {boolean} true if the scheme supports encryption.
 */
function EntityAuthenticationScheme$supportsEncryption(scheme_) {
    switch (scheme_) {
        case EntityAuthenticationScheme.PSK:
        case EntityAuthenticationScheme.MGK:
            return true;
        default:
            return false;
    }
}

/**
 * Only certain entity authentication schemes support integrity protection.
 * This method identifies the schemes that do.
 * 
 * @param {EntityAuthenticationScheme} scheme the entity authentication scheme.
 * @return {boolean} true if the scheme supports integrity protection.
 */
function EntityAuthenticationScheme$supportsIntegrityProtection(scheme_) {
    switch (scheme_) {
        case EntityAuthenticationScheme.PSK:
        case EntityAuthenticationScheme.MGK:
        case EntityAuthenticationScheme.X509:
        case EntityAuthenticationScheme.RSA:
        case EntityAuthenticationScheme.NPTICKET:
        case EntityAuthenticationScheme.ECC:
            return true;
        default:
            return false;
    }
}


// -- javascript/entityauth/EntityAuthenticationData.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>The entity authentication data provides proof of entity identity.</p>
 *
 * <p>Specific entity authentication mechanisms should define their own entity
 * authentication data types.</p>
 *
 * <p>Entity authentication data is represented as
 * {@code
 * entityauthdata = {
 *   "#mandatory" : [ "scheme", "authdata" ],
 *   "scheme" : "string",
 *   "authdata" : object
 * }} where:
 * <ul>
 * <li>{@code scheme} is the entity authentication scheme</li>
 * <li>{@code authdata} is the scheme-specific entity authentication data</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var EntityAuthenticationData;
var EntityAuthenticationData$parse;

(function() {
    /** JSON key entity authentication scheme. */
    var KEY_SCHEME = "scheme";
    /** JSON key entity authentication data. */
    var KEY_AUTHDATA = "authdata";

    EntityAuthenticationData = util.Class.create({
        /**
         * <p>Create a new entity authentication data object with the specified
         * entity authentication scheme.</p>
         *
         * @param {EntityAuthenticationScheme} scheme the entity authentication
         *        scheme.
         * @constructor
         * @interface
         */
        init: function init(scheme) {
            // The properties.
            var props = {
                scheme: { value: scheme, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return {string} the entity identity.
         * @throws MslCryptoException if there is a crypto error accessing the
         *         entity identity.
         */
        getIdentity: function() {},

        /**
         * @return {Object} the authentication data JSON representation.
         * @throws MslEncodingException if there was an error constructing the
         *         JSON representation.
         */
        getAuthData: function() {},

        /**
         * @param {Object} that the object with which to compare.
         * @return {boolean} true if this object is equal to that object.
         */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof EntityAuthenticationData)) return false;
            return this.scheme == that.scheme;
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            var result = {};
            result[KEY_SCHEME] = this.scheme;
            result[KEY_AUTHDATA] = this.getAuthData();
            return result;
        },
    });

    /**
     * Construct a new entity authentication data instance of the correct type
     * from the provided JSON object.
     *
     * @param ctx {MslContext} MSL context.
     * @param entityAuthJO {Object} the JSON object.
     * @return {EntityAuthenticationData} the entity authentication data concrete instance.
     * @throws MslEntityAuthException if unable to create the entity
     *         authentication data.
     * @throws MslEncodingException if there is an error parsing the entity
     *         authentication data.
     * @throws MslCryptoException if there is an error creating the entity
     *         authentication data crypto.
     */
    EntityAuthenticationData$parse = function EntityAuthenticationData$parse(ctx, entityAuthJO) {
        var scheme = entityAuthJO[KEY_SCHEME];
        var authdata = entityAuthJO[KEY_AUTHDATA];

        // Verify entity authentication data.
        if (!scheme || !authdata)
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "entityauthdata " + JSON.stringify(entityAuthJO));

        // Verify entity authentication scheme.
        if (!EntityAuthenticationScheme[scheme])
            throw new MslEntityAuthException(MslError.UNIDENTIFIED_ENTITYAUTH_SCHEME, scheme);

        // Construct an instance of the concrete subclass.
        var factory = ctx.getEntityAuthenticationFactory(scheme);
        if (!factory)
            throw new MslEntityAuthException(MslError.ENTITYAUTH_FACTORY_NOT_FOUND, scheme);
        return factory.createData(ctx, authdata);
    };
})();



// -- javascript/entityauth/EntityAuthenticationFactory.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A entity authentication factory creates authentication data instances and
 * authenticators for a specific entity authentication scheme.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var EntityAuthenticationFactory = util.Class.create({
    /**
     * <p>Create a new entity authentication factory for the specified scheme.</p>
     *
     * @param {EntityAuthenticationScheme} scheme the entity authentication scheme.
     * @constructor
     * @interface
     */
    init: function init(scheme) {
        // The properties.
        var props = {
            scheme: { value: scheme, writable: false, configurable: false },
        };
        Object.defineProperties(this, props);
    },

    /**
     * Construct a new entity authentication data instance from the provided
     * JSON.
     *
     * @param {MslContext} ctx MSL context.
     * @param {Object} entityAuthJO the JSON object.
     * @return {EntityAuthenticationData} the entity authentication data.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException if there is an error with the entity
     *         authentication data cryptography.
     * @throws MslEntityAuthException if there is an error creating the entity
     *         authentication data.
     */
    createData: function(ctx, entityAuthJO) {},

    /**
     * Create a crypto context that can be used to encrypt/decrypt and
     * authenticate data from the entity. The implementation of this function
     * must, by necessity, authenticate the entity authentication data.
     *
     * @param {MslContext} ctx MSL context.
     * @param {EntityAuthenticationData} authdata the authentication data.
     * @return {ICryptoContext} the entity crypto context.
     * @throws MslCryptoException if there is an error instantiating the crypto
     *         context.
     * @throws MslEntityAuthException if there is an error with the entity
     *         authentication data.
     */
    getCryptoContext: function(ctx, authdata) {},
});



// -- javascript/entityauth/ModelGroupAuthenticationData.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Model group keys entity authentication data.</p>
 *
 * <p>
 * {@code {
 *   "#mandatory" : [ "identity" ],
 *   "identity" : "string"
 * } where:
 * <ul>
 * <li>{@code identity} is the entity identity</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var ModelGroupAuthenticationData;
var ModelGroupAuthenticationData$parse;

(function() {
    /**
     * JSON key entity identity.
     * @const
     * @type {string}
     */
    var KEY_IDENTITY = "identity";

    ModelGroupAuthenticationData = EntityAuthenticationData.extend({
        /**
         * <p>Construct a new model group keys authentication data instance from the
         * specified entity identity.</p>
         *
         * @param identity the entity identity.
         * @extends {EntityAuthenticationData}
         */
        init: function init(identity) {
            init.base.call(this, EntityAuthenticationScheme.MGK);
            // The properties.
            var props = {
                identity: { value: identity, writable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getIdentity: function getIdentity() {
            return this.identity;
        },

        /** @inheritDoc */
        getAuthData: function getAuthData() {
            var result = {};
            result[KEY_IDENTITY] = this.identity;
            return result;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof ModelGroupAuthenticationData)) return false;
            return (equals.base.call(this, this, that) && this.identity == that.identity);
        },
    });

    /**
     * Construct a new model group keys authentication data instance from the
     * provided JSON object.
     *
     * @param modelGroupAuthJO the authentication data JSON object.
     * @throws MslEncodingException if there is an error parsing the JSON
     *         representation.
     */
    ModelGroupAuthenticationData$parse = function ModelGroupAuthenticationData$parse(modelGroupAuthJO) {
        var identity = modelGroupAuthJO[KEY_IDENTITY];
        if (!identity)
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "mgk authdata" + JSON.stringify(modelGroupAuthJO));
        return new ModelGroupAuthenticationData(identity);
    };
})();



// -- javascript/entityauth/ModelGroupAuthenticationFactory.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Model group keys entity authentication factory.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var ModelGroupAuthenticationFactory = EntityAuthenticationFactory.extend({
    /**
     * Construct a new model group keys authentication factory instance.
     *
     * @param {string} identity my local identity.
     */
    init: function init(identity) {
        init.base.call(this, EntityAuthenticationScheme.MGK);

        // The properties.
        var props = {
            localIdentity: { value: identity, writable: false, enumerable: false, configurable: false },
        };
        Object.defineProperties(this, props);
    },

    /** @inheritDoc */
    createData: function createData(ctx, entityAuthJO) {
        return ModelGroupAuthenticationData$parse(entityAuthJO);
    },

    /** @inheritDoc */
    getCryptoContext: function getCryptoContext(ctx, authdata) {
        // Make sure we have the right kind of entity authentication data.
        if (!(authdata instanceof ModelGroupAuthenticationData))
            throw new MslInternalException("Incorrect authentication data type " + JSON.stringify(authdata) + ".");

        // If the authdata is not for me then we can't do anything with it.
        if (authdata.identity != this.localIdentity)
            throw new MslEntityAuthException(MslError.ENTITY_NOT_FOUND, "mgk " + authdata.identity).setEntity(authdata);

        // Return the crypto context.
        // FIXME need the crypto stuff.
        return new NullCryptoContext();
    },
});



// -- javascript/entityauth/PresharedAuthenticationData.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Preshared keys entity authentication data.</p>
 *
 * <p>
 * {@code {
 *   "#mandatory" : [ "identity" ],
 *   "identity" : "string"
 * } where:
 * <ul>
 * <li>{@code identity} is the entity identity</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var PresharedAuthenticationData;
var PresharedAuthenticationData$parse;

(function() {
    /**
     * JSON key entity identity.
     * @const
     * @type {string}
     */
    var KEY_IDENTITY = "identity";

    PresharedAuthenticationData = EntityAuthenticationData.extend({
        /**
         * <p>Construct a new preshared keys authentication data instance from the
         * specified entity identity.</p>
         *
         * @param {string} identity the entity identity.
         * @extends {EntityAuthenticationData}
         */
        init: function init(identity) {
            init.base.call(this, EntityAuthenticationScheme.PSK);
            // The properties.
            var props = {
                identity: { value: identity, writable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getIdentity: function getIdentity() {
            return this.identity;
        },

        /** @inheritDoc */
        getAuthData: function getAuthData() {
            var result = {};
            result[KEY_IDENTITY] = this.identity;
            return result;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof PresharedAuthenticationData)) return false;
            return (equals.base.call(this, this, that) && this.identity == that.identity);
        },
    });

    /**
     * Construct a new preshared keys authentication data instance from the
     * provided JSON object.
     *
     * @param presharedAuthJO the authentication data JSON object.
     * @throws MslEncodingException if there is an error parsing the JSON
     *         representation.
     */
    PresharedAuthenticationData$parse = function PresharedAuthenticationData$parse(presharedAuthJO) {
        var identity = presharedAuthJO[KEY_IDENTITY];
        if (!identity)
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "psk authdata" + JSON.stringify(presharedAuthJO));
        return new PresharedAuthenticationData(identity);
    };
})();



// -- javascript/entityauth/PresharedAuthenticationFactory.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */
var PresharedAuthenticationFactory;
var PresharedAuthenticationFactory$create;

/**
 * Preshared keys entity authentication factory.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
PresharedAuthenticationFactory = EntityAuthenticationFactory.extend({
    /**
     * Construct a new preshared keys authentication factory instance.
     *
     * @param {string} identity my local identity.
     */
    init: function init(identity) {
        init.base.call(this, EntityAuthenticationScheme.PSK);

        // The properties.
        var props = {
            localIdentity: { value: identity, writable: false, enumerable: false, configurable: false },
        };
        Object.defineProperties(this, props);
    },

    /** @inheritDoc */
    createData: function createData(ctx, entityAuthJO) {
        return PresharedAuthenticationData$parse(entityAuthJO);
    },

    /** @inheritDoc */
    getCryptoContext: function getCryptoContext(ctx, authdata) {
        // Make sure we have the right kind of entity authentication data.
        if (!(authdata instanceof PresharedAuthenticationData))
            throw new MslInternalException("Incorrect authentication data type " + JSON.stringify(authdata) + ".");

        // If the authdata is not for me then we can't do anything with it.
        if (authdata.getIdentity() != this.localIdentity)
            throw new MslEntityAuthException(MslError.ENTITY_NOT_FOUND, "psk " + authdata.identity).setEntity(authdata);

        // Return the crypto context.
        // FIXME need the crypto stuff.
        return new NullCryptoContext();
    },
});



// -- javascript/entityauth/RsaAuthenticationData.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>RSA asymmetric keys entity authentication data.</p>
 *
 * <p>
 * {@code {
 *   "#mandatory" : [ "identity", "pubkeyid" ],
 *   "identity" : "string",
 *   "pubkeyid" : "string"
 * } where:
 * <ul>
 * <li>{@code identity} is the entity identity</li>
 * <li>{@code pubkeyid} is the identity of the RSA public key associated with this identity</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var RsaAuthenticationData;
var RsaAuthenticationData$parse;

(function() {
    /**
     * JSON key entity identity.
     * @const
     * @type {string}
     */
    var KEY_IDENTITY = "identity";
    /**
     * JSON key public key ID.
     * @const
     * @type {string}
     */
    var KEY_PUBKEY_ID = "pubkeyid";

    RsaAuthenticationData = EntityAuthenticationData.extend({
        /**
         * <p>Construct a new public key authentication data instance from the
         * specified entity identity and public key ID.</p>
         *
         * @param {string} identity the entity identity.
         * @param {string} pubkeyid the public key ID.
         */
        init: function init(identity, pubkeyid) {
            init.base.call(this, EntityAuthenticationScheme.RSA);

            // The properties.
            var props = {
                identity: { value: identity, writable: false, configurable: false },
                publicKeyId: { value: pubkeyid, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getIdentity: function getIdentity() {
            return this.identity;
        },

        /** @inheritDoc */
        getAuthData: function getAuthData() {
            var authdata = {};
            authdata[KEY_IDENTITY] = this.identity;
            authdata[KEY_PUBKEY_ID] = this.publicKeyId;
            return authdata;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof RsaAuthenticationData)) return false;
            return (equals.base.call(this, this, that) && this.identity == that.identity && this.publicKeyId == that.publicKeyId);
        },
    });

    /**
     * Construct a new RSA asymmetric keys authentication data instance from the
     * provided JSON object.
     *
     * @param {Object} rsaAuthJO the authentication data JSON object.
     * @return the authentication data.
     * @throws MslEncodingException if there is an error parsing the entity
     *         authentication data.
     */
    RsaAuthenticationData$parse = function RsaAuthenticationData$parse(rsaAuthJO) {
        var identity = rsaAuthJO[KEY_IDENTITY];
        var pubkeyid = rsaAuthJO[KEY_PUBKEY_ID];
        if (!identity || typeof identity !== 'string' ||
            !pubkeyid || typeof pubkeyid !== 'string')
        {
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "RSA authdata" + JSON.stringify(rsaAuthJO));
        }
        return new RsaAuthenticationData(identity, pubkeyid);
    };
})();



// -- javascript/entityauth/RsaAuthenticationFactory.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>RSA asymmetric keys entity authentication factory.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @implements {EntityAuthenticationFactory}
 */
var RsaAuthenticationFactory = EntityAuthenticationFactory.extend({
    /**
     * <p>Construct a new RSA asymmetric keys authentication factory instance.</p>
     *
     * @param {RsaStore} store RSA public key store.
     * @constructor
     */
    init: function init(store) {
        init.base.call(this, EntityAuthenticationScheme.RSA);

        // The properties.
        var props = {
            store: { value: store, writable: false, enumerable: false, configurable: false }
        };
        Object.defineProperties(this, props);
    },

    /** @inheritDoc */
    createData: function createData(ctx, entityAuthJO) {
        return RsaAuthenticationData$parse(entityAuthJO);
    },

    /** @inheritDoc */
    getCryptoContext: function getCryptoContext(ctx, authdata) {
        // Make sure we have the right kind of entity authentication data.
        if (!(authdata instanceof RsaAuthenticationData))
            throw new MslInternalException("Incorrect authentication data type " + authdata + ".");

        // Extract RSA authentication data.
        var identity = authdata.identity;
        var pubkeyid = authdata.publicKeyId;
        var publicKey = this.store.getPublicKey(pubkeyid);
        if (!publicKey)
            throw new MslEntityAuthException(MslError.RSA_PUBLICKEY_NOT_FOUND, pubkeyid).setEntity(authdata);

        // Return the crypto context.
        return new RsaCryptoContext(ctx, identity, null, publicKey, RsaCryptoContext$Mode.SIGN_VERIFY);
    },
});



// -- javascript/entityauth/UnauthenticatedAuthenticationData.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Unauthenticated entity authentication data. This form of authentication
 * is used by entities that cannot provide any form of entity
 * authentication.</p>
 *
 * <p>Unauthenticated entity authentication data is represented as
 * {@code
 * unauthenticatedauthdata = {
 *   "#mandatory" : [ "identity" ],
 *   "identity" : "string"
 * }} where:
 * <ul>
 * <li>{@code identity} is the entity identity</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var UnauthenticatedAuthenticationData;
var UnauthenticatedAuthenticationData$parse;

(function() {
    /**
     * JSON key entity identity.
     * @const
     * @type {string}
     */
    var KEY_IDENTITY = "identity";

    UnauthenticatedAuthenticationData = EntityAuthenticationData.extend({
        /**
         * <p>Construct a new unauthenticated entity authentication data instance from
         * the specified entity identity.</p>
         *
         * @param {string} identity the entity identity.
         */
        init: function init(identity) {
            init.base.call(this, EntityAuthenticationScheme.NONE);
            // The properties.
            var props = {
                identity: { value: identity, writable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getIdentity: function getIdentity() {
            return this.identity;
        },

        /** @inheritDoc */
        getAuthData: function getAuthData() {
            var result = {};
            result[KEY_IDENTITY] = this.identity;
            return result;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof UnauthenticatedAuthenticationData)) return false;
            return (equals.base.call(this, this, that) && this.identity == that.identity);
        },
    });

    /**
     * Construct a new Unauthenticated asymmetric keys authentication data instance from the
     * provided JSON object.
     *
     * @param unauthenticatedAuthJO the authentication data JSON object.
     * @throws MslEncodingException if there is an error parsing the entity
     *         authentication data.
     */
    UnauthenticatedAuthenticationData$parse = function UnauthenticatedAuthenticationData$parse(unauthenticatedAuthJO) {
        var identity = unauthenticatedAuthJO[KEY_IDENTITY];
        if (!identity)
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "Unauthenticated authdata" + JSON.stringify(unauthenticatedAuthJO));
        return new UnauthenticatedAuthenticationData(identity);
    };
})();



// -- javascript/entityauth/UnauthenticatedAuthenticationFactory.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Unauthenticated entity authentication factory.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var UnauthenticatedAuthenticationFactory = EntityAuthenticationFactory.extend({
    /**
     * Construct a new unauthenticated authentication factory instance.
     *
     * @param {string} identity my local identity.
     */
    init: function init() {
        init.base.call(this, EntityAuthenticationScheme.NONE);
    },

    /** @inheritDoc */
    createData: function createData(ctx, entityAuthJO) {
        return UnauthenticatedAuthenticationData$parse(entityAuthJO);
    },

    /** @inheritDoc */
    getCryptoContext: function getCryptoContext(ctx, authdata) {
        // Make sure we have the right kind of entity authentication data.
        if (!(authdata instanceof UnauthenticatedAuthenticationData))
            throw new MslInternalException("Incorrect authentication data type " + JSON.stringify(authdata) + ".");

        // Return the crypto context.
        return new NullCryptoContext();
    },
});



// -- javascript/entityauth/RsaStore.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * An RSA public key store contains trusted RSA public keys.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var RsaStore = util.Class.create({
    init: function init() {
        // Map of RSA keys by key pair identity.
        var rsaKeys = {};

        // The properties.
        var props = {
            rsaKeys: { value: rsaKeys, writable: false, enumerable: false, configurable: false },
        };
        Object.defineProperties(this, props);
    },

    /**
     * Add an RSA public key to the store.
     *
     * @param {string} identity RSA key pair identity.
     * @param {PublicKey} RSA public key
     * @throws MslInternalException if there is a problem with the public key.
     */
    addPublicKey: function addPublicKey(identity, key) {
        if (!(key instanceof PublicKey))
            throw new MslInternalException("Incorrect key data type " + key + ".");

        this.rsaKeys[identity] = key;
    },

    /** @inheritDoc */
    getIdentities: function getIdentities() {
        return Object.keys(this.rsaKeys);
    },

    /** @inheritDoc */
    removePublicKey: function removePublicKey(identity) {
        delete this.rsaKeys[identity];
    },

    /** @inheritDoc */
    getPublicKey: function getPublicKey(identity) {
        return this.rsaKeys[identity];
    },
});



// -- javascript/io/InputStream.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * An input stream provides read capability of raw bytes.
 *
 * Timeouts are triggered if no character has been read within the timeout
 * period. A slow operation that is able to read at least one character per
 * timeout period will not trigger a timeout.
 *
 * @interface
 */
var InputStream = util.Class.create({
    /**
     * Aborts any outstanding operations.
     */
    abort: function() {},

    /**
     * Closes this input stream and releases any resources associated with the
     * stream.
     */
    close: function() {},

    /**
     * Marks the current position in this input stream. A subsequent call to
     * the reset method repositions this stream at the last marked position so
     * that subsequent reads re-read the same bytes.
     *
     * @see #reset()
     */
    mark: function() {},

    /**
     * Repositions this stream to the position at the time the mark method was
     * last called on this input stream.
     *
     * @throws IOException if this stream has not been marked.
     * @see #mark()
     */
    reset: function() {},

    /**
     * @return {boolean} true if the mark and reset operations are supported.
     */
    markSupported: function() {},

    /**
     * Returns the requested number of bytes from the input stream. If -1
     * is specified for the length then this function returns any bytes
     * that are available but at least one unless the timeout is hit. If 0 is
     * specified for the length then zero bytes are returned.
     *
     * If fewer bytes than requested are available then all available
     * bytes are returned. If zero bytes are available the method
     * blocks until at least one bytes is available or the timeout is hit. If
     * the timeout is hit then whatever bytes that have been read will be
     * returned.
     *
     * If there are no more bytes available (i.e. end of stream is hit)
     * then null is returned.
     *
     * If aborted whatever bytes that have been read will be returned.
     *
     * @param {number} len the number of characters to read.
     * @param {number} timeout read timeout in milliseconds or -1 for no
     *        timeout.
     * @param {{result: function(Uint8Array), timeout: function(Uint8Array), error: function(Error)}}
     *        callback the callback that will receive the bytes or null, be
     *        notified of timeouts, or any thrown exceptions.
     * @throws IOException if there is an error reading the data or the stream
     *         is closed.
     */
    read: function(len, timeout, callback) {},
});



// -- javascript/io/OutputStream.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * An output stream provides write capability of raw bytes.
 *
 * Timeouts are triggered if no character has been sent within the timeout
 * period. A slow operation that is able to write at least one character per
 * timeout period will not trigger a timeout.
 *
 * @interface
 */
var OutputStream = util.Class.create({
    /**
     * Abort any outstanding operations.
     */
    abort: function() {},

    /**
     * Closes this output stream and releases any resources associated with the
     * stream.
     *
     * @param {number} timeout write timeout in milliseconds.
     * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
     *        callback the callback that will receive true upon completion or
     *        false if aborted, be notified of a timeout, or any thrown
     *        exceptions.
     * @throws IOException if there is an error closing the stream.
     */
    close: function(timeout, callback) {},

    /**
     * Writes the specified portion of the byte array to the output stream.
     *
     * This is an asynchronous call and the callback should be returned as soon
     * as the byte structure is no longer needed or the timeout is hit. If the
     * timeout is hit then the number of bytes written will be less than
     * the requested amount.
     *
     * @param {Uint8Array} data the data to write.
     * @param {number} off offset into the data.
     * @param {number} len number of bytes to write.
     * @param {number} timeout write timeout in milliseconds.
     * @param {{result: function(number), timeout: function(number), error: function(Error)}}
     *        callback the callback that will receive the number of bytes
     *        written which will be less than the length if aborted, be
     *        notified of a timeout, or any thrown exceptions.
     * @throws IOException if there is an error writing the data or the stream
     *         is closed.
     * @throws RangeError if the offset is negative, the length is negative, or
     *         the offset plus length exceeds the data length.
     */
    write: function(data, off, len, timeout, callback) {},

    /**
     * Flushes this output stream so any buffered data is written out.
     *
     * @param {number} timeout write timeout in milliseconds or -1 for no
     *        timeout.
     * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
     *        callback the callback that will receive true upon completion or
     *        false if aborted, be notified of a timeout, or any thrown
     *        exceptions.
     * @throws IOException if there is an error flushing the data.
     */
    flush: function(timeout, callback) {},
});



// -- javascript/io/ByteArrayInputStream.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Reads data from a byte array.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var ByteArrayInputStream = util.Class.create({
    /**
     * Create a new byte array input stream from the provided data.
     *
     * @param {Uint8Array} data the data.
     */
    init: function init(data) {
        // The properties.
        var props = {
            _data: { value: data, writable: false, enumerable: false, configurable: false },
            _closed: { value: false, writable: true, enumerable: false, configurable: false },
            _currentPosition: { value: 0, writable: true, enumerable: false, configurable: false },
            _mark: { value: -1, writable: true, enumerable: false, configurable: false },
        };
        Object.defineProperties(this, props);
    },

    /** @inheritDoc */
    abort: function abort() {},

    /** @inheritDoc */
    close: function close() {
        this._close = true;
    },

    /**
     * Marks the current position in this input stream. A subsequent call to
     * the reset method repositions this stream at the last marked position so
     * that subsequent reads re-read the same bytes.
     *
     * @see #reset()
     */
    mark: function mark() {
        this._mark = this._currentPosition;
    },

    /**
     * Repositions this stream to the position at the time the mark method was
     * last called on this input stream.
     *
     * @throws IOException if this stream has not been marked.
     * @see #mark()
     */
    reset: function reset() {
        if (this._mark == -1)
            throw new MslIoException("Stream has not been marked.");
        this._currentPosition = this._mark;
    },

    /**
     * @return {boolean} true if the mark and reset operations are supported.
     */
    markSupported: function markSupported() {
        return true;
    },

    /**
     * Returns the requested number of bytes from the input stream. If -1
     * is specified for the length then this function returns any bytes
     * that are available but at least one unless the timeout is hit.
     *
     * If fewer bytes than requested are available then all available
     * bytes are returned. If zero bytes are available the method
     * blocks until at least one character is available or the timeout is hit.
     *
     * If there are no more bytes available (i.e. end of stream is hit)
     * then null is returned.
     *
     * @param {number} len the number of bytes to read.
     * @param {number} timeout read timeout in milliseconds.
     * @param {{result: function(Uint8Array), timeout: function(Uint8Array), error: function(Error)}}
     *        callback the callback that will receive the bytes or null, be
     *        notified of timeouts, or any thrown exceptions.
     */
    read: function read(len, timeout, callback) {
        InterruptibleExecutor(callback, function() {
            if (this._closed)
                throw new MslIoException("Stream is already closed.");

            if (this._currentPosition == this._data.length)
                return null;

            if (len == -1)
                len = this._data.length - this._currentPosition;
            var endPosition = this._currentPosition + len;
            var data = this._data.subarray(this._currentPosition, endPosition);
            this._currentPosition += data.length;
            return data;
        }, this);
    },
});



// -- javascript/io/ByteArrayOutputStream.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Accumulates all received data into a byte array.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var ByteArrayOutputStream = util.Class.create({
    /**
     * Create a new byte array output stream.
     */
    init: function init() {
        // The properties.
        var props = {
            _closed: { value: false, writable: true, enumerable: false, configurable: false },
            /** @type {Uint8Array} */
            _result: { value: new Uint8Array(0), writable: true, enuemrable: false, configurable: false },
            /** @type {Array.<{data: Uint8Array}>} */
            _buffered: { value: new Array(), writable: false, enumerable: false, configurable: false },
        };
        Object.defineProperties(this, props);
    },

    /** @inheritDoc */
    abort: function abort() {},

    /** @inheritDoc */
    close: function close(timeout, callback) {
        this._closed = true;
        callback.result(true);
    },

    /** @inheritDoc */
    write: function(data, off, len, timeout, callback) {
        InterruptibleExecutor(callback, function() {
            if (this._closed)
                throw new MslIoException("Stream is already closed.");

            if (off < 0)
                throw new RangeError("Offset cannot be negative.");
            if (len < 0)
                throw new RangeError("Length cannot be negative.");
            if (off + len > data.length)
                throw new RangeError("Offset plus length cannot be greater than the array length.");

            var segment = data.subarray(off, len);
            this._buffered.push(segment);
            return segment.length;
        }, this);
    },

    /** @inheritDoc */
    flush: function(timeout, callback) {
        while (this._buffered.length > 0) {
            var segment = this._buffered.shift();
            if (!this._result) {
                this._result = new Uint8Array(segment);
            } else {
                var newResult = new Uint8Array(this._result.length + segment.length);
                newResult.set(this._result);
                newResult.set(segment, this._result.length);
                this._result = newResult;
            }
        }
        callback.result(true);
    },

    /**
     * @return {number} the number of accumulated bytes.
     */
    size: function size() {
        this.flush(1, {result: function() {}});
        return this._result.length;
    },

    /**
     * @return {Uint8Array} a Uint8Array of the accumulated bytes.
     */
    toByteArray: function toByteArray() {
        this.flush(1, {result: function() {}});
        return this._result;
    },
});



// -- javascript/io/Url.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * The URL class provides access to an input stream and output stream tied to a
 * specific URL.
 *
 * This implementation supports single-shot HTTP requests and responses. The
 * output stream data is buffered and only sent when the input stream is first
 * read from. The output stream will not accept additional data once the input
 * stream is read from.
 */
var Url;

var IHttpLocation = util.Class.create({

    /**
     * Given a request, gets the response.
     *
     * @param {{body:string}} request
     * @param {number} timeout request response timeout in milliseconds or -1 for no timeout.
     * @param {{result: function({body:string}), timeout: function(), error: function(Error)}}
     *        callback the callback will receive the response
     * @returns {{abort:Function})
     */
    getResponse: function getResponse(request, timeout, callback) { }

});

(function () {

    /**
     * An HTTP output stream buffers data and then sends it upon close. The
     * response is made available
     */
    var HttpOutputStream = OutputStream.extend({
        /**
         * Create a new HTTP output stream that will send and receive an HTTP
         * request and response to the target location.
         *
         * @param {IHttpLocation} httpLocation target location.
         * @param {number=} timeout optional connect/read/write timeout in
         *        milliseconds. The default is defined by the http client
         *        configuration.
         */
        init: function init(httpLocation, timeout) {
            // The properties.
            var props = {
                _httpLocation: { value: httpLocation, writable: false, enumerable: false, configurable: false },
                _timeout: { value: timeout, writable: true, enumerable: false, configurable: false },
                _buffer: { value: new ByteArrayOutputStream(), writable: false, enumerable: false, configurable: false },
                _response: { value: undefined, writable: true, enumerable: false, configurable: false },
                _abortToken: { value: undefined, writable: true, enumerable: false, configurable: false },
                _responseQueue: { value: new BlockingQueue(), writable: true, enumerable: false, configurable: false },

            };
            Object.defineProperties(this, props);
        },

        /**
         * Set the timeout.
         *
         * @param {number} timeout connect/read/write timeout in milliseconds.
         *        -1 for no timeout.
         */
        setTimeout: function setTimeout(timeout) {
            this._timeout = timeout;
        },

        /**
         * Return the response. This blocks until a response is available.
         *
         * @param {number} timeout response timeout in milliseconds or -1 for
         *        no timeout.
         * @param {{result: function({success: boolean, content: Uint8Array, errorHttpCode: number, errorSubCode: number}),
         *         timeout: function(), error: function(Error)}}
         *        callback the callback will receive the HTTP response or
         *        undefined if the HTTP transaction was aborted, notified of
         *        timeout or any thrown exceptions.
         */
        getResponse: function getResponse(timeout, callback) {
            var self = this;
            this._responseQueue.poll(timeout, {
                result: function(response) {
                    InterruptibleExecutor(callback, function() {
                        // If we received a response then stick it back onto the
                        // queue for the next requestor.
                        if (response)
                            this._responseQueue.add(response);
                        return response;
                    }, self);
                },
                timeout: function() {
                    InterruptibleExecutor(callback, function() {
                        this._response = { isTimeout: true };
                        this._responseQueue.add(this._response);
                        this.abort();
                        callback.timeout();
                    }, self);
                },
                error: function(e) {
                    InterruptibleExecutor(callback, function() {
                        this._response = { isError: true };
                        this._responseQueue.add(this._response);
                        throw e;
                    }, self);
                }
            });
        },

        /** @inheritDoc */
        abort: function abort() {
            if (this._abortToken)
                this._abortToken.abort();
        },

        /** @inheritDoc */
        close: function close(timeout, callback) {
            var self = this;
            InterruptibleExecutor(callback, function() {
                if (this._response)
                    return true;

                var data = this._buffer.toByteArray();
                if (data.length > 0) {
                    var request = {
                        body: data
                    };

                    this._abortToken = this._httpLocation.getResponse(request, this._timeout, {
                        result: function (response) {
                            self._response = { response: response };
                            self._responseQueue.add(self._response);
                        },
                        timeout: function () {
                            self._response = { isTimeout: true };
                            self._responseQueue.add(self._response);
                        },
                        error: function (e) {
                            self._response = { isError: true, error: e };
                            self._responseQueue.add(self._response);
                        }
                    });
                }

                return true;
            }, this);
        },

        /** @inheritDoc */
        write: function write(data, off, len, timeout, callback) {
            InterruptibleExecutor(callback, function() {
                if (this._response)
                    throw new MslIoException("HttpOutputStream already closed.");

                this._buffer.write(data, off, len, timeout, callback);
            }, this);
        },

        /** @inheritDoc */
        flush: function flush(timeout, callback) {
            InterruptibleExecutor(callback, function() {
                if (this._response)
                    return true;

                this._buffer.flush(timeout, callback);
            }, this);
        },
    });

    /**
     * An HTTP input stream buffers data received from an HTTP output stream
     * for later consumption.
     */
    var HttpInputStream = InputStream.extend({
        /**
         * Create a new HTTP input stream that is linked to the provided HTTP
         * output stream.
         *
         * @param {HttpOutputStream} out the linked HTTP output stream.
         */
        init: function init(out) {
            // The properties.
            var props = {
                _out: { value: out, writable: false, enumerable: false, configurable: false },
                _buffer: { value: undefined, writable: true, enumerable: false, configurable: false },
                _exception: { value: undefined, writable: true, enumerable: false, configurable: false },
                _timedout: { value: false, writable: true, enumerable: false, configurable: false },
                _aborted: { value: false, writable: true, enumerable: false, configurable: false },
                _json: { value: undefined, writable: true, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        abort: function abort() {
            this._out.abort();
        },

        /** @inheritDoc */
        close: function close() {
            if (this._buffer)
                this._buffer.close();
        },

        /** @inheritDoc */
        mark: function mark() {
            if (!this._buffer)
                this._buffer.mark();
        },

        /** @inheritDoc */
        reset: function reset() {
            if (this._buffer)
                this._buffer.reset();
        },

        /** @inheritDoc */
        markSupported: function markSupported() {
            if (this._buffer)
                return this._buffer.markSupported();
        },

        /** @inheritDoc */
        read: function read(len, timeout, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // Throw any HTTP exception.
                if (this._exception)
                    throw this._exception;

                // Notify of timeouts.
                if (this._timedout) {
                    callback.timeout();
                    return;
                }

                // If aborted return the empty array.
                if (this._aborted)
                    return new Uint8Array(0);

                // If we don't have the buffer then get it.
                if (!this._buffer) {
                    this._out.close(timeout, {
                        result: function(success) { processResponse(success); },
                        timeout: function() { callback.timeout(); },
                        error: function(e) { callback.error(e); }
                    });
                }

                // Otherwise read from it.
                else {
                    this._buffer.read(len, timeout, callback);
                }
            }, self);

            function processResponse(closed) {
                InterruptibleExecutor(callback, function() {
                    // If aborted return the empty array.
                    if (!closed) return new Uint8Array(0);

                    // Otherwise grab the response.
                    this._out.getResponse(timeout, {
                        result: function(result) {
                            InterruptibleExecutor(callback, function() {
                                var content;

                                if (result.isTimeout) {
                                    this._timedout = true;
                                    callback.timeout();
                                    return;
                                }

                                // Handle errors.
                                if (result.isError) {
                                    this._exception = result.error || new MslIoException("Unknown HTTP exception.");
                                    throw this._exception;
                                }

                                if (!result.response) {
                                    this._exception = new MslIoException("Missing HTTP response.");
                                    throw this._exception;
                                }


                                // this allows the stream to return already-parsed JSON
                                if (result.response.json !== undefined) {
                                    this._json = result.response.json;
                                    this.getJSON = function () { return self._json };
                                }

                                content = result.response.content || utf8$getBytes(typeof result.response.body === 'string' ? result.response.body : JSON.stringify(this._json));
                                this._buffer = new ByteArrayInputStream(content);
                                this._buffer.read(len, timeout, callback);
                            }, self);
                        },
                        timeout: function() { callback.timeout(); },
                        error: function(e) { callback.error(e); }
                    });
                }, self);
            }
        },
    });

    Url = util.Class.create({
        /**
         * Create a new URL that points at the provided location.
         *
         * @param {IHttpLocation} httpEndpoint the target location.
         * @param {number=} timeout optional connect/read/write timeout in
         *        milliseconds. The default is defined by the http client
         *        configuration.
         */
        init: function init(httpLocation, timeout) {

            // The properties.
            var props = {
                _httpLocation: { value: httpLocation, writable: false, enumerable: false, configurable: false },
                _timeout: { value: timeout, writable: true, enumerable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /**
         * Set the timeout.
         *
         * @param {number} timeout connect/read/write timeout in milliseconds.
         */
        setTimeout: function setTimeout(timeout) {
            this._timeout = timeout;
        },

        /**
         * Open a new connection to the target location.
         *
         * @return {{input: InputStream, output: OutputStream}} the input and
         *         output streams.
         */
        openConnection: function openConnection() {
            // The output stream will send the data either when it is closed or
            // when the input stream is read from.
            var output = new HttpOutputStream(this._httpLocation, this._timeout);

            // Buffer the input data after it is received to provide it when
            // requested from the input stream.
            var input = new HttpInputStream(output);

            return {input: input, output: output};
        },
    });
})();



// -- javascript/io/UrlInterceptor.js
/**
 * Copyright (c) 2014 Netflix, Inc.  All rights reserved.
 */

var UrlInterceptor;

/**
 * <p>A URL interceptor is designed to intercept a request created by MSL
 * control by mimicking the functionality of the Url class. Instead of it
 * actually sending out the request over the wire it caches it and for the
 * client to extact</p>
 */
(function () {

    /**
     * Class that MSL control will use to write the request to.
     * This class will capture the actual request and expose a
     * method to return the captured request. It mimics the 
     * Url::HttpOutputStream class in the MSL library.
     */
    var HttpOutputStream = OutputStream.extend({
 
        init: function init( ) {
            // The properties.
            var props = {
                _buffer: { value: new Uint8Array(), writable: true, enumerable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /**
         * Set the timeout on the HTTP request. 
         * 
         * We don't send an actual request so we have no need for a timeout.
         * This method doesn't do anything.
         */
        setTimeout: function () {
            // Nothing to do here
        },

        /**
         * Return the response. 
         *
         * We will not send an HTTP request so we won't have a response so 
         * this method just passes a null back for the response.
         *
         * @param {number} timeout response timeout in milliseconds or -1 for
         *        no timeout.
         * @param {{result: function({success: boolean, content: Uint8Array, errorHttpCode: number, errorSubCode: number}),
         *         timeout: function(), error: function(Error)}}
         *        callback the callback will receive the HTTP response or
         *        undefined if the HTTP transaction was aborted, notified of
         *        timeout or any thrown exceptions.
         */
        getResponse: function (timeout, callback) {
            callback.result({ success: false, content: null, errorHttpCode:undefined, errorSubCode: undefined });
        },

        /**
         * Abort any outstanding operations. 
         * 
         * We will not send any HTTP requests so we won't have have anything to abort.
         */
        abort: function () {
            // Nothing to do here
        },

        /**
         * Closes this output stream and releases any resources associated with the
         * stream.
         *
         * There are no resource to release so this method will just return true.
         *
         * @param {number} timeout write timeout in milliseconds. Ignored as there
         *        is nothing to close.
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback that will always receive true .
         */
        close: function (timeout, callback) {
            callback.result(true);
        },

        /**
         * Writes the specified portion of the byte array to the output stream.
         *
         * This call will cache the data into a byte array for later use.
         *
         * @param {Uint8Array} data the data to write.
         * @param {number} off offset into the data.
         * @param {number} len number of bytes to write.
         * @param {number} timeout write timeout in milliseconds.
         * @param {{result: function(number), timeout: function(number), error: function(Error)}}
         *        callback the callback that will receive the number of bytes
         *        written which will be less than the length if aborted, be
         *        notified of a timeout, or any thrown exceptions.
         * @throws IOException if there is an error writing the data or the stream
         *         is closed.
         * @throws RangeError if the offset is negative, the length is negative, or
         *         the offset plus length exceeds the data length.
         */
        write: function (data, off, len, timeout, callback) {
            try {
                if (off < 0) {
                    throw new RangeError("Offset cannot be negative.");
                }
                if (len < 0) {
                    throw new RangeError("Length cannot be negative.");
                }
                if (off + len > data.length) {
                    throw new RangeError("Offset plus length cannot be greater than the array length.");
                }

                var segment = data.subarray(off, len);

                var newResult = new Uint8Array(this._buffer.length + segment.length);
                newResult.set(this._buffer);
                newResult.set(segment, this._buffer.length);
                this._buffer = newResult;
                callback.result(segment.length);
            } catch (e) {
                callback.error(e);
            }
        },

        /**
         * Flushes the output stream so any buffered data is written out.
         *
         * We son't buffer any data so this method will return true
         *
         * @param {number} timeout write timeout in milliseconds or -1 for no
         *        timeout. Ignored as there is nothing buffered.
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback that will receive true upon completion.
         */
        flush: function (timeout, callback) {
            callback.result(true);
        },

        /**
         * Returns the HTTP request buffered from the write operations
         */
        request: function () {
            return this._buffer;
        }
    });

    /**
     * Class that MSL control will use to read the response from.
     * We have no need for reading the response at this time since
     * it can be done asynchronously and we must be able to read it
     * synchronously. It is just a shell with the same interface as
     * the Url::HttpIntputStream class in the MSL library.
     */
    var HttpInputStream = InputStream.extend({

        /**
         * Create a new HTTP input stream.
         *
         * @param {HttpOutputStream} out the linked HTTP output stream.
         */
        init: function init( ) {

        },
        
        /**
            * Abort any outstanding operations. 
            * 
            * We will not send any HTTP requests so we won't have have anything to abort.
            */
        abort: function () {
            // Nothing to do here
        },

        /**
         * Closes this output stream and releases any resources associated with the
         * stream.
         *
         * There are no resource to release so this method will just return true.
         *
         */
        close: function () {
            // Nothing to do here
        },

        /**
         * Marks the current position in this input stream. A subsequent call to
         * the reset method repositions this stream at the last marked position so
         * that subsequent reads re-read the same bytes.
         * 
         * There is no data to mark so this method is noop
         *
         * @see #reset()
         */
        mark: function () {
            // Nothing to do here
        },

        /**
         * Repositions this stream to the position at the time the mark method was
         * last called on this input stream.
         * 
         * There is no data to reset so this method is noop
         *
         * @see #mark()
         */
        reset: function () {
            // Nothing to do here
        },

        /**
         * Gets whether the stream supports mark and reset operations.
         * 
         * There is no data to reset so this method is noop
         *
         * @return {boolean} undefined.
         * @see #mark(), #reset()
         */
        markSupported: function () {
            // Nothing to do here
        },

        /**
        * Returns the requested number of bytes from the input stream. If -1
        * is specified for the length then this function returns any bytes
        * that are available but at least one unless the timeout is hit. If 0 is
        * specified for the length then zero bytes are returned.
        *
        * If fewer bytes than requested are available then all available
        * bytes are returned. If zero bytes are available the method
        * blocks until at least one bytes is available or the timeout is hit. If
        * the timeout is hit then whatever bytes that have been read will be
        * returned.
        *
        * If there are no more bytes available (i.e. end of stream is hit)
        * then null is returned.
        *
        * If aborted whatever bytes that have been read will be returned.
        *
        * There is no data to read so this method will always return an array 
        * of 16 bytes so MslControl will not throw an exception on a null, 
        * undefined or empty byte array
        *
        * @param {number} len the number of characters to read.
        * @param {number} timeout read timeout in milliseconds or -1 for no
        *        timeout.
        * @param {{result: function(Uint8Array), timeout: function(Uint8Array), error: function(Error)}}
        *        callback the callback that will receive the bytes or null, be
        *        notified of timeouts, or any thrown exceptions.
        * @throws IOException if there is an error reading the data or the stream
        *         is closed.
        */
        read: function (len, timeout, callback) {
            callback.result(new Uint8Array(16));
        }
    });

    UrlInterceptor = util.Class.create({
        /**
         * Create a new URL that points at the provided location.
         *
         * @param {IHttpLocation} httpEndpoint the target location.
         * @param {number=} timeout optional connect/read/write timeout in
         *        milliseconds. The default is defined by the http client
         *        configuration.
         */
        init: function init( ) {
            // The properties.
            var props = {
                output: { value: new HttpOutputStream(), writable: false, enumerable: false, configurable: false },
                input: { value: new HttpInputStream(), writable: true, enumerable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },


        /**
         * Set the timeout.
         *
         * We have no need for a timeout so we don't do anything for this
         * method.
         */
        setTimeout: function () {
            // Nothing to do here
        },

        /**
         * Open a new connection to the target location.
         * 
         * @return {{input: InputStream, output: OutputStream}} the input and
         *         output streams.
         */
        openConnection: function () {
            return {
                input: this.input,
                output: this.output
            };
        },

        /**
         * Returns the HTTP request created by MslControl request operation.
         *
         * @return {string} HTTP request.
         */
        getRequest: function () {
            return utf8$getString(this.output.request());
        }

    });
})();



// -- javascript/io/inputStreamToJSON.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 *
 * Creates a JSON array from an InputStream as defined in the MSL code
 */
var inputStreamToJSON = function (is, timeout, cbObj) {
    simpleReadWithReset(is, timeout, function (err, data) {
        if (err) {
            cbObj.error(err);
        } else if (data) {
            if (is.getJSON !== undefined && typeof is.getJSON === "function") {
                cbObj.result(is.getJSON());
            } else {
                cbObj.result(parse(data));
            }
        } else {
            // we've reached the end of the stream
            cbObj.result(null);
        }
    });

    // reset not currently working as mark/reset is not currently working
    // so this function actually mutates the input stream unfortunately
    function simpleReadWithReset(is, timeout, next) {
        //is.mark();
        is.read(-1, timeout, {
            result: function (data) {
                //is.reset();

                // On end of stream return null for the parser.
                if (!data || !data.length) {
                    next(null, null);
                } else {
                    next(null, data);
                }
            },
            timeout: function () {
                cbObj.timeout();
            },
            error: function (e) {
                next(e, null);
            }
        });
    }

    // parse the raw data
    function parse(data) {
        var parser = new ClarinetParser(textEncoding$getString(data, "utf-8")),
            json = [],
            value;

        value = parser.nextValue();

        while(value !== undefined) {
            json.push(value);
            value = parser.nextValue();
        }

        return json;
    }
};



// -- javascript/keyx/KeyExchangeScheme.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Key exchange schemes.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @enum {string}
 */
var KeyExchangeScheme = {
    /** Symmetric key wrapped. */
    SYMMETRIC_WRAPPED: "SYMMETRIC_WRAPPED",
    /** Asymmetric key wrapped. */
    ASYMMETRIC_WRAPPED: "ASYMMETRIC_WRAPPED",
    /** Diffie-Hellman exchange (Netflix SHA-384 key derivation). */
    DIFFIE_HELLMAN: "DIFFIE_HELLMAN",
    /** JSON web encryption ladder exchange. */
    JWE_LADDER: "JWE_LADDER",
    /** JSON web key ladder exchange. */
    JWK_LADDER: "JWK_LADDER",
    /** Authenticated Diffie-Hellman exchange (Netflix HMAC-SHA-384 key derivation). */
    AUTHENTICATED_DH: "AUTHENTICATED_DH",
};
Object.freeze(KeyExchangeScheme);



// -- javascript/keyx/KeyRequestData.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Key request data contains all the data needed to facilitate a exchange of
 * session keys with the requesting entity.</p>
 *
 * <p>Specific key exchange mechanisms should define their own key request data
 * types.</p>
 *
 * <p>Key request data is represented as
 * {@code
 * keyrequestdata = {
 *   "#mandatory" : [ "scheme", "keydata" ],
 *   "scheme" : "string",
 *   "keydata" : object
 * }} where:
 * <ul>
 * <li>{@code scheme} is the key exchange scheme</li>
 * <li>{@code keydata} is the scheme-specific key data</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var KeyRequestData;
var KeyRequestData$parse;

(function() {
    /**
     * JSON key key exchange scheme.
     * @const
     * @type {string}
     */
    var KEY_SCHEME = "scheme";
    /**
     * JSON key key request data.
     * @const
     * @type {string}
     */
    var KEY_KEYDATA = "keydata";

    KeyRequestData = util.Class.create({
        /**
         * Create a new key request data object with the specified key exchange
         * scheme.
         *
         * @param {KeyExchangeScheme} scheme the key exchange scheme.
         */
        init: function init(scheme) {
            // The properties.
            var props = {
                keyExchangeScheme: { value: scheme, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return {object} the key data JSON representation.
         * @throws JSONException if there was an error constructing the JSON
         *         representation.
         */
        getKeydata: function() {},

        /** @inheritDoc */
        toJSON: function toJSON() {
            var result = {};
            result[KEY_SCHEME] = this.keyExchangeScheme;
            result[KEY_KEYDATA] = this.getKeydata();
            return result;
        },

        /**
         * @param {?} that the reference object with which to compare.
         * @return {boolean} true if the other object is a key request data
         *         with the same scheme.
         * @see #uniqueKey()
         */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof KeyRequestData)) return false;
            return this.keyExchangeScheme == that.keyExchangeScheme;
        },

        /**
         * @return {string} a string that uniquely identifies this key request
         *         data.
         * @see #equals(that)
         */
        uniqueKey: function uniqueKey() {
            return this.keyExchangeScheme;
        },
    });

    /**
     * Construct a new key request data instance of the correct type from the
     * provided JSON object.
     *
     * @param {MslContext} ctx MSL context.
     * @param {Object} keyRequestDataJO the JSON object.
     * @param {{result: function(KeyRequestData), error: function(Error)}}
     *        callback the callback will receive the key request data concrete
     *        instance or any thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException if there is an error verifying the key
     *         request data.
     * @throws MslEntityAuthException if the entity authentication data could
     *         not be created.
     * @throws MslKeyExchangeException if unable to create the key request
     *         data.
     */
    KeyRequestData$parse = function KeyRequestData$parse(ctx, keyRequestDataJO, callback) {
        AsyncExecutor(callback, function() {
            // Pull the key data.
            var scheme = keyRequestDataJO[KEY_SCHEME];
            var keyDataJo = keyRequestDataJO[KEY_KEYDATA];

            // Verify key data.
            if (!scheme || !keyDataJo || typeof keyDataJo !== 'object')
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "keyrequestdata " + JSON.stringify(keyRequestDataJO));

            // Verify scheme.
            if (!KeyExchangeScheme[scheme])
                throw new MslKeyExchangeException(MslError.UNIDENTIFIED_KEYX_SCHEME, scheme);

            // Construct an instance of the concrete subclass.
            var keyFactory = ctx.getKeyExchangeFactory(scheme);
            if (!keyFactory)
                throw new MslKeyExchangeException(MslError.KEYX_FACTORY_NOT_FOUND, scheme);
            keyFactory.createRequestData(ctx, keyDataJo, callback);
        });
    };
})();



// -- javascript/keyx/KeyResponseData.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Key response data contains all the data needed to facilitate a exchange of
 * session keys from the responseor.</p>
 *
 * <p>Specific key exchange mechanisms should define their own key response data
 * types.</p>
 *
 * <p>Key response data is represented as
 * {@code
 * keyresponsedata = {
 *   "#mandatory" : [ "mastertoken", "scheme", "keydata" ],
 *   "mastertoken" : mastertoken,
 *   "scheme" : "string",
 *   "keydata" : object
 * }} where:
 * <ul>
 * <li>{@code mastertoken} is the master token associated with the session keys</li>
 * <li>{@code scheme} is the key exchange scheme</li>
 * <li>{@code keydata} is the scheme-specific key data</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var KeyResponseData;
var KeyResponseData$parse;

(function() {
    /**
     * JSON key master token.
     * @const
     * @type {string}
     */
    var KEY_MASTER_TOKEN = "mastertoken";
    /**
     * JSON key key exchange scheme.
     * @const
     * @type {string}
     */
    var KEY_SCHEME = "scheme";
    /**
     * JSON key key data.
     * @const
     * @type {string}
     */
    var KEY_KEYDATA = "keydata";

    KeyResponseData = util.Class.create({
        /**
         * Create a new key response data object with the specified key exchange
         * scheme and associated master token.
         *
         * @param {MasterToken} masterToken the master token.
         * @param {KeyExchangeScheme} scheme the key exchange scheme.
         */
        init: function init(masterToken, scheme) {
            // The properties.
            var props = {
                masterToken: { value: masterToken, writable: false, configurable: false },
                keyExchangeScheme: { value: scheme, wrtiable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return {object} the key data JSON representation.
         * @throws JSONException if there was an error constructing the JSON
         *         representation.
         */
        getKeydata: function() {},

        /** @inheritDoc */
        toJSON: function toJSON() {
            var result = {};
            result[KEY_MASTER_TOKEN] = this.masterToken;
            result[KEY_SCHEME] = this.keyExchangeScheme;
            result[KEY_KEYDATA] = this.getKeydata();
            return result;
        },

        /**
         * @param {?} that the reference object with which to compare.
         * @return {boolean} true if the other object is a key request data
         *         with the same master token and scheme.
         * @see #uniqueKey()
         */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof KeyResponseData)) return false;
            return this.masterToken.equals(that.masterToken) && this.keyExchangeScheme == that.keyExchangeScheme;
        },

        /**
         * @return {string} a string that uniquely identifies this key response
         *         data.
         * @see #equals(that)
         */
        uniqueKey: function uniqueKey() {
            return this.masterToken.uniqueKey() + ':' + this.keyExchangeScheme;
        },
    });

    /**
     * Construct a new key response data instance of the correct type from the
     * provided JSON object.
     *
     * @param {MslContext} ctx MSL context.
     * @param {Object} keyResponseDataJO the JSON object.
     * @param {{result: function(KeyResponseData), error: function(Error)}}
     *        callback the callback that will receive the key response data
     *        concrete instances or any thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslKeyExchangeException if unable to create the key response
     *         data.
     * @throws MslCryptoException if there is an error verifying the they key
     *         response data.
     * @throws MslException if the key response master token expiration
     *         timestamp occurs before the renewal window.
     */
    KeyResponseData$parse = function KeyResponseData$parse(ctx, keyResponseDataJO, callback) {
        AsyncExecutor(callback, function() {
            // Pull the key data.
            var masterTokenJo = keyResponseDataJO[KEY_MASTER_TOKEN];
            var scheme = keyResponseDataJO[KEY_SCHEME];
            var keyDataJo = keyResponseDataJO[KEY_KEYDATA];

            // Verify key data.
            if (!scheme ||
                !masterTokenJo || typeof masterTokenJo !== 'object' ||
                !keyDataJo || typeof keyDataJo !== 'object')
            {
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "keyresponsedata " + JSON.stringify(keyResponseDataJO));
            }

            // Verify scheme.
            if (!KeyExchangeScheme[scheme])
                throw new MslKeyExchangeException(MslError.UNIDENTIFIED_KEYX_SCHEME, scheme);

            // Rebuild master token.
            MasterToken$parse(ctx, masterTokenJo, {
                result: function(masterToken) {
                    AsyncExecutor(callback, function() {
                        // Construct an instance of the concrete subclass.
                        var factory = ctx.getKeyExchangeFactory(scheme);
                        if (!factory)
                            throw new MslKeyExchangeException(MslError.KEYX_FACTORY_NOT_FOUND, scheme);
                        return factory.createResponseData(ctx, masterToken, keyDataJo);
                    });
                },
                error: function(err) { callback.error(err); }
            });
        });
    };
})();



// -- javascript/keyx/KeyExchangeFactory.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * A key exchange factory creates key request and response data instances for
 * a specific key exchange scheme.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var KeyExchangeFactory;

(function() {
    /**
     * The key exchange data struct contains key response data and a crypto
     * context for the exchanged keys.
     */
    var KeyExchangeData = util.Class.create({
        /**
         * Create a new key key exhange data struct with the provided key
         * response data, master token, and crypto context.
         *
         * @param {KeyResponseData} keyResponseData the key response data.
         * @param {ICryptoContext} cryptoContext the crypto context.
         */
        init: function init(keyResponseData, cryptoContext) {
            // The properties.
            var props = {
                keyResponseData: { value: keyResponseData, writable: false, configurable: false },
                cryptoContext: { value: cryptoContext, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },
    });

    KeyExchangeFactory = util.Class.create({
        /**
         * Create a new key exchange factory for the specified scheme.
         *
         * @param {KeyExchangeScheme} scheme the key exchange scheme.
         */
        init: function init(scheme) {
            var props = {
                scheme: { value: scheme, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /**
         * Construct a new key request data instance from the provided JSON.
         *
         * @param {MslContext} ctx MSL context.
         * @param {Object} keyRequestJO the JSON object.
         * @param {{result: function(KeyRequestData), error: function(Error)}}
         *        callback the callback will receive the key request data or
         *        any thrown exceptions.
         * @throws MslEncodingException if there is an error parsing the JSON.
         * @throws MslKeyExchangeException if there is an error creating the key
         *         request data.
         * @throws MslCryptoException if the keying material cannot be created.
         */
        createRequestData: function(ctx, keyRequestJO, callback) {},

        /**
         * Construct a new key response data instance from the provided JSON.
         *
         * @param {MslContext} ctx MSL context.
         * @param {MasterToken} masterToken the master token for the new key response data.
         * @param {Object} keyDataJO the JSON object.
         * @return {KeyResponseData} the key response data.
         * @throws MslEncodingException if there is an error parsing the JSON.
         * @throws MslKeyExchangeException if there is an error creating the key
         *         response data.
         */
        createResponseData: function(ctx, masterToken, keyDataJO) {},

        /**
         * <p>Generate a new key response data instance and crypto context in
         * response to the provided key request data. The key request data will be
         * from the the remote entity.</p>
         * 
         * <p>If a master token is provided then it should be renewed by
         * incrementing its sequence number but maintaining its serial number
         * by using the MSL context's token factory.</p>
         *
         * @param {MslContext} ctx MSL context.
         * @param {KeyRequestData} keyRequestData the key request data.
         * @param {MasterToken|string} entityToken the master token to renew or
         *        the entity identity.
         * @param {{result: function(KeyExchangeData), error: function(Error)}}
         *        callback the callback functions that will receive the key
         *        response data and crypto context or any thrown exception.
         * @throws MslKeyExchangeException if there is an error with the key
         *         request data or the key response data cannot be created.
         * @throws MslCryptoException if the crypto context cannot be created.
         * @throws MslEncodingException if there is an error parsing or encoding
         *         the JSON.
         * @throws MslMasterTokenException if the master token is not trusted and
         *         needs to be.
         * @throws MslEntityAuthException if there is a problem with the master
         *         token identity.
         */
        generateResponse: function(ctx, keyRequestData, entityToken, callback) {},

        /**
         * Create a crypto context from the provided key request data and key
         * response data. The key request data will be from the local entity and
         * the key response data from the remote entity.
         *
         * @param {MslContext} ctx MSL context.
         * @param {KeyRequestData} keyRequestData the key request data.
         * @param {KeyResponseData} keyResponseData the key response data.
         * @param {MasterToken} masterToken the current master token (not the one inside the key
         *        response data). May be null.
         * @param {{result: function(ICryptoContext), error: function(Error)}}
         *        callback the callback functions that will receive the crypto
         *        context or any thrown exception.
         * @throws MslKeyExchangeException if there is an error with the key
         *         request data or key response data.
         * @throws MslCryptoException if the crypto context cannot be created.
         * @throws MslEncodingException if there is an error parsing the JSON.
         * @throws MslMasterTokenException if the master token is not trusted and
         *         needs to be.
         * @throws MslEntityAuthException if there is a problem with the master
         *         token identity.
         */
        getCryptoContext: function(ctx, keyRequestData, keyResponseData, masterToken, callback) {},

        /**
         * Generate a new pair of AES-128 CBC and HMAC-SHA256 encryption and HMAC
         * session keys.
         *
         * @param {MslContext} ctx MSL context.
         * @param {{result: function({encryptionKey: CipherKey, hmacKey: CipherKey}), error: function(Error)}}
         *        callback the callback will receive the new session keys
         *        (encryption key, HMAC key) or any thrown exceptions.
         * @throws MslCryptoException if there is an error creating the session
         *         keys.
         */
        generateSessionKeys: function generateSessionKeys(ctx, callback) {
            AsyncExecutor(callback, function() {
                var encryptionBytes = new Uint8Array(16);
                var hmacBytes = new Uint8Array(32);
                ctx.getRandom().nextBytes(encryptionBytes);
                ctx.getRandom().nextBytes(hmacBytes);
                CipherKey$import(encryptionBytes, WebCryptoAlgorithm.AES_CBC, WebCryptoUsage.ENCRYPT_DECRYPT, {
                    result: function(encryptionKey) {
                        CipherKey$import(hmacBytes, WebCryptoAlgorithm.HMAC_SHA256, WebCryptoUsage.SIGN_VERIFY, {
                            result: function(hmacKey) {
                                callback.result({encryptionKey: encryptionKey, hmacKey: hmacKey});
                            },
                            error: function(e) {
                                callback.error(new MslCryptoException(MslError.SESSION_KEY_CREATION_FAILURE, null, e));
                            }
                        });
                    },
                    error: function(e) {
                        callback.error(new MslCryptoException(MslError.SESSION_KEY_CREATION_FAILURE, null, e));
                    }
                });
            });
        },

        /**
         * Import a new pair of AES-128 CBC and HMAC-SHA256 encryption and HMAC
         * session keys.
         *
         * @param {Uint8Array} encryptionBytes AES-128 raw key data.
         * @param {Uint8Array} hmacBytes HMAC-SHA256 raw key data.
         * @param {{result: function({encryptionKey: CipherKey, hmacKey: CipherKey}), error: function(Error)}}
         *        callback the callback that will receive the imported session
         *        keys or any thrown exceptions.
         * @throws MslCryptoException if the key data is invalid.
         */
        importSessionKeys: function importSessionKeys(encryptionBytes, hmacBytes, callback) {
            CipherKey$import(encryptionBytes, WebCryptoAlgorithm.AES_CBC, WebCryptoUsage.ENCRYPT_DECRYPT, {
                result: function(encryptionKey) {
                    CipherKey$import(hmacBytes, WebCryptoAlgorithm.HMAC_SHA256, WebCryptoUsage.SIGN_VERIFY, {
                        result: function(hmacKey) {
                            callback.result({ encryptionKey: encryptionKey, hmacKey: hmacKey });
                        },
                        error: function(e) { callback.error(e); }
                    });
                },
                error: function(e) { callback.error(e); }
            });
        },
    });

    // Expose KeyExchangeData.
    KeyExchangeFactory.KeyExchangeData = KeyExchangeData;
})();



// -- javascript/keyx/NetflixJsonWebEncryptionLadderExchange.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>JSON Web Encryption ladder key exchange.</p>
 *
 * <p>The key ladder consists of a symmetric wrapping key used to protect the
 * session keys. The wrapping key is only permitted to wrap and unwrap data. It
 * cannot be used for encrypt/decrypt or sign/verify operations.</p>
 *
 * <p>The wrapping key is protected by wrapping it with a known common key
 * (e.g. preshared keys), a provided public key (e.g. client-generated RSA key
 * pair), or the previously used wrapping key. The previous wrapping key must
 * be provided by the requesting entity in the form found in the response
 * data.</p>
 *
 * <p>The wrapping key is always an AES-128 key for AES key wrap/unwrap.</p>
 *
 * <p>This key exchange scheme does not provide perfect forward secrecy and
 * should only be used if necessary to satisfy other security requirements.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var NetflixJsonWebEncryptionLadderExchange;
var NetflixJsonWebEncryptionLadderExchange$Mechanism;
var NetflixJsonWebEncryptionLadderExchange$RequestData;
var NetflixJsonWebEncryptionLadderExchange$RequestData$parse;
var NetflixJsonWebEncryptionLadderExchange$ResponseData;
var NetflixJsonWebEncryptionLadderExchange$ResponseData$parse;

(function() {
    "use strict";

    /**
     * Wrapping key wrap mechanism.
     * @enum {string}
     */
    var Mechanism = NetflixJsonWebEncryptionLadderExchange$Mechanism = {
        /** Wrapping key wrapped by PSK (AES-128 key wrap). */
        PSK: "PSK",
        /** Wrapping key wrapped by MGK (AES-128 key wrap). */
        MGK: "MGK",
        /** Wrapping key wrapped by previous wrapping key (AES-128 key wrap). */
        WRAP: "WRAP",
    };

    /**
     * JSON key wrap key wrapping mechanism.
     * @const
     * @type {string}
     */
    var KEY_MECHANISM = "mechanism";
    /**
     * JSON key wrap data.
     * @const
     * @type {string}
     */
    var KEY_WRAPDATA = "wrapdata";
    /**
     * JSON key wrapping key.
     * @const
     * @type {string}
     */
    var KEY_WRAP_KEY = "wrapkey";
    /**
     * JSON key encrypted encryption key.
     * @const
     * @type {string}
     */
    var KEY_ENCRYPTION_KEY = "encryptionkey";
    /**
     * JSON key encrypted HMAC key.
     * @const
     * @type {string}
     */
    var KEY_HMAC_KEY = "hmackey";

    /**
     * <p>JSON Web Encryption ladder key request data.</p>
     *
     * <p>
     * {@code {
     *   "#mandatory" : [ "mechanism" ],
     *   "mechanism" : "enum(PSK|MGK|WRAP)",
     *   "wrapdata" : "base64",
     * }} where:
     * <ul>
     * <li>{@code mechanism} identifies the mechanism for wrapping and unwrapping the wrapping key</li>
     * <li>{@code wrapdata} the Base64-encoded wrapping data for the previous wrapping key</li>
     * </ul></p>
     */
    var RequestData = NetflixJsonWebEncryptionLadderExchange$RequestData = KeyRequestData.extend({
        /**
         * <p>Create a new JSON Web Encryption ladder key request data instance
         * with the specified mechanism and wrapping key data.</p>
         *
         * <p>Arguments not applicable to the specified mechanism are
         * ignored.</p>
         *
         * @param {Mechanism} mechanism the wrap key wrapping mechanism.
         * @param {?Uint8Array} wrapdata the wrap data for reconstructing the previous
         *        wrapping key. May be null if the mechanism does not use the
         *        previous wrapping key.
         * @throws MslInternalException if the mechanism requires wrap data and
         *         the required argument is null.
         */
        init: function init(mechanism, wrapdata) {
            init.base.call(this, KeyExchangeScheme.JWE_LADDER);

            switch (mechanism) {
                case Mechanism.WRAP:
                    if (!wrapdata)
                        throw new MslInternalException("Previous wrapping key based key exchange requires the previous wrapping key data and ID.");
                    break;
                default:
                    wrapdata = null;
                    break;
            }

            // The properties.
            var props = {
                mechanism: { value: mechanism, writable: false, configurable: false },
                wrapdata: { value: wrapdata, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getKeydata: function getKeydata() {
            var keydata = {};
            keydata[KEY_MECHANISM] = this.mechanism;
            if (this.wrapdata) keydata[KEY_WRAPDATA] = base64$encode(this.wrapdata);
            return keydata;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (that === this) return true;
            if (!(that instanceof NetflixJsonWebEncryptionLadderExchange$RequestData)) return false;
            return equals.base.call(this, that) &&
                this.mechanism == that.mechanism &&
                Arrays$equal(this.wrapdata, that.wrapdata);
        },

        /** @inheritDoc */
        uniqueKey: function uniqueKey() {
            var key = uniqueKey.base.call(this) + ':' + this.mechanism;
            if (this.wrapdata)
                key += ':' + Arrays$hashCode(this.wrapdata);
            return key;
        },
    });

    /**
     * Create a new JSON Web Encryption ladder key request data instance
     * from the provided JSON object.
     *
     * @param {object} keyRequestJO the JSON object.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException the wrapped key data cannot be verified
     *         or decrypted, or the specified mechanism is not supported.
     * @throws MslKeyExchangeException if the specified mechanism is not
     *         recognized.
     */
    var RequestData$parse = NetflixJsonWebEncryptionLadderExchange$RequestData$parse = function RequestData$parse(keyRequestJO) {
        // Pull key request data.
        var mechanism = keyRequestJO[KEY_MECHANISM];
        var wrapdataB64 = keyRequestJO[KEY_WRAPDATA];

        // Verify key request data.
        if (!mechanism ||
            (mechanism == Mechanism.WRAP && (!wrapdataB64 || typeof wrapdataB64 !== 'string')))
        {
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "keydata " + JSON.stringify(keyRequestJO));
        }

        // Verify mechanism.
        if (!Mechanism[mechanism])
            throw new MslKeyExchangeException(MslError.UNIDENTIFIED_KEYX_MECHANISM, mechanism);

        // Create the request data.
        var wrapdata;
        switch (mechanism) {
            case Mechanism.WRAP:
                try {
                    wrapdata = base64$decode(wrapdataB64);
                } catch (e) {
                    throw new MslKeyExchangeException(MslError.KEYX_WRAPPING_KEY_MISSING, "keydata " + keyRequestJO.toString());
                }
                if (wrapdata == null || wrapdata.length == 0)
                    throw new MslKeyExchangeException(MslError.KEYX_WRAPPING_KEY_MISSING, "keydata " + keyRequestJO.toString());
                break;
            default:
                wrapdata = null;
                break;
        }
        return new RequestData(mechanism, wrapdata);
    };

    /**
     * <p>JSON Web Encryption ladder key response data.</p>
     *
     * <p>
     * {@code {
     *   "#mandatory" : [ "wrapkey", "wrapdata", "encryptionkey", "hmackey" ],
     *   "wrapkey" : "base64",
     *   "wrapdata" : "base64",
     *   "encryptionkey" : "base64",
     *   "hmackey" : "base64",
     * }} where:
     * <ul>
     * <li>{@code wrapkey} the Base64-encoded new wrapping key in JWE format, wrapped by the wrapping key</li>
     * <li>{@code wrapdata} the Base64-encoded wrapping key data for use in subsequent key request data</li>
     * <li>{@code encryptionkey} the Base64-encoded session encryption key in JWE format, wrapped with the new wrapping key</li>
     * <li>{@code hmackey} the Base64-encoded session HMAC key in JWE format, wrapped with the new wrapping key</li>
     * </ul></p>
     */
    var ResponseData = NetflixJsonWebEncryptionLadderExchange$ResponseData = KeyResponseData.extend({
        /**
         * Create a new JSON Web Encryption ladder key response data instance
         * with the provided master token and wrapped keys.
         *
         * @param {MasterToken} masterToken the master token.
         * @param {Uint8Array} wrapKey the wrapped wrap key.
         * @param {Uint8Array} wrapdata the wrap data for reconstructing the wrap key.
         * @param {Uint8Array} encryptionKey the wrap key wrapped encryption key.
         * @param {Uint8Array} hmacKey the wrap key wrapped HMAC key.
         */
        init: function init(masterToken, wrapKey, wrapdata, encryptionKey, hmacKey) {
            init.base.call(this, masterToken, KeyExchangeScheme.JWE_LADDER);

            // The properties.
            var props = {
                wrapKey: { value: wrapKey, writable: false, configurable: false },
                wrapdata: { value: wrapdata, writable: false, configurable: false },
                encryptionKey: { value: encryptionKey, writable: false, configurable: false },
                hmacKey: { value: hmacKey, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getKeydata: function getKeydata() {
            var keydata = {};
            keydata[KEY_WRAP_KEY] = base64$encode(this.wrapKey);
            keydata[KEY_WRAPDATA] = base64$encode(this.wrapdata);
            keydata[KEY_ENCRYPTION_KEY] = base64$encode(this.encryptionKey);
            keydata[KEY_HMAC_KEY] = base64$encode(this.hmacKey);
            return keydata;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof NetflixJsonWebEncryptionLadderExchange$ResponseData)) return false;
            return equals.base.call(this, that) &&
                Arrays$equal(this.wrapKey, that.wrapKey) &&
                Arrays$equal(this.wrapdata, that.wrapdata) &&
                Arrays$equal(this.encryptionKey, that.encryptionKey) &&
                Arrays$equal(this.hmacKey, that.hmacKey);
        },

        /** @inheritDoc */
        uniqueKey: function uniqueKey() {
            var key = uniqueKey.base.call(this) +
                ':' + Arrays$hashCode(this.wrapKey) +
                ':' + Arrays$hashCode(this.wrapdata) +
                ':' + Arrays$hashCode(this.encryptionKey) +
                ':' + Arrays$hashCode(this.hmacKey);
            return key;
        }
    });

    /**
     * Create a new JSON Web Encryption ladder key response data instance
     * with the provided master token from the provided JSON object.
     *
     * @param {MasterToken} masterToken the master token.
     * @param {object} keyDataJO the JSON object.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslKeyExchangeException if the mechanism is not recognized.
     */
    var ResponseData$parse = NetflixJsonWebEncryptionLadderExchange$ResponseData$parse = function NetflixJsonWebEncryptionLadderExchange$ResponseData$parse(masterToken, keyDataJO) {
        // Pull key response data.
        var wrapKeyB64 = keyDataJO[KEY_WRAP_KEY];
        var wrapdataB64 = keyDataJO[KEY_WRAPDATA];
        var encryptionKeyB64 = keyDataJO[KEY_ENCRYPTION_KEY];
        var hmacKeyB64 = keyDataJO[KEY_HMAC_KEY];

        // Verify key response data.
        if (!wrapKeyB64 || typeof wrapKeyB64 !== 'string' ||
            !wrapdataB64 || typeof wrapdataB64 !== 'string' ||
            !encryptionKeyB64 || typeof encryptionKeyB64 !== 'string' ||
            !hmacKeyB64 || typeof hmacKeyB64 !== 'string')
        {
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "keydata " + JSON.stringify(keyDataJO));
        }

        // Decode keys.
        var wrapKey, wrapdata, encryptionKey, hmacKey;
        try {
            wrapKey = base64$decode(wrapKeyB64);
            wrapdata = base64$decode(wrapdataB64);
        } catch (e) {
            throw new MslCryptoException(MslError.INVALID_SYMMETRIC_KEY, "keydata " + JSON.stringify(keyDataJO), e);
        }
        try {
            encryptionKey = base64$decode(encryptionKeyB64);
        } catch (e) {
            throw new MslCryptoException(MslError.INVALID_ENCRYPTION_KEY, "keydata " + JSON.stringify(keyDataJO), e);
        }
        try {
            hmacKey = base64$decode(hmacKeyB64);
        } catch (e) {
            throw new MslCryptoException(MslError.INVALID_HMAC_KEY, "keydata " + JSON.stringify(keyDataJO), e);
        }

        // Return the response data.
        return new ResponseData(masterToken, wrapKey, wrapdata, encryptionKey, hmacKey);
    };

    /**
     * Create the crypto context identified by the mechanism.
     *
     * @param {MslContext} ctx MSL context.
     * @param {Mechanism} mechanism the wrap key wrapping mechanism.
     * @param {Uint8Array} wrapdata the wrap key previous wrapping key data. May be null.
     * @param {string} identity the entity identity.
     * @param {result: function(ICryptoContext), error: function(Error)}
     *        callback the callback that will receive the crypto context or any
     *        thrown exceptions.
     * @throws MslCryptoException if the crypto context cannot be created.
     * @throws MslKeyExchangeException if the mechanism is unsupported.
     * @throws MslEntityAuthException if there is a problem with the entity
     *         identity.
     */
    function createCryptoContext(ctx, mechanism, wrapdata, identity, callback) {
        AsyncExecutor(callback, function() {
            switch (mechanism) {
                // FIXME: For PSK/MGK we need some way to get a JsonWebEncryptionCryptoContext
                // that might run remotely. In other words, some other CryptoContext. Maybe
                // the WrapCryptoContextRepository can be used for that.
                case Mechanism.PSK:
                {
                    var authdata = new PresharedAuthenticationData(identity);
                    var factory = ctx.getEntityAuthenticationFactory(EntityAuthenticationScheme.PSK);
                    if (!factory)
                        throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism);
                    var cryptoContext = factory.getCryptoContext(ctx, authdata);
                    // FIXME: Get a handle to KPE.
                    var kpe = undefined;
                    return new JsonWebEncryptionCryptoContext(ctx, JsonWebEncryptionCryptoContext$Algorithm.A128KW, JsonWebEncryptionCryptoContext$Encryption.A128GCM, kpe);
                }
                case Mechanism.MGK:
                {
                    var authdata = new ModelGroupAuthenticationData(identity);
                    var factory = ctx.getEntityAuthenticationFactory(EntityAuthenticationScheme.MGK);
                    if (!factory)
                        throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism);
                    var cryptoContext = factory.getCryptoContext(ctx, authdata);
                    // FIXME: Get a handle to KDE.
                    var kde = undefined;
                    return new JsonWebEncryptionCryptoContext(ctx, JsonWebEncryptionCryptoContext$Algorithm.A128KW, JsonWebEncryptionCryptoContext$Encryption.A128GCM, kde);
                }
                case Mechanism.WRAP:
                {
                    var cryptoContext = ctx.getMslCryptoContext();
                    cryptoContext.unwrap(wrapdata, WebCryptoAlgorithm.A128KW, WebCryptoUsage.WRAP_UNWRAP, {
                        result: function(wrapKey) {
                            AsyncExecutor(callback, function() {
                                return new JsonWebEncryptionCryptoContext(ctx, JsonWebEncryptionCryptoContext$Algorithm.A128KW, JsonWebEncryptionCryptoContext$Encryption.A128GCM, wrapKey);
                            });
                        },
                        error: callback.error,
                    });
                    return;
                }
                default:
                    throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism);
            }
        });
    }

    NetflixJsonWebEncryptionLadderExchange = KeyExchangeFactory.extend({
        /**
         * Create a new JSON Web Encryption ladder key exchange factory.
         *
         * @param {WrapCryptoContextRepository} repository the wrapping key crypto context repository.
         */
        init: function init(repository) {
            init.base.call(this, KeyExchangeScheme.JWE_LADDER);

            // The properties.
            var props = {
                repository: { value: repository, writable: false, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        createRequestData: function createRequestData(ctx, keyRequestJO, callback) {
            AsyncExecutor(callback, function() {
                return RequestData$parse(keyRequestJO);
            });
        },

        /** @inheritDoc */
        createResponseData: function createResponseData(ctx, masterToken, keyDataJO) {
            return ResponseData$parse(masterToken, keyDataJO);
        },

        /** @inheritDoc */
        generateResponse: function generateResponse(ctx, keyRequestData, entityToken, callback) {
            var self = this;
            var masterToken;

            AsyncExecutor(callback, function() {
                if (!(keyRequestData instanceof RequestData))
                    throw new MslInternalException("Key request data " + JSON.stringify(keyRequestData) + " was not created by this factory.");

                // If the master token was not issued by the local entity then we
                // should not be generating a key response for it.
                var identity = entityToken;
                if (entityToken instanceof MasterToken) {
                    if (!entityToken.isVerified())
                        throw new MslMasterTokenException(MslError.MASTERTOKEN_UNTRUSTED, entityToken);
                    masterToken = entityToken;
                    identity = entityToken.identity;
                }

                // Create random AES-128 wrapping key.
                var wrapBytes = new Uint8Array(16);
                ctx.getRandom().nextBytes(wrapBytes);
                CipherKey$import(wrapBytes, WebCryptoAlgorithm.A128KW, WebCryptoUsage.WRAP_UNWRAP, {
                    result: function(wrapKey) {
                        AsyncExecutor(callback, function() {
                            var mslCryptoContext = ctx.getMslCryptoContext();
                            mslCryptoContext.wrap(wrapKey, {
                                result: function(wrapdata) {
                                    createSessionKeys(identity, wrapKey, wrapdata);
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(masterToken);
                                        throw e;
                                    }, self);
                                }
                            });
                        }, self);
                    },
                    error: function(e) {
                        AsyncExecutor(callback, function() {
                            throw new MslCryptoException(MslError.WRAP_KEY_CREATION_FAILURE, null, e).setEntity(masterToken);
                        }, self);
                    }
                });
            }, self);

            function createSessionKeys(identity, wrapKey, wrapdata) {
                self.generateSessionKeys(ctx, {
                    result: function(sessionKeys) {
                        AsyncExecutor(callback, function() {
                            var encryptionKey = sessionKeys.encryptionKey;
                            var hmacKey = sessionKeys.hmacKey;
                            wrapWrappingKey(identity, wrapKey, wrapdata, encryptionKey, hmacKey);
                        }, self);
                    },
                    error: function(e) {
                        AsyncExecutor(callback, function() {
                            if (e instanceof MslException)
                                e.setEntity(masterToken);
                            throw e;
                        });
                    }
                });
            }

            function wrapWrappingKey(identity, wrapKey, wrapdata, encryptionKey, hmacKey) {
                AsyncExecutor(callback, function() {
                    var request = keyRequestData;

                    // Grab the request data.
                    var mechanism = request.mechanism;
                    var prevWrapdata = request.wrapdata;

                    // Wrap wrapping key using specified wrapping key.
                    createCryptoContext(ctx, mechanism, prevWrapdata, identity, {
                        result: function (wrapKeyCryptoContext) {
                            wrapKeyCryptoContext.wrap(wrapKey, {
                                result: function(wrappedWrapJwk) {
                                    wrapSessionKeys(wrapKey, wrapdata, encryptionKey, hmacKey, wrappedWrapJwk);
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(masterToken);
                                        throw e;
                                    });
                                }
                            });
                        },
                        error: function(e) {
                            AsyncExecutor(callback, function() {
                                if (e instanceof MslException)
                                    e.setEntity(masterToken);
                                throw e;
                            });
                        }
                    });
                }, self);
            }

            function wrapSessionKeys(wrapKey, wrapdata, encryptionKey, hmacKey, wrappedWrapJwk) {
                AsyncExecutor(callback, function() {
                    var wrapCryptoContext = new JsonWebEncryptionCryptoContext(ctx, JsonWebEncryptionCryptoContext$Algorithm.A128KW, JsonWebEncryptionCryptoContext$Encryption.A128GCM, wrapKey);
                    wrapCryptoContext.wrap(encryptionKey, {
                        result: function(wrappedEncryptionJwk) {
                            wrapCryptoContext.wrap(hmacKey, {
                                result: function(wrappedHmacJwk) {
                                    createMasterToken(wrapdata, wrappedWrapJwk, encryptionKey, wrappedEncryptionJwk, hmacKey, wrappedHmacJwk);
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(masterToken);
                                        throw e;
                                    });
                                }
                            });
                        },
                        error: function(e) {
                            AsyncExecutor(callback, function() {
                                if (e instanceof MslException)
                                    e.setEntity(masterToken);
                                throw e;
                            });
                        }
                    });
                }, self);
            }

            function createMasterToken(wrapdata, wrappedWrapJwk, encryptionKey, wrappedEncryptionJwk, hmacKey, wrappedHmacJwk) {
                AsyncExecutor(callback, function() {
                    // Create the master token.
                    var tokenFactory = ctx.getTokenFactory();
                    if (masterToken) {
                        tokenFactory.renewMasterToken(ctx, masterToken, encryptionKey, hmacKey, {
                            result: function(masterToken) {
                                AsyncExecutor(callback, function() {
                                    // Create session crypto context.
                                    var cryptoContext = new SessionCryptoContext(ctx, masterToken);

                                    // Return the key exchange data.
                                    var keyResponseData = new ResponseData(masterToken, wrappedWrapJwk, wrapdata, wrappedEncryptionJwk, wrappedHmacJwk);
                                    return new KeyExchangeFactory.KeyExchangeData(keyResponseData, cryptoContext, callback);
                                }, self);
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException)
                                        e.setEntity(masterToken);
                                    throw e;
                                });
                            }
                        });
                    } else {
                        tokenFactory.createMasterToken(ctx, entityToken, encryptionKey, hmacKey, {
                            result: function(masterToken) {
                                AsyncExecutor(callback, function() {
                                    // Create session crypto context.
                                    var cryptoContext = new SessionCryptoContext(ctx, masterToken);

                                    // Return the key exchange data.
                                    var keyResponseData = new ResponseData(masterToken, wrappedWrapJwk, wrapdata, wrappedEncryptionJwk, wrappedHmacJwk);
                                    return new KeyExchangeFactory.KeyExchangeData(keyResponseData, cryptoContext, callback);
                                }, self);
                            },
                            error: callback.error,
                        });
                    }
                }, self);
            }
        },

        /** @inheritDoc */
        getCryptoContext: function getCryptoContext(ctx, keyRequestData, keyResponseData, masterToken, callback) {
            var self = this;

            AsyncExecutor(callback, function() {
                if (!(keyRequestData instanceof RequestData))
                    throw new MslInternalException("Key request data " + JSON.stringify(keyRequestData) + " was not created by this factory.");
                var request = keyRequestData;
                if (!(keyResponseData instanceof ResponseData))
                    throw new MslInternalException("Key response data " + JSON.stringify(keyResponseData) + " was not created by this factory.");
                var response = keyResponseData;

                // Unwrap new wrapping key.
                var mechanism = request.mechanism;
                var requestWrapdata = request.wrapdata;
                ctx.getEntityAuthenticationData(null, {
                    result: function(entityAuthData) {
                        AsyncExecutor(callback, function() {
                            var identity = entityAuthData.getIdentity();
                            var wrapKeyCryptoContext;
                            switch (mechanism) {
                                case Mechanism.PSK:
                                {
                                    var authdata = new PresharedAuthenticationData(identity);
                                    var factory = ctx.getEntityAuthenticationFactory(EntityAuthenticationScheme.PSK);
                                    if (!factory)
                                        throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism).setEntity(entityAuthData);
                                    var cryptoContext = factory.getCryptoContext(ctx, authdata);
                                    // FIXME: Get a handle to KPE.
                                    var kpe = undefined;
                                    wrapKeyCryptoContext = new JsonWebEncryptionCryptoContext(ctx, JsonWebEncryptionCryptoContext$Algorithm.A128KW, JsonWebEncryptionCryptoContext$Encryption.A128GCM, kpe);
                                    break;
                                }
                                case Mechanism.MGK:
                                {
                                    var authdata = new ModelGroupAuthenticationData(identity);
                                    var factory = ctx.getEntityAuthenticationFactory(EntityAuthenticationScheme.MGK);
                                    if (!factory)
                                        throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism).setEntity(entityAuthData);
                                    var cryptoContext = factory.getCryptoContext(ctx, authdata);
                                    // FIXME: Get a handle to KDE.
                                    var kde = cryptoContext.wrapKey;
                                    wrapKeyCryptoContext = new JsonWebEncryptionCryptoContext(ctx, JsonWebEncryptionCryptoContext$Algorithm.A128KW, JsonWebEncryptionCryptoContext$Encryption.A128GCM, kde);
                                    break;
                                }
                                case Mechanism.WRAP:
                                {
                                    wrapKeyCryptoContext = this.repository.getCryptoContext(requestWrapdata);
                                    if (!wrapKeyCryptoContext)
                                        throw new MslKeyExchangeException(MslError.KEYX_WRAPPING_KEY_MISSING, base64$encode(requestWrapdata)).setEntity(entityAuthData);
                                    break;
                                }
                                default:
                                    throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism).setEntity(entityAuthData);
                            }

                            // Unwrap wrapping key.
                            wrapKeyCryptoContext.unwrap(response.wrapKey, WebCryptoAlgorithm.A128KW, WebCryptoUsage.WRAP_UNWRAP, {
                                result: function(wrapKey) {
                                    unwrapSessionKeys(entityAuthData, response, requestWrapdata, identity, wrapKey);
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(entityAuthData);
                                        throw e;
                                    });
                                }
                            });
                        }, self);
                    },
                    error: callback.error
                });
            }, self);

            function unwrapSessionKeys(entityAuthData, response, requestWrapdata, identity, wrapKey) {
                AsyncExecutor(callback, function() {
                    var unwrapCryptoContext = new JsonWebEncryptionCryptoContext(ctx, JsonWebEncryptionCryptoContext$Algorithm.A128KW, JsonWebEncryptionCryptoContext$Encryption.A128GCM, wrapKey);
                    unwrapCryptoContext.unwrap(response.encryptionKey, WebCryptoAlgorithm.AES_CBC, WebCryptoUsage.ENCRYPT_DECRYPT, {
                        result: function(encryptionKey) {
                            unwrapCryptoContext.unwrap(response.hmacKey, WebCryptoAlgorithm.HMAC_SHA256, WebCryptoUsage.SIGN_VERIFY, {
                                result: function(hmacKey) {
                                    AsyncExecutor(callback, function() {
                                        // Deliver wrap data to wrap key repository.
                                        var wrapdata = response.wrapdata;
                                        this.repository.addCryptoContext(wrapdata, unwrapCryptoContext);
                                        this.repository.removeCryptoContext(requestWrapdata);

                                        // Create crypto context.
                                        var responseMasterToken = response.masterToken;
                                        return new SessionCryptoContext(ctx, responseMasterToken, identity, encryptionKey, hmacKey);
                                    }, self);
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(entityAuthData);
                                        throw e;
                                    });
                                }
                            });
                        },
                        error: function(e) {
                            AsyncExecutor(callback, function() {
                                if (e instanceof MslException)
                                    e.setEntity(entityAuthData);
                                throw e;
                            });
                        }
                    });
                }, self);
            }
        }
    });
})();


// -- javascript/keyx/NetflixJsonWebKeyLadderExchange.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>JSON Web Key ladder key exchange.</p>
 *
 * <p>The key ladder consists of a symmetric wrapping key used to protect the
 * session keys. The wrapping key is only permitted to wrap and unwrap data. It
 * cannot be used for encrypt/decrypt or sign/verify operations.</p>
 *
 * <p>The wrapping key is protected by wrapping it with a known common key
 * (e.g. preshared keys), a provided public key (e.g. client-generated RSA key
 * pair), or the previously used wrapping key. The previous wrapping key must
 * be provided by the requesting entity in the form found in the response
 * data.</p>
 *
 * <p>The wrapping key is always an AES-128 key for AES key wrap/unwrap.</p>
 *
 * <p>This key exchange scheme does not provide perfect forward secrecy and
 * should only be used if necessary to satisfy other security requirements.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var NetflixJsonWebKeyLadderExchange;
var NetflixJsonWebKeyLadderExchange$Mechanism;
var NetflixJsonWebKeyLadderExchange$RequestData;
var NetflixJsonWebKeyLadderExchange$RequestData$parse;
var NetflixJsonWebKeyLadderExchange$ResponseData;
var NetflixJsonWebKeyLadderExchange$ResponseData$parse;
var NetflixJsonWebKeyLadderExchange$AesKwJwkCryptoContext;

(function() {
    "use strict";

    /**
     * Wrapping key wrap mechanism.
     * @enum {string}
     */
    var Mechanism = NetflixJsonWebKeyLadderExchange$Mechanism = {
        /** Wrapping key wrapped by PSK (AES-128 key wrap). */
        PSK: "PSK",
        /** Wrapping key wrapped by MGK (AES-128 key wrap). */
        MGK: "MGK",
        /** Wrapping key wrapped by previous wrapping key (AES-128 key wrap). */
        WRAP: "WRAP",
    };

    /**
     * JSON key wrap key wrapping mechanism.
     * @const
     * @type {string}
     */
    var KEY_MECHANISM = "mechanism";
    /**
     * JSON key wrap data.
     * @const
     * @type {string}
     */
    var KEY_WRAPDATA = "wrapdata";
    /**
     * JSON key wrapping key.
     * @const
     * @type {string}
     */
    var KEY_WRAP_KEY = "wrapkey";
    /**
     * JSON key encrypted encryption key.
     * @const
     * @type {string}
     */
    var KEY_ENCRYPTION_KEY = "encryptionkey";
    /**
     * JSON key encrypted HMAC key.
     * @const
     * @type {string}
     */
    var KEY_HMAC_KEY = "hmackey";

    /**
     * <p>JSON Web Key ladder key request data.</p>
     *
     * <p>
     * {@code {
     *   "#mandatory" : [ "mechanism" ],
     *   "mechanism" : "enum(PSK|MGK|WRAP)",
     *   "wrapdata" : "base64",
     * }} where:
     * <ul>
     * <li>{@code mechanism} identifies the mechanism for wrapping and unwrapping the wrapping key</li>
     * <li>{@code wrapdata} the Base64-encoded wrapping data for the previous wrapping key</li>
     * </ul></p>
     */
    var RequestData = NetflixJsonWebKeyLadderExchange$RequestData = KeyRequestData.extend({
        /**
         * <p>Create a new JSON Web Key ladder key request data instance
         * with the specified mechanism and wrapping key data.</p>
         *
         * <p>Arguments not applicable to the specified mechanism are
         * ignored.</p>
         *
         * @param {Mechanism} mechanism the wrap key wrapping mechanism.
         * @param {?Uint8Array} wrapdata the wrap data for reconstructing the previous
         *        wrapping key. May be null if the mechanism does not use the
         *        previous wrapping key.
         * @throws MslInternalException if the mechanism requires wrap data and
         *         the required argument is null.
         */
        init: function init(mechanism, wrapdata) {
            init.base.call(this, KeyExchangeScheme.JWK_LADDER);

            switch (mechanism) {
                case Mechanism.WRAP:
                    if (!wrapdata)
                        throw new MslInternalException("Previous wrapping key based key exchange requires the previous wrapping key data and ID.");
                    break;
                default:
                    wrapdata = null;
                    break;
            }

            // The properties.
            var props = {
                mechanism: { value: mechanism, writable: false, configurable: false },
                wrapdata: { value: wrapdata, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getKeydata: function getKeydata() {
            var keydata = {};
            keydata[KEY_MECHANISM] = this.mechanism;
            if (this.wrapdata) keydata[KEY_WRAPDATA] = base64$encode(this.wrapdata);
            return keydata;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (that === this) return true;
            if (!(that instanceof NetflixJsonWebKeyLadderExchange$RequestData)) return false;
            return equals.base.call(this, that) &&
                this.mechanism == that.mechanism &&
                Arrays$equal(this.wrapdata, that.wrapdata);
        },

        /** @inheritDoc */
        uniqueKey: function uniqueKey() {
            var key = uniqueKey.base.call(this) + ':' + this.mechanism;
            if (this.wrapdata)
                key += ':' + Arrays$hashCode(this.wrapdata);
            return key;
        },
    });

    /**
     * Create a new JSON Web Key ladder key request data instance
     * from the provided JSON object.
     *
     * @param {object} keyRequestJO the JSON object.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException the wrapped key data cannot be verified
     *         or decrypted, or the specified mechanism is not supported.
     * @throws MslKeyExchangeException if the specified mechanism is not
     *         recognized.
     */
    var RequestData$parse = NetflixJsonWebKeyLadderExchange$RequestData$parse = function RequestData$parse(keyRequestJO) {
        // Pull key request data.
        var mechanism = keyRequestJO[KEY_MECHANISM];
        var wrapdataB64 = keyRequestJO[KEY_WRAPDATA];

        // Verify key request data.
        if (!mechanism ||
            (mechanism == Mechanism.WRAP && (!wrapdataB64 || typeof wrapdataB64 !== 'string')))
        {
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "keydata " + JSON.stringify(keyRequestJO));
        }

        // Verify mechanism.
        if (!Mechanism[mechanism])
            throw new MslKeyExchangeException(MslError.UNIDENTIFIED_KEYX_MECHANISM, mechanism);

        // Create the request data.
        var wrapdata;
        switch (mechanism) {
            case Mechanism.WRAP:
                try {
                    wrapdata = base64$decode(wrapdataB64);
                } catch (e) {
                    throw new MslKeyExchangeException(MslError.KEYX_WRAPPING_KEY_MISSING, "keydata " + keyRequestJO.toString());
                }
                if (wrapdata == null || wrapdata.length == 0)
                    throw new MslKeyExchangeException(MslError.KEYX_WRAPPING_KEY_MISSING, "keydata " + keyRequestJO.toString());
                break;
            default:
                wrapdata = null;
                break;
        }
        return new RequestData(mechanism, wrapdata);
    };

    /**
     * <p>JSON Web Key ladder key response data.</p>
     *
     * <p>
     * {@code {
     *   "#mandatory" : [ "wrapkey", "wrapdata", "encryptionkey", "hmackey" ],
     *   "wrapkey" : "base64",
     *   "wrapdata" : "base64",
     *   "encryptionkey" : "base64",
     *   "hmackey" : "base64",
     * }} where:
     * <ul>
     * <li>{@code wrapkey} the Base64-encoded new wrapping key in JWE format, wrapped by the wrapping key</li>
     * <li>{@code wrapdata} the Base64-encoded wrapping key data for use in subsequent key request data</li>
     * <li>{@code encryptionkey} the Base64-encoded session encryption key in JWE format, wrapped with the new wrapping key</li>
     * <li>{@code hmackey} the Base64-encoded session HMAC key in JWE format, wrapped with the new wrapping key</li>
     * </ul></p>
     */
    var ResponseData = NetflixJsonWebKeyLadderExchange$ResponseData = KeyResponseData.extend({
        /**
         * Create a new JSON Web Key ladder key response data instance
         * with the provided master token and wrapped keys.
         *
         * @param {MasterToken} masterToken the master token.
         * @param {Uint8Array} wrapKey the wrapped wrap key.
         * @param {Uint8Array} wrapdata the wrap data for reconstructing the wrap key.
         * @param {Uint8Array} encryptionKey the wrap key wrapped encryption key.
         * @param {Uint8Array} hmacKey the wrap key wrapped HMAC key.
         */
        init: function init(masterToken, wrapKey, wrapdata, encryptionKey, hmacKey) {
            init.base.call(this, masterToken, KeyExchangeScheme.JWK_LADDER);

            // The properties.
            var props = {
                wrapKey: { value: wrapKey, writable: false, configurable: false },
                wrapdata: { value: wrapdata, writable: false, configurable: false },
                encryptionKey: { value: encryptionKey, writable: false, configurable: false },
                hmacKey: { value: hmacKey, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getKeydata: function getKeydata() {
            var keydata = {};
            keydata[KEY_WRAP_KEY] = base64$encode(this.wrapKey);
            keydata[KEY_WRAPDATA] = base64$encode(this.wrapdata);
            keydata[KEY_ENCRYPTION_KEY] = base64$encode(this.encryptionKey);
            keydata[KEY_HMAC_KEY] = base64$encode(this.hmacKey);
            return keydata;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof NetflixJsonWebKeyLadderExchange$ResponseData)) return false;
            return equals.base.call(this, that) &&
                Arrays$equal(this.wrapKey, that.wrapKey) &&
                Arrays$equal(this.wrapdata, that.wrapdata) &&
                Arrays$equal(this.encryptionKey, that.encryptionKey) &&
                Arrays$equal(this.hmacKey, that.hmacKey);
        },

        /** @inheritDoc */
        uniqueKey: function uniqueKey() {
            var key = uniqueKey.base.call(this) +
                ':' + Arrays$hashCode(this.wrapKey) +
                ':' + Arrays$hashCode(this.wrapdata) +
                ':' + Arrays$hashCode(this.encryptionKey) +
                ':' + Arrays$hashCode(this.hmacKey);
            return key;
        }
    });

    /**
     * Create a new JSON Web Key ladder key response data instance
     * with the provided master token from the provided JSON object.
     *
     * @param {MasterToken} masterToken the master token.
     * @param {object} keyDataJO the JSON object.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslKeyExchangeException if the mechanism is not recognized.
     */
    var ResponseData$parse = NetflixJsonWebKeyLadderExchange$ResponseData$parse = function NetflixJsonWebKeyLadderExchange$ResponseData$parse(masterToken, keyDataJO) {
        // Pull key response data.
        var wrapKeyB64 = keyDataJO[KEY_WRAP_KEY];
        var wrapdataB64 = keyDataJO[KEY_WRAPDATA];
        var encryptionKeyB64 = keyDataJO[KEY_ENCRYPTION_KEY];
        var hmacKeyB64 = keyDataJO[KEY_HMAC_KEY];

        // Verify key response data.
        if (!wrapKeyB64 || typeof wrapKeyB64 !== 'string' ||
            !wrapdataB64 || typeof wrapdataB64 !== 'string' ||
            !encryptionKeyB64 || typeof encryptionKeyB64 !== 'string' ||
            !hmacKeyB64 || typeof hmacKeyB64 !== 'string')
        {
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "keydata " + JSON.stringify(keyDataJO));
        }

        // Decode keys.
        var wrapKey, wrapdata, encryptionKey, hmacKey;
        try {
            wrapKey = base64$decode(wrapKeyB64);
            wrapdata = base64$decode(wrapdataB64);
        } catch (e) {
            throw new MslCryptoException(MslError.INVALID_SYMMETRIC_KEY, "keydata " + JSON.stringify(keyDataJO), e);
        }
        try {
            encryptionKey = base64$decode(encryptionKeyB64);
        } catch (e) {
            throw new MslCryptoException(MslError.INVALID_ENCRYPTION_KEY, "keydata " + JSON.stringify(keyDataJO), e);
        }
        try {
            hmacKey = base64$decode(hmacKeyB64);
        } catch (e) {
            throw new MslCryptoException(MslError.INVALID_HMAC_KEY, "keydata " + JSON.stringify(keyDataJO), e);
        }

        // Return the response data.
        return new ResponseData(masterToken, wrapKey, wrapdata, encryptionKey, hmacKey);
    };
    
    /**
     * AES key wrap JSON web key crypto context.
     */
    var AesKwJwkCryptoContext = NetflixJsonWebKeyLadderExchange$AesKwJwkCryptoContext = ICryptoContext.extend({
        /**
         * Create an AES key wrap JSON web key crypto context with the provided
         * key.
         * 
         * @param {CipherKey} wrapKey AES secret key.
         */
        init: function(wrapKey) {
            // Extract actual wrapping key.
            if (wrapKey && wrapKey.rawKey) {
                wrapKey = wrapKey.rawKey;
            }
            
            // Define properties.
            var props = {
                _wrapKey: { value: wrapKey, writable: false, enumerable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },
        
        /** @inheritDoc */
        encrypt: function encrypt(data, callback) {
            callback.error(new MslCryptoException(MslError.ENCRYPT_NOT_SUPPORTED));
        },

        /** @inheritDoc */
        decrypt: function decrypt(data, callback) {
            callback.error(new MslCryptoException(MslError.DECRYPT_NOT_SUPPORTED));
        },
        
        /** @inheritDoc */
        wrap: function wrap(key, callback) {
            AsyncExecutor(callback, function() {
                var oncomplete = function(result) {
                    callback.result(result);
                };
                var onerror = function(e) {
                    callback.error(new MslCryptoException(MslError.WRAP_ERROR));
                };
                mslCrypto['wrapKey']('jwk', key.rawKey, this._wrapKey, WebCryptoAlgorithm.A128KW)
                    .then(oncomplete, onerror);
            }, this);
        },
        
        /** @inheritDoc */
        unwrap: function unwrap(data, algo, usages, callback) {
            AsyncExecutor(callback, function() {
                var oncomplete = function(result) {
                    constructKey(result);
                };
                var onerror = function(e) {
                    callback.error(new MslCryptoException(MslError.UNWRAP_ERROR));
                };
                mslCrypto['unwrapKey']('jwk', data, this._wrapKey, WebCryptoAlgorithm.A128KW, algo, false, usages)
                    .then(oncomplete, onerror);
            }, this);

            function constructKey(rawKey) {
                AsyncExecutor(callback, function() {
                    switch (rawKey["type"]) {
                        case "secret":
                            CipherKey$create(rawKey, callback);
                            break;
                        case "public":
                            PublicKey$create(rawKey, callback);
                            break;
                        case "private":
                            PrivateKey$create(rawKey, callback);
                            break;
                        default:
                            throw new MslCryptoException(MslError.UNSUPPORTED_KEY, "type: " + rawKey["type"]);
                    }
                });
            }
        },

        /** @inheritDoc */
        sign: function sign(data, callback) {
            callback.error(new MslCryptoException(MslError.SIGN_NOT_SUPPORTED));
        },

        /** @inheritDoc */
        verify: function verify(data, signature, callback) {
            callback.error(new MslCryptoException(MslError.VERIFY_NOT_SUPPORTED));
        },
    });

    /**
     * Create the crypto context identified by the mechanism.
     *
     * @param {MslContext} ctx MSL context.
     * @param {Mechanism} mechanism the wrap key wrapping mechanism.
     * @param {Uint8Array} wrapdata the wrap key previous wrapping key data. May be null.
     * @param {string} identity the entity identity.
     * @param {result: function(ICryptoContext), error: function(Error)}
     *        callback the callback that will receive the crypto context or any
     *        thrown exceptions.
     * @throws MslCryptoException if the crypto context cannot be created.
     * @throws MslKeyExchangeException if the mechanism is unsupported.
     * @throws MslEntityAuthException if there is a problem with the entity
     *         identity.
     */
    function createCryptoContext(ctx, mechanism, wrapdata, identity, callback) {
        AsyncExecutor(callback, function() {
            switch (mechanism) {
                // FIXME: For PSK/MGK we need some way to get an ICryptoContext
                // that might run remotely. In other words, some other CryptoContext. Maybe
                // the WrapCryptoContextRepository can be used for that.
                case Mechanism.PSK:
                {
                    var authdata = new PresharedAuthenticationData(identity);
                    var factory = ctx.getEntityAuthenticationFactory(EntityAuthenticationScheme.PSK);
                    if (!factory)
                        throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism);
                    var cryptoContext = factory.getCryptoContext(ctx, authdata);
                    // FIXME: Get a handle to KPW.
                    var kpw = undefined;
                    return new AesKwJwkCryptoContext(kpw);
                }
                case Mechanism.MGK:
                {
                    var authdata = new ModelGroupAuthenticationData(identity);
                    var factory = ctx.getEntityAuthenticationFactory(EntityAuthenticationScheme.MGK);
                    if (!factory)
                        throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism);
                    var cryptoContext = factory.getCryptoContext(ctx, authdata);
                    // FIXME: Get a handle to KDW.
                    var kdw = undefined;
                    return new AesKwJwkCryptoContext(kdw);
                }
                case Mechanism.WRAP:
                {
                    var cryptoContext = ctx.getMslCryptoContext();
                    cryptoContext.unwrap(wrapdata, WebCryptoAlgorithm.A128KW, WebCryptoUsage.WRAP_UNWRAP, {
                        result: function(wrapKey) {
                            AsyncExecutor(callback, function() {
                                return new AesKwJwkCryptoContext(wrapKey);
                            });
                        },
                        error: callback.error,
                    });
                    return;
                }
                default:
                    throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism);
            }
        });
    }

    NetflixJsonWebKeyLadderExchange = KeyExchangeFactory.extend({
        /**
         * Create a new JSON Web Key ladder key exchange factory.
         *
         * @param {WrapCryptoContextRepository} repository the wrapping key crypto context repository.
         */
        init: function init(repository) {
            init.base.call(this, KeyExchangeScheme.JWK_LADDER);

            // The properties.
            var props = {
                repository: { value: repository, writable: false, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        createRequestData: function createRequestData(ctx, keyRequestJO, callback) {
            AsyncExecutor(callback, function() {
                return RequestData$parse(keyRequestJO);
            });
        },

        /** @inheritDoc */
        createResponseData: function createResponseData(ctx, masterToken, keyDataJO) {
            return ResponseData$parse(masterToken, keyDataJO);
        },

        /** @inheritDoc */
        generateResponse: function generateResponse(ctx, keyRequestData, entityToken, callback) {
            var self = this;
            var masterToken;

            AsyncExecutor(callback, function() {
                if (!(keyRequestData instanceof RequestData))
                    throw new MslInternalException("Key request data " + JSON.stringify(keyRequestData) + " was not created by this factory.");

                // If the master token was not issued by the local entity then we
                // should not be generating a key response for it.
                var identity = entityToken;
                if (entityToken instanceof MasterToken) {
                    if (!entityToken.isVerified())
                        throw new MslMasterTokenException(MslError.MASTERTOKEN_UNTRUSTED, entityToken);
                    masterToken = entityToken;
                    identity = entityToken.identity;
                }

                // Create random AES-128 wrapping key.
                var wrapBytes = new Uint8Array(16);
                ctx.getRandom().nextBytes(wrapBytes);
                CipherKey$import(wrapBytes, WebCryptoAlgorithm.A128KW, WebCryptoUsage.WRAP_UNWRAP, {
                    result: function(wrapKey) {
                        AsyncExecutor(callback, function() {
                            var mslCryptoContext = ctx.getMslCryptoContext();
                            mslCryptoContext.wrap(wrapKey, {
                                result: function(wrapdata) {
                                    createSessionKeys(identity, wrapKey, wrapdata);
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(masterToken);
                                        throw e;
                                    }, self);
                                }
                            });
                        }, self);
                    },
                    error: function(e) {
                        AsyncExecutor(callback, function() {
                            throw new MslCryptoException(MslError.WRAP_KEY_CREATION_FAILURE, null, e).setEntity(masterToken);
                        }, self);
                    }
                });
            }, self);

            function createSessionKeys(identity, wrapKey, wrapdata) {
                self.generateSessionKeys(ctx, {
                    result: function(sessionKeys) {
                        AsyncExecutor(callback, function() {
                            var encryptionKey = sessionKeys.encryptionKey;
                            var hmacKey = sessionKeys.hmacKey;
                            wrapWrappingKey(identity, wrapKey, wrapdata, encryptionKey, hmacKey);
                        }, self);
                    },
                    error: function(e) {
                        AsyncExecutor(callback, function() {
                            if (e instanceof MslException)
                                e.setEntity(masterToken);
                            throw e;
                        });
                    }
                });
            }

            function wrapWrappingKey(identity, wrapKey, wrapdata, encryptionKey, hmacKey) {
                AsyncExecutor(callback, function() {
                    var request = keyRequestData;

                    // Grab the request data.
                    var mechanism = request.mechanism;
                    var prevWrapdata = request.wrapdata;

                    // Wrap wrapping key using specified wrapping key.
                    createCryptoContext(ctx, mechanism, prevWrapdata, identity, {
                        result: function (wrapKeyCryptoContext) {
                            wrapKeyCryptoContext.wrap(wrapKey, {
                                result: function(wrappedWrapJwk) {
                                    wrapSessionKeys(wrapKey, wrapdata, encryptionKey, hmacKey, wrappedWrapJwk);
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(masterToken);
                                        throw e;
                                    });
                                }
                            });
                        },
                        error: function(e) {
                            AsyncExecutor(callback, function() {
                                if (e instanceof MslException)
                                    e.setEntity(masterToken);
                                throw e;
                            });
                        }
                    });
                }, self);
            }

            function wrapSessionKeys(wrapKey, wrapdata, encryptionKey, hmacKey, wrappedWrapJwk) {
                AsyncExecutor(callback, function() {
                    var wrapCryptoContext = new AesKwJwkCryptoContext(wrapKey);
                    wrapCryptoContext.wrap(encryptionKey, {
                        result: function(wrappedEncryptionJwk) {
                            wrapCryptoContext.wrap(hmacKey, {
                                result: function(wrappedHmacJwk) {
                                    createMasterToken(wrapdata, wrappedWrapJwk, encryptionKey, wrappedEncryptionJwk, hmacKey, wrappedHmacJwk);
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(masterToken);
                                        throw e;
                                    });
                                }
                            });
                        },
                        error: function(e) {
                            AsyncExecutor(callback, function() {
                                if (e instanceof MslException)
                                    e.setEntity(masterToken);
                                throw e;
                            });
                        }
                    });
                }, self);
            }

            function createMasterToken(wrapdata, wrappedWrapJwk, encryptionKey, wrappedEncryptionJwk, hmacKey, wrappedHmacJwk) {
                AsyncExecutor(callback, function() {
                    // Create the master token.
                    var tokenFactory = ctx.getTokenFactory();
                    if (masterToken) {
                        tokenFactory.renewMasterToken(ctx, masterToken, encryptionKey, hmacKey, {
                            result: function(masterToken) {
                                AsyncExecutor(callback, function() {
                                    // Create session crypto context.
                                    var cryptoContext = new SessionCryptoContext(ctx, masterToken);

                                    // Return the key exchange data.
                                    var keyResponseData = new ResponseData(masterToken, wrappedWrapJwk, wrapdata, wrappedEncryptionJwk, wrappedHmacJwk);
                                    return new KeyExchangeFactory.KeyExchangeData(keyResponseData, cryptoContext, callback);
                                }, self);
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException)
                                        e.setEntity(masterToken);
                                    throw e;
                                });
                            }
                        });
                    } else {
                        tokenFactory.createMasterToken(ctx, entityToken, encryptionKey, hmacKey, {
                            result: function(masterToken) {
                                AsyncExecutor(callback, function() {
                                    // Create session crypto context.
                                    var cryptoContext = new SessionCryptoContext(ctx, masterToken);

                                    // Return the key exchange data.
                                    var keyResponseData = new ResponseData(masterToken, wrappedWrapJwk, wrapdata, wrappedEncryptionJwk, wrappedHmacJwk);
                                    return new KeyExchangeFactory.KeyExchangeData(keyResponseData, cryptoContext, callback);
                                }, self);
                            },
                            error: callback.error,
                        });
                    }
                }, self);
            }
        },

        /** @inheritDoc */
        getCryptoContext: function getCryptoContext(ctx, keyRequestData, keyResponseData, masterToken, callback) {
            var self = this;

            AsyncExecutor(callback, function() {
                if (!(keyRequestData instanceof RequestData))
                    throw new MslInternalException("Key request data " + JSON.stringify(keyRequestData) + " was not created by this factory.");
                var request = keyRequestData;
                if (!(keyResponseData instanceof ResponseData))
                    throw new MslInternalException("Key response data " + JSON.stringify(keyResponseData) + " was not created by this factory.");
                var response = keyResponseData;

                // Unwrap new wrapping key.
                var mechanism = request.mechanism;
                var requestWrapdata = request.wrapdata;
                ctx.getEntityAuthenticationData(null, {
                    result: function(entityAuthData) {
                        AsyncExecutor(callback, function() {
                            var identity = entityAuthData.getIdentity();
                            var wrapKeyCryptoContext;
                            switch (mechanism) {
                                case Mechanism.PSK:
                                {
                                    var authdata = new PresharedAuthenticationData(identity);
                                    var factory = ctx.getEntityAuthenticationFactory(EntityAuthenticationScheme.PSK);
                                    if (!factory)
                                        throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism).setEntity(entityAuthData);
                                    var cryptoContext = factory.getCryptoContext(ctx, authdata);
                                    // FIXME: Get a handle to KPW.
                                    var kpw = cryptoContext.wrapKey;
                                    wrapKeyCryptoContext = new AesKwJwkCryptoContext(kpw);
                                    break;
                                }
                                case Mechanism.MGK:
                                {
                                    var authdata = new ModelGroupAuthenticationData(identity);
                                    var factory = ctx.getEntityAuthenticationFactory(EntityAuthenticationScheme.MGK);
                                    if (!factory)
                                        throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism).setEntity(entityAuthData);
                                    var cryptoContext = factory.getCryptoContext(ctx, authdata);
                                    // FIXME: Get a handle to KDW.
                                    var kdw = cryptoContext.wrapKey;
                                    wrapKeyCryptoContext = new AesKwJwkCryptoContext(kdw);
                                    break;
                                }
                                case Mechanism.WRAP:
                                {
                                    wrapKeyCryptoContext = this.repository.getCryptoContext(requestWrapdata);
                                    if (!wrapKeyCryptoContext)
                                        throw new MslKeyExchangeException(MslError.KEYX_WRAPPING_KEY_MISSING, base64$encode(requestWrapdata)).setEntity(entityAuthData);
                                    break;
                                }
                                default:
                                    throw new MslKeyExchangeException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism).setEntity(entityAuthData);
                            }

                            // Unwrap wrapping key.
                            wrapKeyCryptoContext.unwrap(response.wrapKey, WebCryptoAlgorithm.A128KW, WebCryptoUsage.WRAP_UNWRAP, {
                                result: function(wrapKey) {
                                    unwrapSessionKeys(entityAuthData, response, requestWrapdata, identity, wrapKey);
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(entityAuthData);
                                        throw e;
                                    });
                                }
                            });
                        }, self);
                    },
                    error: callback.error
                });
            }, self);

            function unwrapSessionKeys(entityAuthData, response, requestWrapdata, identity, wrapKey) {
                AsyncExecutor(callback, function() {
                    var unwrapCryptoContext = new AesKwJwkCryptoContext(wrapKey);
                    unwrapCryptoContext.unwrap(response.encryptionKey, WebCryptoAlgorithm.AES_CBC, WebCryptoUsage.ENCRYPT_DECRYPT, {
                        result: function(encryptionKey) {
                            unwrapCryptoContext.unwrap(response.hmacKey, WebCryptoAlgorithm.HMAC_SHA256, WebCryptoUsage.SIGN_VERIFY, {
                                result: function(hmacKey) {
                                    AsyncExecutor(callback, function() {
                                        // Deliver wrap data to wrap key repository.
                                        var wrapdata = response.wrapdata;
                                        this.repository.addCryptoContext(wrapdata, unwrapCryptoContext);
                                        this.repository.removeCryptoContext(requestWrapdata);

                                        // Create crypto context.
                                        var responseMasterToken = response.masterToken;
                                        return new SessionCryptoContext(ctx, responseMasterToken, identity, encryptionKey, hmacKey);
                                    }, self);
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(entityAuthData);
                                        throw e;
                                    });
                                }
                            });
                        },
                        error: function(e) {
                            AsyncExecutor(callback, function() {
                                if (e instanceof MslException)
                                    e.setEntity(entityAuthData);
                                throw e;
                            });
                        }
                    });
                }, self);
            }
        }
    });
})();


// -- javascript/keyx/WrapCryptoContextRepository.js
/**
 * Copyright (c) 2014 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>The wrap crypto context repository provides access to wrapping key crypto
 * contexts and is used by key exchange factories that make use of intermediate
 * wrapping keys to deliver new wrapping key data to the application. The
 * wrapping key data and its corresponding crypto context can then be used in
 * future key request data.</p>
 * 
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var WrapCryptoContextRepository = util.Class.create({
    /**
     * Add a new wrapping key crypto context and wrap data. The wrap data
     * should be used in key request data to request a new wrapping key
     * wrapped with this wrapping key.
     * 
     * @param {Uint8Array} wrapdata wrapping key wrap data.
     * @param {ICryptoContext} cryptoContext wrapping key crypto context.
     */
    addCryptoContext: function(wrapdata, cryptoContext) {},
    
    /**
     * Return the wrapping key crypto context identified by the specified
     * wrap data.
     * 
     * @param {Uint8Array} wrapdata wrapping key wrap data.
     * @return {ICryptoContext} the wrapping key crypto context or null if none exists.
     */
    getCryptoContext: function(wrapdata) {},
    
    /**
     * Remove the wrapping key crypto context identified by the specified
     * key wrap data. This is called after calling
     * {@link #addCryptoContext(byte[], ICryptoContext)} to
     * indicate the old wrapping crypto context should no longer be
     * necessary.
     * 
     * @param {Uint8Array} wrapdata wrapping key wrap data.
     */
    removeCryptoContext: function(wrapdata) {},
});


// -- javascript/keyx/AsymmetricWrappedExchange.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Asymmetric key wrapped key exchange.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var AsymmetricWrappedExchange;
var AsymmetricWrappedExchange$Mechanism;
var AsymmetricWrappedExchange$RequestData;
var AsymmetricWrappedExchange$RequestData$parse;
var AsymmetricWrappedExchange$ResponseData;
var AsymmetricWrappedExchange$ResponseData$parse;

(function() {
    "use strict";

    /**
     * Asymmetric key wrapped mechanism.
     * @enum {string}
     */
    var Mechanism = AsymmetricWrappedExchange$Mechanism = {
        RSA: "RSA",
        ECC: "ECC",
        JWE_RSA: "JWE_RSA",
        JWEJS_RSA: "JWEJS_RSA",
        JWK_RSA: "JWK_RSA",
        JWK_RSAES: "JWK_RSAES",
    };

    /**
     * JSON key key pair ID.
     * @const
     * @type {string}
     */
    var KEY_KEY_PAIR_ID = "keypairid";
    /**
     * JSON key mechanism.
     * @const
     * @type {string}
     */
    var KEY_MECHANISM = "mechanism";
    /**
     * JSON key public key.
     * @const
     * @type {string}
     */
    var KEY_PUBLIC_KEY = "publickey";
    /**
     * JSON key encrypted encryption key.
     * @const
     * @type {string}
     */
    var KEY_ENCRYPTION_KEY = "encryptionkey";
    /**
     * JSON key encrypted HMAC key.
     * @const
     * @type {string}
     */
    var KEY_HMAC_KEY = "hmackey";

    /**
     * <p>Asymmetric key wrapped key request data.</p>
     *
     * <p>
     * {@code {
     *   "#mandatory" : [ "keypairid", "mechanism", "publickey" ],
     *   "keypairid" : "string",
     *   "mechanism" : "string",
     *   "publickey" : "base64"
     * } where:
     * <ul>
     * <li>{@code keypairid} identifies the key pair for wrapping and unwrapping the session keys</li>
     * <li>{@code mechanism} the public key cryptographic mechanism of the key pair</li>
     * <li>{@code publickey} the Base64-encoded public key used to wrap the session keys</li>
     * </ul></p>
     */
    var RequestData = AsymmetricWrappedExchange$RequestData = KeyRequestData.extend({
        /**
         * Create a new asymmetric key wrapped key request data instance with
         * the specified key pair ID and public key. The private key is also
         * required but is not included in the request data.
         *
         * @param {string} keyPairId the public/private key pair ID.
         * @param {Mechanism} mechanism the key exchange mechanism.
         * @param {PublicKey} publicKey the public key.
         * @param {PrivateKey} privateKey the private key.
         */
        init: function init(keyPairId, mechanism, publicKey, privateKey) {
            init.base.call(this, KeyExchangeScheme.ASYMMETRIC_WRAPPED);

            // The properties.
            var props = {
                keyPairId: { value: keyPairId, writable: false, configurable: false },
                mechanism: { value: mechanism, writable: false, configurable: false },
                publicKey: { value: publicKey, writable: false, configurable: false },
                privateKey: { value: privateKey, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getKeydata: function getKeydata() {
            var keydata = {};
            keydata[KEY_KEY_PAIR_ID] = this.keyPairId;
            keydata[KEY_MECHANISM] = this.mechanism;
            keydata[KEY_PUBLIC_KEY] = base64$encode(this.publicKey.getEncoded());
            return keydata;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (that === this) return true;
            if (!(that instanceof AsymmetricWrappedExchange$RequestData)) return false;
            // Private keys are optional but must be considered.
            var privateKeysEqual =
                this.privateKey === that.privateKey ||
                (this.privateKey && that.privateKey &&
                    Arrays$equal(this.privateKey.getEncoded(), that.privateKey.getEncoded()));
            return equals.base.call(this, that) &&
                this.keyPairId == that.keyPairId &&
                this.mechanism == that.mechanism &&
                Arrays$equal(this.publicKey.getEncoded(), that.publicKey.getEncoded()) &&
                privateKeysEqual;
        },

        /** @inheritDoc */
        uniqueKey: function uniqueKey() {
            var encodedPublicKey = this.publicKey.getEncoded();
            var encodedPrivateKey = this.privateKey && this.privateKey.getEncoded();

            var key = uniqueKey.base.call(this) + ':' + this.keyPairId + ':' + this.mechanism + ':' + Arrays$hashCode(encodedPublicKey);
            if (encodedPrivateKey)
                key += ':' + Arrays$hashCode(encodedPrivateKey);
            return key;
        }
    });

    /**
     * Create a new asymmetric key wrapped key request data instance from
     * the provided JSON object. The private key will be unknown.
     *
     * @param {Object} keyRequestJO the JSON object.
     * @param {{result: function(RequestData), error: function(Error)}}
     *        callback the callback will receive the request data or any
     *        thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException if the encoded key is invalid or the
     *         specified mechanism is not supported.
     * @throws MslKeyExchangeException if the specified mechanism is not
     *         recognized.
     */
    var RequestData$parse = AsymmetricWrappedExchange$RequestData$parse = function RequestData$parse(keyRequestJO, callback) {
        AsyncExecutor(callback, function() {
            // Pull key request data.
            var keyPairId = keyRequestJO[KEY_KEY_PAIR_ID];
            var mechanism = keyRequestJO[KEY_MECHANISM];
            var encodedKeyB64 = keyRequestJO[KEY_PUBLIC_KEY];

            // Verify key request data.
            if (!keyPairId || typeof keyPairId !== 'string' ||
                !mechanism ||
                !encodedKeyB64 || typeof encodedKeyB64 !== 'string')
            {
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "keydata " + JSON.stringify(keyRequestJO));
            }

            // Verify mechanism.
            if (!Mechanism[mechanism])
                throw new MslKeyExchangeException(MslError.UNIDENTIFIED_KEYX_MECHANISM, mechanism);

            // Reconstruct public key.
            try {
                var encodedKey = base64$decode(encodedKeyB64);
                switch (mechanism) {
                case Mechanism.JWE_RSA:
                case Mechanism.JWEJS_RSA:
                case Mechanism.JWK_RSA:
                {
                    PublicKey$import(encodedKey, WebCryptoAlgorithm.RSA_OAEP, WebCryptoUsage.WRAP_UNWRAP, {
                        result: function(publicKey) {
                            constructRequestData(keyPairId, mechanism, publicKey);
                        },
                        error: function(e) { callback.error(e); }
                    });
                    break;
                }
                case Mechanism.JWK_RSAES:
                {
                    PublicKey$import(encodedKey, WebCryptoAlgorithm.RSAES, WebCryptoUsage.WRAP_UNWRAP, {
                        result: function(publicKey) {
                            constructRequestData(keyPairId, mechanism, publicKey);
                        },
                        error: function(e) { callback.error(e); }
                    });
                    break;
                }
                /* Unsupported
                case Mechanism.RSA:
                */
                /* Does not currently work.
                case Mechanism.ECC:
                 */
                default:
                    throw new MslCryptoException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism);
                }
            } catch (e) {
                if (!(e instanceof MslException))
                    throw new MslCryptoException(MslError.INVALID_PUBLIC_KEY, "keydata " + JSON.stringify(keyRequestJO), e);
                throw e;
            }
        });

        function constructRequestData(keyPairId, mechanism, publicKey) {
            // Return the request data. There is no private key.
            var privateKey = null;
            callback.result(new RequestData(keyPairId, mechanism, publicKey, privateKey));
        }
    };

    /**
     * <p>Asymmetric key wrapped key response data.</p>
     *
     * <p>
     * {@code {
     *   "#mandatory" : [ "keypairid", "encryptionkey", "hmackey" ],
     *   "keypairid" : "string",
     *   "encryptionkey" : "base64",
     *   "hmackey" : "base64"
     * } where:
     * <ul>
     * <li>{@code keypairid} identifies the key pair for wrapping and unwrapping the session keys</li>
     * <li>{@code encryptionkey} the Base64-encoded wrapped session encryption key</li>
     * <li>{@code hmackey} the Base64-encoded wrapped session HMAC key</li>
     * </ul></p>
     */
    var ResponseData = AsymmetricWrappedExchange$ResponseData = KeyResponseData.extend({
        /**
         * Create a new asymmetric key wrapped key response data instance with
         * the provided master token, specified key pair ID, and public
         * key-encrypted encryption and HMAC keys.
         *
         * @param {MasterToken} masterToken the master token.
         * @param {string} keyPairId the public/private key pair ID.
         * @param {Uint8Array} encryptionKey the public key-encrypted encryption key.
         * @param {Uint8Array} hmacKey the public key-encrypted HMAC key.
         */
        init: function init(masterToken, keyPairId, encryptionKey, hmacKey) {
            init.base.call(this, masterToken, KeyExchangeScheme.ASYMMETRIC_WRAPPED);

            // The properties.
            var props = {
                keyPairId: { value: keyPairId, writable: false, configurable: false },
                encryptionKey: { value: encryptionKey, writable: false, configurable: false },
                hmacKey: { value: hmacKey, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getKeydata: function getKeydata() {
            var keydata = {};
            keydata[KEY_KEY_PAIR_ID] = this.keyPairId;
            keydata[KEY_ENCRYPTION_KEY] = base64$encode(this.encryptionKey);
            keydata[KEY_HMAC_KEY] = base64$encode(this.hmacKey);
            return keydata;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof AsymmetricWrappedExchange$ResponseData)) return false;
            return equals.base.call(this, that) &&
                this.keyPairId == that.keyPairId &&
                Arrays$equal(this.encryptionKey, that.encryptionKey) &&
                Arrays$equal(this.hmacKey, that.hmacKey);
        },

        /** @inheritDoc */
        uniqueKey: function uniqueKey() {
            return uniqueKey.base.call(this) + ':' + this.keyPairId +
                ':' + Arrays$hashCode(this.encryptionKey) +
                ':' + Arrays$hashCode(this.hmacKey);
        },
    });

    /**
     * Create a new asymmetric key wrapped key response data instance with
     * the provided master token from the provided JSON object.
     *
     * @param {MasterToken} masterToken the master token.
     * @param {Object} keyDataJO the JSON object.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException if an encoded key is invalid.
     */
    var ResponseData$parse = AsymmetricWrappedExchange$ResponseData$parse = function ResponseData$parse(masterToken, keyDataJO) {
        // Pull key response data.
        var keyPairId = keyDataJO[KEY_KEY_PAIR_ID];
        var encryptionKeyB64 = keyDataJO[KEY_ENCRYPTION_KEY];
        var hmacKeyB64 = keyDataJO[KEY_HMAC_KEY];

        // Verify key response data.
        if (!keyPairId || typeof keyPairId !== 'string' ||
            !encryptionKeyB64 || typeof encryptionKeyB64 !== 'string' ||
            !hmacKeyB64 || typeof hmacKeyB64 !== 'string')
        {
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "keydata " + JSON.stringify(keyDataJO));
        }

        // Decode keys.
        var encryptionKey;
        try {
            encryptionKey = base64$decode(encryptionKeyB64);
        } catch (e) {
            throw new MslCryptoException(MslError.INVALID_ENCRYPTION_KEY, "keydata " + JSON.stringify(keyDataJO), e);
        }
        var hmacKey;
        try {
            hmacKey = base64$decode(hmacKeyB64);
        } catch (e) {
            throw new MslCryptoException(MslError.INVALID_HMAC_KEY, "keydata " + JSON.stringify(keyDataJO), e);
        }

        // Return the response data.
        return new ResponseData(masterToken, keyPairId, encryptionKey, hmacKey);
    };

    /**
     * Create the crypto context identified by the key ID, mechanism, and
     * provided keys.
     *
     * @param {MslContext} ctx MSL context.
     * @param {string} keyPairId the key pair ID.
     * @param {Mechanism} mechanism the key mechanism.
     * @param {PrivateKey} privateKey the private key. May be null.
     * @param {PublicKey} publicKey the public key. May be null.
     * @return {ICryptoContext} the crypto context.
     * @throws MslCryptoException if the key mechanism is unsupported.
     */
    function createCryptoContext(ctx, keyPairId, mechanism, privateKey, publicKey) {
        switch (mechanism) {
            case Mechanism.JWE_RSA:
            case Mechanism.JWEJS_RSA:
                return new JsonWebEncryptionCryptoContext(ctx, JsonWebEncryptionCryptoContext$Algorithm.RSA_OAEP, JsonWebEncryptionCryptoContext$Encryption.A128GCM, privateKey, publicKey);
            case Mechanism.JWK_RSA:
                return new RsaCryptoContext(ctx, keyPairId, privateKey, publicKey, RsaCryptoContext$Mode.WRAP_UNWRAP_OAEP);
            case Mechanism.JWK_RSAES:
                return new RsaCryptoContext(ctx, keyPairId, privateKey, publicKey, RsaCryptoContext$Mode.WRAP_UNWRAP_PKCS1);
            default:
                throw new MslCryptoException(MslError.UNSUPPORTED_KEYX_MECHANISM, mechanism);
        }
    }

    AsymmetricWrappedExchange = KeyExchangeFactory.extend({
        /**
         * Create a new asymmetric wrapped key exchange factory.
         */
        init: function init() {
            init.base.call(this, KeyExchangeScheme.ASYMMETRIC_WRAPPED);
        },

        /** @inheritDoc */
        createRequestData: function createRequestData(ctx, keyRequestJO, callback) {
            RequestData$parse(keyRequestJO, callback);
        },


        /** @inheritDoc */
        createResponseData: function createResponseData(ctx, masterToken, keyDataJO) {
            return ResponseData$parse(masterToken, keyDataJO);
        },

        /** @inheritDoc */
        generateResponse: function generateResponse(ctx, keyRequestData, entityToken, callback) {
            var self = this;

            AsyncExecutor(callback, function() {
                if (!(keyRequestData instanceof RequestData))
                    throw new MslInternalException("Key request data " + JSON.stringify(keyRequestData) + " was not created by this factory.");

                // Create random AES-128 encryption and SHA-256 HMAC keys.
                this.generateSessionKeys(ctx, {
                    result: function(sessionKeys) {
                        var encryptionKey = sessionKeys.encryptionKey;
                        var hmacKey = sessionKeys.hmacKey;
                        wrapKeys(encryptionKey, hmacKey);
                    },
                    error: function(e) {
                        AsyncExecutor(callback, function() {
                            if (e instanceof MslException && entityToken instanceof MasterToken)
                                e.setEntity(entityToken);
                            throw e;
                        }, self);
                    }
                });
            }, self);

            function wrapKeys(encryptionKey, hmacKey) {
                AsyncExecutor(callback, function() {
                    var request = keyRequestData;

                    // Wrap session keys with public key.
                    var keyPairId = request.keyPairId;
                    var mechanism = request.mechanism;
                    var publicKey = request.publicKey;
                    var wrapCryptoContext = createCryptoContext(ctx, keyPairId, mechanism, null, publicKey);
                    wrapCryptoContext.wrap(encryptionKey, {
                        result: function(wrappedEncryptionKey) {
                            AsyncExecutor(callback, function() {
                                wrapCryptoContext.wrap(hmacKey, {
                                    result: function(wrappedHmacKey) {
                                        createMasterToken(encryptionKey, wrappedEncryptionKey, hmacKey, wrappedHmacKey);
                                    },
                                    error: function(e) {
                                        AsyncExecutor(callback, function() {
                                            if (e instanceof MslException && entityToken instanceof MasterToken)
                                                e.setEntity(entityToken);
                                            throw e;
                                        }, self);
                                    }
                                });
                            }, self);
                        },
                        error: function(e) {
                            AsyncExecutor(callback, function() {
                                if (e instanceof MslException && entityToken instanceof MasterToken)
                                    e.setEntity(entityToken);
                                throw e;
                            }, self);
                        }
                    });
                }, self);
            }

            function createMasterToken(encryptionKey, wrappedEncryptionKey, hmacKey, wrappedHmacKey) {
                AsyncExecutor(callback, function() {
                    var request = keyRequestData;

                    // Create the master token.
                    var tokenFactory = ctx.getTokenFactory();
                    if (entityToken instanceof MasterToken) {
                        tokenFactory.renewMasterToken(ctx, entityToken, encryptionKey, hmacKey, {
                            result: function(masterToken) {
                                AsyncExecutor(callback, function() {
                                    // Create crypto context.
                                    var cryptoContext = new SessionCryptoContext(ctx, masterToken);

                                    // Return the key exchange data.
                                    var keyResponseData = new ResponseData(masterToken, request.keyPairId, wrappedEncryptionKey, wrappedHmacKey);
                                    return new KeyExchangeFactory.KeyExchangeData(keyResponseData, cryptoContext, callback);
                                }, self);
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException)
                                        e.setEntity(entityToken);
                                    throw e;
                                }, self);
                            }
                        });
                    } else {
                        tokenFactory.createMasterToken(ctx, entityToken, encryptionKey, hmacKey, {
                            result: function(masterToken) {
                                AsyncExecutor(callback, function() {
                                    // Create crypto context.
                                    var cryptoContext = new SessionCryptoContext(ctx, masterToken);

                                    // Return the key exchange data.
                                    var keyResponseData = new ResponseData(masterToken, request.keyPairId, wrappedEncryptionKey, wrappedHmacKey);
                                    return new KeyExchangeFactory.KeyExchangeData(keyResponseData, cryptoContext, callback);
                                }, self);
                            },
                            error: callback.error,
                        });
                    }
                }, self);
            }
        },

        /** @inheritDoc */
        getCryptoContext: function getCryptoContext(ctx, keyRequestData, keyResponseData, masterToken, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                if (!(keyRequestData instanceof RequestData))
                    throw new MslInternalException("Key request data " + JSON.stringify(keyRequestData) + " was not created by this factory.");
                var request = keyRequestData;
                if (!(keyResponseData instanceof ResponseData))
                    throw new MslInternalException("Key response data " + JSON.stringify(keyResponseData) + " was not created by this factory.");
                var response = keyResponseData;

                // Verify response matches request.
                var requestKeyPairId = request.keyPairId;
                var responseKeyPairId = response.keyPairId;
                if (requestKeyPairId != responseKeyPairId)
                    throw new MslKeyExchangeException(MslError.KEYX_RESPONSE_REQUEST_MISMATCH, "request " + requestKeyPairId + "; response " + responseKeyPairId).setEntity(masterToken);

                // Unwrap session keys with identified key.
                var privateKey = request.privateKey;
                if (!privateKey)
                    throw new MslKeyExchangeException(MslError.KEYX_PRIVATE_KEY_MISSING, "request Asymmetric private key").setEntity(masterToken);
                var mechanism = request.mechanism;
                var unwrapCryptoContext = createCryptoContext(ctx, requestKeyPairId, mechanism, privateKey, null);
                unwrapCryptoContext.unwrap(response.encryptionKey, WebCryptoAlgorithm.AES_CBC, WebCryptoUsage.ENCRYPT_DECRYPT, {
                    result: function(encryptionKey) {
                        unwrapCryptoContext.unwrap(response.hmacKey, WebCryptoAlgorithm.HMAC_SHA256, WebCryptoUsage.SIGN_VERIFY, {
                            result: function(hmacKey) {
                                ctx.getEntityAuthenticationData(null, {
                                    result: function(entityAuthData) {
                                        AsyncExecutor(callback, function() {
                                            // Create crypto context.
                                            var identity = entityAuthData.getIdentity();
                                            var responseMasterToken = response.masterToken;
                                            return new SessionCryptoContext(ctx, responseMasterToken, identity, encryptionKey, hmacKey);
                                        }, self);
                                    },
                                    error: function(e) {
                                        AsyncExecutor(callback, function() {
                                            if (e instanceof MslException)
                                                e.setEntity(masterToken);
                                            throw e;
                                        }, self);
                                    }
                                });
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException)
                                        e.setEntity(masterToken);
                                    throw e;
                                }, self);
                            }
                        });
                    },
                    error: function(e) {
                        AsyncExecutor(callback, function() {
                            if (e instanceof MslException)
                                e.setEntity(masterToken);
                            throw e;
                        }, self);
                    }
                });
            }, self);
        },
    });
})();



// -- javascript/msg/ClarinetParser.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * A clarinet parser parses the provided sequence of JSON values into
 * JavaScript values using the clarinet library.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var ClarinetParser = util.Class.create({
    /**
     * @param {string} json the sequence of JSON values.
     */
    init: function init(json) {
        var parser = clarinet.parser();
        var values = new Array();
        var stack = new Array();
        var currentObject;
        var currentArray;
        var currentKey;
        var lastIndex = 0;

        // Attach my methods to the parser.

        var error = false;
        /**
         * @param {Error} e the error.
         */
        parser.onerror = function onError(e) {
            // Stop parsing. We must only do this once to prevent a
            // recursive call into ourselves if ending in a bad state.
            if (!error) {
                error = true;
                parser.end();
            }
        };

        /**
         * @param {string} key the first key in the object.
         */
        parser.onopenobject = function onOpenObject(key) {
            if (currentObject) {
                currentObject[currentKey] = {};
                stack.push(currentObject);
                currentObject = currentObject[currentKey];
            } else if (currentArray) {
                var newObj = {};
                stack.push(currentArray);
                currentArray.push(newObj);
                currentObject = newObj;
                currentArray = undefined;
            } else {
                currentObject = {};
            }
            currentKey = key;
        };

        parser.oncloseobject = function onCloseObject() {
            var prev = stack.pop();
            if (!prev) {
                values.push(currentObject);
                lastIndex = parser.index;
                currentObject = undefined;
            } else {
                if (typeof prev === 'object') {
                    currentObject = prev;
                } else {
                    currentObject = undefined;
                    currentArray = prev;
                }
            }
        };

        parser.onopenarray = function onOpenArray() {
            if (currentObject) {
                currentObject[currentKey] = [];
                stack.push(currentObject);
                currentArray = currentObject[currentKey];
                currentObject = undefined;
            } else if (currentArray) {
                var newArr = [];
                stack.push(currentArray);
                currentArray.push(newArr);
                currentArray = newArr;
            } else {
                currentArray = [];
            }
        };

        parser.onclosearray = function onCloseArray() {
            var prev = stack.pop();
            if (!prev) {
                values.push(currentArray);
                lastIndex = parser.index;
                currentArray = undefined;
            } else {
                if (typeof prev === 'object') {
                    currentObject = prev;
                    currentArray = undefined;
                } else {
                    currentArray = prev;
                }
            }
        };

        /**
         * @param {string} key the key.
         */
        parser.onkey = function onKey(key) {
            currentKey = key;
        };

        /**
         * @param {*} the value.
         */
        parser.onvalue = function onValue(value) {
            if (currentObject) {
                currentObject[currentKey] = value;
            } else if (currentArray) {
                currentArray.push(value);
            } else {
                values.push(value);
                lastIndex = parser.index;
            }
        };

        // Parse.
        parser.write(json).close();

        // The properties.
        var props = {
                _values: { value: values, writable: false, enumerable: false, configurable: false },
                _lastIndex: { value: lastIndex, writable: true, enumerable: false, configurable: false },
        };
        Object.defineProperties(this, props);
    },

    /**
     * @return {boolean} true if there are more values available.
     */
    more: function more() {
        return this._values.length > 0;
    },

    /**
     * @return {string|number|object|array|boolean|null} the next value or
     *         undefined if there is none.
     */
    nextValue: function nextValue() {
        if (this._values.length == 0)
            return undefined;
        return this._values.shift();
    },

    /**
     * @return {number} the index of the last character successfully parsed
     *         into a value.
     */
    lastIndex: function lastIndex() {
        return this._lastIndex;
    },
});



// -- javascript/msg/Header.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A MSL header contains entity authentication data or a master token
 * identifying the message sender and data used to authenticate the header
 * data. Portions of the header may be encrypted.</p>
 *
 * <p>A message header is represented as
 * {@code
 * header = {
 *   "#mandatory" : [ "headerdata", "signature" ],
 *   "#conditions" : [ "entityauthdata xor mastertoken" ],
 *   "entityauthdata" : entityauthdata,
 *   "mastertoken" : mastertoken,
 *   "headerdata" : "base64",
 *   "signature" : "base64"
 * }} where:
 * <ul>
 * <li>{@code entityauthdata} is the entity authentication data (mutually exclusive with mastertoken)</li>
 * <li>{@code mastertoken} is the master token (mutually exclusive with entityauthdata)</li>
 * <li>{@code headerdata} is the Base64-encoded encrypted header data (headerdata)</li>
 * <li>{@code signature} is the Base64-encoded verification data of the header data</li>
 * </ul></p>
 *
 * <p>An error header is represented as
 * {@code
 * errorheader = {
 *   "#mandatory" : [ "entityauthdata", "errordata", "signature" ],
 *   "entityauthdata" : entityauthdata,
 *   "errordata" : "base64",
 *   "signature" : "base64"
 * }} where:
 * <ul>
 * <li>{@code entityauthdata} is the entity authentication data</li>
 * <li>{@code errordata} is the Base64-encoded encrypted error data (errordata)</li>
 * <li>{@code signature} is the Base64-encoded verification data of the error data</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var Header$parseHeader;
var Header$KEY_ENTITY_AUTHENTICATION_DATA;
var Header$KEY_MASTER_TOKEN;
var Header$KEY_HEADERDATA;
var Header$KEY_ERRORDATA;
var Header$KEY_SIGNATURE;

(function() {
    /**
     * JSON key entity authentication data.
     * @const
     * @type {string}
     */
    var KEY_ENTITY_AUTHENTICATION_DATA = Header$KEY_ENTITY_AUTHENTICATION_DATA = "entityauthdata";
    /**
     * JSON key master token.
     * @const
     * @type {string}
     */
    var KEY_MASTER_TOKEN = Header$KEY_MASTER_TOKEN = "mastertoken";
    /**
     * JSON key header data.
     * @const
     * @type {string}
     */
    var KEY_HEADERDATA = Header$KEY_HEADERDATA = "headerdata";
    /**
     * JSON key error data.
     * @const
     * @type {string}
     */
    var KEY_ERRORDATA = Header$KEY_ERRORDATA = "errordata";
    /**
     * JSON key error data signature.
     * @const
     * @type {string}
     */
    var KEY_SIGNATURE = Header$KEY_SIGNATURE = "signature";

    /**
     * <p>Construct a new header from the provided JSON object.</p>
     * 
     * <p>Headers are encrypted and signed. If a master token is found, it will
     * be used for this purpose. Otherwise the crypto context appropriate for
     * the entity authentication scheme will be used.</p>
     * 
     * <p>For message headers the master token or entity authentication data
     * must be found. For error headers the entity authentication data must be
     * found.</p>
     * 
     * <p>Service tokens will be decrypted and verified with the provided crypto
     * contexts identified by token name. A default crypto context may be
     * provided by using the empty string as the token name; if a token name is
     * not explcitly mapped onto a crypto context, the default crypto context
     * will be used.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {Object} headerJO header JSON object.
     * @param {Object.<string,ICryptoContext>} cryptoContexts the map of service token names onto crypto
     *        contexts used to decrypt and verify service tokens.
     * @param {{result: function(MessageHeader|ErrorHeader), error: function(Error)}}
     *        callback the callback functions that will receive the header or
     *        or any thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException if there is an error decrypting or verifying
     *         the message.
     * @throws MslEntityAuthException if unable to create the entity
     *         authentication data.
     * @throws MslKeyExchangeException if unable to create the key request data
     *         or key response data.
     * @throws MslUserAuthException if unable to create the user authentication
     *         data.
     * @throws MslMessageException if the header signature is invalid.
     * @throws MslException if the message does not contain an entity
     *         authentication data or a master token or a token is improperly
     *         bound to another token.
     */
    Header$parseHeader = function Header$parseHeader(ctx, headerJO, cryptoContexts, callback) {
        AsyncExecutor(callback, function() {
            // Pull message data.
            var entityAuthDataJo = headerJO[KEY_ENTITY_AUTHENTICATION_DATA];
            var masterTokenJo = headerJO[KEY_MASTER_TOKEN];
            var signatureB64 = headerJO[KEY_SIGNATURE];

            // Verify message data.
            if ((entityAuthDataJo && typeof entityAuthDataJo !== 'object') ||
                (masterTokenJo && typeof masterTokenJo !== 'object') ||
                typeof signatureB64 !== 'string')
            {
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "header/errormsg " + JSON.stringify(headerJO));
            }
            // Reconstruct signature.
            var signature;
            try {
                signature = base64$decode(signatureB64);
            } catch (e) {
                throw new MslMessageException(MslError.HEADER_SIGNATURE_INVALID, "header/errormsg " + JSON.stringify(headerJO), e);
            }

            // Reconstruct entity authentication data.
            var entityAuthData = null;
            if (entityAuthDataJo)
                entityAuthData = EntityAuthenticationData$parse(ctx, entityAuthDataJo);

            // Process message headers.
            var headerdata = headerJO[KEY_HEADERDATA];
            if (headerdata != undefined && headerdata != null) {
                if (typeof headerdata !== 'string')
                    throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "header/errormsg " + JSON.stringify(headerJO));

                // Reconstruct master token.
                if (masterTokenJo) {
                    MasterToken$parse(ctx, masterTokenJo, {
                        result: function(masterToken) {
                            MessageHeader$parse(ctx, headerdata, entityAuthData, masterToken, signature, cryptoContexts, callback);
                        },
                        error: function(err) { callback.error(err); }
                    });
                    return;
                } else {
                    MessageHeader$parse(ctx, headerdata, entityAuthData, null, signature, cryptoContexts, callback);
                    return;
                }
            }

            // Process error headers.
            var errordata = headerJO[KEY_ERRORDATA];
            if (errordata != undefined && errordata != null) {
                if (typeof errordata !== 'string')
                    throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "header/errormsg " + JSON.stringify(headerJO));
                ErrorHeader$parse(ctx, errordata, entityAuthData, signature, callback);
                return;
            }

            // Unknown header.
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, JSON.stringify(headerJO));
        });
    };
})();



// -- javascript/msg/ErrorHeader.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>The error data is represented as
 * {@code
 * errordata = {
 *   "#mandatory" : [ "messageid", "errorcode" ],
 *   "recipient" : "string",
 *   "messageid" : "int64(0,-)",
 *   "errorcode" : "int32(0,-)",
 *   "internalcode" : "int32(0,-)",
 *   "errormsg" : "string",
 *   "usermsg" : "string",
 * }} where:
 * <ul>
 * <li>{@code recipient} is the intended recipient's entity identity</li>
 * <li>{@code messageid} is the message ID</li>
 * <li>{@code errorcode} is the error code</li>
 * <li>{@code internalcode} is an service-specific error code</li>
 * <li>{@code errormsg} is a developer-consumable error message</li>
 * <li>{@code usermsg} is a user-consumable localized error message</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var ErrorHeader;
var ErrorHeader$create;
var ErrorHeader$parse;

(function() {
    "use strict";

    // Message error data.
    /**
     * JSON key recipient.
     * @const
     * @type {string}
     */
    var KEY_RECIPIENT = "recipient";
    /**
     * JSON key message ID.
     * @const
     * @type {string}
     */
    var KEY_MESSAGE_ID = "messageid";
    /**
     * JSON key error code.
     * @const
     * @type {string}
     */
    var KEY_ERROR_CODE = "errorcode";
    /**
     * JSON key internal code.
     * @const
     * @type {string}
     */
    var KEY_INTERNAL_CODE = "internalcode";
    /**
     * JSON key error message.
     * @const
     * @type {string}
     */
    var KEY_ERROR_MESSAGE = "errormsg";
    /**
     * JSON key user message.
     * @const
     * @type {string}
     */
    var KEY_USER_MESSAGE = "usermsg";

    /**
     * Create a new error data container object.
     *
     * @param {Uint8Array} errordata raw error data.
     * @param {Uint8Array} signature raw signature.
     * @constructor
     */
    function CreationData(errordata, signature) {
        this.errordata = errordata;
        this.signature = signature;
    }

    ErrorHeader = util.Class.create({
        /**
         * <p>Construct a new error header with the provided error data.</p>
         * 
         * <p>Headers are encrypted and signed using the crypto context appropriate
         * for the entity authentication scheme.</p>
         *
         * @param {MslContext} ctx MSL context.
         * @param {EntityAuthenticationData} entityAuthData the entity authentication data.
         * @param {?string} recipient the intended recipient's entity identity. May be null.
         * @param {number} messageId the message ID.
         * @param {MslConstants$ResponseCode} errorCode the error code.
         * @param {number} internalCode the internal code. Negative to indicate no code.
         * @param {?string} errorMsg the error message. May be null.
         * @param {?string} userMsg the user message. May be null.
         * @param {?CreationData} creationData optional creation data.
         * @param {{result: function(ErrorHeader), error: function(Error)}}
         *        callback the callback functions that will receive the error
         *        header or any thrown exceptions.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the message.
         * @throws MslEntityAuthException if there is an error with the entity
         *         authentication data.
         * @throws MslMessageException if no entity authentication data is
         *         provided.
         */
        init: function init(ctx, entityAuthData, recipient, messageId, errorCode, internalCode, errorMsg, userMsg, creationData, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                if (internalCode < 0)
                    internalCode = -1;

                // Message ID must be within range.
                if (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE)
                    throw new MslInternalException("Message ID " + messageId + " is out of range.");

                // Message entity must be provided.
                if (!entityAuthData)
                    throw new MslMessageException(MslError.MESSAGE_ENTITY_NOT_FOUND);

                // Construct the error data.
                if (!creationData) {
                    // Construct the JSON.
                    var errorJO = {};
                    if (recipient) errorJO[KEY_RECIPIENT] = recipient;
                    errorJO[KEY_MESSAGE_ID] = messageId;
                    errorJO[KEY_ERROR_CODE] = errorCode;
                    if (internalCode > 0) errorJO[KEY_INTERNAL_CODE] = internalCode;
                    if (errorMsg) errorJO[KEY_ERROR_MESSAGE] = errorMsg;
                    if (userMsg) errorJO[KEY_USER_MESSAGE] = userMsg;

                    // Create the crypto context.
                    var cryptoContext;
                    try {
                        var factory = ctx.getEntityAuthenticationFactory(entityAuthData.scheme);
                        cryptoContext = factory.getCryptoContext(ctx, entityAuthData);
                    } catch (e) {
                        if (e instanceof MslException) {
                            e.setEntity(entityAuthData);
                            e.setMessageId(messageId);
                        }
                        throw e;
                    }

                    // Encrypt and sign the error data.
                    var plaintext = textEncoding$getBytes(JSON.stringify(errorJO), MslConstants$DEFAULT_CHARSET);
                    cryptoContext.encrypt(plaintext, {
                        result: function(errordata) {
                            AsyncExecutor(callback, function() {
                                cryptoContext.sign(errordata, {
                                    result: function(signature) {
                                        AsyncExecutor(callback, function() {
                                            // The properties.
                                            var props = {
                                                    entityAuthenticationData: { value: entityAuthData, writable: false, configurable: false },
                                                    recipient: { value: recipient, writable: false, configurable: false },
                                                    messageId: { value: messageId, writable: false, configurable: false },
                                                    errorCode: { value: errorCode, writable: false, configurable: false },
                                                    internalCode: { value: internalCode, writable: false, configurable: false },
                                                    errorMessage: { value: errorMsg, writable: false, configurable: false },
                                                    userMessage: { value: userMsg, writable: false, configurable: false },
                                                    errordata: { value: errordata, writable: false, enumerable: false, configurable: false },
                                                    signature: { value: signature, writable: false, enumerable: false, configurable: false }
                                            };
                                            Object.defineProperties(this, props);
                                            return this;
                                        }, self);
                                    },
                                    error: function(e) {
                                        AsyncExecutor(callback, function() {
                                            if (e instanceof MslException) {
                                                e.setEntity(entityAuthData);
                                                e.setMessageId(messageId);
                                            }
                                            throw e;
                                        }, self);
                                    }
                                });
                            }, self);
                        },
                        error: function(e) {
                            AsyncExecutor(callback, function() {
                                if (e instanceof MslException) {
                                    e.setEntity(entityAuthData);
                                    e.setMessageId(messageId);
                                }
                                throw e;
                            }, self);
                        }
                    });
                } else {
                    var errordata = creationData.errordata;
                    var signature = creationData.signature;

                    // The properties.
                    var props = {
                            entityAuthenticationData: { value: entityAuthData, writable: false, configurable: false },
                            recipient: { value: recipient, writable: false, configurable: false },
                            messageId: { value: messageId, writable: false, configurable: false },
                            errorCode: { value: errorCode, writable: false, configurable: false },
                            internalCode: { value: internalCode, writable: false, configurable: false },
                            errorMessage: { value: errorMsg, writable: false, configurable: false },
                            userMessage: { value: userMsg, writable: false, configurable: false },
                            errordata: { value: errordata, writable: false, enumerable: false, configurable: false },
                            signature: { value: signature, writable: false, enumerable: false, configurable: false }
                    };
                    Object.defineProperties(this, props);
                    return this;
                };
            }, self);
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            var jsonObj = {};
            jsonObj[Header$KEY_ENTITY_AUTHENTICATION_DATA] = this.entityAuthenticationData;
            jsonObj[Header$KEY_ERRORDATA] = base64$encode(this.errordata);
            jsonObj[Header$KEY_SIGNATURE] = base64$encode(this.signature);
            return jsonObj;
        },
    });

    /**
     * <p>Construct a new error header from the provided JSON object.</p>
     * 
     * <p>Headers are encrypted and signed using the crypto context appropriate
     * for the entity authentication scheme.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {EntityAuthenticationData} entityAuthData the entity authentication data.
     * @param {?string} recipient the intended recipient's entity identity. May be null.
     * @param {number} messageId the message ID.
     * @param {MslConstants$ResponseCode} errorCode the error code.
     * @param {number} internalCode the internal code. Negative to indicate no code.
     * @param {?string} errorMsg the error message. May be null.
     * @param {?string} userMsg the user message. May be null.
     * @param {{result: function(ErrorHeader), error: function(Error)}}
     *        callback the callback functions that will receive the error
     *        header or any thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the message.
     * @throws MslEntityAuthException if there is an error with the entity
     *         authentication data.
     */
    ErrorHeader$create = function ErrorHeader$create(ctx, entityAuthData, recipient, messageId, errorCode, internalCode, errorMsg, userMsg, callback) {
        new ErrorHeader(ctx, entityAuthData, recipient, messageId, errorCode, internalCode, errorMsg, userMsg, null, callback);
    };

    /**
     * Construct a new error header from the provided JSON object.
     *
     * Headers are encrypted and signed using the crypto context appropriate
     * for the entity authentication scheme.
     *
     * @param {MslContext} ctx MSL context.
     * @param {string} errordata error data JSON representation.
     * @param {EntityAuthenticationData} entityAuthData the entity authentication data.
     * @param {Uint8Array} signature the header signature.
     * @param {{result: function(ErrorHeader), error: function(Error)}}
     *        callback the callback functions that will receive the error
     *        header or any thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException if there is an error decrypting or verifying
     *         the header.
     * @throws MslEntityAuthException if the entity authentication data is not
     *         supported or erroneous.
     * @throws MslMessageException if there is no entity authentication data
     *         (null) or the error data is missing or the message ID is
     *         negative or the internal code is negative.
     */
    ErrorHeader$parse = function ErrorHeader$parse(ctx, errordata, entityAuthData, signature, callback) {
        AsyncExecutor(callback, function() {
            if (!entityAuthData)
                throw new MslMessageException(MslError.MESSAGE_ENTITY_NOT_FOUND);

            var cryptoContext;
            try {
                var scheme = entityAuthData.scheme;
                var factory = ctx.getEntityAuthenticationFactory(scheme);
                if (!factory)
                    throw new MslEntityAuthException(MslError.ENTITYAUTH_FACTORY_NOT_FOUND, scheme);
                cryptoContext = factory.getCryptoContext(ctx, entityAuthData);
            } catch (e) {
                if (e instanceof MslException)
                    e.setEntity(entityAuthData);
                throw e;
            }

            // Verify and decrypt the error data.
            try {
                errordata = base64$decode(errordata);
            } catch (e) {
                throw new MslMessageException(MslError.HEADER_DATA_INVALID, errordata, e).setEntity(entityAuthData);
            }
            if (!errordata || errordata.length == 0)
                throw new MslMessageException(MslError.HEADER_DATA_MISSING, errordata).setEntity(entityAuthData);
            cryptoContext.verify(errordata, signature, {
                result: function(verified) {
                    AsyncExecutor(callback, function() {
                        if (!verified)
                            throw new MslCryptoException(MslError.MESSAGE_VERIFICATION_FAILED).setEntity(entityAuthData);
                        cryptoContext.decrypt(errordata, {
                            result: function(plaintext) {
                                AsyncExecutor(callback, function() {
                                    // Reconstruct error data.
                                    var errordataJson = textEncoding$getString(plaintext, MslConstants$DEFAULT_CHARSET);
                                    var errordataJO;
                                    try {
                                        errordataJO = JSON.parse(errordataJson);
                                    } catch (e) {
                                        if (e instanceof SyntaxError)
                                            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "errordata " + errordataJson, e).setEntity(entityAuthData);
                                        throw e;
                                    }

                                    // Pull the error data.
                                    var recipient = (errordataJO[KEY_RECIPIENT] !== undefined) ? errordataJO[KEY_RECIPIENT] : null;
                                    var messageId = parseInt(errordataJO[KEY_MESSAGE_ID]);
                                    var errorCode = parseInt(errordataJO[KEY_ERROR_CODE]);
                                    var internalCode = parseInt(errordataJO[KEY_INTERNAL_CODE]);
                                    var errorMsg = errordataJO[KEY_ERROR_MESSAGE];
                                    var userMsg = errordataJO[KEY_USER_MESSAGE];

                                    // Verify the error data.
                                    if ((recipient && typeof recipient !== 'string') ||
                                        !messageId || messageId != messageId ||
                                        !errorCode || errorCode != errorCode ||
                                        (errordataJO[KEY_INTERNAL_CODE] && internalCode != internalCode) ||
                                        (errorMsg && typeof errorMsg !== 'string') ||
                                        (userMsg && typeof userMsg !== 'string'))
                                    {
                                        throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "errordata " + errordataJson).setEntity(entityAuthData);
                                    }

                                    // The message ID must be within range.
                                    if (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE)
                                        throw new MslMessageException(MslError.MESSAGE_ID_OUT_OF_RANGE, "errordata " + errordataJson).setEntity(entityAuthData);

                                    // If we do not recognize the error code then default to fail.
                                    var recognized = false;
                                    for (var code in MslConstants$ResponseCode) {
                                        if (MslConstants$ResponseCode[code] == errorCode) {
                                            recognized = true;
                                            break;
                                        }
                                    }
                                    if (!recognized)
                                        errorCode = MslConstants$ResponseCode.FAIL;

                                    // The parsed internal code cannot be negative.
                                    if (internalCode) {
                                        if (internalCode < 0)
                                            throw new MslMessageException(MslError.INTERNAL_CODE_NEGATIVE, "errordata " + errordataJson).setEntity(entityAuthData).setMessageId(messageId);
                                    } else {
                                        internalCode = -1;
                                    }

                                    // Return the error header.
                                    var creationData = new CreationData(errordata, signature);
                                    new ErrorHeader(ctx, entityAuthData, recipient, messageId, errorCode, internalCode, errorMsg, userMsg, creationData, callback);
                                });
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException)
                                        e.setEntity(entityAuthData);
                                    throw e;
                                });
                            }
                        });
                    });
                },
                error: function(e) {
                    AsyncExecutor(callback, function() {
                        if (e instanceof MslException)
                            e.setEntity(entityAuthData);
                        throw e;
                    });
                }
            });
        });
    };
})();



// -- javascript/msg/ErrorMessageRegistry.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>The error message registry is used to provide localized user-consumable
 * messages for specific MSL errors.</p>
 * 
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var ErrorMessageRegistry = util.Class.create({
    /**
     * Returns the user-consumable message associated with the given MSL error
     * or non-MSL error, localized according to the list of preferred
     * languages.
     * 
     * @param {MslError|Error} error MSL error or non-MSL error.
     * @param {Array.<String>} languages preferred languages as BCP-47 codes in descending
     *        order. May be {@code null}.
     * @return {String} the localized user message or {@code null} if there is none.
     */
    getUserMessage: function(error, languages) {},
});



// -- javascript/msg/MessageCapabilities.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>The message capabilities identify the features supported by the message
 * sender.</p>
 * 
 * <p>The message capabilities are represented as
 * {@code
 * capabilities = {
 *   "compressionalgos" : [ enum(GZIP|LZW) ],
 *   "languages" : [ "string" ],
 * }} where:
 * <ul>
 * <li>{@code compressionalgos} is the set of supported compression algorithms</li>
 * <li>{@code languages} is the preferred list of BCP-47 languages in descending order</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MessageCapabilities;
var MessageCapabilities$parse;
var MessageCapabilities$intersection;

(function() {
    /**
     * JSON key compression algorithms.
     * @const
     * @type {string}
     */
    var KEY_COMPRESSION_ALGOS = "compressionalgos";
    /**
     * JSON key languages.
     * @const
     * @type {string}
     */
    var KEY_LANGUAGES = "languages";
    
    /**
     * Computes and returns the intersection of two message capabilities.
     * 
     * @param {?MessageCapabilities} mc1 first message capabilities. May be {@code null}.
     * @param {?MessageCapabilities} mc2 second message capabilities. May be {@code null}.
     * @return {?MessageCapabilities} the intersection of message capabilities or {@code null} if one
     *         of the message capabilities is {@code null}.
     */
    MessageCapabilities$intersection = function MessageCapabilities$intersection(mc1, mc2) {
        if (!mc1 || !mc2)
            return null;
        
        // Compute the intersection of compression algorithms.
        var compressionAlgos = mc1.compressionAlgorithms.filter(function(algo) {
            for (var i = 0; i < mc2.compressionAlgorithms.length; ++i) {
                if (algo == mc2.compressionAlgorithms[i])
                    return true;
            }
            return false;
        });
        
        // Compute the intersection of languages. This may not respect order.
        var languages = mc1.languages.filter(function(lang) {
            for (var i = 0; i < mc2.languages.length; ++i) {
                if (lang == mc2.languages[i])
                    return true;
            }
            return false;
        });
        
        return new MessageCapabilities(compressionAlgos, languages);
    };

    MessageCapabilities = util.Class.create({
        /**
         * Create a new message capabilities object with the specified supported
         * features.
         *
         * @param {Array.<MslConstants$CompressionAlgorithm>} compressionAlgos supported payload compression algorithms.
         * @param {Array.<String>} languages preferred languages as BCP-47 codes in descending
         *        order. May be {@code null}.
         */
        init: function init(compressionAlgos, languages) {
            if (!compressionAlgos)
                compressionAlgos = [];
            if (!languages)
                languages = [];
            compressionAlgos.sort();

            // The properties.
            var props = {
                /** @type {Array.<MslConstants$CompressionAlgorithm>} */
                compressionAlgorithms: { value: compressionAlgos, writable: false, enumerable: true, configurable: false },
                /** @type {Array.<String>} */
                languages: { value: languages, writable: false, enumerable: true, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            var result = {};
            result[KEY_COMPRESSION_ALGOS] = this.compressionAlgorithms;
            result[KEY_LANGUAGES] = this.languages;
            return result;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof MessageCapabilities)) return false;
            return Arrays$containEachOther(this.compressionAlgorithms, that.compressionAlgorithms) &&
                   Arrays$containEachOther(this.languages, that.languages);
        },

        /** @inheritDoc */
        uniqueKey: function uniqueKey() {
            return this.compressionAlgorithms.join(':') + '|' + this.languages.join(':');
        },
    });

    /**
     * Construct a new message capabilities object from the provided JSON
     * object.
     *
     * @param {Object} capabilitiesJO the JSON object.
     * @throws MslEncodingException if there is an error parsing the JSON.
     */
    MessageCapabilities$parse = function MessageCapabilities$parse(capabilitiesJO) {
        // Pull the capabilities.
        var algos = capabilitiesJO[KEY_COMPRESSION_ALGOS];
        var langs = capabilitiesJO[KEY_LANGUAGES];

        // Verify compression algorithms.
        if ((algos && !(algos instanceof Array)) ||
            (langs && !(langs instanceof Array)))
        {
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "capabilities " + JSON.stringify(capabilitiesJO));
        }

        // Extract compression algorithms.
        var compressionAlgos = [];
        for (var i = 0; algos && i < algos.length; ++i) {
            var algo = algos[i];
            // Ignore unsupported algorithms.
            if (MslConstants$CompressionAlgorithm[algo])
                compressionAlgos.push(algo);
        }

        // Return the capabilities.
        return new MessageCapabilities(compressionAlgos, langs);
    };
})();



// -- javascript/msg/MessageHeader.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>If a master token exists, the header data chunks will be encrypted and
 * verified using the master token. The sender will also be included. If no
 * master token exists, the header data will be verified and encrypted based on
 * the entity authentication scheme.</p>
 *
 * <p>If peer tokens exist, the message recipient is expected to use the peer
 * master token to secure its response and send the peer user ID token and peer
 * service tokens back in the header data. The request's tokens should be
 * included as the response's peer tokens.</p>
 *
 * <p>If key response data exists, it applies to the token set the receiving
 * entity uses to identify itself. In a trusted services network the key
 * response data applies to the primary tokens. In a peer-to-peer network the
 * key response data applies to the peer tokens.</p>
 *
 * <p>The header data is represented as
 * {@code
 * headerdata = {
 *   "#mandatory" : [ "messageid", "renewable" ],
 *   "sender" : "string",
 *   "messageid" : "int64(0,2^53^)",
 *   "nonreplayableid" : "int64(0,2^53^)",
 *   "renewable" : "boolean",
 *   "capabilities" : capabilities,
 *   "keyrequestdata" : [ keyrequestdata ],
 *   "keyresponsedata" : keyresponsedata,
 *   "userauthdata" : userauthdata,
 *   "useridtoken" : useridtoken,
 *   "servicetokens" : [ servicetoken ],
 *   "peermastertoken" : mastertoken,
 *   "peeruseridtoken" : useridtoken,
 *   "peerservicetokens" : [ servicetoken ]
 * }} where:
 * <ul>
 * <li>{@code sender} is the sender entity identity</li>
 * <li>{@code messageid} is the message ID</li>
 * <li>{@code nonreplayableid} is the non-replayable ID</li>
 * <li>{@code renewable} indicates if the master token and user ID are renewable</li>
 * <li>{@code capabilities} lists the sender's message capabilities</li>
 * <li>{@code keyrequestdata} is session key request data</li>
 * <li>{@code keyresponsedata} is the session key response data</li>
 * <li>{@code userauthdata} is the user authentication data</li>
 * <li>{@code useridtoken} is the user ID token</li>
 * <li>{@code servicetokens} are the service tokens</li>
 * <li>{@code peermastertoken} is the peer master token</li>
 * <li>{@code peeruseridtoken} is the peer user ID token</li>
 * <li>{@code peerservicetokens} are the peer service tokens</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MessageHeader;
var MessageHeader$create;
var MessageHeader$parse;
var MessageHeader$HeaderData;
var MessageHeader$HeaderPeerData;

(function() {
    // Message header data.
    /**
     * JSON key sender.
     * @const
     * @type {string}
     */
    var KEY_SENDER = "sender";
    /**
     * JSON key message ID.
     * @const
     * @type {string}
     */
    var KEY_MESSAGE_ID = "messageid";
    /**
     * JSON key non-replayable ID.
     * @const
     * @type {string}
     */
    var KEY_NON_REPLAYABLE_ID = "nonreplayableid";
    /**
     * JSON key renewalble flag.
     * @const
     * @type {string}
     */
    var KEY_RENEWABLE = "renewable";
    /**
     * JSON key capabilities.
     * @const
     * @type {string}
     */
    var KEY_CAPABILITIES = "capabilities";
    /**
     * JSON key key exchange request.
     * @const
     * @type {string}
     */
    var KEY_KEY_REQUEST_DATA = "keyrequestdata";
    /**
     * JSON key key exchange response.
     * @const
     * @type {string}
     */
    var KEY_KEY_RESPONSE_DATA = "keyresponsedata";
    /**
     * JSON key user authentication data.
     * @const
     * @type {string}
     */
    var KEY_USER_AUTHENTICATION_DATA = "userauthdata";
    /**
     * JSON key user ID token.
     * @const
     * @type {string}
     */
    var KEY_USER_ID_TOKEN = "useridtoken";
    /**
     * JSON key service tokens.
     * @const
     * @type {string}
     */
    var KEY_SERVICE_TOKENS = "servicetokens";

    // Message header peer data.
    /**
     * JSON key peer master token.
     * @const
     * @type {string}
     */
    var KEY_PEER_MASTER_TOKEN = "peermastertoken";
    /**
     * JSON key peer user ID token.
     * @const
     * @type {string}
     */
    var KEY_PEER_USER_ID_TOKEN = "peeruseridtoken";
    /**
     * JSON key peer service tokens.
     * @const
     * @type {string}
     */
    var KEY_PEER_SERVICE_TOKENS = "peerservicetokens";

    /**
     * Container struct for message header data.
     */
    var HeaderData = MessageHeader$HeaderData = util.Class.create({
        /**
         * @param {number} messageId the message ID.
         * @param {number} nonReplayableId the message's non-replayable ID. May be null.
         * @param {boolean} renewable the message's renewable flag.
         * @param {MessageCapabilities} capabilities the sender's message capabilities.
         * @param {Array.<KeyRequestData>} keyRequestData session key request data. May be null or
         *        empty.
         * @param {KeyResponseData} keyResponseData session key response data. May be null.
         * @param {UserAuthenticationData} userAuthData the user authentication data. May be null if a
         *        user ID token is provided or there is no user authentication
         *        for this message.
         * @param {UserIdToken} userIdToken the user ID token. May be null if user
         *        authentication data is provided or there is no user
         *        authentication for this message.
         * @param {Array.<ServiceToken>} serviceTokens the service tokens. May be empty.
         */
        init: function init(messageId, nonReplayableId, renewable, capabilities,
            keyRequestData, keyResponseData,
            userAuthData, userIdToken,
            serviceTokens)
        {
            // The properties.
            var props = {
                messageId: { value: messageId, writable: false, configurable: false },
                nonReplayableId: { value: nonReplayableId, writable: false, configurable: false },
                renewable: { value: renewable, writable: false, configurable: false },
                capabilities: { value: capabilities, writable: false, configurable: false },
                keyRequestData: { value: keyRequestData, writable: false, configurable: false },
                keyResponseData: { value: keyResponseData, writable: false, configurable: false },
                userAuthData: { value: userAuthData, writable: false, configurable: false },
                userIdToken: { value: userIdToken, writable: false, configurable: false },
                serviceTokens: { value: serviceTokens, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },
    });

    /**
     * Container struct for header peer data.
     */
    var HeaderPeerData = MessageHeader$HeaderPeerData = util.Class.create({
        /**
         * @param {MasterToken} peerMasterToken peer master token. May be null.
         * @param {UserIdToken} peerUserIdToken peer user ID token. May be null if there is
         *        no user authentication for the peer.
         * @param {Array.<ServiceToken>} peerServiceTokens peer service tokens. May be empty.
         */
        init: function init(peerMasterToken, peerUserIdToken,
            peerServiceTokens)
        {
            // The properties.
            var props = {
                peerMasterToken: { value: peerMasterToken, writable: false, configurable: false },
                peerUserIdToken: { value: peerUserIdToken, writable: false, configurable: false },
                peerServiceTokens: { value: peerServiceTokens, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },
    });

    /**
     * Create a new token data container object.
     *
     * @param {CustomerKey} customer customer.
     * @param {string} sender message sender.
     * @param {ICryptoContext} messageCryptoContext message crypto context.
     * @param {Uint8Array} headerdata raw header data.
     * @param {Uint8Array} signature raw signature.
     * @constructor
     */
    function CreationData(customer, sender, messageCryptoContext, headerdata, signature) {
        this.customer = customer;
        this.sender = sender;
        this.messageCryptoContext = messageCryptoContext;
        this.headerdata = headerdata;
        this.signature = signature;
    };

    /**
     * Return a properties configuration for the provided property values.
     *
     * @param {MslContext} ctx
     * @param {ICryptoContext} messageCryptoContext
     * @param {CustomerKey} cutomer
     * @param {EntityAuthenticationData} entityAuthData
     * @param {MasterToken} masterToken
     * @param {string} sender
     * @param {number} messageId
     * @param {Array.<KeyRequestData>} keyRequestData
     * @param {KeyResponseData} keyResponseData
     * @param {UserAuthenticationData} userAuthData
     * @param {UserIdToken} userIdToken
     * @param {Array.<ServiceToken>} serviceTokens
     * @param {MasterToken} peerMasterToken
     * @param {UserIdToken} peerUserIdToken
     * @param {Array.<ServiceToken>} peerServiceTokens
     * @param {number} nonReplayableId
     * @param {boolean} renewable
     * @param {MessageCapabilities} capabilities
     * @param {Uint8Array} headerdata
     * @param {Uint8Array} signature
     * @return {object} the properties configuration.
     */
    function buildProperties(ctx, messageCryptoContext, customer, entityAuthData,
            masterToken, sender, messageId, keyRequestData, keyResponseData,
            userAuthData, userIdToken, serviceTokens,
            peerMasterToken, peerUserIdToken, peerServiceTokens,
            nonReplayableId, renewable, capabilities, headerdata, signature)
    {
        // The properties.
        return {
            /**
             * Returns the crypto context that was used to process the header data.
             * This crypto context should also be used to process the payload data if
             * no key response data is included in the message.
             *
             * @return the header data crypto context.
             * @see #isEncrypting()
             */
            cryptoContext: { value: messageCryptoContext, writable: false, configurable: false },
            /**
             * Returns the customer if the user has been authenticated or a user ID
             * token was provided.
             */
            customer: { value: customer, writable: false, configurable: false },
            /**
             * Returns the entity authentication data. May be null if the entity has
             * already been authenticated and is using a master token instead.
             */
            entityAuthenticationData: { value: entityAuthData, writable: false, configurable: false },
            /**
             * Returns the primary master token identifying the entity and containing
             * the session keys. May be null if the entity has not been authenticated.
             */
            masterToken: { value: masterToken, writable: false, configurable: false },
            sender: { value: sender, writable: false, configurable: false },
            messageId: { value: messageId, writable: false, configurable: false },
            nonReplayableId: { value: nonReplayableId, writable: false, configurable: false },
            keyRequestData: { value: keyRequestData, writable: false, configurable: false },
            keyResponseData: { value: keyResponseData, writable: false, configurable: false },
            /**
             * Returns the user authentication data. May be null if the user has
             * already been authenticated and is using a user ID token or if there is
             * no user authentication requested.
             */
            userAuthenticationData: { value: userAuthData, writable: false, configurable: false },
            /**
             * Returns the primary user ID token identifying the user. May be null if
             * the user has not been authenticated.
             */
            userIdToken: { value: userIdToken, writable: false, configurable: false },
            serviceTokens: { value: serviceTokens, writable: false, configurable: false },
            /**
             * Returns the master token that should be used by an entity responding to
             * this message. Will be null if the responding entity should use its own
             * entity authentication data or the primary master token.
             */
            peerMasterToken: { value: peerMasterToken, writable: false, configurable: false },
            /**
             * Returns the user ID token that must be used by an entity responding to
             * this message if an peer master token is provided. May be null if peer
             * user authentication has not occurred. Will be null if there is no peer
             * master token.
             */
            peerUserIdToken: { value: peerUserIdToken, writable: false, configurable: false },
            /**
             * Returns the service tokens that must be used by an entity responding to
             * this message. May be null if the responding entity should use the
             * primary service tokens.
             */
            peerServiceTokens: { value: peerServiceTokens, writable: false, configurable: false },
            /** Message capabilities. */
            messageCapabilities: { value: capabilities, writable: false, configurable: false },
            // Private properties.
            renewable: { value: renewable, writable: false, enumerable: false, configurable: false },
            headerdata: { value: headerdata, writable: false, enumerable: false, configurable: false },
            signature: { value: signature, writable: false, enumerable: false, configurable: false },
        };
    }

    /**
     * Returns the crypto context that should be used for this message header.
     *
     * @param {MslContext} ctx MSL context.
     * @param {?EntityAuthenticationData} entityAuthData the entity
     *        authentication data. May be null if a master token is provided.
     * @param {MasterToken} masterToken the master token. May be null if
     *        entity authentication data is provided.
     * @return {ICryptoContext} the message crypto context.
     * @throws MslMasterTokenException if the header master token is not
     *         trusted and needs to be to accept this message header.
     * @throws MslEntityAuthException if there is an error with the entity
     *         authentication data.
     */
    function getMessageCryptoContext(ctx, entityAuthData, masterToken) {
        if (masterToken) {
            // Use a stored master token crypto context if we have one.
            var cachedCryptoContext = ctx.getMslStore().getCryptoContext(masterToken);

            // If there was no stored crypto context try making one from
            // the master token. We can only do this if we can open up the
            // master token.
            if (!cachedCryptoContext) {
                if (!masterToken.isVerified() || !masterToken.isDecrypted())
                    throw new MslMasterTokenException(MslError.MASTERTOKEN_UNTRUSTED, masterToken);
                return new SessionCryptoContext(ctx, masterToken);
            } else {
                return cachedCryptoContext;
            }
        } else {
            var scheme = entityAuthData.scheme;
            var factory = ctx.getEntityAuthenticationFactory(scheme);
            if (!factory)
                throw new MslEntityAuthException(MslError.ENTITYAUTH_FACTORY_NOT_FOUND, scheme);
            return factory.getCryptoContext(ctx, entityAuthData);
        }
    }

    MessageHeader = util.Class.create({
        /**
         * <p>Construct a new message header with the provided message data.</p>
         *
         * <p>Headers are encrypted and signed. If a master token is provided, it
         * will be used for this purpose. Otherwise the crypto context appropriate
         * for the entity authentication scheme will be used. N.B. Either the
         * entity authentication data or the master token must be provided.</p>
         *
         * <p>Peer tokens are only processed if operating in peer-to-peer mode.</p>
         *
         * @param {MslContext} ctx MSL context.
         * @param {EntityAuthenticationData} entityAuthData the entity authentication data. May be null if a
         *        master token is provided.
         * @param {MaterToken} masterToken the master token. May be null if entity
         *        authentication data is provided.
         * @param {HeaderData} headerData message header data container.
         * @param {HeaderPeerData} peerData message header peer data container.
         * @param {?CreationData} creationData optional creation data.
         * @param {{result: function(MessageHeader), error: function(Error)}}
         *        callback the callback functions that will receive the message
         *        header or any thrown exceptions.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the message.
         * @throws MslMasterTokenException if the header master token is not
         *         trusted and needs to be to accept this message header.
         * @throws MslEntityAuthException if there is an error with the entity
         *         authentication data.
         * @throws MslMessageException if no entity authentication data or master
         *         token is provided.
         */
        init: function init(ctx, entityAuthData, masterToken, headerData, peerData, creationData, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                if (creationData) {
                    construct(creationData.sender);
                } else {
                    if (masterToken) {
                        ctx.getEntityAuthenticationData(null, {
                            result: function(ead) {
                                var sender = ead.getIdentity();
                                construct(sender);
                            },
                            error: callback.error,
                        });
                    } else {
                        construct(null);
                    }
                }
            }, self);

            function construct(sender) {
                AsyncExecutor(callback, function() {
                    entityAuthData = (!masterToken) ? entityAuthData : null;
                    var nonReplayableId = headerData.nonReplayableId;
                    var renewable = headerData.renewable;
                    var capabilities = headerData.capabilities;
                    var messageId = headerData.messageId;
                    var keyRequestData = (headerData.keyRequestData) ? headerData.keyRequestData : new Array();
                    var keyResponseData = headerData.keyResponseData;
                    var userAuthData = headerData.userAuthData;
                    var userIdToken = headerData.userIdToken;
                    var serviceTokens = (headerData.serviceTokens) ? headerData.serviceTokens : new Array();
                    var peerMasterToken, peerUserIdToken, peerServiceTokens;
                    if (ctx.isPeerToPeer()) {
                        peerMasterToken = peerData.peerMasterToken;
                        peerUserIdToken = peerData.peerUserIdToken;
                        peerServiceTokens = (peerData.peerServiceTokens) ? peerData.peerServiceTokens : new Array();
                    } else {
                        peerMasterToken = null;
                        peerUserIdToken = null;
                        peerServiceTokens = new Array();
                    }

                    // Message ID must be within range.
                    if (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE)
                        throw new MslInternalException("Message ID " + messageId + " is out of range.");

                    // Message entity must be provided.
                    if (!entityAuthData && !masterToken)
                        throw new MslInternalException("Message entity authentication data or master token must be provided.");

                    // Grab token verification master tokens.
                    var tokenVerificationMasterToken, peerTokenVerificationMasterToken;
                    if (keyResponseData) {
                        // The key response data is used for token verification in a
                        // trusted services network and peer token verification in a peer-
                        // to-peer network.
                        if (!ctx.isPeerToPeer()) {
                            tokenVerificationMasterToken = keyResponseData.masterToken;
                            peerTokenVerificationMasterToken = peerMasterToken;
                        } else {
                            tokenVerificationMasterToken = masterToken;
                            peerTokenVerificationMasterToken = keyResponseData.masterToken;
                        }
                    } else {
                        tokenVerificationMasterToken = masterToken;
                        peerTokenVerificationMasterToken = peerMasterToken;
                    }

                    // Check token combinations.
                    if (userIdToken && (!tokenVerificationMasterToken || !userIdToken.isBoundTo(tokenVerificationMasterToken)))
                        throw new MslInternalException("User ID token must be bound to a master token.");
                    if (peerUserIdToken && (!peerTokenVerificationMasterToken || !peerUserIdToken.isBoundTo(peerTokenVerificationMasterToken)))
                        throw new MslInternalException("Peer user ID token must be bound to a peer master token.");

                    // All service tokens must be unbound or if bound, bound to the
                    // provided tokens.
                    serviceTokens.forEach(function(serviceToken) {
                        if (serviceToken.isMasterTokenBound() && (!tokenVerificationMasterToken || !serviceToken.isBoundTo(tokenVerificationMasterToken)))
                            throw new MslInternalException("Master token bound service tokens must be bound to the provided master token.");
                        if (serviceToken.isUserIdTokenBound() && (!userIdToken || !serviceToken.isBoundTo(userIdToken)))
                            throw new MslInternalException("User ID token bound service tokens must be bound to the provided user ID token.");
                    }, this);
                    peerServiceTokens.forEach(function(peerServiceToken) {
                        if (peerServiceToken.isMasterTokenBound() && (!peerTokenVerificationMasterToken || !peerServiceToken.isBoundTo(peerTokenVerificationMasterToken)))
                            throw new MslInternalException("Master token bound peer service tokens must be bound to the provided peer master token.");
                        if (peerServiceToken.isUserIdTokenBound() && (!peerUserIdToken || !peerServiceToken.isBoundTo(peerUserIdToken)))
                            throw new MslInternalException("User ID token bound peer service tokens must be bound to the provided peer user ID token.");
                    }, this);

                    // Create the header data.
                    if (!creationData) {
                        // Grab the customer.
                        var customer = (userIdToken) ? userIdToken.customer : null;

                        // Construct the JSON.
                        var headerJO = {};
                        if (sender) headerJO[KEY_SENDER] = sender;
                        headerJO[KEY_MESSAGE_ID] = messageId;
                        if (typeof nonReplayableId === 'number') headerJO[KEY_NON_REPLAYABLE_ID] = nonReplayableId;
                        headerJO[KEY_RENEWABLE] = renewable;
                        if (capabilities) headerJO[KEY_CAPABILITIES] = capabilities;
                        if (keyRequestData.length > 0) headerJO[KEY_KEY_REQUEST_DATA] = keyRequestData;
                        if (keyResponseData) headerJO[KEY_KEY_RESPONSE_DATA] = keyResponseData;
                        if (userAuthData) headerJO[KEY_USER_AUTHENTICATION_DATA] = userAuthData;
                        if (userIdToken) headerJO[KEY_USER_ID_TOKEN] = userIdToken;
                        if (serviceTokens.length > 0) headerJO[KEY_SERVICE_TOKENS] = serviceTokens;
                        if (peerMasterToken) headerJO[KEY_PEER_MASTER_TOKEN] = peerMasterToken;
                        if (peerUserIdToken) headerJO[KEY_PEER_USER_ID_TOKEN] = peerUserIdToken;
                        if (peerServiceTokens.length > 0) headerJO[KEY_PEER_SERVICE_TOKENS] = peerServiceTokens;

                        // Get the correct crypto context.
                        var messageCryptoContext;
                        try {
                            messageCryptoContext = getMessageCryptoContext(ctx, entityAuthData, masterToken);
                        } catch (e) {
                            if (e instanceof MslException) {
                                e.setEntity(masterToken);
                                e.setEntity(entityAuthData);
                                e.setUser(userIdToken);
                                e.setUser(userAuthData);
                                e.setMessageId(messageId);
                            }
                            throw e;
                        }

                        // Encrypt and sign the header data.
                        var plaintext = textEncoding$getBytes(JSON.stringify(headerJO), MslConstants$DEFAULT_CHARSET);
                        messageCryptoContext.encrypt(plaintext, {
                            result: function(headerdata) {
                                AsyncExecutor(callback, function() {
                                    messageCryptoContext.sign(headerdata, {
                                        result: function(signature) {
                                            AsyncExecutor(callback, function() {
                                                var props = buildProperties(ctx, messageCryptoContext, customer, entityAuthData,
                                                    masterToken, sender, messageId, keyRequestData, keyResponseData,
                                                    userAuthData, userIdToken, serviceTokens,
                                                    peerMasterToken, peerUserIdToken, peerServiceTokens,
                                                    nonReplayableId, renewable, capabilities, headerdata, signature);
                                                Object.defineProperties(this, props);
                                                return this;
                                            }, self);
                                        },
                                        error: function(e) {
                                            AsyncExecutor(callback, function() {
                                                if (e instanceof MslException) {
                                                    e.setEntity(masterToken);
                                                    e.setEntity(entityAuthData);
                                                    e.setUser(userIdToken);
                                                    e.setUser(userAuthData);
                                                    e.setMessageId(messageId);
                                                }
                                                throw e;
                                            }, self);
                                        }
                                    });
                                }, self);
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException) {
                                        e.setEntity(masterToken);
                                        e.setEntity(entityAuthData);
                                        e.setUser(userIdToken);
                                        e.setUser(userAuthData);
                                        e.setMessageId(messageId);
                                    }
                                    throw e;
                                }, self);
                            }
                        });
                    } else {
                        var customer = creationData.customer;
                        var messageCryptoContext = creationData.messageCryptoContext;
                        var headerdata = creationData.headerdata;
                        var signature = creationData.signature;
                        
                        var props = buildProperties(ctx, messageCryptoContext, customer, entityAuthData,
                            masterToken, sender, messageId, keyRequestData, keyResponseData,
                            userAuthData, userIdToken, serviceTokens,
                            peerMasterToken, peerUserIdToken, peerServiceTokens,
                            nonReplayableId, renewable, capabilities, headerdata, signature);
                        Object.defineProperties(this, props);
                        return this;
                    }
                }, self);
            }
        },

        /**
         * @return {boolean} true if the message header crypto context provides encryption.
         * @see #getCryptoContext()
         */
        isEncrypting: function isEncrypting() {
            return this.masterToken || EntityAuthenticationScheme$supportsEncryption(this.entityAuthenticationData.scheme);
        },

        /**
         * @return {boolean} true if the message renewable flag is set.
         */
        isRenewable: function isRenewable() {
            return this.renewable;
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            var jsonObj = {};
            if (this.masterToken)
                jsonObj[Header$KEY_MASTER_TOKEN] = this.masterToken;
            else
                jsonObj[Header$KEY_ENTITY_AUTHENTICATION_DATA] = this.entityAuthenticationData;
            jsonObj[Header$KEY_HEADERDATA] = base64$encode(this.headerdata);
            jsonObj[Header$KEY_SIGNATURE] = base64$encode(this.signature);
            return jsonObj;
        },
    });

    /**
     * <p>Construct a new message header with the provided message data.</p>
     *
     * <p>Headers are encrypted and signed. If a master token is provided, it
     * will be used for this purpose. Otherwise the crypto context appropriate
     * for the entity authentication scheme will be used. N.B. Either the
     * entity authentication data or the master token must be provided.</p>
     *
     * <p>Peer tokens are only processed if operating in peer-to-peer mode.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {EntityAuthenticationData} entityAuthData the entity authentication data. May be null if a
     *        master token is provided.
     * @param {MaterToken} masterToken the master token. May be null if entity
     *        authentication data is provided.
     * @param {HeaderData} headerData message header data container.
     * @param {HeaderPeerData} peerData message header peer data container.
     * @param {{result: function(MessageHeader), error: function(Error)}}
     *        callback the callback functions that will receive the message
     *        header or any thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the message.
     * @throws MslMasterTokenException if the header master token is not
     *         trusted and needs to be to accept this message header.
     * @throws MslEntityAuthException if there is an error with the entity
     *         authentication data.
     * @throws MslMessageException if no entity authentication data or master
     *         token is provided.
     */
    MessageHeader$create = function MessageHeader$create(ctx, entityAuthData, masterToken, headerData, peerData, callback) {
        new MessageHeader(ctx, entityAuthData, masterToken, headerData, peerData, null, callback);
    };

    /**
     * @param {MslContext} ctx MSL context.
     * @param {ICryptoContext} cryptoContext message crypto context.
     * @param {Uint8Array} headerdata header data JSON string raw bytes.
     * @param {Uint8Array} signature header data signature.
     * @param {{result: function(string), error: function(Error)}} callback the
     *        callback that will receive the header JSON string or any thrown
     *        exceptions.
     * @throws MslCryptoException if the header data verification fails.
     */
    function getHeaderJson(ctx, cryptoContext, headerdata, signature, callback) {
        AsyncExecutor(callback, function() {
            // Verify the header data.
            cryptoContext.verify(headerdata, signature, {
                result: function(verified) {
                    AsyncExecutor(callback, function() {
                        if (!verified)
                            throw new MslCryptoException(MslError.MESSAGE_VERIFICATION_FAILED);
                        // Decrypt the header data.
                        cryptoContext.decrypt(headerdata, {
                            result: function(plaintext) {
                                AsyncExecutor(callback, function() {
                                    // Return the message crypto context and header JSON.
                                    return textEncoding$getString(plaintext, MslConstants$DEFAULT_CHARSET);
                                });
                            },
                            error: function(e) { callback.error(e); },
                        });
                    });
                },
                error: function(e) { callback.error(e); },
            });
        });
    }

    /**
     * @param {MslContext} ctx MSL context.
     * @param {?object} keyResponseDataJo key response data JSON object.
     * @param {{result: function(?KeyResponseData), error: function(Error)}}
     *        callback the callback that will receive the key response data or
     *        any thrown exceptions.
     */
    function getKeyResponseData(ctx, keyResponseDataJo, callback) {
        AsyncExecutor(callback, function() {
            if (keyResponseDataJo) {
                KeyResponseData$parse(ctx, keyResponseDataJo, callback);
            } else {
                return null;
            }
        });
    }

    /**
     * @param {MslContext} ctx MSL context.
     * @param {?object} userIdTokenJo user ID token JSON object.
     * @param {MasterToken} masterToken master token.
     * @param {{result: function(?UserIdToken), error: function(Error)}} callback
     *        the callback that will receive the user ID token or any thrown
     *        exceptions.
     */
    function getUserIdToken(ctx, userIdTokenJo, masterToken, callback) {
        AsyncExecutor(callback, function() {
            if (userIdTokenJo) {
                UserIdToken$parse(ctx, userIdTokenJo, masterToken, callback);
            } else {
                return null;
            }
        });
    }

    /**
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken master token.
     * @param {?object} userAuthDataJo user authentication data JSON object.
     * @param {{result: function(?UserAuthenticationData), error: function(Error)}}
     *        callback the callback that will receive the user authentication
     *        data or any thrown exceptions.
     */
    function getUserAuthData(ctx, masterToken, userAuthDataJo, callback) {
        AsyncExecutor(callback, function() {
            if (userAuthDataJo) {
                UserAuthenticationData$parse(ctx, masterToken, userAuthDataJo, callback);
            } else {
                return null;
            }
        });
    }

    /**
     * @param {MslContext} ctx MSL context.
     * @param {Array.<Object>} tokensJA JSON array of service token JSON objects.
     * @param {?MasterToken} masterToken master token.
     * @param {?UserIdToken} userIdToken user ID token.
     * @param {Object.<string,ICryptoContext>} cryptoContexts service token
     *        crypto contexts.
     * @param {string} headerdataJson header data JSON string.
     * @param {{result: function(Array.<ServiceToken>), error: function(Error)}}
     *        callback the callback that will receive the service tokens or any
     *        thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON
     *         array or objects.
     */
    function getServiceTokens(ctx, tokensJA, masterToken, userIdToken, cryptoContexts, headerdataJson, callback) {
        var serviceTokensMap = {};
        function addServiceToken(tokensJA, index, callback) {
            if (index >= tokensJA.length) {
                var serviceTokens = new Array();
                for (var key in serviceTokensMap)
                    serviceTokens.push(serviceTokensMap[key]);
                callback.result(serviceTokens);
                return;
            }

            var tokenJO = tokensJA[index];
            if (typeof tokenJO !== 'object')
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson);
            ServiceToken$parse(ctx, tokenJO, masterToken, userIdToken, cryptoContexts, {
                result: function(serviceToken) {
                    AsyncExecutor(callback, function() {
                        serviceTokensMap[serviceToken.uniqueKey()] = serviceToken;
                        addServiceToken(tokensJA, index + 1, callback);
                    });
                },
                error: function(e) { callback.error(e); }
            });
        }

        AsyncExecutor(callback, function() {
            if (tokensJA) {
                if (!(tokensJA instanceof Array))
                    throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson);
                addServiceToken(tokensJA, 0, callback);
            } else {
                return new Array();
            }
        });
    }

    /**
     * @param {MslContext} ctx MSL context.
     * @param {Object} headerdataJO header data JSON object.
     * @param {?KeyResponseData} keyResponseData key response data.
     * @param {Object.<string,ICryptoContext>} cryptoContexts service token
     *        crypto contexts.
     * @param {string} headerdataJson header data JSON string.
     * @param {{result: function({peerMasterToken: MasterToken, peerUserIdToken: UserIdToken, peerServiceTokens: Array.<ServiceToken>}), error: function(Error)}}
     *        callback the callback to receive the peer tokens or any thrown
     *        exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON
     *         object.
     */
    function getPeerToPeerTokens(ctx, headerdataJO, keyResponseData, cryptoContexts, headerdataJson, callback) {
        function getPeerMasterToken(ctx, headerdataJO, callback) {
            AsyncExecutor(callback, function() {
                var peerMasterTokenJO = headerdataJO[KEY_PEER_MASTER_TOKEN];
                if (peerMasterTokenJO && typeof peerMasterTokenJO !== 'object')
                    throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson);
                if (!peerMasterTokenJO)
                    return null;
                MasterToken$parse(ctx, peerMasterTokenJO, callback);
            });
        }

        function getPeerUserIdToken(ctx, headerdataJO, masterToken, callback) {
            AsyncExecutor(callback, function() {
                var peerUserIdTokenJO = headerdataJO[KEY_PEER_USER_ID_TOKEN];
                if (peerUserIdTokenJO && typeof peerUserIdTokenJO !== 'object')
                    throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson);
                if (!peerUserIdTokenJO)
                    return null;
                UserIdToken$parse(ctx, peerUserIdTokenJO, masterToken, callback);
            });
        }

        AsyncExecutor(callback, function() {
            if (!ctx.isPeerToPeer()) {
                return {
                    peerMasterToken: null,
                    peerUserIdToken: null,
                    peerServiceTokens: new Array(),
                };
            }

            // Pull peer master token.
            getPeerMasterToken(ctx, headerdataJO, {
                result: function(peerMasterToken) {
                    AsyncExecutor(callback, function() {
                        // The key response data master token is used for peer token
                        // verification if in peer-to-peer mode.
                        var peerVerificationMasterToken = (keyResponseData)
                            ? keyResponseData.masterToken
                            : peerMasterToken;

                        // Pull peer user ID token. User ID tokens are always
                        // authenticated by a master token.
                        getPeerUserIdToken(ctx, headerdataJO, peerVerificationMasterToken, {
                            result: function(peerUserIdToken) {
                                AsyncExecutor(callback, function() {
                                    // Peer service tokens are authenticated by the peer master
                                    // token if it exists or by the application crypto context.
                                    var peerServiceTokensJA = headerdataJO[KEY_PEER_SERVICE_TOKENS];
                                    getServiceTokens(ctx, peerServiceTokensJA, peerVerificationMasterToken, peerUserIdToken, cryptoContexts, headerdataJson, {
                                        result: function(peerServiceTokens) {
                                            AsyncExecutor(callback, function() {
                                                return {
                                                    peerMasterToken: peerMasterToken,
                                                    peerUserIdToken: peerUserIdToken,
                                                    peerServiceTokens: peerServiceTokens,
                                                };
                                            });
                                        },
                                        error: function(e) {
                                            AsyncExecutor(callback, function() {
                                                if (e instanceof MslException) {
                                                    e.setEntity(peerVerificationMasterToken);
                                                    e.setUser(peerUserIdToken);
                                                }
                                                throw e;
                                            });
                                        }
                                    });
                                });
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException)
                                        e.setEntity(peerVerificationMasterToken);
                                    throw e;
                                });
                            }
                        });
                    });
                },
                error: callback.error,
            });
        });
    }

    /**
     * @param {MslContext} ctx MSL context.
     * @param {Object} headerdataJO header data JSON object.
     * @param {string} headerdataJson header data JSON string.
     * @param {{result: function(Array.<KeyRequestData>}, error: function(Error)}}
     *        callback the callback to receive the key request data or any
     *        thrown exceptions.
     */
    function getKeyRequestData(ctx, headerdataJO, headerdataJson, callback) {
        var keyRequestData = [];

        function addKeyRequestData(keyRequestDataJA, index) {
            AsyncExecutor(callback, function() {
                if (index >= keyRequestDataJA.length)
                    return keyRequestData;
                var keyRequestDataJO = keyRequestDataJA[index];
                KeyRequestData$parse(ctx, keyRequestDataJO, {
                    result: function(data) {
                        AsyncExecutor(callback, function() {
                            keyRequestData.push(data);
                            addKeyRequestData(keyRequestDataJA, index + 1);
                        });
                    },
                    error: function(e) {
                        callback.error(e);
                    }
                });
            });
        }

        AsyncExecutor(callback, function() {
            var keyRequestDataJA = headerdataJO[KEY_KEY_REQUEST_DATA];
            if (!keyRequestDataJA)
                return keyRequestData;
            if (!(keyRequestDataJA instanceof Array))
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson);
            addKeyRequestData(keyRequestDataJA, 0);
        });
    }

    /**
     * <p>Construct a new message from the provided JSON object.</p>
     *
     * <p>Headers are encrypted and signed. If a master token is found, it will
     * be used for this purpose. Otherwise the crypto context appropriate for
     * the entity authentication scheme will be used. Either the master token
     * or entity authentication data must be found.</p>
     *
     * <p>If user authentication data is included user authentication will be
     * performed. If a user ID token is included then its user information is
     * considered to be trusted.</p>
     *
     * <p>Service tokens will be decrypted and verified with the provided crypto
     * contexts identified by token name. A default crypto context may be
     * provided by using the empty string as the token name; if a token name is
     * not explicitly mapped onto a crypto context, the default crypto context
     * will be used.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {string} headerdata header data JSON representation.
     * @param {EntityAuthenticationData} entityAuthData the entity authentication data. May be null if a
     *        master token is provided.
     * @param {MasterToken} masterToken the master token. May be null if entity
     *        authentication data is provided.
     * @param {Uint8Array} signature the header signature.
     * @param {Object.<string,ICryptoContext>} cryptoContexts the map of service token names onto crypto
     *        contexts used to decrypt and verify service tokens.
     * @param {{result: function(MessageHeader), error: function(Error)}}
     *        callback the callback functions that will receive the message
     *        header or any thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException if there is an error decrypting or verifying
     *         the header or creating the key exchange crypto context.
     * @throws MslEntityAuthException if unable to create the entity
     *         authentication data or there is an error with the entity
     *         authentication data.
     * @throws MslKeyExchangeException if unable to create the key request data
     *         or key response data.
     * @throws MslUserAuthException if unable to create the user authentication
     *         data or authenticate the user.
     * @throws MslMasterTokenException if the header master token is not
     *         trusted and needs to be to accept this message header.
     * @throws MslMessageException if the message does not contain an entity
     *         authentication data or a master token or the header data is
     *         missing or the message ID is negative.
     * @throws MslException if a token is improperly bound to another token.
     */
    MessageHeader$parse = function MessageHeader$parse(ctx, headerdata, entityAuthData, masterToken, signature, cryptoContexts, callback) {
        AsyncExecutor(callback, function() {
            entityAuthData = (!masterToken) ? entityAuthData : null;
            if (!entityAuthData && !masterToken)
                throw new MslMessageException(MslError.MESSAGE_ENTITY_NOT_FOUND);

            // Reconstruct the headerdata.
            var headerdataString = headerdata;
            try {
                headerdata = base64$decode(headerdataString);
            } catch (e) {
                throw new MslMessageException(MslError.HEADER_DATA_INVALID, headerdataString, e);
            }
            if (!headerdata || headerdata.length == 0)
                throw new MslMessageException(MslError.HEADER_DATA_MISSING, headerdataString);

            // Get the correct message crypto context.
            var messageCryptoContext;
            try {
                messageCryptoContext = getMessageCryptoContext(ctx, entityAuthData, masterToken);
            } catch (e) {
                if (e instanceof MslException) {
                    e.setEntity(masterToken);
                    e.setEntity(entityAuthData);
                }
                throw e;
            }

            // Grab the header JSON.
            getHeaderJson(ctx, messageCryptoContext, headerdata, signature, {
                result: function(headerdataJson) {
                    AsyncExecutor(callback, function() {
                        // Reconstruct header JSON object.
                        var headerdataJO;
                        try {
                            headerdataJO = JSON.parse(headerdataJson);
                        } catch (e) {
                            if (e instanceof SyntaxError)
                                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson, e).setEntity(masterToken).setEntity(entityAuthData);
                            throw e;
                        }

                        // Pull the message ID first because any error responses need to
                        // use it.
                        var messageId = parseInt(headerdataJO[KEY_MESSAGE_ID]);

                        // Verify message ID.
                        if (!messageId || messageId != messageId)
                            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson).setEntity(masterToken).setEntity(entityAuthData);
                        if (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE)
                            throw new MslMessageException(MslError.MESSAGE_ID_OUT_OF_RANGE, "headerdata " + headerdataJson).setEntity(masterToken).setEntity(entityAuthData);

                        // If the message was sent with a master token pull the sender.
                        var sender = (masterToken) ? headerdataJO[KEY_SENDER] : null;
                        if (masterToken && (!sender || typeof sender !== 'string'))
                            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson).setEntity(masterToken).setEntity(entityAuthData).setMessageId(messageId);

                        // Pull and verify key response data.
                        var keyResponseDataJo = headerdataJO[KEY_KEY_RESPONSE_DATA];
                        if (keyResponseDataJo && typeof keyResponseDataJo !== 'object')
                            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson).setEntity(masterToken).setEntity(entityAuthData).setMessageId(messageId);

                        // Change the callback so we can add the message Id to
                        // any thrown exceptions.
                        var originalCallback = callback;
                        callback = {
                            result: function(ret) { originalCallback.result(ret); },
                            error: function(e) {
                                if (e instanceof MslException) {
                                    e.setEntity(masterToken);
                                    e.setEntity(entityAuthData);
                                    e.setMessageId(messageId);
                                }
                                originalCallback.error(e);
                            }
                        };

                        // Grab primary token verification master token.
                        getKeyResponseData(ctx, keyResponseDataJo, {
                            result: function(keyResponseData) {
                                AsyncExecutor(callback, function() {
                                    // The key response data master token is used for token
                                    // verification in a trusted services network. Otherwise it
                                    // will be used for peer token verification, which is handled
                                    // below.
                                    var tokenVerificationMasterToken = (!ctx.isPeerToPeer() && keyResponseData)
                                        ? keyResponseData.masterToken
                                        : masterToken;

                                    // User ID tokens are always authenticated by a master token.
                                    var userIdTokenJo = headerdataJO[KEY_USER_ID_TOKEN];
                                    if (userIdTokenJo && typeof userIdTokenJo !== 'object')
                                        throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson);
                                    getUserIdToken(ctx, userIdTokenJo, tokenVerificationMasterToken, {
                                        result: function(userIdToken) {
                                            AsyncExecutor(callback, function() {
                                                // Pull user authentication data.
                                                var userAuthDataJo = headerdataJO[KEY_USER_AUTHENTICATION_DATA];
                                                if (userAuthDataJo && typeof userAuthDataJo !== 'object')
                                                    throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson);
                                                getUserAuthData(ctx, tokenVerificationMasterToken, userAuthDataJo, {
                                                    result: function(userAuthData) {
                                                        AsyncExecutor(callback, function() {
                                                            // Verify the user authentication data.
                                                            var customer;
                                                            if (userAuthData) {
                                                                var scheme = userAuthData.scheme;
                                                                var factory = ctx.getUserAuthenticationFactory(scheme);
                                                                if (!factory)
                                                                    throw new MslUserAuthException(MslError.USERAUTH_FACTORY_NOT_FOUND, scheme).setUser(userIdToken).setUser(userAuthData);
                                                                var identity = (masterToken) ? masterToken.identity : entityAuthData.getIdentity();
                                                                customer = factory.authenticate(ctx, identity, userAuthData, userIdToken);
                                                            } else if (userIdToken) {
                                                                customer = userIdToken.customer;
                                                            } else {
                                                                customer = null;
                                                            }

                                                            // Service tokens are authenticated by the master token if it
                                                            // exists or by the application crypto context.
                                                            var tokensJA = headerdataJO[KEY_SERVICE_TOKENS];
                                                            getServiceTokens(ctx, tokensJA, tokenVerificationMasterToken, userIdToken, cryptoContexts, headerdataJson, {
                                                                result: function(serviceTokens) {
                                                                    AsyncExecutor(callback, function() {
                                                                        var nonReplayableId = (headerdataJO[KEY_NON_REPLAYABLE_ID] !== undefined) ? parseInt(headerdataJO[KEY_NON_REPLAYABLE_ID]) : null;
                                                                        var renewable = headerdataJO[KEY_RENEWABLE];

                                                                        // Verify values.
                                                                        if (nonReplayableId != nonReplayableId ||
                                                                            typeof renewable !== 'boolean')
                                                                        {
                                                                            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson);
                                                                        }
                                                                        if (nonReplayableId < 0 || nonReplayableId > MslConstants$MAX_LONG_VALUE)
                                                                            throw new MslMessageException(MslError.NONREPLAYABLE_ID_OUT_OF_RANGE, "headerdata " + headerdataJson);

                                                                        // Pull message capabilities.
                                                                        var capabilities = null;
                                                                        var capabilitiesJO = headerdataJO[KEY_CAPABILITIES];
                                                                        if (capabilitiesJO) {
                                                                            if (typeof capabilitiesJO !== 'object')
                                                                                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "headerdata " + headerdataJson);
                                                                            capabilities = MessageCapabilities$parse(capabilitiesJO);
                                                                        }

                                                                        // Pull key request data containers.
                                                                        getKeyRequestData(ctx, headerdataJO, headerdataJson, {
                                                                            result: function(keyRequestData) {
                                                                                // Get peer-to-peer tokens.
                                                                                getPeerToPeerTokens(ctx, headerdataJO, keyResponseData, cryptoContexts, headerdataJson, {
                                                                                    result: function(result) {
                                                                                        AsyncExecutor(callback, function() {
                                                                                            var peerMasterToken = result.peerMasterToken;
                                                                                            var peerUserIdToken = result.peerUserIdToken;
                                                                                            var peerServiceTokens = result.peerServiceTokens;

                                                                                            // Return new message header.
                                                                                            var headerData = new HeaderData(messageId, nonReplayableId, renewable, capabilities,
                                                                                                keyRequestData, keyResponseData, userAuthData, userIdToken,
                                                                                                serviceTokens);
                                                                                            var headerPeerData = new HeaderPeerData(peerMasterToken, peerUserIdToken, peerServiceTokens);
                                                                                            var creationData = new CreationData(customer, sender, messageCryptoContext, headerdata, signature);
                                                                                            new MessageHeader(ctx, entityAuthData, masterToken, headerData, headerPeerData, creationData, callback);
                                                                                        });
                                                                                    },
                                                                                    error: callback.error,
                                                                                });
                                                                            },
                                                                            error: function(e) {
                                                                                AsyncExecutor(callback, function() {
                                                                                    if (e instanceof MslException) {
                                                                                        e.setUser(userIdToken);
                                                                                        e.setUser(userAuthData);
                                                                                    }
                                                                                    throw e;
                                                                                });
                                                                            }
                                                                        });
                                                                    });
                                                                },
                                                                error: function(e) {
                                                                    AsyncExecutor(callback, function() {
                                                                        if (e instanceof MslException) {
                                                                            e.setEntity(tokenVerificationMasterToken);
                                                                            e.setUser(userIdToken);
                                                                            e.setUser(userAuthData);
                                                                        }
                                                                        throw e;
                                                                    });
                                                                }
                                                            });
                                                        });
                                                    },
                                                    error: callback.error,
                                                });
                                            });
                                        },
                                        error: callback.error,
                                    });
                                });
                            },
                            error: callback.error,
                        });
                    });
                },
                error: callback.error,
            });
        });
    };
})();



// -- javascript/msg/PayloadChunk.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A payload chunk is a self-contained block of application data that is
 * encrypted, verified, and optionally compressed independent of other chunks.
 * A message payload may contain one or more chunks.</p>
 *
 * <p>Payload chunks are bound to a specific message by the message ID.</p>
 *
 * <p>Each payload chunk in a message is sequentially ordered by the chunk
 * sequence number. The sequence number starts at 1 and is incremented by 1 on
 * each sequential chunk.</p>
 *
 * <p>Payload chunks are represented as
 * {@code
 * payloadchunk = {
 *   "#mandatory" : [ "payload", "signature" ],
 *   "payload" : "base64",
 *   "signature" : "base64"
 * }} where:
 * <ul>
 * <li>{@code payload} is the Base64-encoded encrypted payload (payload)</li>
 * <li>{@code signature} is the Base64-encoded verification data of the payload</li>
 * </ul></p>
 *
 * <p>The payload is represented as
 * {@code
 * payload = {
 *   "#mandatory" : [ "sequencenumber", "messageid", "data" ],
 *   "sequencenumber" : "int64(1,2^53^)",
 *   "messageid" : "int64(0,2^53^)",
 *   "endofmsg" : "boolean",
 *   "compressionalgo" : "enum(GZIP\LZW)",
 *   "data" : "base64"
 * }} where:
 * <ul>
 * <li>{@code sequencenumber} is the chunk sequence number</li>
 * <li>{@code messageid} is the message ID</li>
 * <li>{@code endofmsg} indicates this is the last payload of the message</li>
 * <li>{@code compressionalgo} indicates the algorithm used to compress the data</li>
 * <li>{@code data} is the Base64-encoded optionally compressed application data</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var PayloadChunk;
var PayloadChunk$create;
var PayloadChunk$parse;

(function() {
    "use strict";
    /**
     * JSON key payload.
     * @const
     * @type {string}
     */
    var KEY_PAYLOAD = "payload";
    /**
     * JSON key signature.
     * @const
     * @type {string}
     */
    var KEY_SIGNATURE = "signature";

    // payload
    /**
     * JSON key sequence number.
     * @const
     * @type {string}
     */
    var KEY_SEQUENCE_NUMBER = "sequencenumber";
    /**
     * JSON key message ID.
     * @const
     * @type {string}
     */
    var KEY_MESSAGE_ID = "messageid";
    /**
     * JSON key end of message.
     * @const
     * @type {string}
     */
    var KEY_END_OF_MESSAGE = "endofmsg";
    /**
     * JSON key compression algorithm.
     * @const
     * @type {string}
     */
    var KEY_COMPRESSION_ALGORITHM = "compressionalgo";
    /**
     * JSON key encrypted data.
     * @const
     * @type {string}
     */
    var KEY_DATA = "data";

    /**
     * Create a new payload container object.
     *
     * @param {Uint8Array} payload raw payload data.
     * @param {Uint8Array} signature raw signature.
     * @constructor
     */
    function CreationData(payload, signature) {
        this.payload = payload;
        this.signature = signature;
    }

    PayloadChunk = util.Class.create({
        /**
         * Construct a new payload chunk with the given message ID, data and
         * provided crypto context. If requested, the data will be compressed
         * before encrypting.
         *
         * @param {number} sequenceNumber sequence number.
         * @param {number} messageId the message ID.
         * @param {boolean} endofmsg true if this is the last payload chunk of the message.
         * @param {MslConstants$CompressionAlgorithm} compressionAlgo the compression algorithm. May be {@code null}
         *        for no compression.
         * @param {Uint8Array} data the payload chunk application data.
         * @param {ICryptoContext} cryptoContext the crypto context.
         * @param {?CreationData} optional creation data.
         * @param {{result: function(PayloadChunk), error: function(Error)}}
         *        callback the callback that will receive the payload chunk or
         *        any thrown exceptions.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the payload chunk.
         * @throws MslException if there is an error compressing the data.
         */
        init: function init(sequenceNumber, messageId, endofmsg, compressionAlgo, data, cryptoContext, creationData, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // Verify sequence number and message ID.
                if (sequenceNumber < 0 || sequenceNumber > MslConstants$MAX_LONG_VALUE)
                    throw new MslInternalException("Sequence number " + sequenceNumber + " is outside the valid range.");
                if (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE)
                    throw new MslInternalException("Message ID " + messageId + " is outside the valid range.");

                // Construct the payload.
                if (!creationData) {
                    // Optionally compress the application data.
                    var payloadData;
                    if (compressionAlgo) {
                        var compressed = MslUtils$compress(compressionAlgo, data);

                        // Only use compression if the compressed data is smaller than the
                        // uncompressed data.
                        if (compressed) {
                            payloadData = compressed;
                        } else {
                            compressionAlgo = null;
                            payloadData = data;
                        }
                    } else {
                        compressionAlgo = null;
                        payloadData = data;
                    }

                    // Construct the payload.
                    var payloadJO = {};
                    payloadJO[KEY_SEQUENCE_NUMBER] = sequenceNumber;
                    payloadJO[KEY_MESSAGE_ID] = messageId;
                    if (endofmsg) payloadJO[KEY_END_OF_MESSAGE] = endofmsg;
                    if (compressionAlgo) payloadJO[KEY_COMPRESSION_ALGORITHM] = compressionAlgo;
                    payloadJO[KEY_DATA] = base64$encode(payloadData);
                    var plaintext = textEncoding$getBytes(JSON.stringify(payloadJO), MslConstants$DEFAULT_CHARSET);
                    cryptoContext.encrypt(plaintext, {
                        result: function(payload) {
                            AsyncExecutor(callback, function() {
                                cryptoContext.sign(payload, {
                                    result: function(signature) {
                                        AsyncExecutor(callback, function() {
                                            // The properties.
                                            var props = {
                                                sequenceNumber: { value: sequenceNumber, writable: false, configurable: false },
                                                messageId: { value: messageId, writable: false, configurable: false },
                                                compressionAlgo: { value: compressionAlgo, writable: false, configurable: false },
                                                data: { value: data, writable: false, configurable: false },
                                                endofmsg: { value: endofmsg, writable: false, enumerable: false, configurable: false },
                                                payload: { value: payload, writable: false, enumerable: false, configurable: false },
                                                signature: { value: signature, writable: false, enumerable: false, configurable: false },
                                            };
                                            Object.defineProperties(this, props);
                                            return this;
                                        }, self);
                                    },
                                    error: function(e) { callback.error(e); }
                                });
                            }, self);
                        },
                        error: function(e) { callback.error(e); }
                    });
                } else {
                    var payload = creationData.payload;
                    var signature = creationData.signature;

                    // The properties.
                    var props = {
                        sequenceNumber: { value: sequenceNumber, writable: false, configurable: false },
                        messageId: { value: messageId, writable: false, configurable: false },
                        compressionAlgo: { value: compressionAlgo, writable: false, configurable: false },
                        data: { value: data, writable: false, configurable: false },
                        endofmsg: { value: endofmsg, writable: false, enumerable: false, configurable: false },
                        payload: { value: payload, writable: false, enumerable: false, configurable: false },
                        signature: { value: signature, writable: false, enumerable: false, configurable: false },
                    };
                    Object.defineProperties(this, props);
                    return this;
                }
            }, self);
        },

        /**
         * @return {boolean} true if this is the last payload chunk of the message.
         */
        isEndOfMessage: function isEndOfMessage() {
            return this.endofmsg;
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            var jsonObj = {};
            jsonObj[KEY_PAYLOAD] = base64$encode(this.payload);
            jsonObj[KEY_SIGNATURE] = base64$encode(this.signature);
            return jsonObj;
        },
    });

    /**
     * Construct a new payload chunk with the given message ID, data and
     * provided crypto context. If requested, the data will be compressed
     * before encrypting.
     *
     * @param {number} sequenceNumber sequence number.
     * @param {number} messageId the message ID.
     * @param {boolean} endofmsg true if this is the last payload chunk of the message.
     * @param {MslConstants$CompressionAlgorithm} compressionAlgo the compression algorithm. May be {@code null}
     *        for no compression.
     * @param {Uint8Array} data the payload chunk application data.
     * @param {ICryptoContext} cryptoContext the crypto context.
     * @param {{result: function(PayloadChunk), error: function(Error)}}
     *        callback the callback that will receive the payload chunk or
     *        any thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the payload chunk.
     * @throws MslException if there is an error compressing the data.
     */
    PayloadChunk$create = function PayloadChunk$create(sequenceNumber, messageId, endofmsg, compressionAlgo, data, cryptoContext, callback) {
        new PayloadChunk(sequenceNumber, messageId, endofmsg, compressionAlgo, data, cryptoContext, null, callback);
    };

    /**
     * <p>Construct a new payload chunk from the provided JSON object.</p>
     *
     * <p>The provided crypto context will be used to decrypt and verify the
     * data signature.</p>
     *
     * @param {Object} payloadChunkJO the JSON object.
     * @param {ICryptoContext} cryptoContext the crypto context.
     * @param {{result: function(PayloadChunk), error: function(Error)}}
     *        callback the callback that will receive the payload chunk or
     *        any thrown exceptions.
     * @throws MslCryptoException if there is a problem decrypting or verifying
     *         the payload chunk.
     * @throws MslEncodingException if there is a problem parsing the JSON.
     * @throws MslMessageException if the compression algorithm is not known,
     *         or the payload data is corrupt or missing.
     * @throws MslException if there is an error uncompressing the data.
     */
    PayloadChunk$parse = function PayloadChunk$parse(payloadChunkJO, cryptoContext, callback) {
        AsyncExecutor(callback, function() {
            // Pull the payload and signature.
            var payloadB64 = payloadChunkJO[KEY_PAYLOAD];
            var signatureB64 = payloadChunkJO[KEY_SIGNATURE];
            if (!payloadB64 || typeof payloadB64 !== 'string' ||
                typeof signatureB64 !== 'string')
            {
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "payload chunk " + JSON.stringify(payloadChunkJO));
            }

            // Verify the payload.
            var payload, signature;
            try {
                payload = base64$decode(payloadB64);
            } catch (e) {
                throw new MslMessageException(MslError.PAYLOAD_INVALID, "payload chunk " + JSON.stringify(payloadChunkJO), e);
            }
            try {
                signature = base64$decode(signatureB64);
            } catch (e) {
                throw new MslMessageException(MslError.PAYLOAD_SIGNATURE_INVALID, "payload chunk " + JSON.stringify(payloadChunkJO), e);
            }
            cryptoContext.verify(payload, signature, {
                result: function(verified) {
                    AsyncExecutor(callback, function() {
                        if (!verified)
                            throw new MslCryptoException(MslError.PAYLOAD_VERIFICATION_FAILED);

                        // Decrypt the payload.
                        cryptoContext.decrypt(payload, {
                            result: function(plaintext) {
                                AsyncExecutor(callback, function() {
                                    // Reconstruct the payload object.
                                    var payloadJson = textEncoding$getString(plaintext, MslConstants$DEFAULT_CHARSET);
                                    var payloadJO;
                                    try {
                                        payloadJO = JSON.parse(payloadJson);
                                    } catch (e) {
                                        if (e instanceof SyntaxError)
                                            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "payload chunk payload " + payloadJson, e);
                                        throw e;
                                    }

                                    // Pull payload information.
                                    var sequenceNumber = parseInt(payloadJO[KEY_SEQUENCE_NUMBER]);
                                    var messageId = parseInt(payloadJO[KEY_MESSAGE_ID]);
                                    var endofmsg = payloadJO[KEY_END_OF_MESSAGE];
                                    var compressionAlgo = payloadJO[KEY_COMPRESSION_ALGORITHM];
                                    var payloadData = payloadJO[KEY_DATA];

                                    // Verify payload information.
                                    if (!sequenceNumber || sequenceNumber != sequenceNumber ||
                                        !messageId || messageId != messageId ||
                                        (endofmsg && typeof endofmsg !== 'boolean') ||
                                        (compressionAlgo && typeof compressionAlgo !== 'string') ||
                                        typeof payloadData !== 'string')
                                    {
                                        throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "payload chunk payload " + payloadJson);
                                    }

                                    // Verify sequence number and message ID values.
                                    if (sequenceNumber < 0 || sequenceNumber > MslConstants$MAX_LONG_VALUE)
                                        throw new MslException(MslError.PAYLOAD_SEQUENCE_NUMBER_OUT_OF_RANGE, "payload chunk payload " + payloadJson);
                                    if (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE)
                                        throw new MslException(MslError.PAYLOAD_MESSAGE_ID_OUT_OF_RANGE, "payload chunk payload " + payloadJson);

                                    // Default end of message to false.
                                    if (!endofmsg) endofmsg = false;

                                    // Verify compression algorithm.
                                    if (compressionAlgo && !MslConstants$CompressionAlgorithm[compressionAlgo])
                                        throw new MslMessageException(MslError.UNIDENTIFIED_COMPRESSION, compressionAlgo);

                                    // Decompress the data if it is compressed.
                                    var data;
                                    var compressedData;
                                    try {
                                        compressedData = base64$decode(payloadData);
                                    } catch (e) {
                                        throw new MslMessageException(MslError.PAYLOAD_DATA_CORRUPT, payloadData, e);
                                    }
                                    if (!compressedData || compressedData.length == 0) {
                                        if (payloadData.length > 0)
                                            throw new MslMessageException(MslError.PAYLOAD_DATA_CORRUPT, payloadData);
                                        else if (!endofmsg)
                                            throw new MslMessageException(MslError.PAYLOAD_DATA_MISSING, payloadData);
                                        else
                                            data = new Uint8Array(0);
                                    } else {
                                        data = (compressionAlgo) ? MslUtils$uncompress(compressionAlgo, compressedData) : compressedData;
                                    }

                                    // Return the payload chunk.
                                    var creationData = new CreationData(payload, signature);
                                    new PayloadChunk(sequenceNumber, messageId, endofmsg, compressionAlgo, data, cryptoContext, creationData, callback);
                                });
                            },
                            error: function(e) { callback.error(e); }
                        });
                    });
                },
                error: function(e) { callback.error(e); }
            });
        });
    };
})();



// -- javascript/msg/MessageBuilder.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A message builder provides methods for building messages.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MessageBuilder;
var MessageBuilder$incrementMessageId;
var MessageBuilder$decrementMessageId;
var MessageBuilder$createRequest;
var MessageBuilder$createResponse;
var MessageBuilder$createErrorResponse;

(function() {
    /**
     * Empty service token data.
     * @const
     * @type {Uint8Array}
     */
    var EMPTY_DATA = new Uint8Array(0);

    /**
     * Increments the provided message ID by 1, wrapping around to zero if
     * the provided value is equal to {@link MslConstants.MAX_LONG_VALUE}.
     *
     * @param {number} messageId the message ID to increment.
     * @return {number} the message ID + 1.
     * @throws MslInternalException if the provided message ID is out of range.
     */
    var incrementMessageId = MessageBuilder$incrementMessageId = function MessageBuilder$incrementMessageId(messageId) {
        if (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE)
            throw new MslInternalException("Message ID " + messageId + " is outside the valid range.");
        return (messageId == MslConstants$MAX_LONG_VALUE) ? 0 : messageId + 1;
    };

    /**
     * Decrements the provided message ID by 1, wrapping around to
     * {@link MslConstants.MAX_LONG_VALUE} if the provided value is equal to 0.
     *
     * @param {number} messageId the message ID to decrement.
     * @return {number} the message ID - 1.
     * @throws MslInternalException if the provided message ID is out of range.
     */
    MessageBuilder$decrementMessageId = function MessageBuilder$incrementMessageId(messageId) {
        if (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE)
            throw new MslInternalException("Message ID " + messageId + " is outside the valid range.");
        return (messageId == 0) ? MslConstants$MAX_LONG_VALUE : messageId - 1;
    };

    /**
     * Issue a new master token for the specified identity or renew an existing
     * master token.
     *
     * @param {MslContext} ctx MSL context.
     * @param {Array.<KeyRequestData>} keyRequestData available key request data.
     * @param {MasterToken} masterToken master token to renew. Null if the identity is
     *        provided.
     * @param {string} identity entity identity. Null if a master token is provided.
     * @param {{result: function(KeyExchangeData), error: function(Error)}}
     *        callback the callback that will receive the key exchange data or
     *        any thrown exceptions.
     * @throws MslCryptoException if the crypto context cannot be created.
     * @throws MslKeyExchangeException if there is an error with the key
     *         request data or the key response data cannot be created or none
     *         of the key exchange schemes are supported.
     * @throws MslMasterTokenException if the master token is not trusted.
     * @throws MslEncodingException if there is an error parsing or encoding
     *         the JSON.
     * @throws MslEntityAuthException if there is a problem with the master
     *         token identity or entity identity.
     * @throws MslException if there is an error creating or renewing the
     *         master token.
     */
    function issueMasterToken(ctx, keyRequestData, masterToken, identity, callback) {
        var factoryIndex = 0, requestIndex = 0;
        var factories = ctx.getKeyExchangeFactories();
        var keyxException;
        var entityToken = (masterToken) ? masterToken : identity;

        // Attempt key exchange in the preferred order.
        function nextExchange() {
            AsyncExecutor(callback, function() {
                // If we've reached the end of the key request data, try them all
                // again with the next factory.
                if (requestIndex >= keyRequestData.length) {
                    requestIndex = 0;
                    ++factoryIndex;
                }

                // If we've reached the end of the factories then stop.
                if (factoryIndex >= factories.length) {
                    // We did not perform a successful key exchange. If we caught an
                    // exception then throw that exception now.
                    if (keyxException)
                        throw keyxException;

                    // If we didn't find any then we're unable to perform key exchange.
                    throw new MslKeyExchangeException(MslError.KEYX_FACTORY_NOT_FOUND, JSON.stringify(keyRequestData));
                }

                // Grab this iteration's factory and request.
                var factory = factories[factoryIndex];
                var request = keyRequestData[requestIndex];
                if (factory.scheme != request.keyExchangeScheme) {
                    // Try the next request.
                    ++requestIndex;
                    nextExchange();
                    return;
                }

                // Attempt the key exchange.
                factory.generateResponse(ctx, request, entityToken, {
                    result: function(keyExchangeData) {
                        // Deliver the result.
                        callback.result(keyExchangeData);
                    },
                    error: function(e) {
                        AsyncExecutor(callback, function() {
                            // Immediately deliver anything that's not a MslException.
                            if (!(e instanceof MslException))
                                throw e;

                            // Otherwise save this exception and try the next
                            // combination.
                            // FIXME log the exception.
                            keyxException = e;
                            ++requestIndex;
                            nextExchange();
                        });
                    }
                });
            });
        }

        nextExchange();
    }

    /**
     * Performs key exchange for the request message header if key exchange
     * should occur.
     *
     * @param {MslContext} ctx MSL context.
     * @param {MessageHeader} requestHeader message with which to attempt key exchange.
     * @param {?EntityAuthenticationData} entityAuthData message header entity authentication data.
     * @param {?MasterToken} message header master token.
     * @param {{result: function(KeyExchangeData), error: function(Error)}}
     *        callback the callback that will receive the key exchange data or
     *        any thrown exceptions.
     * @throws MslCryptoException if the crypto context cannot be created.
     * @throws MslKeyExchangeException if there is an error with the key
     *         request data or the key response data cannot be created or none
     *         of the key exchange schemes are supported.
     * @throws MslMasterTokenException if the master token is not trusted.
     * @throws MslEncodingException if there is an error parsing or encoding
     *         the JSON.
     * @throws MslEntityAuthException if there is a problem with the master
     *         token identity or entity identity.
     * @throws MslException if there is an error creating or renewing the
     *         master token.
     */
    function performKeyExchange(ctx, requestHeader, entityAuthData, masterToken, callback) {
        AsyncExecutor(callback, function() {
            // If the message contains key request data and is renewable...
            var keyRequestData = requestHeader.keyRequestData;
            if (requestHeader.isRenewable() && keyRequestData.length > 0) {
                // If the message contains a master token...
                if (masterToken) {
                    // If the master token is renewable/expired or not the
                    // newest master token then renew the master token.
                    if (masterToken.isRenewable() || masterToken.isExpired()) {
                        issueMasterToken(ctx, keyRequestData, masterToken, null, callback);
                    } else {
                        var factory = ctx.getTokenFactory();
                        factory.isNewestMasterToken(ctx, masterToken, {
                            result: function(newest) {
                                AsyncExecutor(callback, function() {
                                    if (!newest)
                                        issueMasterToken(ctx, keyRequestData, masterToken, null, callback);
                                    else
                                        return null;
                                });
                            },
                            error: callback.error,
                        });
                    }
                }

                // Otherwise use the entity authentication data to issue a
                // master token.
                else {
                    // The message header is already authenticated via the
                    // entity authentication data's crypto context so we can
                    // simply proceed with the master token issuance.
                    issueMasterToken(ctx, keyRequestData, null, entityAuthData.getIdentity(), callback);
                }
            }

            // If the message does not contain key request data there is no key
            // exchange for us to do.
            else {
                return null;
            }
        });
    }

    /**
     * <p>Create a new message builder that will craft a new message. If a
     * message ID is provided it will be used for the new message's message ID.
     * Otherwise a random message ID will be generated.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken master token. May be null unless a user ID token is
     *        provided.
     * @param {UserIdToken} userIdToken user ID token. May be null.
     * @param {?number} messageId the message ID to use. Must be within range.
     * @param {{result: function(MessageBuilder), error: function(Error)}}
     *        callback the callback that will receive the message builder or
     *        any thrown exceptions.
     * @throws MslException if a user ID token is not bound to its
     *         corresponding master token.
     */
    MessageBuilder$createRequest = function MessageBuilder$createRequest(ctx, masterToken, userIdToken, messageId, callback) {
        AsyncExecutor(callback, function() {
            if (messageId == undefined || messageId == null) {
                var random = ctx.getRandom();
                do {
                    messageId = random.nextLong();
                } while (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE);
            } else {
                if (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE)
                    throw new MslInternalException("Message ID " + messageId + " is outside the valid range.");
            }

            // Grab the local entity authentication data.
            ctx.getEntityAuthenticationData(null, {
                result: function(entityAuthData) {
                    AsyncExecutor(callback, function() {
                        var capabilities = ctx.getMessageCapabilities();
                        return new MessageBuilder(ctx, messageId, capabilities, entityAuthData, masterToken, userIdToken, null, null, null, null, null);
                    });
                },
                error: function(e) { callback.error(e); }
            });
        });
    };

    /**
     * Return the user ID token that should be included in the message header
     * creating in response to a request. The request's user ID token may be
     * renewed or a new user ID token issued if user authentication data is
     * provided.
     *
     * @param {MslContext} ctx MSL context.
     * @param {MessageHeader} requestHeader request message header.
     * @param {MasterToken} masterToken master token to verify/bind the user ID
     *        token against.
     * @param {{result: function(UserIdToken), error: function(Error)}} callback
     *        the callback that will receive the user ID token or any thrown
     *        exceptions.
     * @throws MslUserAuthException if the user authentication scheme is not
     *         supported.
     */
    function getUserIdToken(ctx, requestHeader, masterToken, callback) {
        AsyncExecutor(callback, function() {
            var userIdToken = requestHeader.userIdToken;
            var userAuthData = requestHeader.userAuthenticationData;
            var requestMessageId = requestHeader.messageId;

            // If the message contains a user ID token issued by the local
            // entity...
            if (userIdToken && userIdToken.isVerified()) {
                // If the user ID token is renewable and the message is
                // renewable, or it is expired, or it needs to be rebound
                // to the new master token then renew the user ID token.
                if ((userIdToken.isRenewable() && requestHeader.isRenewable()) ||
                    userIdToken.isExpired() ||
                    !userIdToken.isBoundTo(masterToken))
                {
                    var tokenFactory = ctx.getTokenFactory();
                    tokenFactory.renewUserIdToken(ctx, userIdToken, masterToken, callback);
                    return;
                }
            }

            // If the message is renewable and contains user authentication
            // data and a master token then we need to attempt user
            // authentication and issue a user ID token.
            else if (requestHeader.isRenewable() && masterToken && userAuthData) {
                // If this request was parsed then its user authentication data
                // should have been authenticated and the customer will exist.
                // If it was not parsed, then we need to perform user
                // authentication now.
                var customer = requestHeader.customer;
                if (!customer) {
                    var scheme = userAuthData.scheme;
                    var factory = ctx.getUserAuthenticationFactory(scheme);
                    if (!factory) {
                        throw new MslUserAuthException(MslError.USERAUTH_FACTORY_NOT_FOUND, scheme)
                        .setEntity(masterToken)
                        .setUser(userAuthData)
                        .setMessageId(requestMessageId);
                    }
                    customer = factory.authenticate(ctx, masterToken.identity, userAuthData, null);
                }
                var tokenFactory = ctx.getTokenFactory();
                tokenFactory.createUserIdToken(ctx, customer, masterToken, callback);
                return;
            }

            // Otherwise return the header's user ID token (may be null).
            return userIdToken;
        });
    }

    /**
     * Create a new message builder that will craft a new message in response
     * to another message. The constructed message may be used as a request.
     *
     * @param {MslContext} ctx MSL context.
     * @param {MessageHeader} requestHeader message header to respond to.
     * @param {{result: function(MessageBuilder), error: function(Error)}}
     *        callback the callback that will receive the message builder or
     *        any thrown exceptions.
     * @throws MslMasterTokenException if the provided message's master token
     *         is not trusted.
     * @throws MslCryptoException if the crypto context from a key exchange
     *         cannot be created.
     * @throws MslKeyExchangeException if there is an error with the key
     *         request data or the key response data cannot be created.
     * @throws MslUserAuthException if there is an error with the user
     *         authentication data or the user ID token cannot be created.
     * @throws MslException if a user ID token in the message header is not
     *         bound to its corresponding master token or there is an error
     *         creating or renewing the master token.
     */
    MessageBuilder$createResponse = function MessageBuilder$createResponse(ctx, requestHeader, callback) {
        AsyncExecutor(callback, function() {
            var masterToken = requestHeader.masterToken;
            var entityAuthData = requestHeader.entityAuthenticationData;
            var userIdToken = requestHeader.userIdToken;
            var userAuthData = requestHeader.userAuthenticationData;

            // The response message ID must be equal to the request message ID + 1.
            var requestMessageId = requestHeader.messageId;
            var messageId = incrementMessageId(requestMessageId);

            // Perform key exchange.
            performKeyExchange(ctx, requestHeader, entityAuthData, masterToken, {
                result: function(keyExchangeData) {
                    AsyncExecutor(callback, function() {
                        // If we successfully performed key exchange, use the new master
                        // token for user authentication.
                        var userAuthMasterToken = (keyExchangeData)
                            ? keyExchangeData.keyResponseData.masterToken
                            : userAuthMasterToken = masterToken;

                        // Grab the local entity authentication data.
                        ctx.getEntityAuthenticationData(null, {
                            result: function(entityAuthData) {
                                AsyncExecutor(callback, function() {
                                    // Grab the user ID token for this response.
                                    getUserIdToken(ctx, requestHeader, userAuthMasterToken, {
                                        result: function(token) {
                                            AsyncExecutor(callback, function() {
                                                userIdToken = token;
                                                
                                                // Compute the intersection of the request and response message
                                                // capabilities.
                                                var capabilities = MessageCapabilities$intersection(requestHeader.messageCapabilities, ctx.getMessageCapabilities());
                                                
                                                // Create the message builder.
                                                //
                                                // Peer-to-peer responses swap the tokens.
                                                var keyResponseData = requestHeader.keyResponseData;
                                                var serviceTokens = requestHeader.serviceTokens;
                                                if (ctx.isPeerToPeer()) {
                                                    var peerMasterToken = (keyResponseData) ? keyResponseData.masterToken : requestHeader.peerMasterToken;
                                                    var peerUserIdToken = requestHeader.peerUserIdToken;
                                                    var peerServiceTokens = requestHeader.peerServiceTokens;
                                                    return new MessageBuilder(ctx, messageId, capabilities, entityAuthData, peerMasterToken, peerUserIdToken, peerServiceTokens, masterToken, userIdToken, serviceTokens, keyExchangeData);
                                                } else {
                                                    var localMasterToken = (keyResponseData) ? keyResponseData.masterToken : masterToken;
                                                    return new MessageBuilder(ctx, messageId, capabilities, entityAuthData, localMasterToken, userIdToken, serviceTokens, null, null, null, keyExchangeData);
                                                }
                                            });
                                        },
                                        error: handleError,
                                    });
                                });
                            },
                            error: handleError,
                        });
                    });
                },
                error: handleError,
            });
            
            function handleError(e) {
                AsyncExecutor(callback, function() {
                    if (e instanceof MslException) {
                        e.setEntity(masterToken);
                        e.setEntity(entityAuthData);
                        e.setUser(userIdToken);
                        e.setUser(userAuthData);
                        e.setMessageId(requestMessageId);
                    }
                    throw e;
                });
            }
        });
    };

    /**
     * <p>Create a new message builder that will craft a new error message in
     * response to another message. If the message ID of the request is not
     * specified (i.e. unknown) then a random message ID will be generated.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {number} requestMessageId message ID of request. May be null.
     * @param {MslError} error the MSL error.
     * @param {string} userMessage localized user-consumable error message. May be null.
     * @param {{result: function(ErrorHeader), error: function(Error)}}
     *        callback the callback that will receive the error header or any
     *        thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the message.
     * @throws MslEntityAuthException if there is an error with the entity
     *         authentication data.
     */
    MessageBuilder$createErrorResponse = function MessageBuilder$createErrorResponse(ctx, requestMessageId, error, userMessage, callback) {
        AsyncExecutor(callback, function() {
            ctx.getEntityAuthenticationData(null, {
                result: function(entityAuthData) {
                    AsyncExecutor(callback, function() {
                        // If we have the request message ID then the error response message ID
                        // must be equal to the request message ID + 1.
                        var messageId;
                        if (requestMessageId != undefined && requestMessageId != null) {
                            messageId = incrementMessageId(requestMessageId);
                        }
                        // Otherwise use a random message ID.
                        else {
                            var random = ctx.getRandom();
                            do {
                                messageId = random.nextInt();
                            } while (messageId < 0 || messageId > MslConstants$MAX_LONG_VALUE);
                        }
                        var errorCode = error.responseCode;
                        var internalCode = error.internalCode;
                        var errorMsg = error.message;
                        ErrorHeader$create(ctx, entityAuthData, messageId, errorCode, internalCode, errorMsg, userMessage, callback);
                    });
                },
                error: function(e) { callback.error(e); }
            });
        });
    };

    MessageBuilder = util.Class.create({
        /**
         * Create a new message builder with the provided tokens and key exchange
         * data if a master token was issued or renewed.
         *
         * @param {MslContext} ctx MSL context.
         * @param {number} messageId message ID.
         * @param {MessageCapabilities} message capabilities.
         * @param {EntityAuthenticationData} entityAuthData entity
         *        authentication data.
         * @param {MsaterToken} masterToken master token. May be null unless a user ID token is
         *        provided.
         * @param {UserIdToken} userIdToken user ID token. May be null.
         * @param {Array.<ServiceToken>} serviceTokens initial set of service tokens. May be null.
         * @param {MasterToken }peerMasterToken peer master token. May be null unless a peer user
         *        ID token is provided.
         * @param {UserIdToken} peerUserIdToken peer user ID token. May be null.
         * @param {Array.<ServiceToken>} peerServiceTokens initial set of peer service tokens.
         *        May be null.
         * @param {KeyExchangeData} keyExchangeData key exchange data. May be null.
         * @param {{result: function(MessageBuilder), error: function(Error)}}
         *        callback the callback that will receive this message builder
         *        or any thrown exceptions.
         * @throws MslException if a user ID token is not bound to its master
         *         token.
         */
        init: function init(ctx, messageId, capabilities, entityAuthData, masterToken, userIdToken, serviceTokens, peerMasterToken, peerUserIdToken, peerServiceTokens, keyExchangeData) {
            // Primary and peer token combinations will be verified when the
            // message header is constructed. So delay those checks in favor of
            // avoiding duplicate code.
            if (!ctx.isPeerToPeer() && (peerMasterToken || peerUserIdToken))
                throw new MslInternalException("Cannot set peer master token or peer user ID token when not in peer-to-peer mode.");

            // If key exchange data is provided and we are not in peer-to-peer mode
            // then its master token should be used for querying service tokens.
            var serviceMasterToken;
            if (keyExchangeData && !ctx.isPeerToPeer()) {
                serviceMasterToken = keyExchangeData.keyResponseData.masterToken;
            } else {
                serviceMasterToken = masterToken;
            }

            // Set the initial service tokens based on the MSL store and provided
            // service tokens.
            var _serviceTokens = {};
            var tokens = ctx.getMslStore().getServiceTokens(serviceMasterToken, userIdToken);
            tokens.forEach(function(token) {
                _serviceTokens[token.name] = token;
            }, this);
            if (serviceTokens) {
                serviceTokens.forEach(function(token) {
                    _serviceTokens[token.name] = token;
                }, this);
            }

            // Set the peer-to-peer data.
            var _peerMasterToken;
            var _peerUserIdToken;
            var _peerServiceTokens = {};
            if (ctx.isPeerToPeer()) {
                _peerMasterToken = peerMasterToken;
                _peerUserIdToken = peerUserIdToken;

                // If key exchange data is provided then its master token should
                // be used to query peer service tokens.
                var peerServiceMasterToken;
                if (keyExchangeData)
                    peerServiceMasterToken = keyExchangeData.keyResponseData.masterToken;
                else
                    peerServiceMasterToken = peerMasterToken;

                // Set the initial peer service tokens based on the MSL store and
                // provided peer service tokens.
                var peerTokens = ctx.getMslStore().getServiceTokens(peerServiceMasterToken, peerUserIdToken);
                peerTokens.forEach(function(peerToken) {
                    _peerServiceTokens[peerToken.name] = peerToken;
                }, this);
                if (peerServiceTokens) {
                    peerServiceTokens.forEach(function(peerToken) {
                        _peerServiceTokens[peerToken.name] = peerToken;
                    }, this);
                }
            }

            // Set the primary fields.
            var _ctx = ctx;
            var _messageId = messageId;
            var _capabilities = capabilities;
            var _entityAuthData = entityAuthData;
            var _masterToken = masterToken;
            var _userIdToken = userIdToken;
            var _keyExchangeData = keyExchangeData;

            // Set default field values.
            var _nonReplayable = false;
            var _renewable = false;
            var _userAuthData = null;
            var _keyRequestData = {};

            // The properties.
            var props = {
                // MSL context.
                /** @type {MslContext} */
                _ctx: { value: _ctx, writable: false, enumerable: false, configurable: false },

                // Private members.
                /** @type {EntityAuthenticationData} */
                _entityAuthData: { value: _entityAuthData, writable: false, enumerable: false, configurable: false },
                /** @type {MasterToken} */
                _masterToken: { value: _masterToken, writable: true, enumerable: false, configurable: false },
                /** @type {number} */
                _messageId: { value: _messageId, writable: false, enumerable: false, configurable: false },
                /** @type {MessageCapabilities} */
                _capabilities: { value: _capabilities, writable: false, enumerable: false, configurable: false },
                /** @type {KeyExchangeData} */
                _keyExchangeData: { value: _keyExchangeData, writable: false, enumerable: false, configurable: false },

                /** @type {boolean} */
                _nonReplayable: { value: _nonReplayable, writable: true, enumerable: false, configurable: false },
                
                /** @type {boolean} */
                _renewable: { value: _renewable, writable: true, enumerable: false, configurable: false },
                /** @type {KeyRequestData} */
                _keyRequestData:{ value: _keyRequestData, writable: false, enumerable: false, configurable: false },
                /** @type {UserAuthenticationData} */
                _userAuthData: { value: _userAuthData, writable: true, enumerable: false, configurable: false },
                /** @type {UserIdToken} */
                _userIdToken: { value: _userIdToken, writable: true, enumerable: false, configurable: false },
                /** @type {Object.<name,ServiceToken>} */
                _serviceTokens: { value: _serviceTokens, writable: false, enumerable: false, configurable: false },

                /** @type {MasterToken} */
                _peerMasterToken: { value: _peerMasterToken, writable: true, enumerable: false, configurable: false },
                /** @type {UserIdToken} */
                _peerUserIdToken: { value: _peerUserIdToken, writable: true, enumerable: false, configurable: false },
                /** @type {Object.<name,ServiceToken>} */
                _peerServiceTokens: { value: _peerServiceTokens, writable: false, enumerable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return {number} the message ID the builder will use.
         */
        getMessageId: function getMessageId() {
            return this._messageId;
        },

        /**
         * @return {MasterToken} the primary master token or null if the message will use entity
         *         authentication data.
         */
        getMasterToken: function getMasterToken() {
            return this._masterToken;
        },

        /**
         * @return {UserIdToken} the primary user ID token or null if the message will use user
         *         authentication data.
         */
        getUserIdToken: function getUserIdToken() {
            return this._userIdToken;
        },

        /**
         * @return {KeyExchangeData} the key exchange data or null if there is none.
         */
        getKeyExchangeData: function getKeyExchangeData() {
            return this._keyExchangeData;
        },

        /**
         * @return {boolean} true if the message builder will create a message capable of
         *        encrypting the header data.
         */
        willEncryptHeader: function willEncryptHeader() {
            return (this._masterToken || EntityAuthenticationScheme$supportsEncryption(this._entityAuthData.scheme));
        },

        /**
         * @return {boolean} true if the message builder will create a message capable of
         *        encrypting the payload data.
         */
        willEncryptPayloads: function willEncryptPayloads() {
            return (this._masterToken ||
                    (!this._ctx.isPeerToPeer() && this._keyExchangeData) ||
                    EntityAuthenticationScheme$supportsEncryption(this._entityAuthData.scheme));
        },
        
        /**
         * @return {boolean} true if the message builder will create a message capable of
         *         integrity protecting the header data.
         */
        willIntegrityProtectHeader: function willIntegrityProtectHeader() {
            return (this._masterToken || EntityAuthenticationScheme$supportsIntegrityProtection(this._entityAuthData.scheme));
        },
        
        /**
         * @return {boolean} true if the message builder will create a message capable of
         *         integrity protecting the payload data.
         */
        willIntegrityProtectPayloads: function willIntegrityProtectPayloads() {
            return (this._masterToken ||
                (!this._ctx.isPeerToPeer() && this._keyExchangeData) ||
                EntityAuthenticationScheme$supportsIntegrityProtection(this._entityAuthData.scheme));
        },

        /**
         * Construct the message header from the current message builder state.
         *
         * @param {{result: function(MessageHeader), error: function(Error)}}
         *        callback the callback that will receive the message header or
         *        any thrown exceptions.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the message.
         * @throws MslMasterTokenException if the header master token is not
         *         trusted and needs to be to accept this message header.
         * @throws MslEntityAuthException if there is an error with the entity
         *         authentication data.
         * @throws MslMessageException if the message is non-replayable but does
         *         not include a master token.
         * @throws MslException should not happen.
         */
        getHeader: function getHeader(callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                var response = (this._keyExchangeData) ? this._keyExchangeData.keyResponseData : null;
                var tokens = new Array();
                for (var name in this._serviceTokens)
                    tokens.push(this._serviceTokens[name]);
                var keyRequests = new Array();
                for (var key in this._keyRequestData)
                    keyRequests.push(this._keyRequestData[key]);
                var nonReplayableId;
                if (this._nonReplayable) {
                    if (!this._masterToken)
                        throw new MslMessageException(MslError.NONREPLAYABLE_MESSAGE_REQUIRES_MASTERTOKEN);
                    nonReplayableId = this._ctx.getMslStore().getNonReplayableId(this._masterToken);
                } else {
                    nonReplayableId = null;
                }
                var headerData = new MessageHeader$HeaderData(this._messageId, nonReplayableId, this._renewable, this._capabilities, keyRequests, response, this._userAuthData, this._userIdToken, tokens);
                var peerTokens = new Array();
                for (var name in this._peerServiceTokens)
                    peerTokens.push(this._peerServiceTokens[name]);
                var peerData = new MessageHeader$HeaderPeerData(this._peerMasterToken, this._peerUserIdToken, peerTokens);
                MessageHeader$create(this._ctx, this._entityAuthData, this._masterToken, headerData, peerData, callback);
            }, self);
        },
        
        /**
         * @return {boolean} true if the message will be marked non-replayable.
         */
        isNonReplayable: function isNonReplayable() {
            return this._nonReplayable;
        },

        /**
         * Make the message non-replayable.
         *
         * @param {boolean} nonReplayable true if the message should be non-replayable.
         * @return this.
         * @see #setRenewable(boolean)
         */
        setNonReplayable: function setNonReplayable(nonReplayable) {
            this._nonReplayable = nonReplayable;
            return this;
        },

        /**
         * @return {boolean} true if the message will be marked renewable.
         */
        isRenewable: function isRenewable() {
            return this._renewable;
        },

        /**
         * Set the message renewable flag.
         *
         * @param {boolean} renewable true if the message is renewable.
         * @return {MessageBuilder} this.
         * @see #setNonReplayable()
         */
        setRenewable: function setRenewable(renewable) {
            this._renewable = renewable;
            return this;
        },

        /**
         * <p>Set or change the master token and user ID token. This will overwrite
         * any existing tokens. If the user ID token is not null then any existing
         * user authentication data will be removed.</p>
         *
         * <p>Changing these tokens may result in invalidation of existing service
         * tokens. Those service tokens will be removed from the message being
         * built.</p>
         * 
         * <p>This is a special method for the {@link MslControl} class that assumes
         * the builder does not have key response data in trusted network mode.</p>
         *
         * @param {MasterToken} masterToken the master token.
         * @param {UserIdToken} userIdToken the user ID token. May be null.
         */
        setAuthTokens: function setAuthTokens(masterToken, userIdToken) {
            // Make sure the assumptions hold. Otherwise a bad message could be
            // built.
            if (userIdToken && !userIdToken.isBoundTo(masterToken))
                throw new MslInternalException("User ID token must be bound to master token.");
            // In trusted network mode key exchange data should only exist if this
            // is a server response. In which case this method should not be
            // getting called.
            if (this._keyExchangeData && !this._ctx.isPeerToPeer())
                throw new MslInternalException("Attempt to set message builder master token when key exchange data exists as a trusted network server.");

            // Load the stored service tokens.
            var storedTokens;
            try {
                storedTokens = this._ctx.getMslStore().getServiceTokens(masterToken, userIdToken);
            } catch (e) {
                // This should never happen because we did not provide a user ID
                // token.
                if (e instanceof MslException)
                    throw new MslInternalException("Invalid master token and user ID token combination despite checking above.", e);
                throw e;
            }

            // Remove any service tokens that will no longer be bound.
            var tokens = new Array();
            for (var name in this._serviceTokens)
                tokens.push(this._serviceTokens[name]);
            tokens.forEach(function(token) {
                if (token.isUserIdTokenBound() && !token.isBoundTo(userIdToken) ||
                    token.isMasterTokenBound() && !token.isBoundTo(masterToken))
                {
                    delete this._serviceTokens[token.name];
                }
            }, this);

            // Add any service tokens based on the MSL store replacing ones already
            // set as they may be newer. The application will have a chance to
            // manage the service tokens before the message is constructed and
            // sent.
            storedTokens.forEach(function(token) {
                this._serviceTokens[token.name] = token;
            }, this);

            // Set the new authentication tokens.
            this._masterToken = masterToken;
            this._userIdToken = userIdToken;
        },

        /**
         * <p>Set the user authentication data of the message.</p>
         * 
         * <p>This will overwrite any existing user authentication data.</p>
         *
         * @param {UserAuthenticationData} userAuthData user authentication data to set. May be null.
         * @return {MessageBuilder} this.
         */
        setUserAuthenticationData: function setUserAuthenticationData(userAuthData) {
            this._userAuthData = userAuthData;
            return this;
        },

        /**
         * <p>Set the remote user (i.e. remote customer) of the message. This will
         * create a user ID token in trusted network mode or peer user ID token in
         * peer-to-peer mode.</p>
         * 
         * <p>Adding a new user ID token will not impact the service tokens; it is
         * assumed that no service tokens exist that are bound to the newly created
         * user ID token.</p>
         * 
         * <p>This is a special method for the {@link MslControl} class that assumes
         * the builder does not already have a user ID token for the remote user
         * and does have a master token that the new user ID token can be bound
         * against.</p>
         *
         * @param {CustomerKey} customer remote user customer.
         * @param {{result: function(boolean), error: function(Error)}} callback
         *        the callback will receive true on completion or any thrown
         *        exceptions.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the token data.
         * @throws MslException if there is an error creating the user ID token.
         */
        setCustomer: function setCustomer(customer, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // Make sure the assumptions hold. Otherwise a bad message could be
                // built.
                if (!this._ctx.isPeerToPeer() && this._userIdToken != null ||
                        this._ctx.isPeerToPeer() && this._peerUserIdToken != null)
                {
                    throw new MslInternalException("User ID token or peer user ID token already exists for the remote user.");
                }

                // If key exchange data is provided then its master token should be
                // used for the new user ID token and for querying service tokens.
                var uitMasterToken;
                if (this._keyExchangeData) {
                    uitMasterToken = this._keyExchangeData.keyResponseData.masterToken;
                } else {
                    uitMasterToken = (!this._ctx.isPeerToPeer()) ? this._masterToken : this._peerMasterToken;
                }

                // Make sure we have a master token to create the customer for.
                if (!uitMasterToken)
                    throw new MslInternalException("User ID token or peer user ID token cannot be created because no corresponding master token exists.");

                // Create the new user ID token.
                var factory = this._ctx.getTokenFactory();
                factory.createUserIdToken(this._ctx, customer, uitMasterToken, {
                    result: function(userIdToken) {
                        AsyncExecutor(callback, function() {
                            // Set the new user ID token.
                            if (!this._ctx.isPeerToPeer()) {
                                this._userIdToken = userIdToken;
                                this._userAuthData = null;
                            } else {
                                this._peerUserIdToken = userIdToken;
                            }

                            // Success.
                            return true;
                        }, self);
                    },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * Add key request data to the message.
         *
         * @param {KeyRequestData} keyRequestData key request data to add.
         * @return {MessageBuilder} this.
         */
        addKeyRequestData: function addKeyRequestData(keyRequestData) {
            this._keyRequestData[keyRequestData.uniqueKey()] = keyRequestData;
            return this;
        },

        /**
         * Remove key request data from the message.
         *
         * @param {KeyRequestData} keyRequestData key request data to remove.
         * @return {MessageBuilder} this.
         */
        removeKeyRequestData: function removeKeyRequestData(keyRequestData) {
            delete this._keyRequestData[keyRequestData.uniqueKey()];
            return this;
        },

        /**
         * <p>Add a service token to the message. This will overwrite any service
         * token with the same name.</p>
         *
         * <p>Adding a service token with empty data indicates the recipient should
         * delete the service token.</p>
         *
         * @param {ServiceToken} serviceToken service token to add.
         * @return {MessageBuilder} this.
         * @throws MslMessageException if the service token serial numbers do not
         *         match the primary master token or primary user ID token of the
         *         message being built.
         */
        addServiceToken: function addServiceToken(serviceToken) {
            // If key exchange data is provided and we are not in peer-to-peer mode
            // then its master token should be used for querying service tokens.
            var serviceMasterToken;
            if (this._keyExchangeData && !this._ctx.isPeerToPeer()) {
                serviceMasterToken = this._keyExchangeData.keyResponseData.masterToken;
            } else {
                serviceMasterToken = this._masterToken;
            }

            // Make sure the service token is properly bound.
            if (serviceToken.isMasterTokenBound() && !serviceToken.isBoundTo(serviceMasterToken))
                throw new MslMessageException(MslError.SERVICETOKEN_MASTERTOKEN_MISMATCH, "st " + JSON.stringify(serviceToken) + "; mt " + JSON.stringify(serviceMasterToken)).setEntity(serviceMasterToken);
            if (serviceToken.isUserIdTokenBound() && !serviceToken.isBoundTo(this._userIdToken))
                throw new MslMessageException(MslError.SERVICETOKEN_USERIDTOKEN_MISMATCH, "st " + JSON.stringify(serviceToken) + "; uit " + JSON.stringify(this._userIdToken)).setEntity(serviceMasterToken).setUser(this._userIdToken);

            // Add the service token.
            this._serviceTokens[serviceToken.name] = serviceToken;
            return this;
        },

        /**
         * <p>Add a service token to the message if a service token with the same
         * name does not already exist.</p>
         * 
         * <p>Adding a service token with empty data indicates the recipient should
         * delete the service token.</p>
         *
         * @param {ServiceToken} serviceToken service token to add.
         * @return {MessageBuilder} this.
         * @throws MslMessageException if the service token serial numbers do not
         *         match the master token or user ID token of the message being
         *         built.
         */
        addServiceTokenIfAbsent: function addServiceTokenIfAbsent(serviceToken) {
            if (!this._serviceTokens[serviceToken.name])
                this.addServiceToken(serviceToken);
            return this;
        },

        /**
         * <p>Exclude a service token from the message.</p>
         *
         * <p>The service token will not be sent in the built message. This is not
         * the same as requesting the remote entity delete a service token.</p>
         *
         * @param {string} name service token name.
         * @return {MessageBuilder} this.
         */
        excludeServiceToken: function excludeServiceToken(name) {
            delete this._serviceTokens[name];
            return this;
        },

        /**
         * <p>Mark a service token for deletion, if it exists. Otherwise this
         * method does nothing.</p>
         *
         * <p>The service token will be sent in the built message with an empty
         * value. This is not the same as requesting that a service token be
         * excluded from the message.</p>
         *
         * @param {string} name service token name.
         * @param {{result: function(MessageBuilder), error: function(Error)}}
         *        callback the callback that will receive this message builder
         *        upon completion or any thrown exceptions.
         */
        deleteServiceToken: function deleteServiceToken(name, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // Do nothing if the original token does not exist.
                var originalToken = this._serviceTokens[name];
                if (!originalToken)
                    return this;

                // Rebuild the original token with empty service data.
                var masterToken = originalToken.isMasterTokenBound() ? this._masterToken : null;
                var userIdToken = originalToken.isUserIdTokenBound() ? this._userIdToken : null;
                ServiceToken$create(this._ctx, name, EMPTY_DATA, masterToken, userIdToken, false, null, new NullCryptoContext(), {
                    result: function(token) {
                        AsyncExecutor(callback, function() {
                            return this.addServiceToken(token);
                        }, self);
                    },
                    error: function(e) {
                        if (e instanceof MslException)
                            e = new MslInternalException("Failed to create and add empty service token to message.", e);
                        callback.error(e);
                    }
                });
            }, self);
        },

        /**
         * @return {Array.<ServiceToken>} the unmodifiable set of service tokens that will be included in
         *         the built message.
         */
        getServiceTokens: function getServiceTokens() {
            var tokens = new Array();
            for (var name in this._serviceTokens)
                tokens.push(this._serviceTokens[name]);
            return tokens;
        },

        /**
         * @return {MasterToken} the peer master token or null if there is none.
         */
        getPeerMasterToken: function getPeerMasterToken() {
            return this._peerMasterToken;
        },

        /**
         * @return {UserIdToken} the peer user ID token or null if there is none.
         */
        getPeerUserIdToken: function getPeerUserIdToken() {
            return this._peerUserIdToken;
        },

        /**
         * <p>Set the peer master token and peer user ID token of the message. This
         * will overwrite any existing peer master token or peer user ID token.</p>
         * 
         * <p>Changing these tokens may result in invalidation of existing peer
         * service tokens. Those peer service tokens will be removed from the
         * message being built.</p>
         *
         * @param {MasterToken} masterToken peer master token to set. May be null.
         * @param {UserIdToken} userIdToken peer user ID token to set. May be null.
         * @return {MessageBuilder} this.
         * @throws MslMessageException if the peer user ID token is not bound to
         *         the peer master token.
         */
        setPeerAuthTokens: function setPeerAuthTokens(masterToken, userIdToken) {
            if (!this._ctx.isPeerToPeer())
                throw new MslInternalException("Cannot set peer master token or peer user ID token when not in peer-to-peer mode.");
            if (userIdToken && !masterToken)
                throw new MslInternalException("Peer master token cannot be null when setting peer user ID token.");
            if (userIdToken && !userIdToken.isBoundTo(masterToken))
                throw new MslMessageException(MslError.USERIDTOKEN_MASTERTOKEN_MISMATCH, "uit " + userIdToken + "; mt " + masterToken).setEntity(masterToken).setUser(userIdToken);

            // Load the stored peer service tokens.
            var storedTokens;
            try {
                storedTokens = this._ctx.getMslStore().getServiceTokens(masterToken, userIdToken);
            } catch (e) {
                // The checks above should have prevented any invalid master token,
                // user ID token combinations.
                if (e instanceof MslException)
                    throw new MslInternalException("Invalid peer master token and user ID token combination despite proper check.", e);
                throw e;
            }

            // Remove any peer service tokens that will no longer be bound.
            var names = Object.keys(this._peerServiceTokens);
            names.forEach(function(name) {
                var token = this._peerServiceTokens[name];
                if (token.isUserIdTokenBound() && !token.isBoundTo(userIdToken)) {
                    delete this._peerServiceTokens[name];
                    return;
                }
                if (token.isMasterTokenBound() && !token.isBoundTo(masterToken)) {
                    delete this._peerServiceTokens[name];
                    return;
                }
            }, this);

            // Add any peer service tokens based on the MSL store if they are not
            // already set (as a set one may be newer than the stored one).
            storedTokens.forEach(function(token) {
                var name = token.name;
                if (!this._peerServiceTokens[name])
                    this._peerServiceTokens[name] = token;
            }, this);

            // Set the new peer authentication tokens.
            this._peerUserIdToken = userIdToken;
            this._peerMasterToken = masterToken;
            return this;
        },

        /**
         * <p>Add a peer service token to the message. This will overwrite any peer
         * service token with the same name.</p>
         *
         * <p>Adding a service token with empty data indicates the recipient should
         * delete the service token.</p>
         *
         * @param {ServiceToken} serviceToken service token to add.
         * @return {MessageBuilder} this.
         * @throws MslMessageException if the service token serial numbers do not
         *         match the peer master token or peer user ID token of the message
         *         being built.
         */
        addPeerServiceToken: function addPeerServiceToken(serviceToken) {
            if (!this._ctx.isPeerToPeer())
                throw new MslInternalException("Cannot set peer service tokens when not in peer-to-peer mode.");
            if (serviceToken.isMasterTokenBound() && !serviceToken.isBoundTo(this._peerMasterToken))
                throw new MslMessageException(MslError.SERVICETOKEN_MASTERTOKEN_MISMATCH, "st " + JSON.stringify(serviceToken) + "; mt " + JSON.stringify(this._peerMasterToken)).setEntity(this._peerMasterToken);
            if (serviceToken.isUserIdTokenBound() && !serviceToken.isBoundTo(this._peerUserIdToken))
                throw new MslMessageException(MslError.SERVICETOKEN_USERIDTOKEN_MISMATCH, "st " + JSON.stringify(serviceToken) + "; uit " + JSON.stringify(this._peerUserIdToken)).setEntity(this._peerMasterToken).setUser(this._peerUserIdToken);

            // Add the peer service token.
            this._peerServiceTokens[serviceToken.name] = serviceToken;
            return this;
        },

        /**
         * <p>Add a peer service token to the message if a peer service token with
         * the same name does not already exist.</p>
         * 
         * <p>Adding a service token with empty data indicates the recipient should
         * delete the service token.</p>
         *
         * @param {ServiceToken} serviceToken service token to add.
         * @return {MessageBuilder} this.
         * @throws MslMessageException if the service token serial numbers do not
         *         match the peer master token or peer user ID token of the message
         *         being built.
         */
        addPeerServiceTokenIfAbsent: function addPeerServiceTokenIfAbsent(serviceToken) {
            if (!this._peerServiceTokens[serviceToken.name])
                this.addPeerServiceToken(serviceToken);
            return this;
        },

        /**
         * <p>Exclude a peer service token from the message.</p>
         *
         * <p>The service token will not be sent in the built message. This is not
         * the same as requesting the remote entity delete a service token.</p>
         *
         * @param {string} name service token name.
         * @return {MessageBuilder} this.
         */
        excludePeerServiceToken: function excludePeerServiceToken(name) {
            delete this._peerServiceTokens[name];
            return this;
        },

        /**
         * <p>Mark a peer service token for deletion, if it exists. Otherwise this
         * method does nothing.</p>
         *
         * <p>The service token will be sent in the built message with an empty
         * value. This is not the same as requesting that a service token be
         * excluded from the message.</p>
         *
         * @param {string} name service token name.
         * @param {{result: function(MessageBuilder), error: function(Error)}}
         *        callback the callback that will receive this message builder
         *        upon completion or any thrown exceptions.
         */
        deletePeerServiceToken: function deletePeerServiceToken(name, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // Do nothing if the original token does not exist.
                var originalToken = this._peerServiceTokens[name];
                if (!originalToken)
                    return this;

                // Rebuild the original token with empty service data.
                var peerMasterToken = originalToken.isMasterTokenBound() ? this._peerMasterToken : null;
                var peerUserIdToken = originalToken.isUserIdTokenBound() ? this._peerUserIdToken : null;
                ServiceToken$create(this._ctx, name, EMPTY_DATA, peerMasterToken, peerUserIdToken, false, null, new NullCryptoContext(), {
                    result: function(token) {
                        AsyncExecutor(callback, function() {
                            return this.addPeerServiceToken(token);
                        }, self);
                    },
                    error: function(e) {
                        if (e instanceof MslException)
                            e = new MslInternalException("Failed to create and add empty peer service token to message.", e);
                        callback.error(e);
                    }
                });
            }, self);
        },

        /**
         * @return {Array.<ServiceToken>} the unmodifiable set of peer service tokens that will be included in
         *         the built message.
         */
        getPeerServiceTokens: function getPeerServiceTokens() {
            var tokens = new Array();
            for (var name in this._peerServiceTokens)
                tokens.push(this._peerServiceTokens[name]);
            return tokens;
        },
    });
})();



// -- javascript/msg/MessageServiceTokenBuilder.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A message service token builder provides methods for intelligently
 * manipulating the primary and peer service tokens that will be included in a
 * message.</p>
 *
 * <p>There are two categories of service tokens: primary and peer.
 * <ul>
 * <li>Primary service tokens are associated with the primary master token and
 * peer user ID token, and are the only category of service token to appear in
 * trusted network mode. Primary service tokens are also used in peer-to-peer
 * mode.</li>
 * <li>Peer service tokens are associated with the peer master token and peer
 * user ID token and only used in peer-to-peer mode.</li>
 * </ul></p>
 *
 * <p>There are three levels of service token binding.
 * <ul>
 * <li>Unbound service tokens may be freely moved between entities and
 * users.</li>
 * <li>Master token bound service tokens must be accompanied by a master token
 * that they are bound to and will be rejected if sent with a different master
 * token or without a master token. This binds a service token to a specific
 * entity.</li>
 * <li>User ID token bound service tokens must be accompanied by a user ID
 * token that they are bound to and will be rejected if sent with a different
 * user or used without a user ID token. This binds a service token to a
 * specific user and by extension a specific entity.</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MessageServiceTokenBuilder;

(function() {
    "use strict";

    /**
     * <p>Select the appropriate crypto context for the named service token.</p>
     * 
     * <p>If the service token name exists as a key in the map of crypto
     * contexts, the mapped crypto context will be returned. Otherwise the
     * default crypto context mapped from the empty string key will be returned.
     * If no explicit or default crypto context exists null will be
     * returned.</p>
     *
     * @param {string} name service token name.
     * @param {Object.<string,ICryptoContext>} cryptoContexts the map of service token names onto crypto
     *        contexts used to decrypt and verify service tokens.
     * @return the correct crypto context for the service token or null.
     */
    function selectCryptoContext(name, cryptoContexts) {
        if (cryptoContexts[name])
            return cryptoContexts[name];
        return cryptoContexts[""];
    }
    
    /**
     * Returns the master token that primary service tokens should be bound
     * against.
     * 
     * @param {MessageServiceTokenBuilder} stBuilder the message service token
     *        builder.
     * @return {MasterToken} the primary service token master token or {@code null} if there
     *         is none.
     */
    function getPrimaryMasterToken(stBuilder) {
        // If key exchange data is provided and we are not in peer-to-peer mode
        // then its master token will be used for creating service tokens.
        var keyExchangeData = stBuilder.builder.getKeyExchangeData();
        if (keyExchangeData && !stBuilder.ctx.isPeerToPeer()) {
            return keyExchangeData.keyResponseData.masterToken;
        } else {
            return stBuilder.builder.getMasterToken();
        }
    }

    MessageServiceTokenBuilder = util.Class.create({
        /**
         * Create a new message service token builder with the provided MSL and
         * message contexts and message builder.
         *
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {MessageBuilder} builder message builder for message being built.
         */
        init: function init(ctx, msgCtx, builder) {
            // The properties.
            var props = {
                ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                cryptoContexts: { value: msgCtx.getCryptoContexts(), writable: false, enumerable: false, configurable: false },
                builder: { value: builder, writable: false, enumerable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /**
         * Returns true if the message has a primary master token available for
         * adding master-bound primary service tokens.
         * 
         * @return {boolean} true if the message has a primary master token.
         */
        isPrimaryMasterTokenAvailable: function isPrimaryMasterTokenAvailable() {
            return (getPrimaryMasterToken(this)) ? true: false;
        },

        /**
         * @return {boolean} true if the message has a primary user ID token.
         */
        isPrimaryUserIdTokenAvailable: function isPrimaryUserIdTokenAvailable() {
            return (this.builder.getUserIdToken()) ? true : false;
        },

        /**
         * @return {boolean} true if the message has a peer master token.
         */
        isPeerMasterTokenAvailable: function isPeerMasterTokenAvailable() {
            return (this.builder.getPeerMasterToken()) ? true : false;
        },

        /**
         * @return {boolean} true if the message has a peer user ID token.
         */
        isPeerUserIdTokenAvailable: function isPeerUserIdTokenAvailable() {
            return (this.builder.getPeerUserIdToken()) ? true : false;
        },

        /**
         * @return {Array.<ServiceToken>} the unmodifiable set of primary service tokens that will be
         *         included in the built message.
         */
        getPrimaryServiceTokens: function getPrimaryServiceTokens() {
            return this.builder.getServiceTokens();
        },

        /**
         * @return {Array.<ServiceToken>} the unmodifiable set of peer service tokens that will be
         *         included in the built message.
         */
        getPeerServiceTokens: function getPeerServiceTokens() {
            return this.builder.getPeerServiceTokens();
        },
        
        /**
         * Adds a primary service token to the message, replacing any existing
         * primary service token with the same name.
         * 
         * @param {ServiceToken} serviceToken primary service token.
         * @return true if the service token was added, false if the service token
         *         is bound to a master token or user ID token and the message does
         *         not have the same token.
         * @throws MslMessageException if the service token serial numbers do not
         *         match the primary master token or primary user ID token of the
         *         message being built.
         */
        addPrimaryServiceToken: function addPrimaryServiceToken(serviceToken) {
            try {
                this.builder.addServiceToken(serviceToken);
                return true;
            } catch (e) {
                if (e instanceof MslMessageException)
                    return false;
                throw e;
            }
        },
        
        /**
         * Adds a peer service token to the message, replacing any existing peer
         * service token with the same name.
         * 
         * @param {ServiceToken} serviceToken peer service token.
         * @return true if the service token was added, false if the service token
         *         is bound to a master token or user ID token and the message does
         *         not have the same token.
         * @throws MslMessageException if the service token serial numbers do not
         *         match the peer master token or peer user ID token of the message
         *         being built.
         */
        addPeerServiceToken: function addPeerServiceToken(serviceToken) {
            try {
                this.builder.addPeerServiceToken(serviceToken);
                return true;
            } catch (e) {
                if (e instanceof MslMessageException)
                    return false;
                throw e;
            }
        },

        /**
         * Adds a new unbound primary service token to the message, replacing any
         * existing primary service token with the same name.
         *
         * @param {string} name service token name.
         * @param {Uint8Array} data service token data.
         * @param {boolean} encrypt true if the service token data should be encrypted.
         * @param {MslConstants$CompressionAlgorithm} compressionAlgo the compression algorithm. May be {@code null}
         *        for no compression.
         * @param {{result: function(boolean), error: function(Error)}} callback
         *        the callback will receive true if the service token was added
         *        and false if there is no crypto context found for this
         *        service token, or any thrown exceptions.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the token data.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslException if there is an error compressing the data.
         */
        addUnboundPrimaryServiceToken: function addUnboundPrimaryServiceToken(name, data, encrypt, compressionAlgo, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // Fail if there is no crypto context.
                var cryptoContext = selectCryptoContext(name, this.cryptoContexts);
                if (!cryptoContext)
                    return false;

                // Add the service token.
                ServiceToken$create(this.ctx, name, data, null, null, encrypt, compressionAlgo, cryptoContext, {
                    result: function(serviceToken) {
                        AsyncExecutor(callback, function() {
                            try {
                                this.builder.addServiceToken(serviceToken);
                            } catch (e) {
                                if (e instanceof MslMessageException)
                                    throw new MslInternalException("Service token bound to incorrect authentication tokens despite being unbound.", e);
                                throw e;
                            }
                            return true;
                        }, self);
                    },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * Adds a new unbound peer service token to the message, replacing any
         * existing peer service token with the same name.
         *
         * @param {string} name service token name.
         * @param {Uint8Array} data service token data.
         * @param {boolean} encrypt true if the service token data should be encrypted.
         * @param {MslConstants$CompressionAlgorithm} compressionAlgo the compression algorithm. May be {@code null}
         *        for no compression.
         * @param {{result: function(boolean), error: function(Error)}} callback
         *        the callback will receive true if the service token was added
         *        and false if there is no crypto context found for this
         *        service token, or any thrown exceptions.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the token data.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslException if there is an error compressing the data.
         */
        addUnboundPeerServiceToken: function addUnboundPeerServiceToken(name, data, encrypt, compressionAlgo, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // Fail if there is no crypto context.
                var cryptoContext = selectCryptoContext(name, this.cryptoContexts);
                if (!cryptoContext)
                    return false;
                ServiceToken$create(this.ctx, name, data, null, null, encrypt, compressionAlgo, cryptoContext, {
                    result: function(serviceToken) {
                        AsyncExecutor(callback, function() {
                            // Add the service token.
                            try {
                                this.builder.addPeerServiceToken(serviceToken);
                            } catch (e) {
                                if (e instanceof MslMessageException)
                                    throw new MslInternalException("Service token bound to incorrect authentication tokens despite being unbound.", e);
                                throw e;
                            }
                            return true;
                        }, self);
                    },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * Adds a new master token bound primary service token to the message,
         * replacing any existing primary service token with the same name.
         *
         * @param {string} name service token name.
         * @param {Uint8Array} data service token data.
         * @param {boolean} encrypt true if the service token data should be encrypted.
         * @param {MslConstants$CompressionAlgorithm} compressionAlgo the compression algorithm. May be {@code null}
         *        for no compression.
         * @param {{result: function(boolean), error: function(Error)}} callback
         *        the callback will receive true if the service token was added
         *        and false if there is no crypto context found for this
         *        service token or the message does not have a master token, or
         *        any thrown exceptions.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the token data.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslException if there is an error compressing the data.
         */
        addMasterBoundPrimaryServiceToken: function addMasterBoundPrimaryServiceToken(name, data, encrypt, compressionAlgo, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // Fail if there is no master token.
                var masterToken = getPrimaryMasterToken(this);
                if (!masterToken)
                    return false;

                // Fail if there is no crypto context.
                var cryptoContext = selectCryptoContext(name, this.cryptoContexts);
                if (!cryptoContext)
                    return false;

                // Add the service token.
                ServiceToken$create(this.ctx, name, data, masterToken, null, encrypt, compressionAlgo, cryptoContext, {
                    result: function(serviceToken) {
                        AsyncExecutor(callback, function() {
                            try {
                                this.builder.addServiceToken(serviceToken);
                            } catch (e) {
                                if (e instanceof MslMessageException)
                                    throw new MslInternalException("Service token bound to incorrect authentication tokens despite setting correct master token.", e);
                                throw e;
                            }
                            return true;
                        }, self);
                    },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * Adds a new master token bound peer service token to the message,
         * replacing any existing peer service token with the same name.
         *
         * @param {string} name service token name.
         * @param {Uint8Array} data service token data.
         * @param {boolean} encrypt true if the service token data should be encrypted.
         * @param {MslConstants$CompressionAlgorithm} compressionAlgo the compression algorithm. May be {@code null}
         *        for no compression.
         * @param {{result: function(boolean), error: function(Error)}} callback
         *        the callback will receive true if the service token was added
         *        and false if there is no crypto context found for this
         *        service token or the message does not have a peer master
         *        token, or any thrown exceptions.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the token data.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslException if there is an error compressing the data.
         */
        addMasterBoundPeerServiceToken: function addMasterBoundPeerServiceToken(name, data, encrypt, compressionAlgo, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // Fail if there is no master token.
                var masterToken = this.builder.getPeerMasterToken();
                if (!masterToken)
                    return false;

                // Fail if there is no crypto context.
                var cryptoContext = selectCryptoContext(name, this.cryptoContexts);
                if (!cryptoContext)
                    return false;

                // Add the service token.
                ServiceToken$create(this.ctx, name, data, masterToken, null, encrypt, compressionAlgo, cryptoContext, {
                    result: function(serviceToken) {
                        AsyncExecutor(callback, function() {
                            try {
                                this.builder.addPeerServiceToken(serviceToken);
                            } catch (e) {
                                if (e instanceof MslMessageException)
                                    throw new MslInternalException("Service token bound to incorrect authentication tokens despite setting correct master token.", e);
                                throw e;
                            }
                            return true;
                        }, self);
                    },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * Adds a new user ID token bound primary service token to the message,
         * replacing any existing primary service token with the same name.
         *
         * @param {string} name service token name.
         * @param {Uint8Array} data service token data.
         * @param {boolean} encrypt true if the service token data should be encrypted.
         * @param {MslConstants$CompressionAlgorithm} compressionAlgo the compression algorithm. May be {@code null}
         *        for no compression.
         * @param {{result: function(boolean), error: function(Error)}} callback
         *        the callback will receive true if the service token was added
         *        and false if there is no crypto context found for this
         *        service token or the message does not have a primary user ID
         *        token, or any thrown exceptions.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the token data.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslException if there is an error compressing the data.
         */
        addUserBoundPrimaryServiceToken: function addUserBoundPrimaryServiceToken(name, data, encrypt, compressionAlgo, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // Fail if there is no master token.
                var masterToken = getPrimaryMasterToken(this);
                if (!masterToken)
                    return false;

                // Fail if there is no user ID token.
                var userIdToken = this.builder.getUserIdToken();
                if (!userIdToken)
                    return false;

                // Fail if there is no crypto context.
                var cryptoContext = selectCryptoContext(name, this.cryptoContexts);
                if (!cryptoContext)
                    return false;

                // Add the service token.
                ServiceToken$create(this.ctx, name, data, masterToken, userIdToken, encrypt, compressionAlgo, cryptoContext, {
                    result: function(serviceToken) {
                        AsyncExecutor(callback, function() {
                            try {
                                this.builder.addServiceToken(serviceToken);
                            } catch (e) {
                                if (e instanceof MslMessageException)
                                    throw new MslInternalException("Service token bound to incorrect authentication tokens despite setting correct master token and user ID token.", e);
                                throw e;
                            }
                            return true;
                        }, self);
                    },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * Adds a new user ID token bound peer service token to the message,
         * replacing any peer existing service token with the same name.
         *
         * @param {string} name service token name.
         * @param {Uint8Array} data service token data.
         * @param {boolean} encrypt true if the service token data should be encrypted.
         * @param {MslConstants$CompressionAlgorithm} compressionAlgo the compression algorithm. May be {@code null}
         *        for no compression.
         * @param {{result: function(boolean), error: function(Error)}} callback
         *        the callback will receive true if the service token was added
         *        and false if there is no crypto context found for this
         *        service token or the message does not have a peer user ID
         *        token, or any thrown exceptions.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the token data.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslException if there is an error compressing the data.
         */
        addUserBoundPeerServiceToken: function addUserBoundPeerServiceToken(name, data, encrypt, compressionAlgo, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // Fail if there is no master token.
                var masterToken = this.builder.getPeerMasterToken();
                if (!masterToken)
                    return false;

                // Fail if there is no user ID token.
                var userIdToken = this.builder.getPeerUserIdToken();
                if (!userIdToken)
                    return false;

                // Fail if there is no crypto context.
                var cryptoContext = selectCryptoContext(name, this.cryptoContexts);
                if (!cryptoContext)
                    return false;

                // Add the service token.
                ServiceToken$create(this.ctx, name, data, masterToken, userIdToken, encrypt, compressionAlgo, cryptoContext, {
                    result: function(serviceToken) {
                        AsyncExecutor(callback, function() {
                            try {
                                this.builder.addPeerServiceToken(serviceToken);
                            } catch (e) {
                                if (e instanceof MslMessageException)
                                    throw new MslInternalException("Service token bound to incorrect authentication tokens despite setting correct master token and user ID token.", e);
                                throw e;
                            }
                            return true;
                        }, self);
                    },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * <p>Exclude a primary service token from the message.</p>
         *
         * <p>The service token will not be sent in the built message. This is not
         * the same as requesting the remote entity delete a service token.</p>
         *
         * @param {string} name service token name.
         * @return {boolean} true if the service token was found and therefore removed.
         */
        excludePrimaryServiceToken: function excludePrimaryServiceToken(name) {
            // Exclude the service token if found.
            var serviceTokens = this.builder.getServiceTokens();
            for (var i = 0; i < serviceTokens.length; ++i) {
                var serviceToken = serviceTokens[i];
                if (serviceToken.name == name) {
                    this.builder.excludeServiceToken(name);
                    return true;
                }
            }

            // Not found.
            return false;
        },

        /**
         * <p>Exclude a peer service token from the message.</p>
         *
         * <p>The service token will not be sent in the built message. This is not
         * the same as requesting the remote entity delete a service token.</p>
         *
         * @param {string} name service token name.
         * @return {boolean} true if the peer service token was found and therefore removed.
         */
        excludePeerServiceToken: function excludePeerServiceToken(name) {
            // Exclude the service token if found.
            var peerServiceTokens = this.builder.getPeerServiceTokens();
            for (var i = 0; i < peerServiceTokens.length; ++i) {
                var serviceToken = peerServiceTokens[i];
                if (serviceToken.name == name) {
                    this.builder.excludePeerServiceToken(name);
                    return true;
                }
            }

            // Not found.
            return false;
        },

        /**
         * <p>Mark a primary service token for deletion, if it exists.</p>
         *
         * <p>The service token will be sent in the built message with an empty
         * value. This is not the same as requesting that a service token be
         * excluded from the message.</p>
         *
         * @param {string} name service token name.
         * @param {{result: function(boolean), error: function(Error)}} callback
         *        the callback will receive true if the service token exists
         *        and was marked for deletion, or any thrown exceptions.
         */
        deletePrimaryServiceToken: function deletePrimaryServiceToken(name, callback) {
            AsyncExecutor(callback, function() {
                // Mark the service token for deletion if found.
                var serviceTokens = this.builder.getServiceTokens();
                for (var i = 0; i < serviceTokens.length; ++i) {
                    var serviceToken = serviceTokens[i];
                    if (serviceToken.name == name) {
                        this.builder.deleteServiceToken(name, {
                            result: function() { callback.result(true); },
                            error: function(e) { callback.error(e); }
                        });
                        return;
                    }
                }

                // Not found.
                return false;
            }, this);
        },

        /**
         * <p>Mark a peer service token for deletion, if it exists.</p>
         *
         * <p>The service token will be sent in the built message with an empty
         * value. This is not the same as requesting that a service token be
         * excluded from the message.</p>
         *
         * @param {string} name service token name.
         * @param {{result: function(boolean), error: function(Error)}} callback
         *        the callback will receive true if the peer service token
         *        exists and was marked for deletion, or any thrown exceptions.
         */
        deletePeerServiceToken: function deletePeerServiceToken(name, callback) {
            AsyncExecutor(callback, function() {
                // Mark the service token for deletion if found.
                var peerServiceTokens = this.builder.getPeerServiceTokens();
                for (var i = 0; i < peerServiceTokens.length; ++i) {
                    var serviceToken = peerServiceTokens[i];
                    if (serviceToken.name == name) {
                        this.builder.deletePeerServiceToken(name, {
                            result: function() { callback.result(true); },
                            error: function(e) { callback.error(e); }
                        });
                        return;
                    }
                }

                // Not found.
                return false;
            }, this);
        },
    });
})();



// -- javascript/msg/MessageInputStream.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A MSL message consists of a single MSL header followed by one or more
 * payload chunks carrying application data. Each payload chunk is individually
 * packaged but sequentially ordered. No payload chunks may be included in an
 * error message.</p>
 *
 * <p>Data is read until an end-of-message payload chunk is encountered or an
 * error occurs. Closing a {@code MessageInputStream} does not close the source
 * input stream in case additional MSL messages will be read.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MessageInputStream;
var MessageInputStream$create;

(function() {
    "use strict";

    /**
     * Delay time between read attempts in milliseconds.
     *
     * @const
     * @type {number}
     */
    var READ_DELAY = 10;

    /**
     * Maximum JSON value size in characters (10MB).
     *
     * @const
     * @type {number}
     */
    var MAX_CHARACTERS = 10 * 1024 * 1024;

    /**
     * <p>Return the crypto context resulting from key response data contained
     * in the provided header.</p>
     *
     * <p>The {@link MslException}s thrown by this method will not have the
     * entity or user set.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {MessageHeader} header header.
     * @param {Array.<KeyRequestData>} keyRequestData key request data for key exchange.
     * @param {{result: function(ICryptoContext), error: function(Error)}}
     *        callback the callback that will receive the crypto context, which
     *        may be null if the header does not contain key response data or
     *        is an error message, or any thrown exceptions.
     * @throws MslKeyExchangeException if there is an error with the key
     *         request data or key response data or the key exchange scheme is
     *         not supported.
     * @throws MslCryptoException if the crypto context cannot be created.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslMasterTokenException if the master token is not trusted and
     *         needs to be.
     * @throws MslEntityAuthException if there is a problem with the master
     *         token identity.
     */
    function getKeyxCryptoContext(ctx, header, keyRequestData, callback) {
        AsyncExecutor(callback, function() {
            // Pull the header data.
            var messageHeader = header;
            var masterToken = messageHeader.masterToken;
            var keyResponse = messageHeader.keyResponseData;

            // If there is no key response data then return null.
            if (!keyResponse)
                return null;

            // Perform the key exchange.
            var responseScheme = keyResponse.keyExchangeScheme;
            var factory = ctx.getKeyExchangeFactory(responseScheme);
            if (!factory)
                throw new MslKeyExchangeException(MslError.KEYX_FACTORY_NOT_FOUND, responseScheme);

            // Attempt the key exchange but if it fails then try with the next
            // key request data before giving up.
            var keyxException;
            var requestIndex = 0;
            function nextExchange() {
                AsyncExecutor(callback, function() {
                    // If we've reached the end of the requests then stop.
                    if (requestIndex >= keyRequestData.length) {
                        // We did not perform a successful key exchange. If we caught an
                        // exception then throw that exception now.
                        if (keyxException)
                            throw keyxException;

                        // If we didn't find any then we're unable to perform key
                        // exchange.
                        throw new MslKeyExchangeException(MslError.KEYX_RESPONSE_REQUEST_MISMATCH, JSON.stringify(keyRequestData));
                    }

                    // Grab this iteration's request.
                    var keyRequest = keyRequestData[requestIndex];
                    if (responseScheme != keyRequest.keyExchangeScheme) {
                        // Try the next request.
                        ++requestIndex;
                        nextExchange();
                        return;
                    }

                    // Attempt the key exchange.
                    factory.getCryptoContext(ctx, keyRequest, keyResponse, masterToken, {
                        result: callback.result,
                        error: function(e) {
                            AsyncExecutor(callback, function() {
                                // Immediately deliver anything that's not a
                                // MslException.
                                if (!(e instanceof MslException))
                                    throw e;

                                // Otherwise save this exception and try the next
                                // combination.
                                // FIXME log the exception.
                                keyxException = e;
                                ++requestIndex;
                                nextExchange();
                            });
                        }
                    });
                });
            }

            nextExchange();
        });
    }

    MessageInputStream = InputStream.extend({
        /**
         * <p>Construct a new message input stream. The header is parsed.</p>
         *
         * <p>If key request data is provided and a matching key response data is
         * found in the message header the key exchange will be performed to
         * process the message payloads.</p>
         *
         * <p>Service tokens will be decrypted and verified with the provided crypto
         * contexts identified by token name. A default crypto context may be
         * provided by using the empty string as the token name; if a token name is
         * not explcitly mapped onto a crypto context, the default crypto context
         * will be used.</p>
         *
         * @param {MslContext} ctx MSL context.
         * @param {InputStream} source MSL input stream.
         * @param {string} charset input stream character set encoding.
         * @param {Array.<KeyRequestData>} keyRequestData key request data to use when processing key
         *        response data.
         * @param {Object.<string,ICryptoContext>} cryptoContexts the map of service token names onto crypto
         *        contexts used to decrypt and verify service tokens.
         * @param {number} timeout read timeout in milliseconds.
         * @param {{result: function(MessageInputStream), timeout: function(), error: function(Error)}}
         *        callback the callback that will receive the message input
         *        stream, or any thrown exceptions.
         * @throws MslEncodingException if there is an error parsing the message.
         * @throws MslCryptoException if there is an error decrypting or verifying
         *         the header or creating the message payload crypto context.
         * @throws MslEntityAuthException if unable to create the entity
         *         authentication data.
         * @throws MslUserAuthException if unable to create the user authentication
         *         data.
         * @throws MslMessageException if the message master token is expired and
         *         the message is not renewable.
         * @throws MslMasterTokenException if the master token is not trusted and
         *         needs to be or if it has been revoked.
         * @throws MslUserIdTokenException if the user ID token has been revoked.
         * @throws MslKeyExchangeException if there is an error with the key
         *         request data or key response data or the key exchange scheme is
         *         not supported.
         * @throws MslMessageException if the message master token is expired and
         *         the message is not renewable.
         * @throws MslException if the message does not contain an entity
         *         authentication data or a master token, or a token is improperly
         *         bound to another token.
         */
        init: function init(ctx, source, charset, keyRequestData, cryptoContexts, timeout, callback) {
            var self = this;
            InterruptibleExecutor(callback, function() {
                // Set properties.
                var props = {
                    _source: { value: source, writable: false, enumerable: false, configurable: false },
                    _parser: { value: undefined, writable: true, enumerable: false, configurable: false },
                    _charset: { value: charset, writable: false, enumerable: false, configurable: false },
                    _remainingData: { value: '', writable: true, enumerable: false, configurable: false },
                    _timeout: { value: timeout, writable: false, enumerable: false, configurable: false },
                    _header: { value: undefined, writable: true, enumerable: false, configurable: false },
                    _cryptoContext: { value: undefined, writable: true, enumerable: false, configurable: false },
                    _keyxCryptoContext: { value: undefined, writable: true, enumerable: false, configurable: false },
                    _payloadSequenceNumber: { value: 1, writable: true, enuemrable: false, configurable: false },
                    _eom: { value: false, writable: true, enumerable: false, configurable: false },
                    _closeSource: { value: false, writable: true, enumerable: false, configurable: false },
                    /** @type {Array.<Uint8Array>} */
                    _payloads: { value: new Array(), writable: true, enumerable: false, configurable: false },
                    _payloadIndex: { value: -1, writable: true, enumerable: false, configurable: false },
                    _payloadOffset: { value: 0, writable: true, enuemrable: false, configurable: false },
                    _markOffset: { value: 0, writable: true, enumerable: false, configurable: false },
                    _currentPayload: { value: null, writable: true, enumerable: false, configurable: false },
                    _readException: { value: null, writable: true, enumerable: false, configurable: false },
                    // Set true once the header has been read and payloads may
                    // be read.
                    _ready: { value: false, writable: true, enumerable: false, configurable: false },
                    // Use a blocking queue as a semaphore.
                    _readyQueue: { value: new BlockingQueue(), writable: false, enumerable: false, configurable: false },
                    _aborted: { value: false, writable: true, enumerable: false, configurable: false },
                    // If timed out reading the header then deliver the timeout
                    // at the next operation.
                    _timedout: { value: false, writable: true, enumerable: false, configurable: false },
                    // If an error occurs while reading the header then deliver
                    // it at the next operation.
                    _errored: { value: null, writable: true, enumerable: false, configurable: false },
                };
                Object.defineProperties(this, props);

                function ready() {
                    self._ready = true;
                    self._readyQueue.add(true);
                }

                inputStreamToJSON(self._source, timeout, {
                    result: function (json) {
                        self._json = json;
                        self._jsonIndex = 0;

                        if (self._json === null) {
                            self._errored = new MslEncodingException(MslError.MESSAGE_DATA_MISSING);
                            ready();
                            return;
                        }

                        Header$parseHeader(ctx, self._json[self._jsonIndex++], cryptoContexts, {
                            result: function(header) {
                                self._header = header;

                                // For error messages there are no key exchange or payload crypto
                                // contexts.
                                if (self._header instanceof ErrorHeader) {
                                    self._keyxCryptoContext = null;
                                    self._cryptoContext = null;
                                    ready();
                                    return;
                                }

                                // Grab the key exchange crypto context, if any.
                                var messageHeader = self._header;
                                getKeyxCryptoContext(ctx, messageHeader, keyRequestData, {
                                    result: function(keyxCryptoContext) {
                                        setCryptoContexts(ctx, messageHeader, keyxCryptoContext);
                                    },
                                    error: function(e) {
                                        if (e instanceof MslException) {
                                            e.setEntity(messageHeader.masterToken);
                                            e.setEntity(messageHeader.entityAuthenticationData);
                                            e.setUser(messageHeader.userIdToken);
                                            e.setUser(messageHeader.userAuthenticationData);
                                            e.setMessageId(messageHeader.messageId);
                                        }
                                        self._errored = e;
                                        ready();
                                    }
                                });
                            },
                            error: function(e) {
                                self._errored = e;
                                ready();
                            }
                        });
                    },
                    timeout: function () {
                        self._timedout = true;
                        ready();
                    },
                    error: function (e) {
                        self._errored = e;
                        ready();
                    }
                });

                function setCryptoContexts(ctx, messageHeader, keyxCryptoContext) {
                    try {
                        self._keyxCryptoContext = keyxCryptoContext;

                        // In peer-to-peer mode or in trusted network mode with no key
                        // exchange the payload crypto context equals the header crypto
                        // context.
                        if (ctx.isPeerToPeer() || !self._keyxCryptoContext)
                            self._cryptoContext = messageHeader.cryptoContext;

                        // Otherwise the payload crypto context equals the key exchange
                        // crypto context.
                        else
                            self._cryptoContext = self._keyxCryptoContext;

                        checkMasterToken(ctx, messageHeader);
                    } catch (e) {
                        if (e instanceof MslException) {
                            e.setEntity(messageHeader.masterToken);
                            e.setEntity(messageHeader.entityAuthenticationData);
                            e.setUser(messageHeader.userIdToken);
                            e.setUser(messageHeader.userAuthenticationData);
                            e.setMessageId(messageHeader.messageId);
                        }
                        self._errored = e;
                        ready();
                    }
                }

                function checkMasterToken(ctx, messageHeader) {
                    try {
                        // If I am in peer-to-peer mode or the master token is verified
                        // (i.e. issued by the local entity which is therefore a trusted
                        // network server) then perform the master token checks.
                        var masterToken = messageHeader.masterToken;
                        if (masterToken && (ctx.isPeerToPeer() || masterToken.isVerified())) {
                            checkMasterTokenRevoked(ctx, messageHeader);
                        } else {
                            checkNonReplayableId(ctx, messageHeader);
                        }
                    } catch (e) {
                        if (e instanceof MslException) {
                            e.setEntity(messageHeader.masterToken);
                            e.setUser(messageHeader.userIdToken);
                            e.setUser(messageHeader.userAuthenticationData);
                            e.setMessageId(messageHeader.messageId);
                        }
                        self._errored = e;
                        ready();
                    }
                }

                function checkMasterTokenRevoked(ctx, messageHeader) {
                    try {
                        // If the master token has been revoked then reject the
                        // message.
                        var masterToken = messageHeader.masterToken;
                        var factory = ctx.getTokenFactory();
                        factory.isMasterTokenRevoked(ctx, masterToken, {
                            result: function(revoked) {
                                if (revoked) {
                                    self._errored = new MslMasterTokenException(revoked, masterToken)
                                    .setUser(messageHeader.userIdToken)
                                    .setUser(messageHeader.userAuthenticationData)
                                    .setMessageId(messageHeader.messageId);
                                    ready();
                                } else {
                                    checkUserIdTokenRevoked(ctx, messageHeader);
                                }
                            },
                            error: function(e) {
                                if (e instanceof MslException) {
                                    e.setEntity(messageHeader.masterToken);
                                    e.setUser(messageHeader.userIdToken);
                                    e.setUser(messageHeader.userAuthenticationData);
                                    e.setMessageId(messageHeader.messageId);
                                }
                                self._errored = e;
                                ready();
                            }
                        });
                    } catch (e) {
                        if (e instanceof MslException) {
                            e.setEntity(messageHeader.masterToken);
                            e.setUser(messageHeader.userIdToken);
                            e.setUser(messageHeader.userAuthenticationData);
                            e.setMessageId(messageHeader.messageId);
                        }
                        self._errored = e;
                        ready();
                    }
                }

                function checkUserIdTokenRevoked(ctx, messageHeader) {
                    try {
                        // If the user ID token has been revoked then reject the
                        // message. We know the master token is not null and that it is
                        // verified so we assume the user ID token is as well.
                        var masterToken = messageHeader.masterToken;
                        var userIdToken = messageHeader.userIdToken;
                        if (userIdToken) {
                            var factory = ctx.getTokenFactory();
                            factory.isUserIdTokenRevoked(ctx, masterToken, userIdToken, {
                                result: function(revoked) {
                                    if (revoked) {
                                        self._errored = new MslUserIdTokenException(revoked, userIdToken)
                                        .setEntity(masterToken)
                                        .setUser(userIdToken)
                                        .setMessageId(messageHeader.messageId);
                                        ready();
                                    } else {
                                        checkMasterTokenExpired(ctx, messageHeader);
                                    }
                                },
                                error: function(e) {
                                    if (e instanceof MslException) {
                                        e.setEntity(messageHeader.masterToken);
                                        e.setUser(messageHeader.userIdToken);
                                        e.setUser(messageHeader.userAuthenticationData);
                                        e.setMessageId(messageHeader.messageId);
                                    }
                                    self._errored = e;
                                    ready();
                                }
                            });
                        } else {
                            checkMasterTokenExpired(ctx, messageHeader);
                        }
                    } catch (e) {
                        if (e instanceof MslException) {
                            e.setEntity(messageHeader.masterToken);
                            e.setUser(messageHeader.userIdToken);
                            e.setUser(messageHeader.userAuthenticationData);
                            e.setMessageId(messageHeader.messageId);
                        }
                        self._errored = e;
                        ready();
                    }
                }

                function checkMasterTokenExpired(ctx, messageHeader) {
                    try {
                        // If the master token is expired...
                        var masterToken = messageHeader.masterToken;
                        if (masterToken.isExpired()) {
                            // If the message is not renewable or does not contain key
                            // request data then reject the message.
                            if (!messageHeader.isRenewable() || messageHeader.keyRequestData.length == 0) {
                                self._errored = new MslMessageException(MslError.MESSAGE_EXPIRED, JSON.stringify(messageHeader))
                                .setEntity(masterToken)
                                .setUser(messageHeader.userIdToken)
                                .setUser(messageHeader.userAuthenticationData)
                                .setMessageId(messageHeader.messageId);
                                ready();
                                return;
                            }

                            // If the master token will not be renewed by the token
                            // factory then reject the message.
                            //
                            // This throws an exception if the master token is not
                            // renewable.
                            var factory = ctx.getTokenFactory();
                            factory.isMasterTokenRenewable(ctx, masterToken, {
                                result: function(notRenewable) {
                                    if (notRenewable) {
                                        self._errored = new MslMessageException(notRenewable, "Master token is expired and not renewable.")
                                        .setEntity(masterToken)
                                        .setUser(messageHeader.userIdToken)
                                        .setUser(messageHeader.userAuthenticationData)
                                        .setMessageId(messageHeader.messageId);;
                                        ready();
                                    } else {
                                        checkNonReplayableId(ctx, messageHeader);
                                    }
                                },
                                error: function(e) {
                                    if (e instanceof MslException) {
                                        e.setEntity(messageHeader.masterToken);
                                        e.setUser(messageHeader.userIdToken);
                                        e.setUser(messageHeader.userAuthenticationData);
                                        e.setMessageId(messageHeader.messageId);
                                    }
                                    self._errored = e;
                                    ready();
                                },
                            });
                        } else {
                            checkNonReplayableId(ctx, messageHeader);
                        }
                    } catch (e) {
                        if (e instanceof MslException) {
                            e.setEntity(messageHeader.masterToken);
                            e.setUser(messageHeader.userIdToken);
                            e.setUser(messageHeader.userAuthenticationData);
                            e.setMessageId(messageHeader.messageId);
                        }
                        self._errored = e;
                        ready();
                    }
                }

                function checkNonReplayableId(ctx, messageHeader) {
                    try {
                        // If the message is non-replayable (it is not from a trusted
                        // network server).
                        var masterToken = messageHeader.masterToken;
                        var nonReplayableId = messageHeader.nonReplayableId;
                        if (typeof nonReplayableId === 'number') {
                            // ...and does not include a master token then reject the
                            // message.
                            if (!masterToken) {
                                self._errored = new MslMessageException(MslError.INCOMPLETE_NONREPLAYABLE_MESSAGE, JSON.stringify(messageHeader))
                                .setEntity(messageHeader.entityAuthenticationData)
                                .setUser(messageHeader.userIdToken)
                                .setUser(messageHeader.userAuthenticationData)
                                .setMessageId(messageHeader.messageId);
                                ready();
                                return;
                            }

                            // If the non-replayable ID is not accepted then notify the
                            // sender.
                            var factory = ctx.getTokenFactory();
                            factory.acceptNonReplayableId(ctx, masterToken, nonReplayableId, {
                                result: function(accepted) {
                                    if (!accepted) {
                                        self._errored = new MslMessageException(MslError.MESSAGE_REPLAYED, JSON.stringify(messageHeader))
                                        .setEntity(masterToken)
                                        .setUser(messageHeader.userIdToken)
                                        .setUser(messageHeader.userAuthenticationData)
                                        .setMessageId(messageHeader.messageId);
                                    }

                                    // Notify all that it is ready.
                                    ready();
                                },
                                error: function(e) {
                                    if (e instanceof MslException) {
                                        e.setEntity(masterToken);
                                        e.setUser(messageHeader.userIdToken);
                                        e.setUser(messageHeader.userAuthenticationData);
                                        e.setMessageId(messageHeader.messageId);
                                    }
                                    self._errored = e;
                                    ready();
                                }
                            });
                        }

                        // Notify all that it is ready.
                        else {
                            ready();
                        }
                    } catch (e) {
                        if (e instanceof MslException) {
                            e.setEntity(messageHeader.masterToken);
                            e.setEntity(messageHeader.entityAuthenticationData);
                            e.setUser(messageHeader.userIdToken);
                            e.setUser(messageHeader.userAuthenticationData);
                            e.setMessageId(messageHeader.messageId);
                        }
                        self._errored = e;
                        ready();
                    }
                }

                // Return this immediately instead of after reading the header
                // so the read can be aborted.
                return this;
            }, self);
        },


        /**
         * Retrieve the next payload chunk data.
         *
         * @param {number} timeout read timeout in milliseconds.
         * @param {{result: function(Uint8Array), timeout: function(), error: function(Error)}} callback
         *        the callback that will receive the next payload chunk data or
         *        null if none remaining, or any thrown exceptions.
         * @throws MslCryptoException if there is a problem decrypting or verifying
         *         the payload chunk.
         * @throws MslEncodingException if there is a problem parsing the JSON.
         * @throws MslMessageException if the payload verification failed.
         * @throws MslInternalException if attempting to access payloads of an
         *         error message.
         * @throws MslException if there is an error uncompressing the data.
         */
        nextData: function nextData(timeout, callback) {
            var self = this;
            InterruptibleExecutor(callback, function() {
                // Make sure this message is allowed to have payload chunks.
                var messageHeader = this.getMessageHeader();
                if (!messageHeader)
                    throw new MslInternalException("Read attempted with error message.");

                // If reading buffered data return the next buffered payload data.
                if (this._payloadIndex != -1 && this._payloadIndex < this._payloads.length)
                    return this._payloads[this._payloadIndex++];

                // If we previously reached the end of the mesage don't try to
                // read more.
                if (this._eom)
                    return null;

                // Otherwise read the next payload.
                function nextPayload(callback) {
                    InterruptibleExecutor(callback, function() {
                        var payloadJo;
                        //var payloadJo = this._parser.nextValue();
                        if (this._jsonIndex < this._json.length) {
                            payloadJo = this._json[this._jsonIndex++];
                            return payloadJo;
                        } else {

                            // in this case there's been a request for
                            // another payload, but we don't actually have
                            // the object parsed yet. So we need to parse
                            // the source again
                            inputStreamToJSON(this._source, this._timeout, {

                                result: function (json) {
                                    if (json && json.length && json.length > 0) {
                                        json.forEach(function (elt) {
                                            this._json.push(elt);
                                        });
                                        nextPayload(callback);
                                    } else {
                                        // we've reached the end of the stream
                                        this._eom = true;
                                        callback.result(null);
                                    }
                                },
                                timeout: function () {
                                    callback.timeout();
                                },
                                error: function (err) {
                                    callback.error(err);
                                }
                            });
                        }
                    }, self);
                }
                nextPayload({
                    result: function(payloadJo) {
                        InterruptibleExecutor(callback, function() {
                            if (!payloadJo)
                                return null;
                            if (typeof payloadJo !== 'object')
                                throw new MslEncodingException(MslError.MESSAGE_FORMAT_ERROR);
                            PayloadChunk$parse(payloadJo, this._cryptoContext, {
                                result: function(payload) {
                                    InterruptibleExecutor(callback, function() {
                                        // Make sure the payload belongs to this message and is the one
                                        // we are expecting.
                                        var masterToken = messageHeader.masterToken;
                                        var entityAuthData = messageHeader.entityAuthenticationData;
                                        var userIdToken = messageHeader.userIdToken;
                                        var userAuthData = messageHeader.getUserAuthenticationData;
                                        if (payload.messageId != messageHeader.messageId) {
                                            throw new MslMessageException(MslError.PAYLOAD_MESSAGE_ID_MISMATCH, "payload mid " + payload.messageId + " header mid " + messageHeader.messageId)
                                            .setEntity(masterToken)
                                            .setEntity(entityAuthData)
                                            .setUser(userIdToken)
                                            .setUser(userAuthData);
                                        }
                                        if (payload.sequenceNumber != this._payloadSequenceNumber) {
                                            throw new MslMessageException(MslError.PAYLOAD_SEQUENCE_NUMBER_MISMATCH, "payload seqno " + payload.sequenceNumber + " expected seqno " + this._payloadSequenceNumber)
                                            .setEntity(masterToken)
                                            .setEntity(entityAuthData)
                                            .setUser(userIdToken)
                                            .setUser(userAuthData);
                                        }
                                        ++this._payloadSequenceNumber;

                                        // Check for end of message.
                                        if (payload.isEndOfMessage())
                                            this._eom = true;

                                        // Save the payload in the buffer and return it. We have to
                                        // unset the payload iterator since we're adding to the
                                        // payloads list.
                                        var data = payload.data;
                                        this._payloads.push(data);
                                        this._payloadIndex = -1;
                                        return data;
                                    }, self);
                                },
                                error: function(e) {
                                    if (e instanceof SyntaxError)
                                        e = new MslEncodingException(MslError.JSON_PARSE_ERROR, "payloadchunk", e);
                                    callback.error(e);
                                }
                            });
                        }, self);
                    },
                    timeout: function() { callback.timeout(); },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * Block until the message input stream successfully read the message
         * header and been fully initialized.
         *
         * @param {number} timeout ready timeout in milliseconds.
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback will receive true once the message
         *        input stream is ready or false if it has been aborted,
         *        notified of timeout, or any exceptions thrown during the
         *        message initialization.
         */
        isReady: function isReady(timeout, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // If not ready wait until we are ready.
                if (!this._ready) {
                    this._readyQueue.poll(timeout, {
                        result: function(elem) {
                            InterruptibleExecutor(callback, function() {
                                // If aborted return false.
                                if (elem === undefined) return false;
                                perform();
                            }, self);
                        },
                        timeout: function() { callback.timeout(); },
                        error: function(e) { callback.error(e); }
                    });
                } else {
                    perform();
                }
            }, self);

            function perform() {
                InterruptibleExecutor(callback, function() {
                    // Check if already aborted, timedout, or errored.
                    if (this._aborted)
                        return false;
                    if (this._timedout) {
                        callback.timeout();
                        return;
                    }
                    if (this._errored)
                        throw this._errored;

                    // Ready.
                    return true;
                }, self);
            }
        },

        /**
         * @return {MessageHeader} the message header. Will be null for error messages.
         */
        getMessageHeader: function getMessageHeader() {
            if (this._header instanceof MessageHeader)
                return this._header;
            return null;
        },

        /**
         * @return {ErrorHeader} the error header. Will be null except for error messages.
         */
        getErrorHeader: function getErrorHeader() {
            if (this._header instanceof ErrorHeader)
                return this._header;
            return null;
        },

        /**
         * Returns the sender's entity identity. The identity will be unknown if
         * the local entity is a trusted network client and the message was sent by
         * a trusted network server using the local entity's master token.
         *
         * @return {string} the sender's entity identity or null if unknown.
         * @throws MslCryptoException if there is a crypto error accessing the
         *         entity identity;
         */
        getIdentity: function getIdentity() {
            var messageHeader = this.getMessageHeader();
            if (messageHeader) {
                var masterToken = messageHeader.masterToken;
                if (masterToken)
                    return masterToken.identity;
                return messageHeader.entityAuthenticationData.getIdentity();
            }
            var errorHeader = this.getErrorHeader();
            return errorHeader.entityAuthenticationData.getIdentity();
        },

        /**
         * Returns the user associated with the message. The user will be unknown
         * if the local entity is a trusted network client and the message was sent
         * by a trusted network server.
         *
         * @return {CustomerKey} the user associated with the message or null if unknown.
         */
        getCustomer: function getCustomer() {
            var messageHeader = this.getMessageHeader();
            if (!messageHeader)
                return null;
            return messageHeader.customer;
        },

        /**
         * @return {ICryptoContext} the payload crypto context. Will be null for error messages.
         */
        getPayloadCryptoContext: function getPayloadCryptContext() {
            return this._cryptoContext;
        },

        /**
         * @return {ICryptoContext} the key exchange crypto context. Will be null if no key response
         *         data was returned in this message and for error messages.
         */
        getKeyExchangeCryptoContext: function getKeyExchangeCryptoContext() {
            return this._keyxCryptoContext;
        },

        /**
         * By default the source input stream is not closed when this message input
         * stream is closed. If it should be closed then this method can be used to
         * dictate the desired behavior.
         *
         * @param {boolean} close true if the source input stream should be closed, false if
         *        it should not.
         */
        closeSource: function closeSource(close) {
            this._closeSource = close;
        },

        /** @inheritDoc */
        abort: function abort() {
            this._aborted = true;
            this._source.abort();
            this._readyQueue.cancelAll();
        },

        /** @inheritDoc */
        close: function close() {
            // Only close the source if instructed to do so because we might want
            // to reuse the connection.
            if (this._closeSource)
                this._source.close();
        },

        /** @inheritDoc */
        mark: function mark() {
            // If there is a current payload...
            if (this._currentPayload) {
                // Remove all buffered data earlier than the current payload.
                while (this._payloads.length > 0 && this._payloads[0] !== this._currentPayload)
                    this._payloads.shift();

                // Reset the iterator to continue reading buffered data from the
                // current payload.
                this._payloadIndex = 0;
                this._currentPayload = this._payloads[this._payloadIndex++];

                // Set the new mark point on the current payload.
                this._markOffset = this._payloadOffset;
                return;
            }

            // Otherwise we've either read to the end or haven't read anything at
            // all yet. Discard all buffered data.
            this._payloadIndex = -1;
            this._payloads = [];
        },

        /** @inheritDoc */
        markSupported: function markSupported() {
            return true;
        },

        /** @inheritDoc */
        read: function read(len, timeout, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // Error on illegal length values.
                if (len < -1)
                    throw new RangeError("read requested with illegal length " + len);

                // If not ready wait until we are ready.
                if (!this._ready) {
                    this._readyQueue.poll(timeout, {
                        result: function(elem) {
                            // If aborted return false.
                            if (elem === undefined) callback.result(false);
                            else perform();
                        },
                        timeout: function() { callback.timeout(new Uint8Array(0)); },
                        error: function(e) { callback.error(e); }
                    });
                } else {
                    perform();
                }
            }, self);

            function perform() {
                InterruptibleExecutor(callback, function() {
                    // Check if already aborted, timedout, or errored.
                    if (this._aborted)
                        return new Uint8Array(0);
                    if (this._timedout) {
                        callback.timeout(new Uint8Array(0));
                        return;
                    }
                    if (this._errored)
                        throw this._errored;

                    // Throw any cached read exception.
                    if (this._readException != null) {
                        var e = this._readException;
                        this._readException = null;
                        throw e;
                    }

                    // Allocate the data buffer if the caller requested a
                    // specific amount of data. Otherwise we'll allocate once
                    // we have some data available.
                    //
                    // The data buffer size is equal to the amount of data
                    // requested by the caller.
                    var data = (len != -1) ? new Uint8Array(len) : undefined;

                    // Read from payloads until we are done or cannot read anymore.
                    var dataOffset = 0;
                    var bytesRead = 0;
                    function readMore(callback) {
                        InterruptibleExecutor(callback, function() {
                            // If we've read everything then return the result.
                            if (data && (bytesRead >= data.length))
                                return data.subarray(0, bytesRead);

                            // Read from the current payload.
                            var read = -1;
                            if (this._currentPayload) {
                                // If the caller requested everything available
                                // allocate the data buffer as needed.
                                var currentAvailable = this._currentPayload.length - this._payloadOffset;
                                if (!data) {
                                    // Start with the bytes available in the
                                    // current buffer. Add any subsequent
                                    // buffered payloads.
                                    var readlen = currentAvailable;
                                    if (this._payloadIndex != -1) {
                                        for (var i = this._payloadIndex; i < this._payloads.length; ++i) {
                                            var payload = this._payloads[i];
                                            readlen += payload.length;
                                        }
                                    }

                                    // If there is something available then
                                    // allocate the data buffer.
                                    if (readlen > 0)
                                        data = new Uint8Array(readlen);
                                }

                                // Copy into the data buffer.
                                //
                                // If there is nothing available then the count
                                // will be zero and we won't attempt to use
                                // the data buffer (as it may not exist).
                                var remaining = (data) ? data.length - bytesRead : 0;
                                var count = Math.min(currentAvailable, remaining);
                                if (count > 0) {
                                    var end = this._payloadOffset + count;
                                    var payloadData = this._currentPayload.subarray(this._payloadOffset, end);
                                    data.set(payloadData, dataOffset);

                                    // Update our read count and offsets.
                                    read = count;
                                    dataOffset += count;
                                    this._payloadOffset += count;
                                }
                            }

                            // If we read some data continue.
                            if (read != -1) {
                                bytesRead += read;
                                readMore(callback);
                                return;
                            }

                            // Otherwise grab the next payload data.
                            this.nextData(timeout, {
                                result: function(payload) {
                                    InterruptibleExecutor(callback, function() {
                                        // If we were aborted then return whatever
                                        // has been read.
                                        if (this._aborted)
                                            return (data) ? data.subarray(0, bytesRead) : new Uint8Array(0)

                                        this._currentPayload = payload;
                                        this._payloadOffset = 0;

                                        // If we got more data, continue.
                                        if (this._currentPayload) {
                                            readMore(callback);
                                            return;
                                        }

                                        // If nothing was read (but something was requested) return end of
                                        // stream.
                                        if (bytesRead == 0 && len != 0)
                                            return null;

                                        // Return whatever data we have, which
                                        // may be none.
                                        return (data) ? data.subarray(0, bytesRead) : new Uint8Array(0)
                                    }, self);
                                },
                                timeout: function() {
                                    // Return whatever data we have, which may be
                                    // none.
                                    callback.timeout((data) ? data.subarray(0, bytesRead) : new Uint8Array(0));
                                },
                                error: function(e) {
                                    InterruptibleExecutor(callback, function() {
                                        // If we already read some data return it and save the
                                        // exception to be thrown next time read() is called.
                                        if (e instanceof MslException)
                                            e = new MslIoException("Error reading the payload chunk.", e);
                                        if (bytesRead > 0) {
                                            self._readException = e;
                                            return data.subarray(0, bytesRead);
                                        }

                                        // Otherwise throw the exception now.
                                        throw e;
                                    }, self);
                                }
                            });
                        }, self);
                    }

                    readMore(callback);
                }, self);
            }
        },

        /** @inheritDoc */
        reset: function reset() {
            // Reset all payloads and initialize the payload iterator.
            //
            // We need to reset the payloads since we are going to re-read them and
            // want the correct value returned when queried for available bytes.
            this._payloadIndex = 0;
            if (this._payloads.length > 0) {
                this._currentPayload = this._payloads[this._payloadIndex++];
                this._payloadOffset = this._markOffset;
            } else {
                this._currentPayload = null;
            }
        },
    });

    /**
     * <p>Construct a new message input stream. The header is parsed.</p>
     *
     * <p>If key request data is provided and a matching key response data is
     * found in the message header the key exchange will be performed to
     * process the message payloads.</p>
     *
     * <p>Service tokens will be decrypted and verified with the provided crypto
     * contexts identified by token name. A default crypto context may be
     * provided by using the empty string as the token name; if a token name is
     * not explcitly mapped onto a crypto context, the default crypto context
     * will be used.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {InputStream} source MSL input stream.
     * @param {string} charset input stream character set encoding.
     * @param {Array.<KeyRequestData>} keyRequestData key request data to use when processing key
     *        response data.
     * @param {Object.<string,ICryptoContext>} cryptoContexts the map of service token names onto crypto
     *        contexts used to decrypt and verify service tokens.
     * @param {number} timeout read timeout in milliseconds.
     * @param {{result: function(MessageInputStream), timeout: function(), error: function(Error)}}
     *        callback the callback that will receive the message input
     *        stream, or any thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the message.
     * @throws MslCryptoException if there is an error decrypting or verifying
     *         the header or creating the message payload crypto context.
     * @throws MslEntityAuthException if unable to create the entity
     *         authentication data.
     * @throws MslUserAuthException if unable to create the user authentication
     *         data.
     * @throws MslMessageException if the message master token is expired and
     *         the message is not renewable.
     * @throws MslMasterTokenException if the master token is not trusted and
     *         needs to be.
     * @throws MslKeyExchangeException if there is an error with the key
     *         request data or key response data or the key exchange scheme is
     *         not supported.
     * @throws MslMessageException if the message master token is expired and
     *         the message is not renewable.
     * @throws MslException if the message does not contain an entity
     *         authentication data or a master token, or a token is improperly
     *         bound to another token.
     */
    MessageInputStream$create = function MessageInputStream$create(ctx, source, charset, keyRequestData, cryptoContexts, timeout, callback) {
        new MessageInputStream(ctx, source, charset, keyRequestData, cryptoContexts, timeout, callback);
    };
})();



// -- javascript/msg/MessageOutputStream.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A MSL message consists of a single MSL header followed by one or more
 * payload chunks carrying application data. Each payload chunk is individually
 * packaged but sequentially ordered. The end of the message is indicated by a
 * payload with no data.</p>
 *
 * <p>No payload chunks may be included in an error message.</p>
 *
 * <p>Data is buffered until {@link #flush()} or {@link #close()} is called.
 * At that point a new payload chunk is created and written out. Closing a
 * {@code MessageOutputStream} does not close the destination output stream in
 * case additional MSL messages will be written.</p>
 *
 * <p>A copy of the payload chunks is kept in-memory and can be retrieved by a
 * a call to {@code getPayloads()}. This is used to facilitate automatic
 * re-sending of messages.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MessageOutputStream;
var MessageOutputStream$create;

(function() {
    "use strict";
    
    MessageOutputStream = OutputStream.extend({
        /**
         * Construct a new message output stream. The header is output
         * immediately by calling {@code #flush()} on the destination output
         * stream. The most preferred compression algorithm supported by the
         * local entity and message header will be used.
         *
         * @param {MslContext} ctx the MSL context.
         * @param {OutputStream} destination MSL output stream.
         * @param {string} charset output stream character set encoding.
         * @param {MessageHeader|ErrorHeader} header message or error header.
         * @param {?ICryptoContext} cryptoContext payload data crypto context.
         *        Required if a message header is provided.
         * @param {number} timeout write timeout in milliseconds.
         * @param {{result: function(MessageOutputStream), timeout: function(), error: function(Error)}}
         *        callback the callback that will receive the message output
         *        stream, or any thrown exceptions.
         * @throws IOException if there is an error writing the header.
         */
        init: function init(ctx, destination, charset, header, cryptoContext, timeout, callback) {
            var self = this;
            InterruptibleExecutor(callback, function() {
                // The supported compression algorithms is the intersection of what the
                // local entity supports and what the remote entity supports.
                var capabilities = MessageCapabilities$intersection(ctx.getMessageCapabilities(), header.messageCapabilities);
                var compressionAlgo = null;
                if (capabilities) {
                    var compressionAlgos = capabilities.compressionAlgorithms;
                    compressionAlgo = MslConstants$CompressionAlgorithm$getPreferredAlgorithm(compressionAlgos);
                }
                
                // Set properties.
                var props = {
                    _destination: { value: destination, writable: false, enumerable: false, configurable: false },
                    _charset: { value: charset, writable: false, enumerable: false, configurable: false },
                    _capabilities : { value: capabilities, writable: false, enumerable: false, configurable: false },
                    _header: { value: header, writable: false, enumerable: false, configurable: false },
                    _compressionAlgo: { value: compressionAlgo, writable: true, enumerable: false, configurable: false },
                    _cryptoContext: { value: cryptoContext, writable: false, enumerable: false, configurable: false },
                    _payloadSequenceNumber: { value: 1, writable: true, enumerable: false, configurable: false },
                    /** @type {Array.<Uint8Array>} */
                    _currentPayload: { value: new Array(), writable: true, enumerable: false, configurable: false },
                    _closed: { value: false, writable: true, enumerable: false, configurable: false },
                    /** @type {Array.<PayloadChunk>} */
                    _payloads: { value: new Array(), writable: false, enumerable: false, configurable: false },
                    // Set true once the header has been sent and payloads may
                    // be written.
                    _ready: { value: false, writable: true, enumerable: false, configurable: false },
                    // Use a blocking queue as a semaphore.
                    _readyQueue: { value: new BlockingQueue(), writable: false, enumerable: false, configurable: false },
                    _aborted: { value: false, writable: true, enumerable: false, configurable: false },
                    // If timed out writing the header then deliver the timeout
                    // at the next operation.
                    _timedout: { value: false, writable: true, enumerable: false, configurable: false },
                    // If an error occurs while writing the header then deliver
                    // it at the next operation.
                    _errored: { value: null, writable: true, enumerable: false, configurable: false },
                };
                Object.defineProperties(this, props);

                function ready() {
                    self._ready = true;
                    self._readyQueue.add(true);
                }

                var headerBytes = textEncoding$getBytes(JSON.stringify(header), charset);
                destination.write(headerBytes, 0, headerBytes.length, timeout, {
                    result: function(numWritten) {
                        try {
                            // If aborted do nothing.
                            if (self._aborted) {
                                ready();
                                return;
                            }

                            // Check if timed out.
                            if (numWritten < headerBytes.length) {
                                self._timedout = true;
                                ready();
                                return;
                            }
                            destination.flush(timeout, {
                                result: function(success) {
                                    // If aborted do nothing.
                                    if (self._aborted) {
                                        ready();
                                        return;
                                    }
                                    self._timedout = !success;

                                    // Notify all that it is ready.
                                    ready();
                                },
                                timeout: function() {
                                    self._timedout = true;
                                    ready();
                                },
                                error: function(e) {
                                    self._errored = e;
                                    ready();
                                }
                            });
                        } catch (e) {
                            self._errored = e;
                            ready();
                        }
                    },
                    timeout: function() {
                        self._timedout = true;
                        ready();
                    },
                    error: function(e) {
                        self._errored = e;
                        ready();
                    }
                });

                // Return this immediately instead of after writing the header
                // so the write can be aborted.
                return this;
            }, self);
        },

        /**
         * Set the payload chunk compression algorithm that will be used for all
         * future payload chunks. This function will flush any buffered data iff
         * the compression algorithm is being changed.
         *
         * @param {MslConstants$CompressionAlgorithm} compressionAlgo payload chunk
         *            compression algorithm. Null for no compression.
         * @param {number} timeout write timeout in milliseconds.
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback that will receive true if the
         *        compression algorithm is supported by the message, false if
         *        it is not, or any thrown exceptions.
         * @throws IOException if buffered data could not be flushed. The
         *         compression algorithm will be unchanged.
         * @throws MslInternalException if writing an error message.
         * @see #flush()
         */
        setCompressionAlgorithm: function setCompressionAlgorithm(compressionAlgo, timeout, callback) {
            var self = this;
            InterruptibleExecutor(callback, function() {
                // Make sure this is not an error message,
                var messageHeader = this.getMessageHeader();
                if (!messageHeader)
                    throw new MslInternalException("Cannot write payload data for an error message.");

                // Do nothing if the compression algorithm is not different.
                if (this._compressionAlgo == compressionAlgo)
                    return true;
                
                // Make sure the message is capable of using the compression algorithm.
                if (compressionAlgo) {
                    if (!this._capabilities)
                        return false;
                    var compressionAlgos = this._capabilities.compressionAlgorithms;
                    for (var i = 0; i < compressionAlgos.length; ++i) {
                        if (compressionAlgos[i] == compressionAlgo) {
                            flush();
                            return;
                        }
                    }
                    return false;
                } else {
                    flush();
                    return;
                }
            }, self);
            
            function flush() {
                self.flush(timeout, {
                    result: function(success) {
                        InterruptibleExecutor(callback, function() {
                            // If unsuccessful deliver an error.
                            if (!success)
                                throw new MslIoException("flush() aborted");
                            this._compressionAlgo = compressionAlgo;
                            return true;
                        }, self);
                    },
                    timeout: function() { callback.timeout(); },
                    error: function(e) { callback.error(e); }
                });
            }
        },

        /**
         * @return {MessageHeader} the message header. Will be null for error messages.
         */
        getMessageHeader: function getMessageHeader() {
            if (this._header instanceof MessageHeader)
                return this._header;
            return null;
        },

        /**
         * @return {ErrorHeader} the error header. Will be null except for error messages.
         */
        getErrorMessage: function getErrorHeader() {
            if (this._header instanceof ErrorHeader)
                return this._header;
            return null;
        },

        /**
         * @return {Array.<PayloadChunk>} an ordered list of the payloads sent so far.
         */
        getPayloads: function getPayloads() {
            return this._payloads;
        },

        /** @inheritDoc */
        abort: function abort() {
            this._aborted = true;
            this._destination.abort();
            this._readyQueue.cancelAll();
        },

        /** @inheritDoc */
        close: function close(timeout, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // Check if already aborted, timedout, or errored.
                if (this._aborted)
                    return false;
                if (this._timedout) {
                    callback.timeout();
                    return;
                }
                if (this._errored)
                    throw this._errored;

                if (this._closed) return true;

                // Send a final payload that can be used to identify the end of data.
                // This is done by setting closed equal to true while the current
                // payload not null.
                this._closed = true;
                this.flush(timeout, {
                    result: function(success) {
                        InterruptibleExecutor(callback, function() {
                            // If successful the payload is sent.
                            if (success)
                                this._currentPayload = null;

                            // Do not close the output stream because we might want to reuse it.
                            return success;
                        }, self);
                    },
                    timeout: function() { callback.timeout(); },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * Flush any buffered data out to the destination. This creates a payload
         * chunk. If there is no buffered data or this is an error message this
         * function does nothing.
         *
         * @param {number} timeout write timeout in milliseconds.
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback that will receive true upon completion
         *        or false if aborted, be notified of a timeout, or any thrown
         *        exceptions.
         * @throws IOException if buffered data could not be flushed.
         * @throws MslInternalException if writing an error message.
         * @see java.io.OutputStream#flush()
         */
        flush: function flush(timeout, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // If not ready wait until we are ready.
                if (!this._ready) {
                    this._readyQueue.poll(timeout, {
                        result: function(elem) {
                            // If aborted return false.
                            if (elem === undefined) callback.result(false);
                            else perform();
                        },
                        timeout: function() { callback.timeout(); },
                        error: function(e) { callback.error(e); }
                    });
                } else {
                    perform();
                }
            }, self);

            function perform() {
                InterruptibleExecutor(callback, function() {
                    // Check if already aborted, timedout, or errored.
                    if (this._aborted)
                        return false;
                    if (this._timedout) {
                        callback.timeout();
                        return;
                    }
                    if (this._errored)
                        throw this._errored;

                    // If the current payload is null, we are already closed.
                    if (!this._currentPayload) return true;

                    // If we are not closed, and there is no data then we have nothing to
                    // send.
                    if (!this._closed && this._currentPayload.length == 0) return true;

                    // This is a no-op for error messages.
                    var messageHeader = this.getMessageHeader();
                    if (!messageHeader) return true;

                    // Otherwise we are closed and need to send any buffered data as the
                    // last payload. If there is no buffered data, we still need to send a
                    // payload with the end of message flag set.
                    //
                    // Convert the current payload to a single Uint8Array.
                    var length = 0;
                    if (this._currentPayload)
                        this._currentPayload.forEach(function(segment) { length += segment.length; });
                    var data = new Uint8Array(length);
                    for (var offset = 0, i = 0; this._currentPayload && i < this._currentPayload.length; ++i) {
                        var segment = this._currentPayload[i];
                        data.set(segment, offset);
                        offset += segment.length;
                    }

                    // Write the payload chunk.
                    PayloadChunk$create(this._payloadSequenceNumber, messageHeader.messageId, this._closed, this._compressionAlgo, data, this._cryptoContext, {
                        result: function(chunk) {
                            InterruptibleExecutor(callback, function() {
                                this._payloads.push(chunk);
                                var payloadBytes = textEncoding$getBytes(JSON.stringify(chunk), this._charset);
                                this._destination.write(payloadBytes, 0, payloadBytes.length, timeout, {
                                    result: function(numWritten) {
                                        InterruptibleExecutor(callback, function() {
                                            // If we were aborted then return false.
                                            if (this._aborted) return false;

                                            // If we timed out then notify the caller.
                                            if (numWritten < chunk.length) {
                                                callback.timeout();
                                                return;
                                            }

                                            this._destination.flush(timeout, {
                                                result: function(success) {
                                                    InterruptibleExecutor(callback, function() {
                                                        // If we were aborted then return false.
                                                        if (this._aborted) return false;

                                                        // If we timed out then return false.
                                                        if (!success) {
                                                            callback.timeout();
                                                            return;
                                                        }

                                                        // Increment the payload number.
                                                        ++this._payloadSequenceNumber;

                                                        // If we are closed, get rid of the current payload. This prevents
                                                        // us from sending any more payloads. Otherwise reset it for reuse.
                                                        if (this._closed)
                                                            this._currentPayload = null;
                                                        else
                                                            this._currentPayload = [];
                                                        return true;
                                                    }, self);
                                                },
                                                timeout: function() { callback.timeout(); },
                                                error: function(e) {
                                                    if (e instanceof MslException)
                                                        e = new MslIoException("Error encoding payload chunk [sequence number " + self._payloadSequenceNumber + "].", e);
                                                    callback.error(e);
                                                }
                                            });
                                        }, self);
                                    },
                                    timeout: function(numWritten) { callback.timeout(); },
                                    error: function(e) {
                                        if (e instanceof MslException)
                                            e = new MslIoException("Error encoding payload chunk [sequence number " + self._payloadSequenceNumber + "].", e);
                                        callback.error(e);
                                    }
                                });
                            }, self);
                        },
                        error: function(e) {
                            if (e instanceof MslException)
                                e = new MslIoException("Error encoding payload chunk [sequence number " + self._payloadSequenceNumber + "].", e);
                            callback.error(e);
                        }
                    });
                }, self);
            }
        },

        /* (non-Javadoc)
         * @see java.io.OutputStream#write(byte[], int, int)
         */
        write: function write(data, off, len, timeout, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // Check if already aborted, timedout, or errored.
                if (this._aborted)
                    return false;
                if (this._timedout) {
                    callback.timeout();
                    return;
                }
                if (this._errored)
                    throw this._errored;

                // Fail if closed.
                if (this._closed)
                    throw new MslIoException("Message output stream already closed.");

                // Verify arguments.
                if (off < 0)
                    throw new RangeError("Offset cannot be negative.");
                if (len < 0)
                    throw new RangeError("Length cannot be negative.");
                if (off + len > data.length)
                    throw new RangeError("Offset plus length cannot be greater than the array length.");

                // Make sure this is not an error message,
                var messageHeader = this.getMessageHeader();
                if (!messageHeader)
                    throw new MslInternalException("Cannot write payload data for an error message.");

                // Append data.
                var bytes = data.subarray(off, off + len);
                this._currentPayload.push(bytes);
                return bytes.length;
            }, self);
        },
    });


    /**
     * Construct a new message output stream. The header is output
     * immediately by calling {@code #flush()} on the destination output
     * stream. The most preferred compression algorithm supported by the
     * local entity and message header will be used.
     *
     * @param {MslContext} ctx the MSL context.
     * @param {OutputStream} destination MSL output stream.
     * @param {string} charset output stream character set encoding.
     * @param {MessageHeader|ErrorHeader} header message or error header.
     * @param {?ICryptoContext} cryptoContext payload data crypto context.
     *        Required if a message header is provided.
     * @param {number} timeout write timeout in milliseconds.
     * @param {{result: function(MessageOutputStream), timeout: function(), error: function(Error)}}
     *        callback the callback that will receive the message output
     *        stream, or any thrown exceptions.
     * @throws IOException if there is an error writing the header.
     */
    MessageOutputStream$create = function MessageOutputStream$create(ctx, destination, charset, header, cryptoContext, timeout, callback) {
        new MessageOutputStream(ctx, destination, charset, header, cryptoContext, timeout, callback);
    };
})();



// -- javascript/msg/MessageDebugContext.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A message debug context is used to provide debugging callbacks to
 * {@code MslControl}.</p>
 * 
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @interface
 */
var MessageDebugContext = util.Class.create({
    /**
     * Called just prior to sending a message with the message header or error
     * header that will be sent. An error may occur preventing successful
     * transmission of the header after this method is called.
     * 
     * @param {Header} header message header or error header. 
     */
    sentHeader: function(header) {},
    
    /**
     * Called just after receiving a message, before performing additional
     * validation, with the message header or error header.
     * 
     * @param {Header} header message header or error header.
     */
    receivedHeader: function(header) {}
});


// -- javascript/msg/MessageContext.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Re-authentication reason codes.
 * @enum
 */
var MessageContext$ReauthCode = {
    /** The user authentication data did not identify a user. */
    USERDATA_REAUTH: MslConstants$ResponseCode.USERDATA_REAUTH,
    /** The single-sign-on token was rejected as bad, invalid, or expired. */
    SSOTOKEN_REJECTED: MslConstants$ResponseCode.SSOTOKEN_REJECTED,
};
Object.freeze(MessageContext$ReauthCode);

/**
 * <p>The message context provides the information that should be used to
 * construct a single message. Each message should have its own context.</p>
 *
 * <p>All context methods may be called multiple times except for
 * {@code #write(OutputStream)} which is guaranteed to be called only once.
 * (The written data will be cached in memory in case the message needs to be
 * resent.)</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @interface
 */
var MessageContext = util.Class.create({
    /**
     * <p>Called when receiving a message to process service tokens.</p>
     * 
     * <p>This method should return a map of crypto contexts by service token
     * name for all known service tokens. If the service token name is not
     * found then the crypto context mapped onto the empty string will be
     * used if found.</p>
     *
     * @return {Object.<string,ICryptoContext>} the service token crypto contexts.
     */
    getCryptoContexts: function() {},
    
    /**
     * <p>Called to identify the entity identity the message application data
     * is intended for. If the identity is not known this method must return
     * {@code null}.</p> 
     * 
     * <p>Trusted network servers may always return {@code null}.</p>
     * 
     * @return {string} the entity identity of the application data recipient or
     *         {@code null} if the identity is not known.
     */
    getRecipient: function() {},

    /**
     * <p>Called to determine if the message application data must be
     * encrypted.</p>
     *
     * @return {boolean} true if the application data must be encrypted.
     */
    isEncrypted: function() {},
    
    /**
     * <p>Called to determine if the message application data must be integrity
     * protected.</p>
     * 
     * @return {boolean} true if the application data must be integrity protected.
     */
    isIntegrityProtected: function isIntegrityProtected() {},

    /**
     * <p>Called to determine if a message should be marked as
     * non-replayable.</p>
     * 
     * <p>Trusted network servers must always return {@code false}.</p>
     *
     * @return {boolean} true if the application data should not be carried in a
     *         replayable message.
     */
    isNonReplayable: function() {},
    
    /**
     * <p>Called to determine if a message is requesting a master token, user
     * ID token, or service tokens.</p>
     * 
     * <p>Trusted network servers must always return {@code false}.</p>
     * 
     * @return {boolean} true if the message must have a master token and user ID token
     *         (if associated with a user) or must be carried in a renewable
     *         message to acquire said tokens.
     */
    isRequestingTokens: function() {},

    /**
     * <p>Called to identify the local user the message should be sent with. If
     * a user ID token exists for this user it will be used.</p>
     * 
     * <p>Trusted network servers must always return {@code null}.</p>
     * 
     * <p>Any non-null value returned by this method must match the local user
     * associated with the user authentication data returned by
     * {@link #getUserAuthData(ReauthCode, boolean, boolean)}.</p>
     * 
     * <p>This method may return a non-null value when
     * {@link #getUserAuthData(ReauthCode, boolean, boolean)} will return null
     * if the message should be associated with a user but there is no user
     * authentication data. For example during new user creation.</p>
     * 
     * <p>This method must return {@code null} if the message should not be
     * associated with a user and
     * {@link #getUserAuthData(ReauthCode, boolean, boolean)} will also return
     * {@code null}.</p>
     *
     * @return {string} the local user identity or null.
     */
    getUserId: function() {},

    /**
     * <p>Called if the user ID is not {@code null} to attach user
     * authentication data to messages.</p>
     * 
     * <p>Trusted network servers must always return {@code null}.</p>
     * 
     * <p>This method should return user authentication data if the message
     * should be associated with a user that has not already received a user ID
     * token. This may involve prompting the user for credentials. If the
     * message should not be associated with a user, a user ID token already
     * exists for the user, or if user credentials are unavailable then this
     * method should return {@code null}.</p>
     *
     * <p>The one exception is if the application wishes to re-authenticate the
     * user against the current user ID token in which case this method should
     * return user authentication data. The {@code renewable} parameter may be
     * used to limit this operation to renewable messages.</p>
     * 
     * <p>This method may be called if user re-authentication is required for
     * the transaction to complete. If the application knows that user
     * authentication is required for the request being sent and is unable to
     * provide user authentication data then it should attempt to cancel the
     * request and return {@code null}.</p>
     * 
     * <p>If the {@code reauthCode} parameter is non-{@code null} then new user
     * authentication data should be returned for this and all subsequent calls.
     * The application may wish to return {@code null} if it knows that the
     * request being sent can no longer succeed because the existing user ID
     * token or service tokens are no longer valid. This will abort the
     * request. Note that a {@code reauthCode} argument may be provided even if
     * no user authentication data was included in the message.</p>
     * 
     * <p>If the {@code required} parameter is true then user authentication
     * should be returned for this call, even if a user ID token already exists
     * for the user. {@code null} should still be returned when {@code required}
     * is true if the message should be associated with a user but there is no
     * user authentication data. For example during new user creation.</p>
     * 
     * <p>This method will be called multiple times.</p>
     *
     * @param {MessageContext$ReauthCode} reauthCode non-{@code null} if new user authentication data is
     *        required. The reason the old user authentication data was
     *        rejected is identified by the code.
     * @param {boolean} renewable true if the message being sent is renewable.
     * @param {boolean} required true if user authentication data must be returned.
     * @param {{result: function(UserAuthenticationData), error: function(Error)}}
     *        callback the callback that will receive the user authentication
     *        data, which may be null, or any thrown exceptions.
     */
    getUserAuthData: function(reauthCode, renewable, required, callback) {},

    /**
     * <p>Called if a message does not contain a user ID token for the remote
     * user.</p>
     * 
     * <p>Trusted network clients must always return {@code null}.</p>
     * 
     * <p>If a non-null value is returned by this method and a master token
     * exists for the remote entity then a new user ID token will be created
     * for the remote user and sent in the message. This is not the user
     * identified by {@link #getUserId()} or authenticated by
     * {@link #getUserAuthData(ReauthCode, boolean, boolean)} as those methods
     * are used for the local user.</p>
     */
    getCustomer: function() {},

    /**
     * <p>Called if a request is eligible for key exchange (i.e. the request
     * is renewable and contains entity authentication data or a renewable
     * master token).</p>
     * 
     * <p>Trusted network servers must always return the empty set.</p>
     * 
     * <p>This method must return key request data for all supported key
     * exchange schemes. Failure to provide any key request data may result in
     * message delivery failures.</p>
     * 
     * <p>This method may also be called if entity re-authentication is required
     * for the transaction to complete.</p>
     *
     * param {result: function(Array.<KeyRequestData>), error: function(Error)}
     *       callback the callback that will receive the key request data,
     *       which may be the empty set, or any thrown exceptions.
     */
    getKeyRequestData: function(callback) {},

    /**
     * <p>Called prior to message sending to allow the processor to modify the
     * message being built.</p>
     * 
     * <p>The boolean {@code handshake} will be true if the function is being
     * called for a handshake message that must be sent before the application
     * data can be sent. The builder for handshake messages may lack a master
     * token, user ID token, and other bound service tokens.</p>
     * 
     * <p>This is a synchronous callback; the processor should finish using the
     * builder before returning from the function.</p>
     * 
     * <p>This method will be called multiple times. The set of service tokens
     * managed by the provided message service token builder may be different
     * for each call. The processor should treat each call to this method
     * independently from each other.</p>
     *
     * @param {MessageServiceTokenBuilder} builder message service token builder.
     * @param {boolean} handshake true if the provided builder is for a handshake message.
     * @param {{result: function(boolean), error: function(Error)}} callback the
     *        callback should always receive true on completion, or any thrown
     *        exceptions.
     * @throws MslMessageException if the builder throws an exception or the
     *         desired service tokens cannot be attached.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the service token data.
     * @throws MslEncodingException if there is an error encoding the service
     *         token JSON data.
     * @throws MslException if there is an error compressing the data.
     * @see {@link com.netflix.msl.MslError#RESPONSE_REQUIRES_MASTERTOKEN}
     * @see {@link com.netflix.msl.MslError#RESPONSE_REQUIRES_USERIDTOKEN}
     */
    updateServiceTokens: function(builder, handshake, callback) {},

    /**
     * <p>Called when the message is ready to be sent. The processor should
     * use the provided {@code MessageOutputStream} to write its application
     * data.</p>
     * 
     * <o>This is a synchronous callback; the processor should write all
     * application data before returning from the function. It is okay for this
     * method to be long-running as the data will be streamed.</p>
     *
     * @param {MessageOutputStream} output message output stream.
     * @param {number} timeout write timeout in milliseconds.
     * @param {{result: function(boolean), timeout: function() {}, error: function(Error)}}
     *        callback the callback should always receive true on completion,
     *        or any thrown exceptions.
     * @throws IOException if the output stream throws an I/O exception.
     */
    write: function(output, timeout, callback) {},
    
    /**
     * Returns a message debug context applicable to the message being sent or
     * received.
     * 
     * @return {MessageDebugContext} the message debug context or {@code null}
     *         if there is none.
     */
    getDebugContext: function() {},
});



// -- javascript/msg/FilterStreamFactory.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * A filter stream factory provides filter input stream and filter output
 * stream instances.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var FilterStreamFactory = util.Class.create({
    /**
     * Return a new input stream that has the provided input stream as its
     * backing source. If no filtering is desired then the original input
     * stream must be returned.
     *
     * @param {InputStream} input the input stream to wrap.
     * @return {InputStream} a new filter input stream backed by the provided input stream or
     *         the original input stream..
     */
    getInputStream: function(input) {},

    /**
     * Return a new output stream that has the provided output stream as its
     * backing destination. If no filtering is desired then the original output
     * stream must be returned.
     *
     * @param {OutputStream} output the output stream to wrap.
     * @return {OutputStream} a new filter output stream backed by the provided output stream
     *         or the original output stream.
     */
    getOutputStream: function(output) {},
});



// -- javascript/msg/MslControl.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Message Security Layer control provides the base operational MSL logic of
 * sending and receiving messages with an optional thread pool. An application
 * should only use one instance of {@code MslControl} for all MSL
 * communication. This class is thread-safe.</p>
 *
 * <p>This class provides methods for sending and receiving messages for all
 * types of entities in both trusted network and peer-to-peer network types.
 * Refer to the documentation for each method to determine which methods should
 * be used based on the entity's role and network type.</p>
 *
 * <h3>Error Handling</h3>
 *
 * <dl>
 *  <dt>{@link ResponseCode#FAIL}</dt>
 *  <dd>The caller is notified of the failure.</dd>
 *
 *  <dt>{@link ResponseCode#TRANSIENT_FAILURE}</dt>
 *  <dd>The caller is notified of the failure. MSL will not automatically
 *      retry.</dd>
 *
 *  <dt>{@link ResponseCode#ENTITY_REAUTH}</dt>
 *  <dd>MSL will attempt to resend the message using the entity authentication
 *      data. The previous master token and master token-bound service tokens
 *      will be discarded if successful.</dd>
 *
 *  <dt>{@link ResponseCode#USER_REAUTH}</dt>
 *  <dd>MSL will attempt to resend the message using the user authentication
 *      data if made available by the message context. Otherwise request fails.
 *      The previous user ID token-bound service tokens will be discarded if
 *      successful.</dd>
 *
 *  <dt>{@link ResponseCode#KEYX_REQUIRED}</dt>
 *  <dd>MSL will attempt to perform key exchange to establish session keys and
 *      then resend the message.</dd>
 *
 *  <dt>{@link ResponseCode#ENTITYDATA_REAUTH}</dt>
 *  <dd>MSL will attempt to resend the message using new entity authentication
 *      data. The previous master token and master token-bound service tokens
 *      will be discarded if successful.</dd>
 *
 *  <dt>{@link ResponseCode#USERDATA_REAUTH}</dt>
 *  <dd>MSL will attempt to resend the message using new user authentication
 *      data if made available by the message context. Otherwise request fails.
 *      The previous user ID token-bound service tokens will be discarded if
 *      successful.</dd>
 *
 *  <dt>{@link ResponseCode#EXPIRED}</dt>
 *  <dd>MSL will attempt to resend the message with the renewable flag set or
 *      after receiving a new master token.</dd>
 *
 *  <dt>{@link ResponseCode#REPLAYED}</dt>
 *  <dd>MSL will attempt to resend the message after renewing the master token
 *      or receiving a new master token.</dd>
 *
 *  <dt>{@link ResponseCode#SSOTOKEN_REJECTED}</dt>
 *  <dd>Identical to {@link ResponseCode#USERDATA_REAUTH}.</dd>
 * </dl>
 *
 * <h3>Anti-Replay</h3>
 *
 * <p>Requests marked as non-replayable will include a non-replayable ID.</p>
 *
 * <p>Responses must always reply with the message ID of the request
 * incremented by 1. When the request message ID equals 2<sup>63</sup>-1 the
 * response message ID must be 0. If the response message ID does not equal the
 * expected value it is rejected and the caller is notified.</p>
 *
 * <h3>Renewal Synchronization</h3>
 *
 * <p>For a given MSL context there will be at most one renewable request with
 * a master token and key request data in process. This prevents excessive
 * master token renewal and potential renewal race conditions.</p>
 *
 * <p>Requests will be marked renewable if any of the following is true:
 * <ul>
 * <li>The master token renewal window has been entered.</li>
 * <li>The user ID token renewal window has been entered.</li>
 * <li>The application requests or requires establishment of session keys.</li>
 * </ul>
 * </p>
 *
 * <h3>MSL Handshake</h3>
 *
 * <p>Whenever requested or possible application data is encrypted and
 * integrity-protected while in transit. If the MSL context entity
 * authentication scheme does not support encryption or integrity protection
 * when requested an initial handshake will be performed to establish session
 * keys. This handshake occurs silently without the application's
 * knowledge.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslControl;
var MslControl$ApplicationError;

(function() {
//    "use strict";
// 'SyntaxError: Cannot declare a parameter named 'error' in strict mode'

    /**
     * Application level errors that may translate into MSL level errors.
     */
    MslControl$ApplicationError = {
        /** The entity identity is no longer accepted by the application. */
        ENTITY_REJECTED: "ENTITY_REJECTED",
        /** The user identity is no longer accepted by the application. */
        USER_REJECTED: "USER_REJECTED"
    };

    /**
     * Creates a function that when called will abort the service.
     *
     * @param {ReceiveService|RespondService|RequestService} service the
     *        service that will be aborted.
     */
    function CancellationFunction(service) {
        return function() { service.abort(); };
    }

    /**
     * A null output stream has no-ops when writing data.
     */
    var NullOutputStream = OutputStream.extend({
        /** @inheritDoc */
        close: function close(timeout, callback) {
            callback.result(true);
        },

        /** @inheritDoc */
        write: function write(data, off, len, timeout, callback) {
            AsyncExecutor(callback, function() {
                var written = Math.min(data.length - off, len);
                return written;
            });
        },

        /** @inheritDoc */
        flush: function flush(timeout, callback) {
            callback.result(true);
        }
    });

    /**
     * A dummy error message registry that always returns null for the user
     * message.
     */
    var DummyMessageRegistry = ErrorMessageRegistry.extend({
        /** @inheritDoc */
        getUserMessage: function getUserMessage(error, languages) {
            return null;
        },
    });

    /**
     * Base class for custom message contexts. All methods are passed through
     * to the backing message context.
     */
    var FilterMessageContext = MessageContext.extend({
        /**
         * Creates a message context that passes through calls to the backing
         * message context.
         *
         * @param {MessageContext} appCtx the application's message context.
         */
        init: function init(appCtx) {
            // The properties.
            var props = {
                _appCtx: { value: appCtx, writable: false, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getCryptoContexts: function getCryptoContexts() {
            return this._appCtx.getCryptoContexts();
        },

        /** @inheritDoc */
        isEncrypted: function isEncrypted() {
            return this._appCtx.isEncrypted();
        },

        /** @inheritDoc */
        isIntegrityProtected: function isIntegrityProtected() {
            return this._appCtx.isIntegrityProtected();
        },

        /** @inheritDoc */
        isNonReplayable: function isNonReplayable() {
            return this._appCtx.isNonReplayable();
        },

        /** @inheritDoc */
        isRequestingTokens: function isRequestingTokens() {
            return this._appCtx.isRequestingTokens();
        },

        /** @inheritDoc */
        getUserId: function getUserId() {
            return this._appCtx.getUserId();
        },

        /** @inheritDoc */
        getUserAuthData: function getUserAuthData(reauthCode, renewable, required, callback) {
            this._appCtx.getUserAuthData(reauthCode, renewable, required, callback);
        },

        /** @inheritDoc */
        getCustomer: function getCustomer() {
            return this._appCtx.getCustomer();
        },

        /** @inheritDoc */
        getKeyRequestData: function getKeyRequestData(callback) {
            this._appCtx.getKeyRequestData(callback);
        },

        /** @inheritDoc */
        updateServiceTokens: function updateServiceTokens(builder, handshake, callback) {
            this._appCtx.updateServiceTokens(builder, handshake, callback);
        },

        /** @inheritDoc */
        write: function write(output, timeout, callback) {
            this._appCtx.write(output, timeout, callback);
        },

        /** @inheritDoc */
        getDebugContext: function getDebugContext() {
            return this._appCtx.getDebugContext();
        }
    });

    /**
     * This message context is used to re-send a message.
     */
    var ResendMessageContext = FilterMessageContext.extend({
        /**
         * Creates a message context used to re-send a message after an error
         * or handshake.
         *
         * @param {Array.<PayloadChunk>} payloads original request payload chunks.
         * @param {MessageContext} appCtx the application's message context.
         */
        init: function init(payloads, appCtx) {
            init.base.call(this, appCtx);
            // The properties.
            var props = {
                _payloads: { value: payloads, writable: false, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        write: function write(output, timeout, callback) {
            var self = this;
            function nextChunk(index, func) {
                if (index == self._payloads.length) {
                    callback.result(true);
                    return;
                }

                var chunk = self._payloads[index];
                output.setCompressionAlgorithm(chunk.compressionAlgo, timeout, {
                    result: function(success) {
                        output.write(chunk.data, 0, chunk.data.length, timeout, {
                            result: function(written) {
                                InterruptibleExecutor(callback, function() {
                                    // Don't flush the final payload. It will get sent when the
                                    // message output stream is closed.
                                    if (!chunk.isEndOfMessage()) {
                                        output.flush(timeout, {
                                            result: function(success) { callback.result(success); },
                                            timeout: function() { callback.timeout(); },
                                            error: function(e) { callback.error(e); }
                                        });
                                        return;
                                    }

                                    nextChunk(index + 1, func);
                                }, self);
                            },
                            timeout: function(written) { callback.timeout(written); },
                            error: function(e) { callback.error(e); }
                        });
                    },
                    timeout: function() {},
                    error: function(e) { callback.error(e); }
                });
            }
            nextChunk(0);
        }
    });

    /**
     * This message context is used to send a handshake response.
     */
    var KeyxResponseMessageContext = FilterMessageContext.extend({
        /**
         * Creates a message context used for automatically generated handshake
         * responses.
         *
         * @param {MessageContext} appCtx the application's message context.
         */
        init: function init(appCtx) {
            init.base.call(this, appCtx);
        },

        /** @inheritDoc */
        isEncrypted: function isEncrypted() {
            return false;
        },

        /** @inheritDoc */
        isNonReplayable: function isNonReplayable() {
            return false;
        },

        /** @inheritDoc */
        write: function write(output, timeout, callback) {
            callback.result(true);
        }
    });

    /**
     * A master token and its associated read/write lock ticket number.
     *
     * @param {MasterToken} masterToken
     * @param {number} ticket
     */
    function TokenTicket(masterToken, ticket) {
        // The properties.
        var props = {
            masterToken: { value: masterToken, writable: false, configurable: false },
            ticket: { value: ticket, writable: false, configurable: false }
        };
        Object.defineProperties(this, props);
    }

    /**
     * The result of building an error response.
     *
     * Create a new result with the provided request builder and message
     * context.
     *
     * @param {MessageBuilder} builder
     * @param {MessageContext} msgCtx
     */
    function ErrorResult(builder, msgCtx) {
        // The properties.
        var props = {
            /** The new request to send. */
            builder: { value: builder, writable: false, configurable: false },
            /** The new message context to use. */
            msgCtx: { value: msgCtx, writable: false, configurable: false }
        };
        Object.defineProperties(this, props);
    }

    /**
     * The result of sending a message.
     *
     * Create a new result with the provided message header and cached
     * application data (which was not sent if the message was a
     * handshake).
     *
     * @param {MessageHeader} requestHeader request message header.
     * @param {Array.<PayloadChunk>} payloads request payload chunks.
     * @param {boolean} handshake true if a handshake message was sent and the
     *        application data was not sent.
     */
    function SendResult(requestHeader, payloads, handshake) {
        // The properties.
        var props = {
            /** The request message header. */
            requestHeader: { value: requestHeader, writable: false, configurable: false },
            /** The request payload chunks. */
            payloads: { value: payloads, writable: false, configurable: false },
            /** True if the message was a handshake (application data was not sent). */
            handshake: { value: handshake, writable: false, configurable: false }
        };
        Object.defineProperties(this, props);
    }

    /**
     * The result of sending and receiving messages.
     *
     * Create a new result with the provided response and send result.
     *
     * @param {MessageInputStream} response response message input stream.
     * @param {SendResult} sent sent message result.
     */
    function SendReceiveResult(response, sent) {
        // The properties.
        var props = {
            /** The request message header. */
            requestHeader: { value: sent.requestHeader, writable: false, configurable: false },
            /** The request payload chunks. */
            payloads: { value: sent.payloads, writable: false, configurable: false },
            /** True if the message was a handshake (application data was not sent). */
            handshake: { value: sent.handshake, writable: false, configurable: false },
            /** The response message input stream. */
            response: { value: response, writable: false, configurable: false }
        };
        Object.defineProperties(this, props);
    }

    /**
     * The maximum number of MSL messages (requests sent or responses received)
     * to allow before giving up. Six exchanges, or twelve total messages,
     * should be sufficient to capture all possible error recovery and
     * handshake requirements in both trusted network and peer-to-peer modes.
     *
     * @type {number}
     * @const
     */
    var MAX_MESSAGES = 12;

    /**
     * The buffer size used to read off all discarded payloads.
     */
    var PAYLOAD_BUFFER_SIZE = 32 * 1024;

    /**
     * Dummy master token used to release the renewal lock.
     */
    var NULL_MASTER_TOKEN = {};

    /**
     * Returns true if the current operation has been interrupted/cancelled as
     * indicated by the type of caught error.
     *
     * @param {?Error} e caught error. May be null.
     * @return {boolean} true if the error indicates an operation was
     *         interrupted.
     */
    function cancelled(t) {
        while (t) {
            if (t instanceof MslInterruptedException)
                return true;
            if (t instanceof MslException)
                t = t.cause;
            else
                t = undefined;
        }
        return false;
    }

    var ReceiveService;
    var RespondService;
    var ErrorService;
    var RequestService;

    var MslControlImpl = util.Class.create({
        /**
         * Create a new instance of MSL control.
         *
         * @param {ErrorMessageRegistry} messageRegistry error message registry.
         */
        init: function init(messageRegistry) {
            if (!messageRegistry)
                messageRegistry = new DummyMessageRegistry();

            // The properties.
            var props = {
                /**
                 * Filter stream factory. May be null.
                 * @type {FilterStreamFactory}
                 */
                _filterFactory: { value: null, writable: true, enumerable: false, configurable: false },
                /**
                 * Map tracking outstanding renewable messages by MSL context. The blocking
                 * queue is used to wait for a master token from a different thread if the
                 * message requires one.
                 * @type {Array.<{ctx: MslContext, queue: BlockingQueue}>}
                 */
                _renewingContexts: { value: [], writable: false, enumerable: false, configurable: false },
                /**
                 * Map of in-flight master token in-flight read-write locks by MSL context.
                 * @type {Object.<MasterToken,ReadWriteLock>}
                 */
                _masterTokenLocks: { value: {}, writable: false, enumerable: false, configurable: false },
                /**
                 * Error message registry.
                 * @type {ErrorMessageRegistry}
                 */
                _messageRegistry: { value: messageRegistry, writable: false, enumerable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /**
         * Assigns a filter stream factory that will be used to filter any incoming
         * or outgoing messages. The filters will be placed between the MSL message
         * and MSL control, meaning they will see the actual MSL message data as it
         * is being read from or written to the remote entity.
         *
         * @param {FilterStreamFactory} factory filter stream factory. May be null.
         */
        setFilterFactory: function setFilterFactory(factory) {
            this._filterFactory = factory;
        },

        /**
         * <p>Returns the newest master token from the MSL store and acquires the
         * master token's read lock.</p>
         *
         * <p>When the caller no longer requires the master token or its crypto
         * context to exist (i.e. it does not expect to receive a response that
         * uses the same master token) then it must release the lock.</p>
         *
         * @param {ReceiveService|RespondService|RequestService} service the calling service.
         * @param {MslContext} ctx MSL context.
         * @param {number} timeout lock acquisition timeout in milliseconds.
         * @param {{result: function(TokenTicket), timeout: function(), error: function(Error)}}
         *        callback the callback that will receive the master token (or null
         *        if there is none) and lock ticket, notification of timeout,
         *        or any thrown exceptions.
         * @throws InterruptedException if the thread is interrupted while trying
         *         to acquire the master token's read lock.
         * @see #releaseMasterToken(MasterToken)
         */
        getNewestMasterToken: function getNewestMasterToken(service, ctx, timeout, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // Get the newest master token. If there is none then immediately
                // return.
                var store = ctx.getMslStore();
                var masterToken = store.getMasterToken();
                if (!masterToken) return null;

                // Acquire the master token read lock, creating it if necessary.
                var key = masterToken.uniqueKey();
                var rwlock = this._masterTokenLocks[key];
                if (!rwlock) {
                    rwlock = new ReadWriteLock();
                    this._masterTokenLocks[key] = rwlock;
                }
                var ticket = rwlock.readLock(timeout, {
                    result: function(ticket) {
                        InterruptibleExecutor(callback, function() {
                            // If aborted throw an exception.
                            if (ticket === undefined)
                                throw new MslInterruptedException('getNewestMasterToken aborted.');
                            
                            // Now we have to be tricky and make sure the master token we just
                            // acquired is still the newest master token. This is necessary
                            // just in case the master token was deleted between grabbing it
                            // from the MSL store and acquiring the read lock.
                            var newestMasterToken = store.getMasterToken();
                            if (masterToken.equals(newestMasterToken))
                                return new TokenTicket(masterToken, ticket);
                            
                            // If the master tokens are not the same then release the read
                            // lock, acquire the write lock, and then delete the master token
                            // lock (it may already be deleted). Then try again.
                            rwlock.unlock(ticket);
                            rwlock.writeLock(timeout, {
                                result: function(writeTicket) {
                                    InterruptibleExecutor(callback, function() {
                                        // If aborted throw an exception.
                                        if (writeTicket === undefined)
                                            throw new MslInterruptedException('getNewestMasterToken aborted.');
                                        
                                        delete this._masterTokenLocks[key];
                                        rwlock.unlock(writeTicket);
                                        return this.getNewestMasterToken(service, ctx, timeout, callback);
                                    }, self);
                                },
                                timeout: function() { callback.timeout(); },
                                error: function(e) { callback.error(e); }
                            });
                        }, self);
                    },
                    timeout: function() { callback.timeout(); },
                    error: function(e) { callback.error(e); }
                });
                service.setAbort(function() {
                    if (ticket) {
                        rwlock.cancel(ticket);
                        ticket = undefined;
                    }
                });
            }, self);
        },

        /**
         * Deletes the provided master token from the MSL store. Doing so requires
         * acquiring the master token's write lock.
         *
         * @param {MslContext} ctx MSL context.
         * @param {?MasterToken} masterToken master token to delete. May be null.
         * @throws InterruptedException if the thread is interrupted while trying
         *         to acquire the master token's write lock.
         */
        deleteMasterToken: function deleteMasterToken(ctx, masterToken) {
            // Do nothing if the master token is null.
            if (!masterToken)
                return;

            // Separately, acquire the write lock and delete the master token
            // from the store. We must do this 'later' because the write lock
            // cannot be acquired until the read lock is released and we are
            // currently holding it.
            //
            // The timeout will be clamped.
            var self = this;
            setTimeout(function() {
                var key = masterToken.uniqueKey();
                var rwlock = self._masterTokenLocks[key];
                if (!rwlock) {
                    rwlock = new ReadWriteLock();
                    self._masterTokenLocks[key] = rwlock;
                }
                // No need to register an abort function with the calling
                // service as this occurs in a independently.
                rwlock.writeLock(-1, {
                    result: function(ticket) {
                        ctx.getMslStore().removeCryptoContext(masterToken);
                        // It should be okay to delete this read/write lock because no
                        // one should be using the deleted master token anymore; a new
                        // master token would have been received before deleting the
                        // old one.
                        delete self._masterTokenLocks[key];
                        rwlock.unlock(ticket);
                    },
                    timeout: function() { throw new MslInternalException("Unexpected timeout received."); },
                    error: function(e) { throw e; }
                });
            }, 0);
        },

        /**
         * Release the read lock of the provided master token. If no master token
         * is provided then this method is a no-op.
         *
         * @param {?TokenTicket} tokenTicket the
         *        master token (which may be null) and lock ticket.
         * @see #getNewestMasterToken(MslContext)
         */
        releaseMasterToken: function releaseMasterToken(tokenTicket) {
            if (tokenTicket && tokenTicket.masterToken) {
                var masterToken = tokenTicket.masterToken;
                var key = masterToken.uniqueKey();
                var rwlock = this._masterTokenLocks[key];
                if (!rwlock)
                    throw new MslInternalException("Master token read/write lock does not exist when it should.");
                rwlock.unlock(tokenTicket.ticket);
            }
        },

        /**
         * Update the MSL store crypto contexts with the crypto contexts of the
         * message being sent. Only crypto contexts for master tokens used by the
         * local entity for message authentication are saved.
         *
         * @param {MslContext} ctx MSL context.
         * @param {MessageHeader} messageHeader outgoing message header.
         * @param {KeyExchangeData} keyExchangeData outgoing message key exchange
         *        data.
         * @throws InterruptedException if the thread is interrupted while trying
         *         to delete an old master token.
         */
        updateOutgoingCryptoContexts: function updateOutgoingCryptoContexts(ctx, messageHeader, keyExchangeData) {
            // In trusted network mode save the crypto context of the message's key
            // response data as an optimization.
            var store = ctx.getMslStore();
            if (!ctx.isPeerToPeer() && keyExchangeData) {
                var keyResponseData = keyExchangeData.keyResponseData;
                var keyxCryptoContext = keyExchangeData.cryptoContext;
                var keyxMasterToken = keyResponseData.masterToken;
                store.setCryptoContext(keyxMasterToken, keyxCryptoContext);

                // Delete the old master token. Even if we receive future messages
                // with this master token we can reconstruct the crypto context.
                this.deleteMasterToken(ctx, messageHeader.masterToken);
            }
        },

        /**
         * Update the MSL store crypto contexts with the crypto contexts provided
         * by received message.
         *
         * @param {MslContext} ctx MSL context.
         * @param {MessageHeader} request previous message the response was received for.
         * @param {MessageInputStream} response received message input stream.
         * @throws InterruptedException if the thread is interrupted while trying
         *         to delete an old master token.
         */
        updateIncomingCryptoContexts: function updateIncomingCryptoContexts(ctx, request, response) {
            // Do nothing for error messages.
            var messageHeader = response.getMessageHeader();
            if (!messageHeader)
                return;

            // Save the crypto context of the message's key response data.
            var store = ctx.getMslStore();
            var keyResponseData = messageHeader.keyResponseData;
            if (keyResponseData) {
                var keyxMasterToken = keyResponseData.masterToken;
                store.setCryptoContext(keyxMasterToken, response.getKeyExchangeCryptoContext());

                // Delete the old master token. We won't use it anymore to build
                // messages.
                this.deleteMasterToken(ctx, request.masterToken);
            }
        },

        /**
         * Update the MSL store by removing any service tokens marked for deletion
         * and adding/replacing any other service tokens contained in the message
         * header.
         *
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {?MasterToken} masterToken master for the service tokens.
         * @param {?UserIdToken} userIdToken user ID token for the service tokens.
         * @param {Array.<ServiceToken>} serviceTokens the service tokens to update.
         * @throws MslException if a token cannot be removed because of a master
         *         token or user ID token mismatch.
         */
        storeServiceTokens: function storeServiceTokens(ctx, masterToken, userIdToken, serviceTokens) {
            // Remove deleted service tokens from the store. Update stored
            // service tokens.
            var store = ctx.getMslStore();
            var storeTokens = [];
            for (var i = 0; i < serviceTokens.length; ++i) {
                var token = serviceTokens[i];

                // Skip service tokens that are bound to a master token if the
                // local entity issued the master token.
                if (token.isBoundTo(masterToken) && masterToken.isVerified())
                    continue;
                var data = token.data;
                if (data && data.length == 0)
                    store.removeServiceTokens(token.name, token.isMasterTokenBound() ? masterToken : null, token.isUserIdTokenBound() ? userIdToken : null);
                else
                    storeTokens.push(token);
            }
            if (storeTokens.length > 0)
                store.addServiceTokens(storeTokens);
        },

        /**
         * <p>Create a new message builder that will craft a new message.</p>
         *
         * <p>If a master token is available it will be used to build the new
         * message and its read lock will be acquired. The caller must release the
         * read lock after it has either received a response to the built request
         * or after sending the message if no response is expected.</p>
         *
         * <p>If a master token is available and a user ID is provided by the
         * message context the user ID token for that user ID will be used to build
         * the message if the user ID token is bound to the master token.</p>
         *
         * @param {ReceiveService|RespondService|RequestService} service the calling service.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {number} lock acquisition timeout in milliseconds.
         * @param {{result: function({builder: MessageBuilder, tokenTicket: ?TokenTicket}),
         *         timeout: function(), error: function(Error)}} callback the
         *        callback that will receive the message builder and master
         *        token / lock ticket, notification of a timeout, and any
         *        thrown exceptions.
         * @throws InterruptedException if the thread is interrupted while trying
         *         to acquire the master token's read lock.
         */
        buildRequest: function buildRequest(service, ctx, msgCtx, timeout, callback) {
            var self = this;

            // Grab the newest master token.
            this.getNewestMasterToken(service, ctx, timeout, {
                result: function(tokenTicket) {
                    AsyncExecutor(callback, function() {
                        var masterToken = (tokenTicket && tokenTicket.masterToken);
                        var userIdToken;
                        if (masterToken) {
                            // Grab the user ID token for the message's user. It may not be bound
                            // to the newest master token if the newest master token invalidated
                            // it.
                            var userId = msgCtx.getUserId();
                            var store = ctx.getMslStore();
                            var storedUserIdToken = (userId) ? store.getUserIdToken(userId) : null;
                            userIdToken = (storedUserIdToken && storedUserIdToken.isBoundTo(masterToken)) ? storedUserIdToken : null;
                        } else {
                            userIdToken = null;
                        }

                        MessageBuilder$createRequest(ctx, masterToken, userIdToken, null, {
                            result: function(builder) {
                                AsyncExecutor(callback, function() {
                                    builder.setNonReplayable(msgCtx.isNonReplayable());
                                    return {
                                        builder: builder,
                                        tokenTicket: tokenTicket
                                    }
                                });
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    // Release the master token lock.
                                    this.releaseMasterToken(tokenTicket);
                                    if (e instanceof MslException)
                                        e = new MslInternalException("User ID token not bound to master token despite internal check.", e);
                                    throw e;
                                }, self);
                            }
                        });
                    }, self);
                },
                timeout: function() { callback.timeout(); },
                error: function(e) { callback.error(e); }
            });
        },

        /**
         * <p>Create a new message builder that will craft a new message in
         * response to another message. The constructed message may be used as a
         * request.</p>
         *
         * <p>In peer-to-peer mode if the response does not have a primary master
         * token and a master token is available then it will be used to build the
         * new message and its read lock will be acquired. The caller must release
         * the read lock after it has either received a response to the built
         * request or after sending the message if no response is expected.</p>
         *
         * <p>In peer-to-peer mode if a master token is being used to build the new
         * message but there is no user ID token set or the user ID token is not
         * bound to the and a user ID is provided by the message context the user
         * ID token for that user ID will be used to build the message if the user
         * ID token is bound to the master token.</p>
         *
         * @param {ReceiveService|RespondService|RequestService} service the calling service.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {MessageHeader} requestHeader message header to respond to.
         * @param {number} lock acquisition timeout in milliseconds.
         * @param {{result: function({builder: MessageBuilder, tokenTicket: ?TokenTicket}),
         *         timeout: function(), error: function(Error)}} callback the
         *        callback that will receive the message builder and master
         *        token / lock ticket, notification of a timeout, and any
         *        thrown exceptions.
         * @throws MslMasterTokenException if the provided message's master token
         *         is not trusted.
         * @throws MslCryptoException if the crypto context from a key exchange
         *         cannot be created.
         * @throws MslKeyExchangeException if there is an error with the key
         *         request data or the key response data cannot be created.
         * @throws MslUserAuthException if there is an error with the user
         *         authentication data or the user ID token cannot be created.
         * @throws MslException if a user ID token in the message header is not
         *         bound to its corresponding master token.
         * @throws InterruptedException if the thread is interrupted while trying
         *         to acquire the master token's read lock. (Only applicable in
         *         peer-to-peer mode.)
         */
        buildResponse: function buildResponse(service, ctx, msgCtx, request, timeout, callback) {
            var self = this;

            // Create the response.
            MessageBuilder$createResponse(ctx, request, {
                result: function(builder) {
                    InterruptibleExecutor(callback, function() {
                        builder.setNonReplayable(msgCtx.isNonReplayable());

                        // Trusted network clients should use the newest master token. Trusted
                        // network servers must not use a newer master token. This method is
                        // only called by trusted network clients after a handshake response is
                        // received so if the request does not contain key response data then
                        // we know the local entity is a trusted network server and should
                        // return immediately.
                        if (!ctx.isPeerToPeer() && !request.keyResponseData) {
                            return { builder: builder, tokenTicket: null };
                        }

                        // In peer-to-peer mode the primary master token may no longer be known
                        // if it was renewed between calls to receive() and respond()
                        // (otherwise we would have held a lock). In this case, we need to
                        // use the newest primary authentication tokens.
                        //
                        // Likewise, if the primary authentication tokens are not already set
                        // then use what we have received.
                        //
                        // Either way we should be able to use the newest master token,
                        // acquiring the read lock at the same time which we definitely want.
                        this.getNewestMasterToken(service, ctx, timeout, {
                            result: function(tokenTicket) {
                                InterruptibleExecutor(callback, function() {
                                    var masterToken = tokenTicket && tokenTicket.masterToken;
                                    var userIdToken;
                                    if (masterToken) {
                                        // Grab the user ID token for the message's user. It may not be
                                        // bound to the newest master token if the newest master token
                                        // invalidated it.
                                        var userId = msgCtx.getUserId();
                                        var store = ctx.getMslStore();
                                        var storedUserIdToken = (userId) ? store.getUserIdToken(userId) : null;
                                        userIdToken = (storedUserIdToken && storedUserIdToken.isBoundTo(masterToken)) ? storedUserIdToken : null;
                                    } else {
                                        userIdToken = null;
                                    }

                                    // Set the authentication tokens.
                                    builder.setAuthTokens(masterToken, userIdToken);
                                    return { builder: builder, tokenTicket: tokenTicket };
                                }, self);
                            },
                            timeout: function() { callback.timeout(); },
                            error: function(e) { callback.error(e); }
                        });
                    }, self);
                },
                error: function(e) { callback.error(e); }
            });
        },

        /**
         * Creates a message builder and message context appropriate for re-sending
         * the original message in response to the received error.
         *
         * @param {ReceiveService|RespondService|RequestService} service the calling service.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {SendResult} sent result of original sent message.
         * @param {ErrorHeader} errorHeader received error header.
         * @param {number} lock acquisition timeout in milliseconds.
         * @param {{result: function({errorResult: ErrorResult, tokenTicket: ?TokenTicket}),
         *         timeout: function(), error: function(Error)}} callback the
         *        callback that will receive the message builder and message
         *        context that should be used to re-send the original request
         *        in response to the received error and master token / lock
         *        ticket or null if the error cannot be handled (i.e. should be
         *        returned to the application), notification of a timeout, and
         *        any thrown exceptions.
         * @throws MslException if there is an error creating the message.
         * @throws InterruptedException if the thread is interrupted while trying
         *         to acquire the master token lock (user re-authentication only).
         */
        buildErrorResponse: function buildErrorResponse(service, ctx, msgCtx, sent, errorHeader, timeout, callback) {
            var self = this;

            function entityReauth(requestHeader, payloads) {
                InterruptibleExecutor(callback, function() {
                    // Resend the request without a master token or user ID token.
                    // Make sure the use the error header message ID + 1.
                    var messageId = MessageBuilder$incrementMessageId(errorHeader.messageId);
                    var resendMsgCtx = new ResendMessageContext(payloads, msgCtx);

                    MessageBuilder$createRequest(ctx, null, null, messageId, {
                        result: function(requestBuilder) {
                            InterruptibleExecutor(callback, function() {
                                if (ctx.isPeerToPeer()) {
                                    var peerMasterToken = requestHeader.peerMasterToken;
                                    var peerUserIdToken = requestHeader.peerUserIdToken;
                                    requestBuilder.setPeerAuthTokens(peerMasterToken, peerUserIdToken);
                                }
                                requestBuilder.setNonReplayable(resendMsgCtx.isNonReplayable());
                                return {
                                    errorResult: new ErrorResult(requestBuilder, resendMsgCtx),
                                    tokenTicket: null,
                                };
                            },self);
                        },
                        error: function(e) { callback.error(e); }
                    });
                }, self);
            }

            function userReauth(requestHeader, payloads) {
                // Grab the newest master token and its read lock.
                self.getNewestMasterToken(service, ctx, timeout, {
                    result: function(tokenTicket) {
                        InterruptibleExecutor(callback, function() {
                            // Resend the request without a user ID token.
                            // Make sure the use the error header message ID + 1.
                            var masterToken = tokenTicket && tokenTicket.masterToken;
                            var messageId = MessageBuilder$incrementMessageId(errorHeader.messageId);
                            var resendMsgCtx = new ResendMessageContext(payloads, msgCtx);
                            MessageBuilder$createRequest(ctx, masterToken, null, messageId, {
                                result: function(requestBuilder) {
                                    InterruptibleExecutor(callback, function() {
                                        if (ctx.isPeerToPeer()) {
                                            var peerMasterToken = requestHeader.peerMasterToken;
                                            var peerUserIdToken = requestHeader.peerUserIdToken;
                                            requestBuilder.setPeerAuthTokens(peerMasterToken, peerUserIdToken);
                                        }
                                        requestBuilder.setNonReplayable(resendMsgCtx.isNonReplayable());
                                        return {
                                            errorResult: new ErrorResult(requestBuilder, resendMsgCtx),
                                            tokenTicket: tokenTicket
                                        };
                                    }, self);
                                },
                                error: function(e) { callback.error(e); }
                            });

                        }, self);
                    },
                    timeout: function() { callback.timeout(); },
                    error: function(e) { callback.error(e); }
                });
            }

            InterruptibleExecutor(callback, function() {
                // Handle the error.
                var requestHeader = sent.requestHeader;
                var payloads = sent.payloads;
                var errorCode = errorHeader.errorCode;
                switch (errorCode) {
                case MslConstants$ResponseCode.ENTITYDATA_REAUTH:
                case MslConstants$ResponseCode.ENTITY_REAUTH:
                {
                    // If the MSL context cannot provide new entity authentication
                    // data then return null. This function should never return
                    // null.
                    var reauthCode = errorCode;
                    ctx.getEntityAuthenticationData(reauthCode, {
                        result: function(entityAuthData) {
                            InterruptibleExecutor(callback, function() {
                                if (!entityAuthData)
                                    return null;

                                // Otherwise we have now triggered the need for new entity
                                // authentication data. Fall through.
                                entityReauth(requestHeader, payloads);
                            }, self);
                        },
                        error: function(e) { callback.error(e); }
                    });
                    return;
                }
                case MslConstants$ResponseCode.USERDATA_REAUTH:
                case MslConstants$ResponseCode.SSOTOKEN_REJECTED:
                {
                    // If the message context cannot provide user authentication
                    // data then return null.
                    var reauthCode = errorCode;
                    msgCtx.getUserAuthData(reauthCode, false, true, {
                        result: function(userAuthData) {
                            InterruptibleExecutor(callback, function() {
                                if (!userAuthData)
                                    return null;

                                // Otherwise we have now triggered the need for new user
                                // authentication data. Fall through.
                                userReauth(requestHeader, payloads);
                            }, self);
                        },
                        error: function(e) { callback.error(e); }
                    });
                    return;
                }
                case MslConstants$ResponseCode.USER_REAUTH:
                {
                    userReauth(requestHeader, payloads);
                    return;
                }
                case MslConstants$ResponseCode.KEYX_REQUIRED:
                {
                    // This error will only be received by trusted network clients
                    // and peer-to-peer entities that do not have a master token.
                    // Make sure the use the error header message ID + 1.
                    var messageId = MessageBuilder$incrementMessageId(errorHeader.messageId);
                    var resendMsgCtx = new ResendMessageContext(payloads, msgCtx);
                    MessageBuilder$createRequest(ctx, null, null, messageId, {
                        result: function(requestBuilder) {
                            InterruptibleExecutor(callback, function() {
                                if (ctx.isPeerToPeer()) {
                                    var peerMasterToken = requestHeader.peerMasterToken;
                                    var peerUserIdToken = requestHeader.peerUserIdToken;
                                    requestBuilder.setPeerAuthTokens(peerMasterToken, peerUserIdToken);
                                }
                                // Mark the message as renewable to make sure the response can
                                // be encrypted. During renewal lock acquisition we will either
                                // block until we acquire the renewal lock or receive a master
                                // token.
                                requestBuilder.setRenewable(true);
                                requestBuilder.setNonReplayable(resendMsgCtx.isNonReplayable());
                                return {
                                    errorResult: new ErrorResult(requestBuilder, resendMsgCtx),
                                    tokenTicket: null,
                                };
                            }, self);
                        },
                        error: function(e) { callback.error(e); }
                    });
                    return;
                }
                case MslConstants$ResponseCode.EXPIRED:
                {
                    // Grab the newest master token and its read lock.
                    this.getNewestMasterToken(service, ctx, timeout, {
                        result: function(tokenTicket) {
                            InterruptibleExecutor(callback, function() {
                                // Resend the request.
                                var masterToken = tokenTicket && tokenTicket.masterToken;
                                var userIdToken = requestHeader.userIdToken;
                                var messageId = MessageBuilder$incrementMessageId(errorHeader.messageId);
                                var resendMsgCtx = new ResendMessageContext(payloads, msgCtx);
                                MessageBuilder$createRequest(ctx, masterToken, userIdToken, messageId, {
                                    result: function(requestBuilder) {
                                        InterruptibleExecutor(callback, function() {
                                            if (ctx.isPeerToPeer()) {
                                                var peerMasterToken = requestHeader.peerMasterToken;
                                                var peerUserIdToken = requestHeader.peerUserIdToken;
                                                requestBuilder.setPeerAuthTokens(peerMasterToken, peerUserIdToken);
                                            }
                                            // If the newest master token is equal to the previous
                                            // request's master token then mark this message as renewable.
                                            // During renewal lock acquisition we will either block until
                                            // we acquire the renewal lock or receive a master token.
                                            if (requestHeader.masterToken.equals(masterToken))
                                                requestBuilder.setRenewable(true);
                                            requestBuilder.setNonReplayable(resendMsgCtx.isNonReplayable());
                                            return {
                                                errorResult: new ErrorResult(requestBuilder, resendMsgCtx),
                                                tokenTicket: tokenTicket
                                            };
                                        }, self);
                                    },
                                    error: function(e) { callback.error(e); }
                                }, self);
                            }, self);
                        },
                        timeout: function() { callback.timeout(); },
                        error: function(e) { callback.error(e); }
                    });
                    return;
                }
                case MslConstants$ResponseCode.REPLAYED:
                {
                    // This error will only be received if the previous request's
                    // master token has an old sequence number. If a new master
                    // token was issued then we know that this old master token's
                    // renewal window has already been entered and we should get a
                    // new master token by sending a renewable message.

                    // Grab the newest master token and its read lock.
                    this.getNewestMasterToken(service, ctx, timeout, {
                        result: function(tokenTicket) {
                            InterruptibleExecutor(callback, function() {
                                // Resend the request.
                                var masterToken = tokenTicket && tokenTicket.masterToken;
                                var userIdToken = requestHeader.userIdToken;
                                var messageId = MessageBuilder$incrementMessageId(errorHeader.messageId);
                                var resendMsgCtx = new ResendMessageContext(payloads, msgCtx);
                                MessageBuilder$createRequest(ctx, masterToken, userIdToken, messageId, {
                                    result: function(requestBuilder) {
                                        InterruptibleExecutor(callback, function() {
                                            if (ctx.isPeerToPeer()) {
                                                var peerMasterToken = requestHeader.peerMasterToken;
                                                var peerUserIdToken = requestHeader.peerUserIdToken;
                                                requestBuilder.setPeerAuthTokens(peerMasterToken, peerUserIdToken);
                                            }
                                            // If the newest master token is equal to the previous
                                            // request's master token then mark this message as renewable
                                            // and replayable.
                                            //
                                            // During renewal lock acquisition we will either block until
                                            // we acquire the renewal lock or receive a master token.
                                            //
                                            // During send the application data will be delayed because the
                                            // message is replayable but the message context indicates the
                                            // application data must sent in a non-replayable message.
                                            if (requestHeader.masterToken.equals(masterToken)) {
                                                requestBuilder.setRenewable(true);
                                                requestBuilder.setNonReplayable(false);
                                            }
                                            // Otherwise mark it as replayable as dictated by the message
                                            // context.
                                            else {
                                                requestBuilder.setNonReplayable(resendMsgCtx.isNonReplayable());
                                            }
                                            return {
                                                errorResult: new ErrorResult(requestBuilder, resendMsgCtx),
                                                tokenTicket: tokenTicket
                                            };
                                        }, self);
                                    },
                                    error: function(e) { callback.error(e); }
                                });
                            }, self);
                        },
                        timeout: function() { callback.timeout(); },
                        error: function(e) { callback.error(e); }
                    });
                    return;
                }
                default:
                    // Nothing to do. Return null.
                    return null;
                }
            }, self);
        },

        /**
         * Called after successfully handling an error message to delete the old
         * invalid crypto contexts and bound service tokens associated with the
         * invalid master token or user ID token.
         *
         * @param {MslContext} ctx MSL context.
         * @param {MessageHeader} requestHeader initial request that generated the error.
         * @param {ErrorHeader} errorHeader error response received and successfully handled.
         * @throws MslException if the user ID token is not bound to the master
         *         token. (This should not happen.)
         * @throws InterruptedException if the thread is interrupted while trying
         *         to delete the old master token.
         */
        cleanupContext: function cleanupContext(ctx, requestHeader, errorHeader) {
            switch (errorHeader.errorCode) {
            case MslConstants$ResponseCode.ENTITY_REAUTH:
            {
                // The old master token is invalid. Delete the old
                // crypto context and any bound service tokens.
                this.deleteMasterToken(ctx, requestHeader.masterToken);
                break;
            }
            case MslConstants$ResponseCode.USER_REAUTH:
            {
                // The old user ID token is invalid. Delete the old user ID
                // token and any bound service tokens. It is okay to stomp on
                // other requests when doing this because automatically
                // generated messages and replies to outstanding requests that
                // use the user ID token and service tokens will work fine.
                //
                // This will be a no-op if we received a new user ID token that
                // overwrote the old one.
                var masterToken = requestHeader.masterToken;
                var userIdToken = requestHeader.userIdToken;
                if (masterToken && userIdToken) {
                    var store = ctx.getMslStore();
                    store.removeUserIdToken(userIdToken);
                }
                break;
            }
            default:
                // No cleanup required.
            }
        },

        /**
         * <p>Send a message. The message context will be used to build the message.
         * If the message will be sent then the stored master token crypto contexts
         * and service tokens will be updated just prior to sending.</p>
         *
         * <p>If the application data must be encrypted but the message does not
         * support payload encryption then a handshake message will be sent. This
         * will be indicated by the returned result.</p>
         *
         * <p>N.B. The message builder must be set renewable and non-replayable
         * before calling this method. If the application data must be delayed then
         * this specific message will be sent replayable regardless of the builder
         * non-replayable value.</p>
         *
         * @param {ReceiveService|RespondService|RequestService} service the calling service.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {OutputStream} out remote entity output stream.
         * @param {MessageBuilder} builder message builder.
         * @param {number} timeout send timeout in milliseconds.
         * @param {{result: function(SendResult), timeout: function(), error: function(Error)}}
         *        callback the callback that will receive a result containing
         *        the sent message header and a copy of the application data,
         *        notification of a timeout, or any thrown exceptions.
         * @throws IOException if there is an error writing the message.
         * @throws MslMessageException if there is an error building the request.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the message.
         * @throws MslMasterTokenException if the header master token is not
         *         trusted and needs to be to accept this message header.
         * @throws MslEntityAuthException if there is an error with the entity
         *         authentication data.
         * @throws MslException if there was an error updating the service tokens
         *         or building the message header.
         * @throws InterruptedException if the thread is interrupted while trying
         *         to delete an old master token the sent message is replacing.
         */
        send: function send(service, ctx, msgCtx, out, builder, timeout, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                var masterToken = builder.getMasterToken();
                var userIdToken = builder.getUserIdToken();

                // Ask the message context for user authentication data.
                var userAuthDataDelayed = false;
                var userId = msgCtx.getUserId();
                if (userId) {
                    // If we are not including a user ID token, the user authentication
                    // data is required.
                    var required = (!userIdToken);
                    msgCtx.getUserAuthData(null, builder.isRenewable(), required, {
                        result: function(userAuthData) {
                            InterruptibleExecutor(callback, function() {
                                if (userAuthData) {
                                    // We can only include user authentication data if the message
                                    // header will be encrypted and integrity protected.
                                    if (builder.willEncryptHeader() && builder.willIntegrityProtectHeader())
                                        builder.setUserAuthenticationData(userAuthData);

                                    // If the message should include user authentication data but
                                    // cannot at this time then we also cannot send the application
                                    // data as it may be user-specific. There is also no user ID token
                                    // otherwise the header will be encrypted.
                                    else
                                        userAuthDataDelayed = true;

                                    // Fall through to attach the customer.
                                }

                                // If user authentication data is required but was not provided
                                // then this message may be associated with a user but not have any
                                // user authentication data. For example upon user creation.

                                // Everything is okay so continue.
                                attachCustomer(masterToken, userIdToken, userAuthDataDelayed);
                            }, self);
                        },
                        error: function(e) { callback.error(e); }
                    });
                } else {
                    attachCustomer(masterToken, userIdToken, userAuthDataDelayed);
                }
            }, self);

            function attachCustomer(masterToken, userIdToken, userAuthDataDelayed) {
                InterruptibleExecutor(callback, function() {
                    var peerUserIdToken = builder.getPeerUserIdToken();

                    // If there is no user ID token for the remote user then check if a
                    // user ID token should be created and attached.
                    if (!ctx.isPeerToPeer() && !userIdToken ||
                        ctx.isPeerToPeer() && !peerUserIdToken)
                    {
                        var customer = msgCtx.getCustomer();
                        if (customer) {
                            builder.setCustomer(customer, {
                                result: function(complete) {
                                    InterruptibleExecutor(callback, function() {
                                        // The user ID token may have changed and we need the latest one to
                                        // store the service tokens below.
                                        userIdToken = builder.getUserIdToken();
                                        prepare(masterToken, userIdToken, userAuthDataDelayed);
                                    }, self);
                                },
                                error: function(e) { callback.error(e); }
                            });
                        } else {
                            prepare(masterToken, userIdToken, userAuthDataDelayed);
                        }
                    } else {
                        prepare(masterToken, userIdToken, userAuthDataDelayed);
                    }
                }, self);
            }

            function prepare(masterToken, userIdToken, userAuthDataDelayed) {
                InterruptibleExecutor(callback, function() {
                    // If we have not delayed the user authentication data, and the message
                    // payloads either do not need to be encrypted or can be encrypted with
                    // this message, and the message payloads either do not need to be
                    // integrity protected or can be integrity protected with this message,
                    // and the message is either replayable or the message will be sent non-
                    // replayable and has a master token, then we can write the application
                    // data now.
                    var writeData = !userAuthDataDelayed &&
                        (!msgCtx.isEncrypted() || builder.willEncryptPayloads()) &&
                        (!msgCtx.isIntegrityProtected() || builder.willIntegrityProtectPayloads()) &&
                        (!msgCtx.isNonReplayable() || (builder.isNonReplayable() && masterToken));

                    // Mark the message as replayable if we will not be sending the
                    // application data.
                    if (!writeData)
                        builder.setNonReplayable(false);

                    // If this message is renewable...
                    var keyRequests = [];
                    if (builder.isRenewable()) {
                        // Ask for key request data if we are using entity authentication
                        // data or if the master token needs renewing or if the message is
                        // non-replayable.
                        if (!masterToken || masterToken.isRenewable() || msgCtx.isNonReplayable()) {
                            msgCtx.getKeyRequestData({
                                result: function(requests) {
                                    InterruptibleExecutor(callback, function() {
                                        for (var i = 0; i < requests.length; ++i) {
                                            var request = requests[i];
                                            keyRequests.push(request);
                                            builder.addKeyRequestData(request);
                                        }
                                        perform(masterToken, userIdToken, writeData, keyRequests);
                                    }, self);
                                },
                                error: function(e) { callback.error(e); }
                            });
                            return;
                        }
                    }
                    perform(masterToken, userIdToken, writeData, keyRequests);
                }, self);
            }

            function perform(masterToken, userIdToken, writeData, keyRequests) {
                InterruptibleExecutor(callback, function() {
                    // Ask the caller to perform any final modifications to the
                    // message and then build the message.
                    var serviceTokenBuilder = new MessageServiceTokenBuilder(ctx, msgCtx, builder);
                    msgCtx.updateServiceTokens(serviceTokenBuilder, !writeData, {
                        result: function(success) {
                            builder.getHeader({
                                result: function(requestHeader) {
                                    InterruptibleExecutor(callback, function() {
                                        // Deliver the header that will be sent to the debug context.
                                        var debugCtx = msgCtx.getDebugContext();
                                        if (debugCtx) debugCtx.sentHeader(requestHeader);

                                        // Update the stored crypto contexts just before sending the
                                        // message so we can receive new messages immediately after it is
                                        // sent.
                                        var keyExchangeData = builder.getKeyExchangeData();
                                        this.updateOutgoingCryptoContexts(ctx, requestHeader, keyExchangeData);

                                        // Update the stored service tokens.
                                        var serviceTokens = requestHeader.serviceTokens;
                                        this.storeServiceTokens(ctx, masterToken, userIdToken, serviceTokens);

                                        // We will either use the header crypto context or the key exchange
                                        // data crypto context in trusted network mode to process the message
                                        // payloads.
                                        var payloadCryptoContext;
                                        if (!ctx.isPeerToPeer() && keyExchangeData)
                                            payloadCryptoContext = keyExchangeData.cryptoContext;
                                        else
                                            payloadCryptoContext = requestHeader.cryptoContext;

                                        // Stop and throw an exception if aborted.
                                        if (service.isAborted())
                                            throw new MslInterruptedException('send aborted.');

                                        // Send the request.
                                        var os = (this._filterFactory != null) ? this._filterFactory.getOutputStream(out) : out;
                                        MessageOutputStream$create(ctx, os, MslConstants$DEFAULT_CHARSET, requestHeader, payloadCryptoContext, timeout, {
                                            result: function(request) {
                                                service.setAbort(function() { request.abort(); });
                                                write(request, requestHeader, writeData);
                                            },
                                            timeout: function() { callback.timeout(); },
                                            error: function(e) { callback.error(e); }
                                        });
                                    }, self);
                                },
                                timeout: function() { callback.timeout(); },
                                error: function(e) { callback.error(e); }
                            });
                        },
                        error: function(e) { callback.error(e); }
                    });
                }, self);
            }

            function write(request, requestHeader, writeData) {
                // If it is okay to write the data then ask the application to write it
                // and we're done.
                if (writeData) {
                    msgCtx.write(request, timeout, {
                        result: function(success) {
                            InterruptibleExecutor(callback, function() {
                                // If aborted throw an exception.
                                if (service.isAborted())
                                    throw new MslInterruptedException('MessageOutputStream write aborted.');

                                finish(request, requestHeader, writeData);
                            }, self);
                        },
                        timeout: function() { callback.timeout(); },
                        error: function(e) { callback.error(e); }
                    });
                }

                // Otherwise provide the message context with a fake
                // MessageOutputStream to capture the payloads.
                else {
                    var nullStream = new NullOutputStream();
                    var nullCryptoContext = new NullCryptoContext();
                    MessageOutputStream$create(ctx, nullStream, MslConstants$DEFAULT_CHARSET, requestHeader, nullCryptoContext, timeout, {
                        result: function(proxy) {
                            msgCtx.write(proxy, timeout, {
                                result: function(success) {
                                    InterruptibleExecutor(callback, function() {
                                        // If aborted throw an exception.
                                        if (service.isAborted())
                                            throw new MslInterruptedException('MessageOutputStream proxy write aborted.');

                                        // Close the fake MessageOutputStream
                                        // and get its payloads.
                                        proxy.close(timeout, {
                                           result: function(success) {
                                               InterruptibleExecutor(callback, function() {
                                                   // If aborted throw an exception.
                                                   if (!success)
                                                       throw new MslInterruptedException('MessageOutputStream proxy close aborted.');

                                                   // Use the proxy payloads.
                                                   var payloads = proxy.getPayloads();
                                                   finish(request, requestHeader, writeData, payloads);
                                               }, self);
                                           },
                                           timeout: function() { callback.timeout(); },
                                           error: function(e) { callback.error(e); }
                                        });
                                    }, self);
                                },
                                timeout: function() { callback.timeout(); },
                                error: function(e) { callback.error(e); }
                            });
                        },
                        timeout: function() { callback.timeout(); },
                        error: function(e) { callback.error(e); }
                    });
                }
            }

            function finish(request, requestHeader, writeData, payloads) {
                request.close(timeout, {
                    result: function(success) {
                        InterruptibleExecutor(callback, function() {
                            // If aborted throw an exception.
                            if (!success)
                                throw new MslInterruptedException('MessageOutputStream close aborted.');

                            // If no payloads were provided, pull them from the
                            // request.
                            if (!payloads)
                                payloads = request.getPayloads();

                            // Return the result.
                            return new SendResult(requestHeader, payloads, !writeData);
                        }, self);
                    },
                    timeout: function() { callback.timeout(); },
                    error: function(e) { callback.error(e); }
                });
            }
        },

        /**
         * <p>Receive a message.</p>
         *
         * <p>If a message is received the stored master tokens, crypto contexts,
         * user ID tokens, and service tokens will be updated.</p>
         *
         * @param {ReceiveService|RespondService|RequestService} service calling service.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {InputStream} input remote entity input stream.
         * @param {MessageHeader} request message header of the previously sent message, if any,
         *        the received message is responding to. May be null.
         * @param {number} timeout read timeout in milliseconds.
         * @param {{result: function(MessageInputStream), timeout: function(), error: function(Error)}}
         *        callback the callback returned the received message, timeouts,
         *        or any thrown exceptions.
         * @throws MslEncodingException if there is an error parsing the message.
         * @throws MslCryptoException if there is an error decrypting or verifying
         *         the header or creating the message payload crypto context.
         * @throws MslEntityAuthException if unable to create the entity
         *         authentication data.
         * @throws MslUserAuthException if unable to create the user authentication
         *         data.
         * @throws MslMessageException if the message master token is expired and
         *         the message is not renewable.
         * @throws MslMasterTokenException if the master token is not trusted and
         *         needs to be.
         * @throws MslKeyExchangeException if there is an error with the key
         *         request data or key response data or the key exchange scheme is
         *         not supported.
         * @throws MslMessageException if the message master token is expired and
         *         the message is not renewable.
         * @throws MslException if the message does not contain an entity
         *         authentication data or a master token, or a token is improperly
         *         bound to another token, or there is an error updating the
         *         service tokens.
         * @throws InterruptedException if the thread is interrupted while trying
         *         to delete an old master token the received message is replacing.
         */
        receive: function receive(service, ctx, msgCtx, input, request, timeout, callback) {
            var self = this;
            InterruptibleExecutor(callback, function() {
                // Stop and throw an exception if aborted.
                if (service.isAborted())
                    throw new MslInterruptedException('receive aborted.');

                // Grab the response.
                var keyRequestData = [];
                if (request)
                    keyRequestData = request.keyRequestData.filter(function() { return true; });
                var cryptoContexts = msgCtx.getCryptoContexts();
                var is = (this._filterFactory) ? this._filterFactory.getInputStream(input) : input;
                MessageInputStream$create(ctx, is, MslConstants$DEFAULT_CHARSET, keyRequestData, cryptoContexts, timeout, {
                    result: function(response) {
                        // Register abort function.
                        service.setAbort(function() { response.abort(); });

                        // Wait until the input stream is ready.
                        response.isReady(timeout, {
                            result: function(ready) {
                                InterruptibleExecutor(callback, function() {
                                    // If aborted throw an exception.
                                    if (!ready)
                                        throw new MslInterruptedException('MessageInputStream aborted.');

                                    // Deliver the received header to the debug context.
                                    var responseHeader = response.getMessageHeader();
                                    var errorHeader = response.getErrorHeader();
                                    var debugCtx = msgCtx.getDebugContext();
                                    if (debugCtx) debugCtx.receivedHeader((responseHeader) ? responseHeader : errorHeader);

                                    // If there is a request, make sure the response message ID equals the
                                    // request message ID + 1.
                                    if (request) {
                                        // Only enforce this for message headers and error headers that are
                                        // not entity re-authentcate or entity data re-authenticate (as in
                                        // those cases the remote entity is not always able to extract the
                                        // request message ID).
                                        var errorCode = (errorHeader) ? errorHeader.errorCode : null;
                                        if (responseHeader ||
                                            (errorCode != MslConstants$ResponseCode.FAIL && errorCode != MslConstants$ResponseCode.TRANSIENT_FAILURE && errorCode != MslConstants$ResponseCode.ENTITY_REAUTH && errorCode != MslConstants$ResponseCode.ENTITYDATA_REAUTH))
                                        {
                                            var responseMessageId = (responseHeader) ? responseHeader.messageId : errorHeader.messageId;
                                            var expectedMessageId = MessageBuilder$incrementMessageId(request.messageId);
                                            if (responseMessageId != expectedMessageId)
                                                throw new MslMessageException(MslError.UNEXPECTED_RESPONSE_MESSAGE_ID, "expected " + expectedMessageId + "; received " + responseMessageId);
                                        }
                                    }

                                    // Process the response.
                                    ctx.getEntityAuthenticationData(null, {
                                        result: function(ead) {
                                            InterruptibleExecutor(callback, function() {
                                                var localIdentity = ead.getIdentity();
                                                var sender;
                                                if (responseHeader) {
                                                    // Reject messages if this is a trusted network server and the
                                                    // sender is not equal to the master token identity or if the
                                                    // sender is equal to this entity.
                                                    var entityAuthData = responseHeader.entityAuthenticationData;
                                                    var masterToken = responseHeader.masterToken;
                                                    sender = (masterToken) ? responseHeader.sender : entityAuthData.getIdentity();
                                                    if ((masterToken && masterToken.isDecrypted() && masterToken.identity != sender) ||
                                                        localIdentity == sender)
                                                    {
                                                        throw new MslMessageException(MslError.UNEXPECTED_MESSAGE_SENDER, sender);
                                                    }

                                                    // If there is a request update the stored crypto contexts.
                                                    if (request)
                                                        this.updateIncomingCryptoContexts(ctx, request, response);

                                                    // In trusted network mode the local tokens are the primary tokens.
                                                    // In peer-to-peer mode they are the peer tokens. The master token
                                                    // might be in the key response data.
                                                    var keyResponseData = responseHeader.keyResponseData;
                                                    var tokenVerificationMasterToken;
                                                    var userIdToken;
                                                    var serviceTokens;
                                                    if (!ctx.isPeerToPeer()) {
                                                        tokenVerificationMasterToken = (keyResponseData) ? keyResponseData.masterToken : responseHeader.masterToken;
                                                        userIdToken = responseHeader.userIdToken;
                                                        serviceTokens = responseHeader.serviceTokens;
                                                    } else {
                                                        tokenVerificationMasterToken = (keyResponseData) ? keyResponseData.masterToken : responseHeader.peerMasterToken;
                                                        userIdToken = responseHeader.peerUserIdToken;
                                                        serviceTokens = responseHeader.peerServiceTokens;
                                                    }

                                                    // Save any returned user ID token if the local entity is not the
                                                    // issuer of the user ID token.
                                                    var userId = msgCtx.getUserId();
                                                    if (userId && userIdToken && !userIdToken.isVerified())
                                                        ctx.getMslStore().addUserIdToken(userId, userIdToken);

                                                    // Update the stored service tokens.
                                                    this.storeServiceTokens(ctx, tokenVerificationMasterToken, userIdToken, serviceTokens);
                                                } else {
                                                    // Reject errors if the sender is equal to this entity.
                                                    sender = errorHeader.entityAuthenticationData.getIdentity();
                                                    if (localIdentity == sender)
                                                        throw new MslMessageException(MslError.UNEXPECTED_MESSAGE_SENDER, sender);
                                                }

                                                // Return the result.
                                                return response;
                                            }, self);
                                        },
                                        error: callback.error,
                                    });
                                }, self);
                            },
                            timeout: function() { callback.timeout(); },
                            error: function(e) { callback.error(e); }
                        });
                    },
                    timeout: function() { callback.timeout(); },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * <p>Send the provided request and optionally receive a response from the
         * remote entity. The method will attempt to receive a response if one of
         * the following is met:
         * <ul>
         * <li>the caller indicates a response is expected</li>
         * <li>application data could not be sent</li>
         * <li>if key request data appears in the request</li>
         * </ul></p>
         *
         * <p>This method is only used from trusted network clients and peer-to-
         * peer entities.</p>
         *
         * @param {ReceiveService|RespondService|RequestService} service the calling service.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {InputStream} input remote entity input stream.
         * @param {OutputStream} output remote entity output stream.
         * @param {MessageBuilder} builder request message builder.
         * @param {number} timeout renewal lock acquisition timeout in milliseconds.
         * @param {boolean} receive if a response is expected.
         * @param {{result: function(?SendReceiveResult), timeout: function(), error: function(Error)}}
         *        callback the callback will be given the received message or
         *        {@code null} if cancelled, notified of timeouts, or any
         *        thrown exceptions.
         * @throws IOException if there was an error reading or writing a
         *         message.
         * @throws MslEncodingException if there is an error parsing or encoding a
         *         message.
         * @throws MslCryptoException if there is an error encrypting/decrypting or
         *         signing/verifying a message header or creating the message
         *         payload crypto context.
         * @throws MslEntityAuthException if there is an error with the entity
         *         authentication data.
         * @throws MslUserAuthException if unable to create the user authentication
         *         data.
         * @throws MslMasterTokenException if the master token is not trusted and
         *         needs to be.
         * @throws MslKeyExchangeException if there is an error with the key
         *         request data or key response data or the key exchange scheme is
         *         not supported.
         * @throws MslMessageException if the message master token is expired and
         *         the message is not renewable, if there is an error building the
         *         request, or if the response message ID does not equal the
         *         expected value.
         * @throws MslException if the message does not contain an entity
         *         authentication data or a master token, or a token is improperly
         *         bound to another token, or there is an error updating the
         *         service tokens, or there was an error building the message
         *         header.
         * @throws InterruptedException if the thread is interrupted while trying
         *         to delete an old master token the received message is replacing.
         */
        sendReceive: function sendReceive(service, ctx, msgCtx, input, output, builder, timeout, receive, callback) {
            var self = this;
            // Attempt to acquire the renewal lock.
            InterruptibleExecutor(callback, function() {
                var renewalQueue = new BlockingQueue();
                this.acquireRenewalLock(service, ctx, msgCtx, renewalQueue, builder, timeout, {
                    result: function(renewing) {
                        sendrecv(renewalQueue, renewing);
                    },
                    timeout: function() { callback.timeout(); },
                    error: function(e) {
                        // This should only be if we were cancelled so return null.
                        if (e instanceof MslInterruptedException) {
                            callback.result(null);
                        } else {
                            callback.error(e);
                        }
                    }
                });
            }, self);

            // Send the request and receive the response.
            function sendrecv(renewalQueue, renewing) {
                InterruptibleExecutor(callback, function sendrecv_send() {
                    // Send the request.
                    builder.setRenewable(renewing);
                    this.send(service, ctx, msgCtx, output, builder, timeout, {
                        result: function(sent) {
                            InterruptibleExecutor(callback, function sendrecv_receive() {
                                // Receive the response if expected, or if we did not send
                                // application data or did send key request data.
                                var keyRequestData = sent.requestHeader.keyRequestData;
                                if (receive || sent.handshake || !keyRequestData.isEmpty()) {
                                    this.receive(service, ctx, msgCtx, input, sent.requestHeader, timeout, {
                                        result: function(response) {
                                            InterruptibleExecutor(callback, function() {
                                                // Release the renewal lock.
                                                if (renewing)
                                                    this.releaseRenewalLock(ctx, renewalQueue, response);

                                                // Return the response.
                                                return new SendReceiveResult(response, sent);
                                            }, self);
                                        },
                                        timeout: function() {
                                            InterruptibleExecutor(callback, function() {
                                                // Release the renewal lock.
                                                if (renewing)
                                                    this.releaseRenewalLock(ctx, renewalQueue, null);
                                                callback.timeout();
                                            }, self);
                                        },
                                        error: function(e) {
                                            InterruptibleExecutor(callback, function() {
                                                // Release the renewal lock.
                                                if (renewing)
                                                    this.releaseRenewalLock(ctx, renewalQueue, null);
                                                throw e;
                                            }, self);
                                        }
                                    });
                                } else {
                                    // Release the renewal lock.
                                    InterruptibleExecutor(callback, function() {
                                        var response = null;
                                        if (renewing)
                                            this.releaseRenewalLock(ctx, renewalQueue, response);

                                        // Return the response.
                                        return new SendReceiveResult(response, sent);
                                    }, self);
                                }
                            }, self);
                        },
                        timeout: function() {
                            InterruptibleExecutor(callback, function() {
                                // Release the renewal lock.
                                if (renewing)
                                    this.releaseRenewalLock(ctx, renewalQueue, null);
                                callback.timeout();
                            }, self);
                        },
                        error: function(e) {
                            // Release the renewal lock.
                            InterruptibleExecutor(callback, function() {
                                var response = null;
                                if (renewing)
                                    this.releaseRenewalLock(ctx, renewalQueue, response);
                                throw e;
                            }, self);
                        }
                    });
                }, self);
            }
        },

        /**
         * <p>Attempt to acquire the renewal lock if the message will need it using
         * the given blocking queue.</p>
         *
         * <p>If anti-replay is required then this method will block until the
         * renewal lock is acquired.</p>
         *
         * <p>If the message has already been marked renewable then this method
         * will block until the renewal lock is acquired or a renewing thread
         * delivers a new master token to this builder.</p>
         *
         * <p>If encryption is required but the builder will not be able to encrypt
         * the message payloads, or if integrity protection is required but the
         * builder will not be able to integrity protect the message payloads, or
         * if the builder's master token is expired, or if there is no user ID
         * token but the message is associated with a user and the builder will not
         * be able to encrypt and integrity protect the message header, then this
         * method will block until the renewal lock is acquired or a renewing
         * thread delivers a master token to this builder.</p>
         *
         * <p>If the message is requesting tokens in response but there is no
         * master token, or there is no user ID token but the message is associated
         * with a user, then this method will block until the renewal lock is
         * acquired or a renewing thread delivers a master token to this builder
         * and a user ID token is also available if the message is associated with
         * a user.</p>
         *
         *
         * <p>If there is no master token, or either the master token or the user
         * ID token is renewable, or there is no user ID token but the message is
         * associated with a user and the builder will be able to encrypt the
         * message header then this method will attempt to acquire the renewal
         * lock. If unable to do so, it returns null.</p>
         *
         * <p>If this method returns true, then the renewal lock must be released by
         * calling {@code releaseRenewalLock()}.</p>
         *
         * <p>This method is only used from trusted network clients and peer-to-
         * peer entities.</p>
         *
         * @param {ReceiveService|RespondService|RequestService} service the calling service.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {BlockingQueue} queue caller's blocking queue.
         * @param {MessageBuilder} builder message builder for message to be sent.
         * @param {number} timeout timeout in milliseconds for acquiring the renewal lock
         *        or receiving a master token.
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback will receive true if the renewal lock
         *        was acquired, false if the builder's message is now capable
         *        of encryption or the renewal lock is not needed, notified of
         *        timeouts and any thrown exceptions.
         * @throws MslInterruptedException if interrupted while waiting to acquire
         *         a master token from a renewing thread.
         * @see #releaseRenewalLock()
         */
        acquireRenewalLock: function acquireRenewalLock(service, ctx, msgCtx, queue, builder, timeout, callback) {
            var self = this;
            InterruptibleExecutor(callback, function() {
                var masterToken = builder.getMasterToken();
                var userIdToken = builder.getUserIdToken();
                var userId = msgCtx.getUserId();

                // If the application data needs to be encrypted and the builder will
                // not encrypt payloads, or the application data needs to be integrity
                // protected and the bulder will not integrity protect payloads, or if
                // the master token is expired, or if the message is to be sent with
                // user authentication data and the builder will not encrypt and
                // integrity protect the header, then we must either mark this message
                // as renewable to perform a handshake or get a master token from a
                // renewing thread.
                //
                // If the message has been marked renewable then we must either mark
                // this message as renewable or receive a new master token.
                //
                // If the message must be marked non-replayable and we do not have a
                // master token then we must mark this message as renewable to perform
                // a handshake or receive a new master token.
                if ((msgCtx.isEncrypted() && !builder.willEncryptPayloads()) ||
                    (msgCtx.isIntegrityProtected() && !builder.willIntegrityProtectPayloads()) ||
                    builder.isRenewable() ||
                    (!masterToken && msgCtx.isNonReplayable()) ||
                    (masterToken && masterToken.isExpired()) ||
                    (!userIdToken && userId && (!builder.willEncryptHeader() || !builder.willIntegrityProtectHeader())) ||
                    (msgCtx.isRequestingTokens() && (!masterToken || (userId && !userIdToken))))
                {
                    blockingAcquisition(masterToken, userIdToken, userId);
                } else {
                    tryAcquisition(masterToken, userIdToken);
                }
            }, self);

            function blockingAcquisition(masterToken, userIdToken, userId) {
                InterruptibleExecutor(callback, function() {
                    // Stop and throw an exception if aborted.
                    if (service.isAborted())
                        throw new MslInterruptedException('acquireRenewalLock aborted.');

                    // We do not have a master token or this message is non-
                    // replayable. Try to acquire the renewal lock on this MSL
                    // context so we can send a handshake message.
                    var ctxRenewingQueue = null;
                    for (var i = 0; i < this._renewingContexts.length; ++i) {
                        var ctxQueue = this._renewingContexts[i];
                        if (ctxQueue.ctx === ctx) {
                            ctxRenewingQueue = ctxQueue.queue;
                            break;
                        }
                    }

                    // If there is no one else already renewing then our queue has
                    // acquired the renewal lock.
                    if (!ctxRenewingQueue) {
                        this._renewingContexts.push({ctx: ctx, queue: queue});
                        return true;
                    }

                    // Otherwise we need to wait for a master token from the
                    // renewing request.
                    var previousMasterToken = masterToken;
                    var ticket = ctxRenewingQueue.poll(timeout, {
                        result: function(masterToken) {
                            InterruptibleExecutor(callback, function() {
                                // If aborted throw an exception.
                                if (masterToken === undefined)
                                    throw new MslInterruptedException('acquireRenewalLock aborted.');

                                // Put the same master token back on the renewing queue so
                                // anyone else waiting can also proceed.
                                ctxRenewingQueue.add(masterToken);

                                // If the renewing request did not acquire a master token or if
                                // the new master token is still expired then try again to
                                // acquire renewal ownership.
                                if (masterToken === NULL_MASTER_TOKEN || masterToken.isExpired()) {
                                    blockingAcquisition(masterToken, userIdToken, userId);
                                    return;
                                }

                                // The renewing request may have acquired a new user ID token.
                                // Attach it to this message if the message is associated with
                                // a user and we do not already have a user ID token.
                                //
                                // Unless the previous master token was thrown out, any user ID
                                // token should still be bound to this new master token. If the
                                // master token serial number has changed then our user ID
                                // token is no longer valid and the new one should be attached.
                                if ((userId && !userIdToken) ||
                                    (userIdToken && !userIdToken.isBoundTo(masterToken)))
                                {
                                    var storedUserIdToken = ctx.getMslStore().getUserIdToken(userId);
                                    userIdToken = (storedUserIdToken && storedUserIdToken.isBoundTo(masterToken)) ? storedUserIdToken : null;
                                }

                                // Update the message's master token and user ID token.
                                //
                                // FIXME: The master token lock has not been acquired. This is
                                // maybe bad.
                                builder.setAuthTokens(masterToken, userIdToken);

                                // If this message is already marked renewable and the received
                                // master token is the same as the previous master token then
                                // we must still attempt to acquire the renewal lock.
                                if (builder.isRenewable() && masterToken.equals(previousMasterToken)) {
                                    blockingAcquisition(masterToken, userIdToken, userId);
                                    return;
                                }

                                // If this message is requesting tokens and is associated with
                                // a user but there is no user ID token then we must still
                                // attempt to acquire the renewal lock.
                                if (msgCtx.isRequestingTokens() && !userIdToken) {
                                    blockingAcquisition(masterToken, userIdToken, userId);
                                    return;
                                }

                                // We may still want to renew, but it is not required. Fall
                                // through.
                                tryAcquisition(masterToken, userIdToken);
                            }, self);
                        },
                        timeout: function() {},
                        error: function(e) {}
                    });
                    service.setAbort(function() {
                        if (ticket) {
                            ctxRenewingQueue.cancel(ticket);
                            ticket = undefined;
                        }
                    });
                }, self);
            }

            function tryAcquisition(masterToken, userIdToken) {
                InterruptibleExecutor(callback, function() {
                    // Stop and throw an exception if aborted.
                    if (service.isAborted()) {
                        throw new MslInterruptedException('acquireRenewalLock aborted.');
                    }

                    // If we do not have a master token or the master token should be
                    // renewed, or we do not have a user ID token but the message is
                    // associated with a user, or if the user ID token should be renewed,
                    // then try to mark this message as renewable.
                    if ((!masterToken || masterToken.isRenewable()) ||
                        (!userIdToken && msgCtx.getUserId()) ||
                        (userIdToken && userIdToken.isRenewable()))
                    {
                        // Try to acquire the renewal lock on this MSL context.
                        var ctxRenewingQueue = null;
                        for (var i = 0; i < this._renewingContexts.length; ++i) {
                            var ctxQueue = this._renewingContexts[i];
                            if (ctxQueue.ctx === ctx) {
                                ctxRenewingQueue = ctxQueue.queue;
                                break;
                            }
                        }

                        // If there is no one else already renewing then our queue has
                        // acquired the renewal lock.
                        if (!ctxRenewingQueue) {
                            this._renewingContexts.push({ctx: ctx, queue: queue});
                            return true;
                        }

                        // Otherwise proceed without acquiring the lock.
                        return false;
                    }

                    // Otherwise we do not need to acquire the renewal lock.
                    return false;
                }, self);
            }
        },

        /**
         * <p>Release the renewal lock.</p>
         *
         * <p>Delivers any received master token to the blocking queue. This may be
         * a null value if an error message was received or if the received message
         * does not contain a master token for the local entity.</p>
         *
         * <p>If no message was received a null master token will be delivered.</p>
         *
         * <p>This method is only used from trusted network clients and peer-to-
         * peer entities.</p>
         *
         * @param {MslContext} ctx MSL context.
         * @param {BlockingQueue} queue caller's blocking queue.
         * @param {?MessageInputStream} message received message. May be null if no message was received.
         */
        releaseRenewalLock: function releaseRenewalLock(ctx, queue, message) {
            // Sanity check.
            var index;
            var ctxQueue;
            for (var i = 0; i < this._renewingContexts.length; ++i) {
                var q = this._renewingContexts[i];
                if (q.ctx === ctx) {
                    index = i;
                    ctxQueue = q.queue;
                    break;
                }
            }

            if (ctxQueue !== queue)
                throw new MslInternalException("Attempt to release renewal lock that is not owned by this queue.");

            // If no message was received then deliver a null master token, release
            // the lock, and return immediately.
            if (!message) {
                queue.add(NULL_MASTER_TOKEN);
                this._renewingContexts.splice(index, 1);
                return;
            }

            // If we received an error message then deliver a null master token,
            // release the lock, and return immediately.
            var messageHeader = message.messageHeader;
            if (!messageHeader) {
                queue.add(NULL_MASTER_TOKEN);
                this._renewingContexts.splice(index, 1);
                return;
            }

            // If we performed key exchange then the renewed master token should be
            // delivered.
            var keyResponseData = messageHeader.keyResponseData;
            if (keyResponseData) {
                queue.add(keyResponseData.masterToken);
            }

            // In trusted network mode deliver the header master token. This may be
            // null.
            else if (!ctx.isPeerToPeer()) {
                var masterToken = messageHeader.masterToken;
                if (masterToken)
                    queue.add(masterToken);
                else
                    queue.add(NULL_MASTER_TOKEN);
            }

            // In peer-to-peer mode deliver the peer master token. This may be
            // null.
            else {
                var masterToken = messageHeader.peerMasterToken;
                if (masterToken)
                    queue.add(masterToken);
                else
                    queue.add(NULL_MASTER_TOKEN);
            }

            // Release the lock.
            this._renewingContexts.splice(index, 1);
        }
    });

    MslControl = util.Class.create({
        /**
         * Create a new instance of MSL control.
         */
        init: function init() {
            // The properties.
            var props = {
                /** @type {MslControlImpl} */
                _impl: { value: new MslControlImpl(), writable: false, enumerable: false, configurable: false },
                /** True if shutdown. */
                _shutdown: { value: false, writable: false, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /**
         * Assigns a filter stream factory that will be used to filter any incoming
         * or outgoing messages. The filters will be placed between the MSL message
         * and MSL control, meaning they will see the actual MSL message data as it
         * is being read from or written to the remote entity.
         *
         * @param {FilterStreamFactory} factory filter stream factory. May be null.
         */
        setFilterFactory: function setFilterFactory(factory) {
            this._impl.setFilterFactory(factory);
        },

        /**
         * Gracefully shutdown the MSL control instance. No additional messages may
         * be processed. Any messages pending or in process will be completed.
         */
        shutdown: function shutdown() {
            this._shutdown = true;
        },

        /**
         * <p>Receive a request over the provided input stream.</p>
         *
         * <p>If there is an error with the message an error response will be sent
         * over the provided output stream.</p>
         *
         * <p>This method should only be used by trusted network servers and peer-
         * to-peer entities to receive a request initiated by the remote entity.
         * The remote entity should have used
         * {@link #request(MslContext, MessageContext, Url, MessageBuilder, int)}.<p>
         *
         * <p>The returned {@code Future} will return the received
         * {@code MessageInputStream} on completion or {@code null} if a reply was
         * automatically sent (for example in response to a handshake request) or
         * if the operation was cancelled or interrupted. The returned message may
         * be an error message if the maximum number of messages is hit without
         * successfully receiving the final message. It may throw a
         * {@code MslException}, {@code MslErrorResponseException}, or
         * {@code IOException}.</p>
         *
         * <p>The input and output streams will not be closed.</p>
         *
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {InputStream} input remote entity input stream.
         * @param {OutputStream} output remote entity output stream.
         * @param {number} timeout read/write and renewal lock acquisition
         *        timeout in milliseconds.
         * @param {{result: function(MessageInputStream), timeout: function(), error: function(Error)}}
         *        callback the callback that will be used for the operation.
         * @return {function()} a function which if called will cancel the
         *         operation.
         * @throws MslException immediately if called after having been shut
         *         down. This exception is not delivered to the callback.
         */
        receive: function receive(ctx, msgCtx, input, output, timeout, callback) {
            if (this._shutdown)
                throw new MslException('MslControl is shutdown.');
            var service = new ReceiveService(this._impl, ctx, msgCtx, input, output, timeout);
            setTimeout(function() { service.call(callback); }, 0);
            return CancellationFunction(service);
        },

        /**
         * <p>Send a response over the provided output stream. In peer-to-peer mode
         * we may need to receive a reply over the provided input stream.</p>
         *
         * <p>This method should only be used by trusted network servers and peer-
         * to-peer entities after receiving a request via
         * {@link #receive(MslContext, MessageContext, InputStream, OutputStream, int)}.
         * The remote entity should have used
         * {@link #request(MslContext, MessageContext, Url, MessageBuilder, int)}.</p>
         *
         * <p>The returned {@code Future} will return true on success or false if
         * cancelled, interrupted, or an error response was received (peer-to-peer
         * mode only), if the response could not be sent encrypted when encryption
         * is required (trusted network-mode only), or if the maximum number of
         * messages is hit without sending the message. It may throw a
         * {@code MslException}, {@code MslErrorResponseException}, or
         * {@code IOException}.</p>
         *
         * <p>The input and output streams will not be closed.</p>
         *
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {InputStream} input remote entity input stream.
         * @param {OutputStream} output remote entity output stream.
         * @param {MessageHeader} request request header to create the response from.
         * @param {number} timeout read/write and renewal lock acquisition
         *        timeout in milliseconds.
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback that will be used for the operation.
         * @return {function()} a function which if called will cancel the
         *         operation.
         * @throws MslException immediately if called after having been shut
         *         down. This exception is not delivered to the callback.
         */
        respond: function respond(ctx, msgCtx, input, output, request, timeout, callback) {
            if (this._shutdown)
                throw new MslException('MslControl is shutdown.');
            var service = new RespondService(this._impl, ctx, msgCtx, input, output, request, timeout);
            setTimeout(function() { service.call(callback); }, 0);
            return CancellationFunction(service);
        },

        /**
         * <p>Send an error response over the provided output stream. Any replies
         * to the error response may be received by a subsequent call to
         * {@link #receive(MslContext, MessageContext, InputStream, OutputStream, int)}.</p>
         *
         * <p>This method should only be used by trusted network servers and peer-
         * to-peer entities after receiving a request via
         * {@link #receive(MslContext, MessageContext, InputStream, OutputStream, int)}.
         * The remote entity should have used
         * {@link #request(MslContext, MessageContext, URL, MessageBuilder, int)}.</p>
         *
         * <p>The returned {@code Future} will return true on success or false if
         * cancelled or interrupted. It may throw a {@code MslException} or
         * {@code IOException}.</p>
         *
         * <p>The input and output streams will not be closed.</p>
         *
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {MslControl$ApplicationError} error error type.
         * @param {OutputStream} out remote entity output stream.
         * @param {MessageHeader} request request header to create the response from.
         * @param {number} timeout read/write timeout in milliseconds.
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback that will be used for the operation.
         * @return {function()} a function which if called will cancel the
         *         operation.
         * @throws MslException immediately if called after having been shut
         *         down. This exception is not delivered to the callback.
         */
        error: function error(ctx, msgCtx, error, out, request, timeout, callback) {
            if (this._shutdown)
                throw new MslException('MslControl is shutdown.');
            var service = new ErrorService(this._impl, ctx, msgCtx, error, out, request, timeout);
            setTimeout(function() { service.call(callback); }, 0);
            return CancellationFunction(service);
        },

        /**
         * <p>This method has two acceptable parameter lists.</p>
         *
         * <p>The first form accepts a remote entity URL and will send a
         * request to the remote entity at the provided URL. This form should
         * only be used by trusted network clients when initiating a new
         * request.</p>
         *
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {Url} remoteEntity remote entity URL.
         * @param {number} timeout connect, read/write, and renewal lock
         *        acquisition timeout in milliseconds.
         * @param {{result: function(MessageInputStream), timeout: function(), error: function(Error)}}
         *        callback the callback that will be used for the operation.
         * @return {function()} a function which if called will cancel the
         *         operation.
         * @throws MslInternalException if used in peer-to-peer mode.
         * @throws MslException immediately if called after having been shut
         *         down. This exception is not delivered to the callback.
         *
         * <p>The second form accepts an InputStream and OutputStream and will
         * send a request to the remote entity over the provided output stream
         * and receive a response over the provided input stream. This form
         * should only be used by peer-to-peer entities when initiating a new
         * request.</p>
         *
         * TODO once Java supports the WebSocket protocol we can remove this form
         * in favor of the one accepting a URL parameter.
         *
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {InputStream} input remote entity input stream.
         * @param {OutputStream} output remote entity output stream.
         * @param {number} timeout connect and read timeout in milliseconds.
         * @param {{result: function(MessageInputStream), timeout: function(), error: function(Error)}}
         *        callback the callback that will be used for the operation.
         * @return {function()} a function which if called will cancel the
         *         operation.
         * @throws MslInternalException if used in trusted network mode.
         * @throws MslException immediately if called after having been shut
         *         down. This exception is not delivered to the callback.
         *
         * <p>The remote entity should be using
         * {@link #receive(MslContext, MessageContext, InputStream, OutputStream, int)}
         * and
         * {@link #respond(MslContext, MessageContext, InputStream, OutputStream, MessageBuilder, int)}.</p>
         *
         * <p>The returned {@code Future} will return the response's
         * {@code MessageInputStream} on completion or {@code null} if cancelled or
         * interrupted. The returned message may be an error message if the maximum
         * number of messages is hit without successfully sending the request and
         * receiving the response. It may throw a {@code MslException} or
         * {@code IOException}.</p>
         */
        request: function request(ctx, msgCtx /* variable arguments */) {
            if (this._shutdown)
                throw new MslException('MslControl is shutdown.');

            var remoteEntity,
                input,
                output,
                timeout,
                callback;

            // Handle the first form.
            if (arguments.length == 5) {
                remoteEntity = arguments[2];
                input = null;
                output = null;
                timeout = arguments[3];
                callback = arguments[4];

                if (ctx.isPeerToPeer()) {
                    callback.error(new MslInternalException("This method cannot be used in peer-to-peer mode."));
                    return;
                }
            }

            // Handle the second form.
            else if (arguments.length == 6) {
                remoteEntity = null;
                input = arguments[2];
                output = arguments[3];
                timeout = arguments[4];
                callback = arguments[5];

                if (!ctx.isPeerToPeer()) {
                    callback.error(new MslInternalException("This method cannot be used in trusted network mode."));
                    return;
                }
            }

            // Malformed arguments are not explicitly handled, just as with any
            // other function.

            var service = new RequestService(this._impl, ctx, msgCtx, remoteEntity, input, output, null, 0, timeout);
            setTimeout(function() { service.call(callback); }, 0);
            return CancellationFunction(service);
        }
    });

    /**
     * Send an error response over the provided output stream.
     *
     * @param {ReceiveService|RespondService|ErrorService|RequestService} service the calling service.
     * @param {MslContext} ctx MSL context.
     * @param {?MessageDebugContext} debugCtx message debug context. May be null.
     * @param {number} messageId error response message ID.
     * @param {MslError} error MSL error.
     * @param {string} userMessage user-consumable error message. May be null.
     * @param {OutputStream} output remote entity output stream.
     * @param {number} timeout send timeout in milliseconds.
     * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
     *        callback the callback will receive true on success, be notified
     *        of timeout and any thrown exceptions.
     */
    function sendError(service, ctx, debugCtx, messageId, error, userMessage, output, timeout, callback) {
        MessageBuilder$createErrorResponse(ctx, messageId, error, userMessage, {
            result: function(errorHeader) {
                if (debugCtx) debugCtx.sentHeader(errorHeader);
                MessageOutputStream$create(ctx, output, MslConstants$DEFAULT_CHARSET, errorHeader, null, null, timeout, {
                    result: function(response) {
                        service.setAbort(function() { response.abort(); });
                        response.close(timeout, {
                            result: function(success) {
                                InterruptibleExecutor(callback, function() {
                                    // If aborted throw an exception.
                                    if (!success)
                                        throw new MslInterruptedException('sendError aborted.');
                                    return success;
                                });
                            },
                            timeout: function() { callback.timeout(); },
                            error: function(e) { callback.error(e); }

                        });
                    },
                    timeout: function() {},
                    error: function(e) { callback.error(e); }
                });
            },
            error: function(re) { callback.error(re); }
        });
    }

    /**
     * <p>This service receives a request from a remote entity, and either
     * returns the received message or automatically generates a reply (and
     * returns null).</p>
     *
     * <p>This class will only be used by trusted-network servers and peer-to-
     * peer servers.</p>
     */
    ReceiveService = util.Class.create({
        /**
         * Create a new message receive service.
         *
         * @param {MslControl} ctrl parent MSL control.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {InputStream} input remote entity input stream.
         * @param {OutputStream} output remote entity output stream.
         * @param {number} timeout read/write and renewal lock acquisition
         *        timeout in milliseconds.
         */
        init: function init(ctrl, ctx, msgCtx, input, output, timeout) {
            // The properties.
            var props = {
                _ctrl: { value: ctrl, writable: false, enumerable: false, configurable: false },
                _ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                _msgCtx: { value: msgCtx, writable: false, enumerable: false, configurable: false },
                _input: { value: input, writable: false, enumerable: false, configurable: false },
                _output: { value: output, writable: false, enumerable: false, configurable: false },
                _timeout: { value: timeout, writable: false, enumerable: false, configurable: false },
                _aborted: { value: false, writable: true, enumerable: false, configurable: false },
                _abortFunc: { value: undefined, writable: true, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return {boolean} true if the oepration has been aborted.
         */
        isAborted: function isAborted() {
            return this._aborted;
        },

        /**
         * Abort the operation. The service cannot be used after being aborted.
         */
        abort: function abort() {
            this._aborted = true;
            if (this._abortFunc)
                this._abortFunc.call(this);
        },

        /**
         * Set the abort function. This replaces any previous abort function.
         *
         * @param {?function()} func the abort function. Null to unset.
         */
        setAbort: function setAbort(func) {
            this._abortFunc = func;
        },

        /**
         * @param {{result: function(?MessageInputStream), timeout: function(), error: function(Error)}}
         *        callback the callback will be given the received message or
         *        {@code null} if cancelled, notified of timeout and any thrown
         *        exceptions.
         * @throws MslException if there was an error with the received message
         *         or an error creating an automatically generated response.
         * @throws MslErrorResponseException if there was an error sending an
         *         automatically generated error response.
         * @throws IOException if there was an error reading or writing a
         *         message.
         */
        call: function call(callback) {
            var self = this;

            // Read the incoming message.
            InterruptibleExecutor(callback, function() {
                this._ctrl.receive(this, this._ctx, this._msgCtx, this._input, null, this._timeout, {
                    result: function(request) { deliverMessage(request); },
                    timeout: function() { callback.timeout(); },
                    error: function(e) {
                        InterruptibleExecutor(callback, function() {
                            // If we were cancelled then return null.
                            if (cancelled(e)) return null;

                            // Try to send an error response.
                            var requestMessageId, mslError, userMessage, toThrow;
                            if (e instanceof MslException) {
                                requestMessageId = e.messageId;
                                mslError = e.error;
                                userMessage = this._ctrl.messageRegistry.getUserMessage(mslError, null);
                                toThrow = e;
                            } else {
                                requestMessageId = null;
                                mslError = MslError.INTERNAL_EXCEPTION;
                                userMessage = null;
                                toThrow = new MslInternalException("Error receiving the message header.", e);
                            }
                            sendError(this, this._ctx, this._msgCtx.getDebugContext(), requestMessageId, mslError, userMessage, this._output, this._timeout, {
                                result: function(success) { callback.error(toThrow); },
                                timeout: function() { callback.timeout(); },
                                error: function(re) {
                                    InterruptibleExecutor(callback, function() {
                                        // If we were cancelled then return null.
                                        if (cancelled(re)) return null;

                                        throw new MslErrorResponseException("Error receiving the message header.", re, e);
                                    }, self);
                                }
                            });
                        }, self);
                    }
                });
            }, self);

            function deliverMessage(request) {
                InterruptibleExecutor(callback, function() {
                    // Return error headers to the caller.
                    var requestHeader = request.messageHeader;
                    if (!requestHeader)
                        return request;

                    // If the message payload is not empty deliver the message to the
                    // caller.
                    this.setAbort(function() { request.abort(); });
                    request.mark(Number.MAX_VALUE);
                    request.read(1, self._timeout, {
                        result: function(data) {
                            InterruptibleExecutor(callback, function() {
                                // If aborted return null;
                                if (data && data.length == 0)
                                    return null;

                                // Message payload is not empty. Deliver it to
                                // the caller.
                                if (data) {
                                    request.reset();
                                    return request;
                                }

                                // Otherwise continue processing.
                                handshakeResponse(request);
                            }, self);
                        },
                        timeout: function() { callback.timeout(); },
                        error: function(e) {
                            InterruptibleExecutor(callback, function() {
                                // If we were cancelled then return null.
                                if (cancelled(e)) return null;

                                // We couldn't read, but maybe we can write an error response.
                                var requestMessageId = (requestHeader) ? requestHeader.messageId : null;
                                var mslError, toThrow;
                                if (e instanceof MslIoException) {
                                    mslError = MslError.MSL_COMMS_FAILURE;
                                    toThrow = e;
                                } else {
                                    mslError = MslError.INTERNAL_EXCEPTION;
                                    toThrow = new MslInternalException("Error peeking into the message payloads.");
                                }
                                sendError(this, this._ctx, this._msgCtx.getDebugContext(), requestMessageId, mslError, null, this._output, this._timeout, {
                                    result: function(success) { callback.error(toThrow); },
                                    timeout: function() { callback.timeout(); },
                                    error: function(re) {
                                        InterruptibleExecutor(callback, function() {
                                            // If we were cancelled then return null.
                                            if (cancelled(re)) return null;

                                            throw new MslErrorResponseException("Error peeking into the message payloads.", re, e);
                                        }, self);
                                    }
                                });
                            }, self);
                        }
                    });
                }, self);
            }

            function handshakeResponse(request) {
                InterruptibleExecutor(callback, function() {
                    // Close the request. We're done with it.
                    request.close();

                    // Since the message payload is empty, automatically return a
                    // response under the assumption the request is a handshake
                    // message.
                    //
                    // In peer-to-peer mode this will acquire the local entity's
                    // master token read lock.
                    this._ctrl.buildResponse(this, this._ctx, this._msgCtx, request.messageHeader, this._timeout, {
                        result: function(builderTokenTicket) {
                            InterruptibleExecutor(callback, function() {
                                var responseBuilder = builderTokenTicket.builder;
                                var tokenTicket = builderTokenTicket.tokenTicket;

                                // If we are in trusted network mode or if the original request was
                                // capable of encrypting its application data then no additional
                                // data is expected. Send the handshake response and return null.
                                var requestHeader = request.messageHeader;
                                var keyxMsgCtx = new KeyxResponseMessageContext(this._msgCtx);
                                if (!this._ctx.isPeerToPeer() ||
                                        requestHeader.isEncrypting() || requestHeader.keyResponseData)
                                {
                                    sendHandshake(requestHeader, responseBuilder, keyxMsgCtx, tokenTicket);
                                    return;
                                }

                                // We may receive another request after the key exchange completes.
                                // The received request may have peer authentication tokens for the
                                // local entity.
                                //
                                // The master token lock acquired from buildResponse() will be
                                // released when the service executes.
                                //
                                // We have received one message.
                                var service = new RequestService(this._ctrl, this._ctx, keyxMsgCtx, null, this._input, this._output, builderTokenTicket, 1, this._timeout);
                                // Set the abort function to abort the new service before executing
                                // the service.
                                this.setAbort(function() { service.abort(); });
                                service.call(callback);
                            }, self);
                        },
                        timeout: function() { callback.timeout(); },
                        error: function(e) {
                            InterruptibleExecutor(callback, function() {
                                // If we were cancelled then return null.
                                if (cancelled(e)) return null;

                                // Try to send an error response.
                                var requestMessageId, mslError, userMessage, toThrow;
                                if (e instanceof MslException) {
                                    requestMessageId = e.messageId;
                                    mslError = e.error;
                                    var caps = request.messageHeader.messageCapabilities;
                                    var languages = (caps) ? caps.languages : null;
                                    userMessage = this._ctrl.messageRegistry.getUserMessage(mslError, languages);
                                    toThrow = e;
                                } else {
                                    requestMessageId = (requestHeader) ? requestHeader.messageId : null;
                                    mslError = MslError.INTERNAL_EXCEPTION;
                                    userMessage = null;
                                    toThrow = new MslInternalException("Error creating an automatic handshake response.", e);
                                }
                                sendError(this, this._ctx, this._msgCtx.getDebugContext(), requestMessageId, mslError, userMessage, this._output, this._timeout, {
                                    result: function(success) { callback.error(toThrow); },
                                    timeout: function() { callback.timeout(); },
                                    error: function(re) {
                                        InterruptibleExecutor(callback, function() {
                                            // If we were cancelled then return null.
                                            if (cancelled(re)) return null;

                                            throw new MslErrorResponseException("Error creating an automatic handshake response.", re, e);
                                        }, self);
                                    }
                                });
                            }, self);
                        }
                    });
                }, self);
            }

            function sendHandshake(requestHeader, responseBuilder, keyxMsgCtx, tokenTicket) {
                InterruptibleExecutor(callback, function() {
                    responseBuilder.setRenewable(false);
                    this._ctrl.send(this._ctx, keyxMsgCtx, this._output, responseBuilder, this._timeout, {
                        result: function(sent) {
                            InterruptibleExecutor(callback, function() {
                                // Release the master token lock.
                                if (this._ctx.isPeerToPeer())
                                    this._ctrl.releaseMasterToken(tokenTicket);
                                return null;
                            }, self);
                        },
                        timeout: function() {
                            InterruptibleExecutor(callback, function() {
                                // Release the master token lock.
                                if (this._ctx.isPeerToPeer())
                                    this._ctrl.releaseMasterToken(tokenTicket);
                                callback.timeout();
                            }, self);
                        },
                        error: function(e) {
                            InterruptibleExecutor(callback, function() {
                                // Release the master token lock.
                                if (this._ctx.isPeerToPeer())
                                    this._ctrl.releaseMasterToken(tokenTicket);

                                // If we were cancelled then return null.
                                if (cancelled(e)) return null;

                                // Try to send an error response.
                                var requestMessageId, mslError, userMessage, toThrow;
                                if (e instanceof MslException) {
                                    requestMessageId = e.messageId;
                                    mslError = e.error;
                                    var caps = (requestHeader) ? requestHeader.messageCapabilities : null;
                                    var languages = (caps) ? caps.languages : null;
                                    userMessage = this._ctrl.messageRegistry.getUserMessage(mslError, languages);
                                    toThrow = e;
                                } else if (e instanceof MslIoException) {
                                    requestMessageId = (requestHeader) ? requestHeader.messageId : null;
                                    mslError = MslError.MSL_COMMS_FAILURE;
                                    userMessage = null;
                                    toThrow = e;
                                } else {
                                    requestMessageId = (requestHeader) ? requestHeader.messageId : null;
                                    mslError = MslError.INTERNAL_EXCEPTION;
                                    userMessage = null;
                                    toThrow = new MslInternalException("Error sending an automatic handshake response.", e);
                                }
                                sendError(this, this._ctx, this._msgCtx.getDebugContext(), requestMessageId, mslError, userMessage, this._output, this._timeout, {
                                    result: function(success) { callback.error(toThrow); },
                                    timeout: function() { callback.timeout(); },
                                    error: function(re) {
                                        InterruptibleExecutor(callback, function() {
                                            // If we were cancelled then return null.
                                            if (cancelled(re)) return null;

                                            throw new MslErrorResponseException("Error sending an automatic handshake response.", re, e);
                                        }, self);
                                    }
                                });
                            }, self);
                        }
                    });
                }, self);
            }
        }
    });

    /**
     * <p>This service sends a response to the remote entity.</p>
     *
     * <p>This class will only be used trusted network servers and peer-to-peer
     * servers.</p>
     */
    RespondService = util.Class.create({
        /**
         * Create a new message respond service.
         *
         * @param {MslControl} ctrl parent MSL control.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {InputStream} input remote entity input stream.
         * @param {OutputStream} output remote entity output stream.
         * @param {MessageHeader} request request message header.
         * @param {number} timeout read/write and renewal lock acquisition
         *        timeout in milliseconds.
         */
        init: function init(ctrl, ctx, msgCtx, input, output, request, timeout) {
            // The properties.
            var props = {
                _ctrl: { value: ctrl, writable: false, enumerable: false, configurable: false },
                _ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                _msgCtx: { value: msgCtx, writable: false, enumerable: false, configurable: false },
                _input: { value: input, writable: false, enumerable: false, configurable: false },
                _output: { value: output, writable: false, enumerable: false, configurable: false },
                _request: { value: request, writable: false, enumerable: false, configurable: false },
                _timeout: { value: timeout, writable: false, enumerable: false, configurable: false },
                _aborted: { value: false, writable: true, enumerable: false, configurable: false },
                _abortFunc: { value: undefined, writable: true, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return {boolean} true if the oepration has been aborted.
         */
        isAborted: function isAborted() {
            return this._aborted;
        },

        /**
         * Abort the operation. The service cannot be used after being aborted.
         */
        abort: function abort() {
            this._aborted = true;
            if (this._abortFunc)
                this._abortFunc.call(this);
        },

        /**
         * Set the abort function. This replaces any previous abort function.
         *
         * @param {?function()} func the abort function. Null to unset.
         */
        setAbort: function setAbort(func) {
            this._abortFunc = func;
        },

        /**
         * Send the response as a trusted network server.
         *
         * @param {MessageBuilder} builder response message builder.
         * @param {number} msgCount number of messages that have already been sent or
         *        received.
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback will receive true if the response was
         *        sent or false if it was cancelled, interrupted, could not be
         *        sent encrypted when encryption is required, or if the maximum
         *        message count is hit; notified of timeouts or any thrown
         *        exceptions.
         * @throws MslException if there was an error creating the response.
         * @throws MslErrorResponseException if there was an error sending an
         *         automatically generated error response.
         * @throws IOException if there was an error writing the message.
         */
        trustedNetworkExecute: function trustedNetworkExecute(builder, msgCount, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // Do nothing if we cannot send one more message.
                if (msgCount + 1 > MAX_MESSAGES)
                    return false;

                // If the response must be encrypted or integrity protected but
                // cannot then send an error requesting it. The client must re-
                // initiate the transaction.
                var securityRequired;
                if (this._msgCtx.isIntegrityProtected() && !builder.willIntegrityProtectHeader())
                    securityRequired = MslError.RESPONSE_REQUIRES_INTEGRITY_PROTECTION;
                else if (this._msgCtx.isEncrypted() && !builder.willEncryptPayloads())
                    securityRequired = MslError.RESPONSE_REQUIRES_ENCRYPTION;
                else
                    securityRequired = null;
                if (securityRequired) {
                    // Try to send an error response.
                    var requestMessageId = MessageBuilder$decrementMessageId(builder.getMessageId());
                    sendError(this, this._ctx, this._msgCtx.getDebugContext(), requestMessageId, securityRequired, null, this._output, this._timeout, {
                        result: function(success) { callback.result(false); },
                        timeout: function() { callback.timeout(); },
                        error: function(re) {
                            InterruptibleExecutor(callback, function() {
                                // If we were cancelled then return false.
                                if (cancelled(re)) return false;

                                throw new MslErrorResponseException("Response requires encryption or integrity protection but cannot be protected: " + securityRequired, re, null);
                            }, self);
                        }
                    });
                    return;
                }

                // If the response wishes to attach a user ID token but there is no
                // master token then send an error requesting the master token. The
                // client must re-initiate the transaction.
                if (this._msgCtx.getCustomer() && !builder.getMasterToken() && !builder.getKeyExchangeData()) {
                    // Try to send an error response.
                    var requestMessageId = MessageBuilder$decrementMessageId(builder.getMessageId());
                    sendError(this, this._ctx, this._msgCtx.getDebugContext(), requestMessageId, MslError.RESPONSE_REQUIRES_MASTERTOKEN, null, this._output, this._timeout, {
                        result: function(success) { callback.result(false); },
                        timeout: function() { callback.timeout(); },
                        error: function(re) {
                            InterruptibleExecutor(callback, function() {
                                // If we were cancelled then return false.
                                if (cancelled(re)) return false;

                                throw new MslErrorResponseException("Response wishes to attach a user ID token but there is no master token.", re, null);
                            }, self);
                        }
                    });
                    return;
                }

                // Otherwise simply send the response.
                builder.setRenewable(false);
                this._ctrl.send(this._ctx, this._msgCtx, this._output, builder, this._timeout, {
                    result: function(sent) { callback.result(true); },
                    timeout: function() { callback.timeout(); },
                    error: function(e) { callback.error(e); }
                });
            }, self);
        },

        /**
         * Send the response as a peer-to-peer entity.
         *
         * @param {MessageContext} msgCtx message context.
         * @param {MessageBuilder} builder response message builder.
         * @param {number} msgCount number of messages sent or received so far.
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback will receive true if the response was
         *        sent or false if cancelled, interrupted, or could not be sent
         *        encrypted when encryption is required; notified of timeout or
         *        any thrown exceptions.
         * @throws MslException if there was an error creating the response.
         * @throws MslErrorResponseException if there was an error sending an
         *         automatically generated error response.
         * @throws IOException if there was an error writing the message.
         * @throws InterruptedException if the thread is interrupted while
         *         trying to acquire the master token lock.
         */
        peerToPeerExecute: function peerToPeerExecute(msgCtx, builder, msgCount, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // Do nothing if we cannot send and receive two more messages.
                if (msgCount + 2 > MAX_MESSAGES)
                    return false;

                // If the response wishes to attach a user ID token but there is no
                // master token then send an error requesting the master token. The
                // client must re-initiate the transaction.
                if (msgCtx.getCustomer() != null && builder.getPeerMasterToken() == null && builder.getKeyExchangeData() == null) {
                    // Try to send an error response.
                    var requestMessageId = MessageBuilder$decrementMessageId(builder.getMessageId());
                    sendError(this, this._ctx, msgCtx.getDebugContext(), requestMessageId, MslError.RESPONSE_REQUIRES_MASTERTOKEN, null, this._output, this._timeout, {
                        result: function(success) { callback.result(false); },
                        timeout: function() { callback.timeout(); },
                        error: function(re) {
                            InterruptibleExecutor(callback, function() {
                                // If we were cancelled then return false.
                                if (cancelled(re)) return false;

                                throw new MslErrorResponseException("Response wishes to attach a user ID token but there is no master token.", re, null);
                            }, self);
                        }
                    });
                    return;
                }

                // Send the response. A reply is not expected, but may be received.
                // This adds two to our message count.
                this._ctrl.sendReceive(this._ctx, msgCtx, this._input, this._output, builder, this._timeout, false, {
                    result: function(result) {
                        InterruptibleExecutor(callback, function() {
                            var response = result.response;
                            msgCount += 2;

                            // If we did not receive a response then we're done.
                            if (!response)
                                return true;

                            // If the response is an error see if we can handle the error and
                            // retry.
                            var responseHeader = response.getMessageHeader();
                            if (!responseHeader) {
                                handleError(result);
                                return;
                            }

                            // Determine if there is any application data.
                            var payloads = result.payloads;
                            var appdata = payloads.length > 0 && payloads[0].data.length > 0;

                            // If we did perform a handshake and there is buffered application
                            // data re-send the message over the same connection.
                            if (result.handshake && appdata) {
                                readAll();
                                return;
                            }

                            // Otherwise we did send our application data (which may have been
                            // zero-length) so we do not need to re-send our message. The only
                            // reason we should have received this response then is because it
                            // returned key response data, which has already been processed.
                            // We're done.
                            return true;

                            // The response may have included payloads which should be
                            // ignored since the request is being resent. We must consume
                            // all of the payloads otherwise they will still be on the
                            // input stream.
                            function readAll() {
                                response.read(PAYLOAD_BUFFER_SIZE, self._timeout, {
                                    result: function(data) {
                                        InterruptibleExecutor(callback, function() {
                                            if (!data) resend();
                                            else readAll();
                                        }, self);
                                    },
                                    timeout: function() { callback.timeout(); },
                                    error: function(e) { callback.error(e); }
                                });
                            }

                            function resend() {
                                InterruptibleExecutor(callback, function() {
                                    var resendMsgCtx = new ResendMessageContext(result.payloads, msgCtx);
                                    this._ctrl.buildResponse(this, this._ctx, resendMsgCtx, responseHeader, this._timeout, {
                                        result: function(builderTokenTicket) {
                                            InterruptibleExecutor(callback, function() {
                                                var requestBuilder = builderTokenTicket.builder;
                                                var tokenTicket = builderTokenTicket.tokenTicket;

                                                this.peerToPeerExecute(resendMsgCtx, requestBuilder, msgCount, {
                                                    result: function(success) {
                                                        InterruptibleExecutor(callback, function() {
                                                            // Release the error message's master token read lock.
                                                            this._ctrl.releaseMasterToken(tokenTicket);
                                                            return success;
                                                        }, self);
                                                    },
                                                    timeout: function() {
                                                        InterruptibleExecutor(callback, function() {
                                                            // Release the error message's master token read lock.
                                                            this._ctrl.releaseMasterToken(tokenTicket);
                                                            callback.timeout();
                                                        }, self);
                                                    },
                                                    error: function(e) {
                                                        InterruptibleExecutor(callback, function() {
                                                            // Release the error message's master token read lock.
                                                            this._ctrl.releaseMasterToken(tokenTicket);
                                                            throw e;
                                                        }, self);
                                                    }
                                                });
                                            }, self);
                                        },
                                        timeout: function() { callback.timeout(); },
                                        error: function(e) { callback.error(e); }
                                    });
                                }, self);
                            }
                        }, self);
                    },
                    timeout: function() { callback.timeout(); },
                    error: function(e) { callback.error(e); }
                });
            }, self);

            function handleError(result) {
                InterruptibleExecutor(callback, function() {
                    // Close the response. We have everything we need.
                    var response = result.response;
                    response.close();

                    // Cleanup and build the error response. This will acquire the
                    // master token lock.
                    var errorHeader = response.getErrorHeader();
                    this._ctrl.cleanupContext(this._ctx, result.requestHeader, errorHeader);
                    this._ctrl.buildErrorResponse(this, this._ctx, msgCtx, result, errorHeader, {
                        result: function(errTokenTicket) {
                            InterruptibleExecutor(callback, function() {
                                // If there is no error response then return the error.
                                if (!errTokenTicket)
                                    return false;

                                var errMsg = errTokenTicket.errorResult;
                                var tokenTicket = errTokenTicket.tokenTicket;

                                // Send the error response. Recursively execute this because it
                                // may take multiple messages to succeed with sending the
                                // response.
                                var requestBuilder = errMsg.builder;
                                var resendMsgCtx = errMsg.msgCtx;
                                this.peerToPeerExecute(resendMsgCtx, requestBuilder, msgCount, {
                                    result: function(success) {
                                        InterruptibleExecutor(callback, function() {
                                            // Release the error message's master token read lock.
                                            this._ctrl.releaseMasterToken(tokenTicket);
                                            return success;
                                        }, self);
                                    },
                                    timeout: function() {
                                        InterruptibleExecutor(callback, function() {
                                            // Release the error message's master token read lock.
                                            this._ctrl.releaseMasterToken(tokenTicket);
                                            callback.timeout();
                                        }, self);
                                    },
                                    error: function(e) {
                                        InterruptibleExecutor(callback, function() {
                                            // Release the error message's master token read lock.
                                            this._ctrl.releaseMasterToken(tokenTicket);
                                            throw e;
                                        }, self);
                                    }
                                });
                            }, self);
                        }
                    });
                }, self);
            }
        },

        /**
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback will receive true on success or false
         *        if cancelled, interrupted, an error response was received
         *        (peer-to-peer mode only), or the response could not be sent
         *        encrypted when encryption is required (trusted network-mode
         *        only); notified of a timeout or any thrown exceptions.
         * @throws MslException if there was an error creating the response.
         * @throws MslErrorResponseException if there was an error sending an
         *         automatically generated error response.
         * @throws IOException if there was an error writing the message.
         */
        call: function call(callback) {
            var self = this;
            // In peer-to-peer mode this will acquire the local entity's
            // master token read lock.
            this._ctrl.buildResponse(this, this._ctx, this._msgCtx, this._request, this._timeout, {
                result: function(builderTokenTicket) {
                    InterruptibleExecutor(callback, function() {
                        var builder = builderTokenTicket.builder;
                        var tokenTicket = builderTokenTicket.tokenTicket;

                        // At most three messages would have been involved in the original
                        // receive.
                        if (!this._ctx.isPeerToPeer()) {
                            this.trustedNetworkExecute(builder, 3, {
                                result: function(success) {
                                    InterruptibleExecutor(callback, function() {
                                        // Release the master token lock.
                                        if (this._ctx.isPeerToPeer())
                                            this.releaseMasterToken(tokenTicket);

                                        return success;
                                    }, self);
                                },
                                timeout: function() {
                                    InterruptibleExecutor(callback, function() {
                                        // Release the master token lock.
                                        if (this._ctx.isPeerToPeer())
                                            this.releaseMasterToken(tokenTicket);
                                        callback.timeout();
                                    }, self);
                                },
                                error: function(e) {
                                    InterruptibleExecutor(callback, function() {
                                        // Release the master token lock.
                                        if (this._ctx.isPeerToPeer())
                                            this.releaseMasterToken(tokenTicket);

                                        // If we were cancelled then return false.
                                        if (cancelled(e)) return false;

                                        // Maybe we can send an error response.
                                        var requestMessageId = MessageBuilder$decrementMessageId(builder.getMessageId());
                                        var mslError, userMessage, toThrow;
                                        if (e instanceof MslException) {
                                            mslError = e.error;
                                            var caps = this._request.messageCapabilities;
                                            var languages = (caps) ? caps.languages : null;
                                            userMessage = this._ctrl.messageRegistry.getUserMessage(mslError, languages);
                                            toThrow = e;
                                        } else if (e instanceof MslIoException) {
                                            mslError = MslError.MSL_COMMS_FAILURE;
                                            userMessage = null;
                                            toThrow = e;
                                        } else {
                                            mslError = MslError.INTERNAL_EXCEPTION;
                                            userMessage = null;
                                            toThrow = new MslInternalException("Error sending the response.", e);
                                        }
                                        sendError(this, this._ctx, this._msgCtx.getDebugContext(), requestMessageId, mslError, userMessage, this._output, this._timeout, {
                                            result: function(success) { callback.error(toThrow); },
                                            timeout: function() { callback.timeout(); },
                                            error: function(re) {
                                                InterruptibleExecutor(callback, function() {
                                                    // If we were cancelled then return false.
                                                    if (cancelled(re)) return false;

                                                    throw new MslErrorResponseException("Error sending the response.", re, null);
                                                }, self);
                                            }
                                        });
                                    }, self);
                                }
                            });
                        } else {
                            this.peerToPeerExecute(this._msgCtx, builder, 3, {
                                result: function(success) {
                                    InterruptibleExecutor(callback, function() {
                                        // Release the master token lock.
                                        if (this._ctx.isPeerToPeer())
                                            this.releaseMasterToken(tokenTicket);

                                        return success;
                                    }, self);
                                },
                                timeout: function() {
                                    InterruptibleExecutor(callback, function() {
                                        // Release the master token lock.
                                        if (this._ctx.isPeerToPeer())
                                            this.releaseMasterToken(tokenTicket);
                                        callback.timeout();
                                    }, self);
                                },
                                error: function(e) {
                                    InterruptibleExecutor(callback, function() {
                                        // Release the master token lock.
                                        if (this._ctx.isPeerToPeer())
                                            this.releaseMasterToken(tokenTicket);

                                        // If we were cancelled then return false.
                                        if (cancelled(e)) return false;

                                        // Maybe we can send an error response.
                                        var requestMessageId = MessageBuilder$decrementMessageId(builder.getMessageId());
                                        var mslError, userMessage, toThrow;
                                        if (e instanceof MslException) {
                                            mslError = e.error;
                                            var caps = this._request.messageCapabilities;
                                            var languages = (caps) ? caps.languages : null;
                                            userMessage = this._ctrl.messageRegistry.getUserMessage(mslError, languages);
                                            toThrow = e;
                                        } else if (e instanceof MslIoException) {
                                            mslError = MslError.MSL_COMMS_FAILURE;
                                            userMessage = null;
                                            toThrow = e;
                                        } else {
                                            mslError = MslError.INTERNAL_EXCEPTION;
                                            userMessage = null;
                                            toThrow = new MslInternalException("Error sending the response.", e);
                                        }
                                        sendError(this, this._ctx, this._msgCtx.getDebugContext(), requestMessageId, mslError, userMessage, this._output, this._timeout, {
                                            result: function(success) { callback.error(toThrow); },
                                            timeout: function() { callback.timeout(); },
                                            error: function(re) {
                                                InterruptibleExecutor(callback, function() {
                                                    // If we were cancelled then return false.
                                                    if (cancelled(re)) return false;

                                                    throw new MslErrorResponseException("Error sending the response.", re, null);
                                                }, self);
                                            }
                                        });
                                    }, self);
                                }
                            });
                        }
                    }, self);
                },
                timeout: function() { callback.timeout(); },
                error: function(e) {
                    InterruptibleExecutor(callback, function() {
                        // If we were cancelled then return false.
                        if (cancelled(e)) return false;

                        // Try to send an error response.
                        var requestMessageId, mslError, userMessage, toThrow;
                        if (e instanceof MslException) {
                            requestMessageId = e.messageId;
                            mslError = e.error;
                            var caps = this._request.messageCapabilities;
                            var languages = (caps) ? caps.languages : null;
                            userMessage = this._ctrl.messageRegistry.getUserMessage(mslError, languages);
                            toThrow = e;
                        } else {
                            requestMessageId = null;
                            mslError = MslError.INTERNAL_EXCEPTION;
                            userMessage = null;
                            toThrow = new MslInternalException("Error building the response.", e);
                        }
                        sendError(this, this._ctx, this._msgCtx.getDebugContext(), requestMessageId, mslError, userMessage, this._output, this._timeout, {
                            result: function(success) { callback.error(toThrow); },
                            timeout: function() { callback.timeout(); },
                            error: function(re) {
                                InterruptibleExecutor(callback, function() {
                                    // If we were cancelled then return null.
                                    if (cancelled(re)) return null;

                                    throw new MslErrorResponseException("Error building the response.", re, e);
                                }, self);
                            }
                        });
                    }, self);
                }
            });
        }
    });

    /**
     * <p>This service sends an error response to the remote entity.</p>
     *
     * <p>This class will only be used trusted network servers and peer-to-peer
     * entities.</p>
     */
    ErrorService = util.Class.create({
        /**
         * Create a new error service.
         *
         * @param {MslControl} ctrl parent MSL control.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {MslControl$ApplicationError} error the application error.
         * @param {OutputStream} out remote entity output stream.
         * @param {MessageHeader} request request message header.
         * @param {number} timeout read/write timeout in milliseconds.
         */
        init: function init(ctrl, ctx, msgCtx, error, out, request, timeout) {
            // The properties.
            var props = {
                _ctrl: { value: ctrl, writable: false, enumerable: false, configurable: false },
                _ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                _msgCtx: { value: msgCtx, writable: false, enumerable: false, configurable: false },
                _appError: { value: error, writable: false, enumerable: false, configurable: false },
                _output: { value: output, writable: false, enumerable: false, configurable: false },
                _request: { value: request, writable: false, enumerable: false, configurable: false },
                _timeout: { value: timeout, writable: false, enumerable: false, configurable: false },
                _aborted: { value: false, writable: true, enumerable: false, configurable: false },
                _abortFunc: { value: undefined, writable: true, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return {boolean} true if the oepration has been aborted.
         */
        isAborted: function isAborted() {
            return this._aborted;
        },

        /**
         * Abort the operation. The service cannot be used after being aborted.
         */
        abort: function abort() {
            this._aborted = true;
            if (this._abortFunc)
                this._abortFunc.call(this);
        },

        /**
         * Set the abort function. This replaces any previous abort function.
         *
         * @param {?function()} func the abort function. Null to unset.
         */
        setAbort: function setAbort(func) {
            this._abortFunc = func;
        },

        /**
         * @param {{result: function(boolean), timeout: function(), error: function(Error)}}
         *        callback the callback will receive true on success or false
         *        if cancelled or interrupted and notified of a timeout or any
         *        thrown exceptions.
         * @throws MslException if there was an error creating the response.
         * @throws IOException if there was an error writing the message.
         */
        call: function call(callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // Identify the correct MSL error.
                var error;
                if (this._appError == ENTITY_REJECTED) {
                    error = (this._request.masterToken)
                        ? MslError.MASTERTOKEN_REJECTED_BY_APP
                        : MslError.ENTITY_REJECTED_BY_APP;
                } else if (this._appError == USER_REJECTED) {
                    error = (this._request.userIdToken)
                        ? MslError.USERIDTOKEN_REJECTED_BY_APP
                        : MslError.USER_REJECTED_BY_APP;
                } else {
                    throw new MslInternalException("Unhandled application error " + this._appError + ".");
                }

                // Build and send the error response.
                var caps = this._request.messageCapabilities;
                var languages = (caps) ? caps.languages : null;
                var userMessage = this._ctrl.messageRegistry.getUserMessage(error, languages);
                sendError(this, this._ctx, this._msgCtx.getDebugContext(), this._request.messageId, error, userMessage, this._output, this._timeout, {
                    result: function(success) { callback.result(success); },
                    timeout: callback.timeout,
                    error: function(e) {
                        InterruptibleExecutor(callback, function() {
                            // If we were cancelled then return false.
                            if (cancelled(e)) return false;

                            if (e instanceof MslException) {
                                // We failed to return an error response. Deliver the exception
                                // to the application.
                                throw e;
                            }

                            // An unexpected exception occurred.
                            throw new MslInternalException("Error building the error response.", e);
                        }, self);
                    }
                });
            }, self);
        },
    });

    /**
     * The null close handler is used to close output streams without caring if
     * the close operation is successful or not.
     *
     * TODO: Log failures/errors.
     */
    var NULL_CLOSE_HANDLER = {
        result: function() {},
        timeout: function() {},
        error: function() {}
    };

    /**
     * <p>This service sends a request to the remote entity and returns the
     * response.</p>
     *
     * <p>This class will only be used by trusted network clients, peer-to-peer
     * clients, and peer-to-peer servers.</p>
     */
    RequestService = util.Class.create({
        /**
         * Create a new message request service.
         *
         * @param {MslControl} ctrl parent MSL control.
         * @param {MslContext} ctx MSL context.
         * @param {MessageContext} msgCtx message context.
         * @param {?Url} remoteEntity remote entity URL.
         * @param {?InputStream} input remote entity input stream.
         * @param {?OutputStream} output remote entity output stream.
         * @param {?{builder: MessageBuilder, tokenTicket: ?TokenTicket}} builderTokenTicket request message builder.
         * @param {number} msgCount number of messages that have already been
         *        sent or received.
         * @param {number} timeout connect, read/write, and renewal lock
         *        acquisition timeout in milliseconds.
         */
        init: function init(ctrl, ctx, msgCtx, remoteEntity, input, output, builderTokenTicket, msgCount, timeout) {
            var builder, tokenTicket;
            if (builderTokenTicket) {
                builder = builderTokenTicket.builder;
                tokenTicket = builderTokenTicket.tokenTicket;
            } else {
                builder = null;
                tokenTicket = null;
            }

            // The properties.
            var props = {
                _ctrl: { value: ctrl, writable: false, enumerable: false, configurable: false },
                _ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                _msgCtx: { value: msgCtx, writable: false, enumerable: false, configurable: false },
                _remoteEntity: { value: remoteEntity, writable: false, enumerable: false, configurable: false },
                _input: { value: input, writable: true, enumerable: false, configurable: false },
                _output: { value: output, writable: true, enumerable: false, configurable: false },
                _openedStreams: { value: false, writable: true, enumerable: false, configurable: false },
                _builder: { value: builder, writable: true, enumerable: false, configurable: false },
                _tokenTicket: { value: tokenTicket, writable: true, enumerable: false, configurable: false },
                _timeout: { value: timeout, writable: false, enumerable: false, configurable: false },
                _msgCount: { value: msgCount, writable: false, enumerable: false, configurable: false },
                _aborted: { value: false, writable: true, enumerable: false, configurable: false },
                _abortFunc: { value: undefined, writable: true, enumerable: false, configurable: false }
            };
            Object.defineProperties(this, props);
        },

        /**
         * @return {boolean} true if the oepration has been aborted.
         */
        isAborted: function isAborted() {
            return this._aborted;
        },

        /**
         * Abort the operation. The service cannot be used after being aborted.
         */
        abort: function abort() {
            this._aborted = true;
            if (this._abortFunc)
                this._abortFunc.call(this);
        },

        /**
         * Set the abort function. This replaces any previous abort function.
         *
         * @param {?function()} func the abort function. Null to unset.
         */
        setAbort: function setAbort(func) {
            this._abortFunc = func;
        },

        /**
         * Send the provided request and receive a response from the remote
         * entity. Any necessary handshake messages will be sent.
         *
         * @param {MessageContext} msgCtx message context.
         * @param {MessageBuilder} builder request message builder.
         * @param {number} timeout renewal lock acquisition timeout in milliseconds.
         * @param {number} msgCount number of messages sent or received so far.
         * @param {{result: function(MessageInputStream), timeout: function(), error: function(Error)}}
         *        callback the callback will be given the received message or
         *        {@code null} if cancelled or if the maximum message count is
         *        hit; notified of timeout or any thrown exceptions.
         * @throws MslException if there was an error creating or processing
         *         a message.
         * @throws IOException if there was an error reading or writing a
         *         message.
         * @throws InterruptedException if the thread is interrupted while
         *         trying to acquire a master token's read lock.
         */
        execute: function execute(msgCtx, builder, timeout, msgCount, callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // Do not do anything if cannot send and receive two more messages.
                if (msgCount + 2 > MAX_MESSAGES)
                    return null;

                // Send the request and receive the response. This adds two to our
                // message count.

                this._ctrl.sendReceive(this, this._ctx, msgCtx, this._input, this._output, builder, timeout, true, {
                    result: function(result) {
                        InterruptibleExecutor(callback, function() {
                            if (!result)
                                return null;
                            var response = result.response;
                            msgCount += 2;

                            // If the response is an error see if we can handle the error and
                            // retry.
                            var responseHeader = response.getMessageHeader();
                            if (!responseHeader) {
                                handleError(result);
                            } else {
                                processResponse(result);
                            }
                        }, self);
                    },
                    timeout: function() { callback.timeout(); },
                    error: function(e) { callback.error(e); }
                });
            }, self);

            function handleError(result) {
                InterruptibleExecutor(callback, function() {
                    // Close the response. We have everything we need.
                    var response = result.response;
                    response.close();

                    // Cleanup and build the error response. This will acquire the
                    // master token lock.
                    var errorHeader = response.getErrorHeader();
                    this._ctrl.cleanupContext(this._ctx, result.requestHeader, errorHeader);
                    this._ctrl.buildErrorResponse(this, this._ctx, msgCtx, result, errorHeader, timeout, {
                        result: function(errTokenTicket) {
                            InterruptibleExecutor(callback, function() {
                                // If there is no error response then return the error.
                                if (!errTokenTicket)
                                    return response;

                                var errMsg = errTokenTicket.errorResult;
                                var tokenTicket = errTokenTicket.tokenTicket;

                                // In trusted network mode send the response in a new request.
                                // In peer-to-peer mode reuse the connection.
                                var requestBuilder = errMsg.builder;
                                var resendMsgCtx = errMsg.msgCtx;
                                if (!this._ctx.isPeerToPeer()) {
                                    // If we opened the streams, close them now since we're
                                    // going to issue a new request.
                                    if (this._openedStreams) {
                                        this._input.close();
                                        this._output.close(timeout, NULL_CLOSE_HANDLER);
                                    }

                                    // The master token lock acquired from buildErrorResponse()
                                    // will be released when the service executes.
                                    var builderTokenTicket = { builder: requestBuilder, tokenTicket: tokenTicket };
                                    var service = new RequestService(this._ctrl, this._ctx, resendMsgCtx, this._remoteEntity, null, null, builderTokenTicket, msgCount, this._timeout);
                                    // Set the abort function to abort the new service before executing
                                    // the service.
                                    this.setAbort(function() { service.abort(); });
                                    service.call({
                                        result: function(newResponse) { processErrorResponse(newResponse); },
                                        timeout: function() { callback.timeout(); },
                                        error: function(e) { callback.error(e); }
                                    });
                                } else {
                                    // Send the error response. Recursively execute this
                                    // because it may take multiple messages to succeed with
                                    // sending the request.
                                    this.execute(resendMsgCtx, requestBuilder, this._timeout, msgCount, {
                                        result: function(newResponse) {
                                            InterruptibleExecutor(callback, function() {
                                                // Release the error message's master token read lock.
                                                this._ctrl.releaseMasterToken(tokenTicket);

                                                processErrorResponse(newResponse);
                                            }, self);
                                        },
                                        timeout: function() {
                                            InterruptibleExecutor(callback, function() {
                                                // Release the error message's master token read lock.
                                                this._ctrl.releaseMasterToken(tokenTicket);

                                                callback.timeout();
                                            }, self);
                                        },
                                        error: function(e) {
                                            InterruptibleExecutor(callback, function() {
                                                // Release the error message's master token read lock.
                                                this._ctrl.releaseMasterToken(tokenTicket);

                                                callback.error(e);
                                            }, self);
                                        }
                                    });
                                }
                            }, self);
                        },
                        timeout: function() { callback.timeout(); },
                        error: function(e) { callback.error(e); }
                    });
                }, self);

                function processErrorResponse(newResponse) {
                    InterruptibleExecutor(callback, function() {
                        // If there is no new response, return the original error
                        // response.
                        var response = result.response;
                        if (!newResponse)
                            return response;

                        // Return the new response, which may be an error.
                        return newResponse;
                    }, self);
                }
            }

            function processResponse(result) {
                InterruptibleExecutor(callback, function() {
                    var response = result.response;
                    var responseHeader = response.getMessageHeader();

                    // Determine if there is any application data.
                    var payloads = result.payloads;
                    var appdata = payloads.length > 0 && payloads[0].data.length > 0;

                    // If we are in trusted network mode...
                    if (!this._ctx.isPeerToPeer()) {
                        // If we did not perform a handshake or there is no buffered
                        // application data then we're done. Deliver the response.
                        if (!result.handshake || !appdata)
                            return response;

                        // We did perform a handshake and there is buffered application
                        // data. Re-send the message over a new connection.
                        //
                        // If we opened the streams, close them now since we're
                        // going to issue a new request.
                        if (this._openedStreams) {
                            this._input.close();
                            this._output.close(timeout, NULL_CLOSE_HANDLER);
                        }

                        // The master token lock acquired from buildResponse() will be
                        // released when the service executes.
                        var resendMsgCtx = new ResendMessageContext(result.payloads, msgCtx);
                        this._ctrl.buildResponse(this, this._ctx, msgCtx, responseHeader, timeout, {
                            result: function(builderTokenTicket) {
                                InterruptibleExecutor(callback, function() {
                                    var service = new RequestService(this._ctrl, this._ctx, resendMsgCtx, this._remoteEntity, null, null, builderTokenTicket, msgCount, this._timeout);
                                    // Set the abort function to abort the new service before executing
                                    // the service.
                                    this.setAbort(function() { service.abort(); });
                                    service.call(callback);
                                }, self);
                            },
                            timeout: function() { callback.timeout(); },
                            error: function(e) { callback.error(e); }
                        });
                        return;
                    }

                    // If we did perform a handshake and there is buffered application
                    // data re-send the message over the same connection. This may also
                    // return key response data.
                    if (result.handshake && appdata) {
                        readAll();
                        return;
                    }

                    // The response may have included payload data which should be
                    // ignored since the request is being resent. We must consume
                    // all of the payloads otherwise they will still be on the
                    // input stream.
                    function readAll() {
                        response.read(PAYLOAD_BUFFER_SIZE, self._timeout, {
                            result: function(data) {
                                if (!data) resend();
                                else readAll();
                            },
                            timeout: function() { callback.timeout(); },
                            error: function(e) { callback.error(e); }
                        });
                    }

                    // Now resend.
                    function resend() {
                        InterruptibleExecutor(callback, function() {
                            var resendMsgCtx = new ResendMessageContext(result.payloads, msgCtx);
                            this._ctrl.buildResponse(this, this._ctx, msgCtx, responseHeader, timeout, {
                                result: function(builderTokenTicket) {
                                    InterruptibleExecutor(callback, function() {
                                        var requestBuilder = builderTokenTicket.builder;
                                        var tokenTicket = builderTokenTicket.tokenTicket;
                                        this.execute(resendMsgCtx, requestBuilder, this._timeout, msgCount, {
                                            result: function(response) {
                                                InterruptibleExecutor(callback, function() {
                                                    // Release the master token read lock.
                                                    this._ctrl.releaseMasterToken(tokenTicket);
                                                    return response;
                                                }, self);
                                            },
                                            timeout: function() {
                                                InterruptibleExecutor(callback, function() {
                                                    // Release the master token read lock.
                                                    this._ctrl.releaseMasterToken(tokenTicket);
                                                    callback.timeout();
                                                }, self);
                                            },
                                            error: function(e) {
                                                InterruptibleExecutor(callback, function() {
                                                    // Release the master token read lock.
                                                    this._ctrl.releaseMasterToken(tokenTicket);
                                                    throw e;
                                                }, self);
                                            }
                                        });
                                    }, self);
                                },
                                timeout: function() { callback.timeout(); },
                                error: function(e) { callback.error(e); }
                            });
                        }, self);
                    }

                    // Otherwise we did send our application data (which may have been
                    // zero-length) so we do not need to re-send our message.
                    //
                    // If the response contains key request data then we need to return
                    // a response to perform key exchange.
                    var responseKeyxData = responseHeader.keyRequestData;
                    if (responseKeyxData.length > 0) {
                        var keyxMsgCtx = new KeyxResponseMessageContext(msgCtx);
                        this._ctrl.buildResponse(this, this._ctx, keyxMsgCtx, responseHeader, timeout, {
                            result: function(builderTokenTicket) {
                                InterruptibleExecutor(callback, function() {
                                    var keyxBuilder = builderTokenTicket.builder;
                                    var tokenTicket = builderTokenTicket.tokenTicket;

                                    // If the response already contains application data then
                                    // we do not expect a reply. Return the received response
                                    // to the caller.
                                    response.mark();
                                    response.read(1, this._timeout, {
                                        result: function(data) {
                                            InterruptibleExecutor(callback, function() {
                                                if (data) {
                                                    response.reset();
                                                    // Only send the response if we have not hit the
                                                    // maximum number of messages.
                                                    if (msgCount + 1 <= MAX_MESSAGES) {
                                                        keyxBuilder.setRenewable(false);
                                                        this._ctrl.send(this, this._ctx, keyxMsgCtx, this._output, keyxBuilder, this._timeout, {
                                                            result: function(sent) {
                                                                InterruptibleExecutor(callback, function() {
                                                                    // Release the master token read lock.
                                                                    this.releaseMasterToken(tokenTicket);
                                                                    return response;
                                                                }, self);
                                                            },
                                                            timeout: function() { callback.timeout(); },
                                                            error: function(e) { callback.error(e); }
                                                        });
                                                    } else {
                                                        // Release the master token read lock.
                                                        this.releaseMasterToken(tokenTicket);
                                                        return response;
                                                    }
                                                }

                                                // Otherwise the remote entity may still have to send us the
                                                // application data in a reply.
                                                else {
                                                    readAll();
                                                    return;
                                                }

                                                // The response may have included payload data which should be
                                                // ignored since the request is being resent. We must consume
                                                // all of the payloads otherwise they will still be on the
                                                // input stream.
                                                function readAll() {
                                                    response.read(PAYLOAD_BUFFER_SIZE, self._timeout, {
                                                        result: function(data) {
                                                            if (!data) resend();
                                                            else readAll();
                                                        },
                                                        timeout: function() { callback.timeout(); },
                                                        error: function(e) { callback.error(e); }
                                                    });
                                                }

                                                function resend() {
                                                    self.execute(keyxMsgCtx, keyxBuilder, self._timeout, msgCount, {
                                                        result: function(newResponse) {
                                                            InterruptibleExecutor(callback, function() {
                                                                // Release the master token read lock.
                                                                this._ctrl.releaseMasterToken(tokenTicket);
                                                                return newResponse;
                                                            }, self);
                                                        },
                                                        timeout: function() {
                                                            InterruptibleExecutor(callback, function() {
                                                                // Release the master token read lock.
                                                                this._ctrl.releaseMasterToken(tokenTicket);
                                                                callback.timeout();
                                                            }, self);
                                                        },
                                                        error: function(e) {
                                                            InterruptibleExecutor(callback, function() {
                                                                // Release the master token read lock.
                                                                this._ctrl.releaseMasterToken(tokenTicket);
                                                                throw e;
                                                            }, self);
                                                        }
                                                    });
                                                }
                                            }, self);
                                        },
                                        timeout: function() {
                                            InterruptibleExecutor(callback, function() {
                                                // Release the master token read lock.
                                                this.releaseMasterToken(tokenTicket);
                                                callback.timeout();
                                            }, self);
                                        },
                                        error: function(e) {
                                            InterruptibleExecutor(callback, function() {
                                                // Release the master token read lock.
                                                this.releaseMasterToken(tokenTicket);
                                                throw e;
                                            }, self);
                                        }
                                    });
                                }, self);
                            },
                            timeout: function() { callback.timeout(); },
                            error: function(e) { callback.error(e); }
                        });
                        return;
                    }
                }, self);
            }
        },

        /**
         * @param {{result: function(MessageInputStream), timeout: function(), error: function(Error)}}
         *        callback the callback will be given the received message or
         *        {@code null} if cancelled, notified of timeout or any thrown
         *        exceptions.
         * @throws MslException if there was an error creating or processing
         *         a message.
         * @throws IOException if there was an error reading or writing a
         *         message.
         */
        call: function call(callback) {
            var self = this;

            InterruptibleExecutor(callback, function() {
                // If we do not already have a connection then establish one.
                var lockTimeout = this._timeout;
                if (!this._input || !this._output) {
                    try {
                        // Set up the connection.
                        this._remoteEntity.setTimeout(this._timeout);

                        // Grab the input and output streams. Keep track of how
                        // much time this takes to subtract that from the lock
                        // timeout.
                        var start = Date.now();
                        var conn = this._remoteEntity.openConnection();
                        this._output = conn.output;
                        this._input = conn.input;
                        if (lockTimeout != -1) {
                           lockTimeout = this._timeout - (Date.now() - start);
                        }
                        this._openedStreams = true;
                    } catch (e) {
                        // If a message builder was provided then release the
                        // master token read lock.
                        if (this._builder)
                            this._ctrl.releaseMasterToken(this._tokenTicket);

                        // Close any open streams.
                        if (this._output) this._output.close(this._timeout, NULL_CLOSE_HANDLER);
                        if (this._input) this._input.close();

                        // If we were cancelled then return null.
                        if (cancelled(e)) return null;
                        throw e;
                    }
                }

                // If no builder was provided then build a new request. This will
                // acquire the master token lock.
                if (!this._builder) {
                    this._ctrl.buildRequest(this, this._ctx, this._msgCtx, this._timeout, {
                        result: function(builderTokenTicket) {
                            InterruptibleExecutor(callback, function() {
                                var builder = builderTokenTicket.builder;
                                var tokenTicket = builderTokenTicket.tokenTicket;
                                perform(builder, tokenTicket, lockTimeout);
                            }, self);
                        },
                        timeout: function() {
                            InterruptibleExecutor(callback, function() {
                                // Close the streams if we opened them.
                                if (this._openedStreams) {
                                    this._output.close(this._timeout, NULL_CLOSE_HANDLER);
                                    this._input.close();
                                }
                                callback.timeout();
                            }, self);
                        },
                        error: function(e) {
                            InterruptibleExecutor(callback, function() {
                                // Close the streams if we opened them.
                                if (this._openedStreams) {
                                    this._output.close(this._timeout, NULL_CLOSE_HANDLER);
                                    this._input.close();
                                }

                                // If we were cancelled then return null.
                                if (cancelled(e)) return null;

                                throw e;
                            }, self);
                        }
                    });
                } else {
                    perform(this._builder, this._tokenTicket, lockTimeout);
                }
            }, self);

            function perform(builder, tokenTicket, lockTimeout) {
                InterruptibleExecutor(callback, function() {
                    this.execute(this._msgCtx, builder, lockTimeout, this._msgCount, {
                        result: function(response) {
                            InterruptibleExecutor(callback, function() {
                                // Release the master token read lock.
                                this._ctrl.releaseMasterToken(tokenTicket);

                                // Close the output stream if we opened it. (The input stream
                                // still needs to be consumed by the caller.)
                                if (this._openedStreams)
                                    this._output.close(lockTimeout, NULL_CLOSE_HANDLER);

                                // Closing the message input stream must close the underlying
                                // output stream if we opened it.
                                if (response)
                                    response.closeSource(this._openedStreams);
                                return response;
                            }, self);
                        },
                        timeout: function() {
                            InterruptibleExecutor(callback, function() {
                                // Release the master token read lock.
                                this._ctrl.releaseMasterToken(tokenTicket);

                                // Close the streams if we opened them.
                                if (this._openedStreams) {
                                    this._output.close(lockTimeout, NULL_CLOSE_HANDLER);
                                    this._input.close();
                                }
                                callback.timeout();
                            }, self);
                        },
                        error: function(e) {
                            InterruptibleExecutor(callback, function() {
                                // Release the master token read lock.
                                this._ctrl.releaseMasterToken(tokenTicket);

                                // Close the streams if we opened them.
                                if (this._openedStreams) {
                                    this._output.close(lockTimeout, NULL_CLOSE_HANDLER);
                                    this._input.close();
                                }

                                // If we were cancelled then return null.
                                if (cancelled(e)) return null;
                                throw e;
                            }, self);
                        }
                    });
                }, self);
            }
        }
    });
})();



// -- javascript/tokens/CustomerKey.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A customer key contains the Netflix customer ID MD5 hash value.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var CustomerKey;
var CustomerKey$parse;

(function() {
    /**
     * JSON key ID.
     * @const
     * @type {string}
     */
    var KEY_ID = "id";

    CustomerKey = util.Class.create({
        /**
         * Construct a new customer key with the given MD5 hash as the customer ID.
         *
         * @param {string} id MD5 hash identifying the customer.
         */
        init: function init(id) {
            // The properties.
            var props = {
                id: { value: id, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            var result = {};
            result[KEY_ID] = this.id;
            return result;
        },

        /**
         * @param {?} that the reference object with which to compare.
         * @return {boolean} true if the other object is a customer key with
         *         the same ID.
         * @see #uniqueKey()
         */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof CustomerKey)) return false;
            return this.id == that.id;
        },
        
        /**
         * @return {string} a string that uniquely identifies this customer
         *         key.
         * @see #equals(that)
         */
        uniqueKey: function uniqueKey() {
            return this.id;
        },
    });

    /**
     * Create a new customer key from the provided JSON representation.
     *
     * @param {Object} customerKeyJo JSON object representing customer key.
     * @return {CustomerKey} the customer key.
     * @throws MslEncodingException if there is an error parsing the customer
     *         key JSON object.
     */
    CustomerKey$parse = function CustomerKey$parse(customerKeyJo) {
        var id = customerKeyJo[KEY_ID];
        if (!id)
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, JSON.stringify(customerKeyJo));
        return new CustomerKey(id);
    };
})();



// -- javascript/tokens/TokenFactory.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * The token factory creates and renews master tokens and user ID tokens.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @interface
 */
var TokenFactory = util.Class.create({
    /**
     * Check if the master token sequence number is up-to-date.
     *
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken the master token to check.
     * @param {{result: function(boolean), error: function(Error)}} callback the
     *        callback will receive true if the master token sequence number is
     *        up-to-date and false if it is not, or any thrown exceptions.
     * @throws MslMasterTokenException if the master token is not trusted.
     * @throws MslException if there is an error checking the master token
     *         sequence number.
     */
    isNewestMasterToken: function(ctx, masterToken, callback) {},

    /**
     * <p>Return false if the master token has been revoked.</p>
     * 
     * <p>A master token may be revoked at any time after creation and before
     * renewal for various reasons, including but not limited to entity
     * revocation or knowledge that a master token or its session keys has been
     * compromised. The entity will be forced to re-authenticate if its master
     * token is rejected.</p>
     * 
     * <p>This method is slightly different than
     * {@link #isMasterTokenRenewable(MslContext, MasterToken)} because it
     * will be called for every received message and should not check the
     * renewability of the master token.</p>
     * 
     * <p>This method should return the exact {@link MslError} identifying the
     * reason the master token has been revoked.</p>
     * 
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken the master token to check.
     * @return {{result: function(MslError), error: function(Error)}} callback
     *        callback the callback functions that will receive {@code null} if
     *        the master token has not been revoked, a MSL error if it has, or
     *        or any thrown exceptions.
     * @throws MslMasterTokenException if the master token is not trusted.
     * @throws MslException if there is an error performing the revocation
     *         check.
     */
    isMasterTokenRevoked: function(ctx, masterToken) {},
    
    /**
     * <p>Return true if the non-replayable ID is larger by no more than 65536
     * than the largest non-replayable ID accepted so far for the provided
     * master token.</p>
     * 
     * <p>Non-replayable IDs should be tracked by the master token entity
     * identity and serial number. Before accepting any non-replayable IDs the
     * largest value accepted so far shall be considered zero. The maximum non-
     * replayable ID is equal to {@link MslConstants#MAX_LONG_VALUE} after
     * which the IDs wrap around to zero. The wrap around must be considered
     * when comparing the non-replayable ID to the largest non-replayable ID
     * accepted so far.</p>
     * 
     * <p>It is also permitted to accept non-replayable IDs less than the
     * largest non-replayable ID accepted so far if those non-replayable IDs
     * have not been seen. The set of smaller non-replayable IDs accepted
     * should be limited in size based on a reasonable expectation for the the
     * number of concurrent non-replayable messages the entity may create.</p>
     * 
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken the master token.
     * @param {number} nonReplayableId non-replayable ID.
     * @param {{result: function(boolean), error: function(Error)}} callback
     *        the callback that will receive true if the non-replayable ID has
     *        been accepted, false if it will not, or any thrown exceptions.
     * @throws MslMasterTokenException if the master token is not trusted.
     * @throws MslException if there is an error comparing or updating the non-
     *         replayable ID associated with this master token.
     * @see #createMasterToken(MslContext, String, CipherKey, CipherKey)
     */
    acceptNonReplayableId: function(ctx, masterToken, nonReplayableId, callback) {},
    
    /**
     * <p>Create a new master token with the specified identity and session
     * keys.</p>
     * 
     * <p>Creating a new master token implies all previous master tokens issued
     * to the specified entity are no longer valid and therefore all state data
     * for the non-replayable IDs associated with the entity identity may be
     * discarded.</p>
     * 
     * @param {MslContext} ctx MSL context.
     * @param {string} identity the singular identity this master token represents.
     * @param {CipherKey} encryptionKey the session encryption key.
     * @param {CipherKey} hmacKey the session HMAC key.
     * @param {{result: function(MasterToken), error: function(Error)}}
     *        callback the callback functions that will receive the new master
     *        token or any thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the token data.
     * @throws MslException if there is an error creating the master token.
     * @see #acceptNonReplayableId(MslContext, MasterToken, long)
     */
    createMasterToken: function(ctx, identity, encryptionKey, hmacKey, callback) {},

    /**
     * <p>Check if the master token would be renewed by a call to
     * {@link #renewMasterToken(MslContext, MasterToken, CipherKey, CipherKey)}.</p>
     * 
     * <p>This method should return the exact {@link MslError} identifying the
     * reason the master token will not be renewed.</p>
     * 
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken the master token to check.
     * @param {{result: function(?MslError), error: function(Error)}}
     *        callback the callback functions that will receive {@code null} if
     *        the master token would be renewed, a MSL error if it would not,
     *        or any thrown exceptions.
     * @throws MslMasterTokenException if the master token is not trusted.
     * @throws MslException if there is an error checking the master token
     *         renewability.
     * @see #renewMasterToken(MslContext, MasterToken, CipherKey, CipherKey)
     */
    isMasterTokenRenewable: function(ctx, masterToken, callback) {},
    
    /**
     * <p>Renew a master token assigning it the new session keys.</p>
     *
     * <p>This method should also perform any additional entity checks such as
     * if the entity has been revoked.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken the master token to renew.
     * @param {CipherKey} encryptionKey the session encryption key.
     * @param {CipherKey} hmacKey the session HMAC key.
     * @param {{result: function(MasterToken), error: function(Error)}}
     *        callback the callback functions that will receive the new master
     *        token or any thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the token data.
     * @throws MslMasterTokenException if the master token is not trusted or
     *         the factory does not wish to renew it.
     * @throws MslException if there is an error renewing the master token.
     * @see #isMasterTokenRenewable(MslContext, MasterToken)
     */
    renewMasterToken: function(ctx, masterToken, encryptionKey, hmacKey, callback) {},

    /**
     * <p>Return false if the user ID token has been revoked.</p>
     * 
     * <p>A user ID token may be revoked at any time after creation and before
     * renewal for various reasons, including but not limited to user deletion.
     * The user will be forced to re-authenticate if its user ID token is
     * rejected.</p>
     * 
     * <p>This method should return the exact {@link MslError} identifying the
     * reason the user ID token has been revoked.</p>
     * 
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken the associated master token.
     * @param {UserIdToken} userIdToken the user ID token to check.
     * @return {{result: function(MslError), error: function(Error)}} callback
     *        callback the callback functions that will receive {@code null} if
     *        the user ID token has not been revoked, a MSL error if it has, or
     *        or any thrown exceptions.
     * @throws MslMasterTokenException if the master token is not trusted.
     * @throws MslUserIdTokenException if the user ID token is not trusted.
     * @throws MslException if there is an error performing the revocation
     *         check.
     */
    isUserIdTokenRevoked: function(ctx, masterToken, userIdToken, callback) {},
    
    /**
     * Create a new user ID token bound to the provided master token.
     *
     * @param {MslContext} ctx MSL context.
     * @param {CustomerKey} customer Netflix customer.
     * @param {MasterToken} masterToken the master token to bind the user token against.
     * @param {{result: function(UserIdToken), error: function(Error)}}
     *        callback the callback functions that will receive the new user ID
     *        token or any thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the token data.
     * @throws MslMasterTokenException if the master token is not trusted.
     * @throws MslException if there is an error creating the user ID token.
     */
    createUserIdToken: function(ctx, customer, masterToken, callback) {},

    /**
     * <p>Renew a user ID token and bind it to the provided master token.</p>
     *
     * <p>This method should also perform any additional user checks such as if
     * the user no longer exists or must re-login.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {UserIdToken} userIdToken the user ID token to renew.
     * @param {MasterToken} masterToken the master token to bind the user token against.
     * @param {{result: function(UserIdToken), error: function(Error)}}
     *        callback the callback functions that will receive the new user ID
     *        token or any thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the token data.
     * @throws MslUserIdTokenException if the user ID token is not decrypted or
     *         the factory does not wish to renew it.
     * @throws MslMasterTokenException if the master token is not trusted.
     * @throws MslException if there is an error renewing the user ID token.
     */
    renewUserIdToken: function(ctx, userIdToken, masterToken, callback) {},
});



// -- javascript/tokens/MasterToken.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>The master token provides proof of remote entity identity. A MSL-specific
 * crypto context is used to encrypt the master token data and generate the
 * master token verification data. The remote entity cannot decrypt the master
 * token data or generate the master token verification data.</p>
 *
 * <p>The master token session keys will be used for MSL message encryption and
 * integrity protection. The use of these session keys implies the MSL message
 * identity as specified in the master token.</p>
 *
 * <p>Master tokens also contain a sequence number identifying the issue number
 * of the token. This is a monotonically increasing number that is incremented
 * by one each time a master token is renewed.</p>
 *
 * <p>When in possession of multiple master tokens, the token with the highest
 * sequence number should be considered the newest token. Since the sequence
 * number space is signed 53-bit numbers, if a sequence number is smaller by
 * more than 45-bits (e.g. the new sequence number is <= 128 and the old
 * sequence number is 2^53), it is considered the newest token.</p>
 *
 * <p>The renewal window indicates the time after which the master token will
 * be renewed if requested by the entity. The expiration is the time after
 * which the master token will be renewed no matter what.</p>
 *
 * <p>Master tokens also contain a serial number against which all other tokens
 * are bound. Changing the serial number when the master token is renewed
 * invalidates all of those tokens.</p>
 *
 * <p>The issuer identity identifies the issuer of this master token, which may
 * be useful to services that accept the master token.</p>
 *
 * <p>While there can be multiple versions of a master token, this class should
 * encapsulate support for all of those versions.</p>
 *
 * <p>Master tokens are represented as
 * {@code
 * mastertoken = {
 *   "#mandatory" : [ "tokendata", "signature" ],
 *   "tokendata" : "base64",
 *   "signature" : "base64"
 * }} where:
 * <ul>
 * <li>{@code tokendata} is the Base64-encoded master token data (mastertokendata)</li>
 * <li>{@code signature} is the Base64-encoded verification data of the master token data</li>
 * </ul></p>
 *
 * <p>The token data is represented as
 * {@code
 * mastertokendata = {
 *   "#mandatory" : [ "renewalwindow", "expiration", "sequencenumber", "serialnumber", "sessiondata" ],
 *   "renewalwindow" : "int64(0,-)",
 *   "expiration" : "int64(0,-)",
 *   "sequencenumber" : "int64(0,-)",
 *   "serialnumber" : "int64(0,-)",
 *   "sessiondata" : "base64"
 * }} where:
 * <ul>
 * <li>{@code renewalwindow} is when the renewal window opens in seconds since the epoch</li>
 * <li>{@code expiration} is the expiration timestamp in seconds since the epoch</li>
 * <li>{@code sequencenumber} is the master token sequence number</li>
 * <li>{@code serialnumber} is the master token serial number</li>
 * <li>{@code sessiondata} is the Base64-encoded encrypted session data (sessiondata)</li>
 * </ul></p>
 *
 * <p>The decrypted session data is represented as
 * {@code
 * sessiondata = {
 *   "#mandatory" : [ "identity", "encryptionkey", "hmackey" ],
 *   "issuerdata" : object,
 *   "identity" : "string",
 *   "encryptionkey" : "base64",
 *   "hmackey" : "base64"
 * }}
 * where:
 * <ul>
 * <li>{@code issuerdata} is the master token issuer data</li>
 * <li>{@code identity} is the identifier of the remote entity</li>
 * <li>{@code encryptionkey} is the Base64-encoded AES-128 encryption session key</li>
 * <li>{@code hmackey} is the Base64-encoded SHA-256 HMAC session key</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MasterToken;
var MasterToken$create;
var MasterToken$parse;

(function() {
    /**
     * Milliseconds per second.
     * @const
     * @type {number}
     */
    var MILLISECONDS_PER_SECOND = 1000;

    /**
     * JSON key token data.
     * @const
     * @type {string}
     */
    var KEY_TOKENDATA = "tokendata";
    /**
     * JSON key signature.
     * @const
     * @type {string}
     */
    var KEY_SIGNATURE = "signature";

    // tokendata
    /**
     * JSON key renewal window timestamp.
     * @const
     * @type {string}
     */
    var KEY_RENEWAL_WINDOW = "renewalwindow";
    /**
     * JSON key expiration timestamp.
     * @const
     * @type {string}
     */
    var KEY_EXPIRATION = "expiration";
    /**
     * JSON key sequence number.
     * @const
     * @type {string}
     */
    var KEY_SEQUENCE_NUMBER = "sequencenumber";
    /**
     * JSON key serial number.
     * @const
     * @type {string}
     */
    var KEY_SERIAL_NUMBER = "serialnumber";
    /**
     * JSON key session data.
     * @const
     * @type {string}
     */
    var KEY_SESSIONDATA = "sessiondata";

    // sessiondata
    /**
     * JSON key issuer data.
     * @const
     * @type {string}
     */
    var KEY_ISSUER_DATA = "issuerdata";
    /**
     * JSON key identity.
     * @const
     * @type {string}
     */
    var KEY_IDENTITY = "identity";
    /**
     * JSON key symmetric encryption key.
     * @const
     * @type {string}
     */
    var KEY_ENCRYPTION_KEY = "encryptionkey";
    /**
     * JSON key symmetric HMAC key.
     * @const
     * @type {string}
     */
    var KEY_HMAC_KEY = "hmackey";

    /**
     * Create a new session and token data container object.
     *
     * @param {Uint8Array} sessiondata raw session data. May be null.
     * @param {Uint8Array} tokendata raw token data.
     * @param {Uint8Array} signature raw signature.
     * @param {boolean} verified true if verified.
     * @constructor
     */
    function CreationData(sessiondata, tokendata, signature, verified) {
        this.sessiondata = sessiondata;
        this.tokendata = tokendata;
        this.signature = signature;
        this.verified = verified;
    };

    MasterToken = util.Class.create({
        /**
         * Create a new master token with the specified expiration, identity,
         * serial number, and encryption and HMAC keys.
         *
         * @param {MslContext} ctx MSL context.
         * @param {Date} renewalWindow the renewal window.
         * @param {Date} expiration the expiration.
         * @param {number} sequenceNumber the master token sequence number.
         * @param {number} serialNumber the master token serial number.
         * @param {Object} issuerData the issuer data. May be null.
         * @param {string} identity the singular identity this master token represents.
         * @param {CipherKey} encryptionKey the session encryption key.
         * @param {CipherKey} hmacKey the session HMAC key.
         * @param {?CreationData} creationData optional creation data.
         * @param {{result: function(MasterToken), error: function(Error)}}
         *        callback the callback functions that will receive the master token
         *        or any thrown exceptions.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the token data.
         * @constructor
         */
        init: function init(ctx, renewalWindow, expiration, sequenceNumber, serialNumber, issuerData, identity, encryptionKey, hmacKey, creationData, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // The expiration must appear after the renewal window.
                if (expiration.getTime() < renewalWindow.getTime())
                    throw new MslInternalException("Cannot construct a master token that expires before its renewal window opens.");
                // The sequence number and serial number must be within range.
                if (sequenceNumber < 0 || sequenceNumber > MslConstants$MAX_LONG_VALUE)
                    throw new MslInternalException("Sequence number " + sequenceNumber + " is outside the valid range.");
                if (serialNumber < 0 || serialNumber > MslConstants$MAX_LONG_VALUE)
                    throw new MslInternalException("Serial number " + serialNumber + " is outside the valid range.");

                // Renewal window and expiration are in seconds, not milliseconds.
                var renewalWindowSeconds = Math.floor(renewalWindow.getTime() / MILLISECONDS_PER_SECOND);
                var expirationSeconds = Math.floor(expiration.getTime() / MILLISECONDS_PER_SECOND);

                // Construct the session data.
                var sessiondata;
                if (!creationData) {
                    var sessionDataJO = {};
                    if (issuerData)
                        sessionDataJO[KEY_ISSUER_DATA] = issuerData;
                    sessionDataJO[KEY_IDENTITY] = identity;
                    sessionDataJO[KEY_ENCRYPTION_KEY] = base64$encode(encryptionKey.toByteArray());
                    sessionDataJO[KEY_HMAC_KEY] = base64$encode(hmacKey.toByteArray());
                    sessiondata = textEncoding$getBytes(JSON.stringify(sessionDataJO), MslConstants$DEFAULT_CHARSET);
                } else {
                    sessiondata = creationData.sessiondata;
                }

                // Construct the token data.
                if (!creationData) {
                    // Encrypt the session data.
                    var cryptoContext = ctx.getMslCryptoContext();
                    cryptoContext.encrypt(sessiondata, {
                        result: function(ciphertext) {
                            AsyncExecutor(callback, function() {
                                // Construct the token data.
                                var tokenDataJO = {};
                                tokenDataJO[KEY_RENEWAL_WINDOW] = renewalWindowSeconds;
                                tokenDataJO[KEY_EXPIRATION] = expirationSeconds;
                                tokenDataJO[KEY_SEQUENCE_NUMBER] = sequenceNumber;
                                tokenDataJO[KEY_SERIAL_NUMBER] = serialNumber;
                                tokenDataJO[KEY_SESSIONDATA] = base64$encode(ciphertext);
                                var tokendata = textEncoding$getBytes(JSON.stringify(tokenDataJO), MslConstants$DEFAULT_CHARSET);

                                // Sign the token data.
                                cryptoContext.sign(tokendata, {
                                    result: function(signature) {
                                        AsyncExecutor(callback, function() {
                                            var verified = true;

                                            // The properties.
                                            var props = {
                                                ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                                                renewalWindowSeconds: { value: renewalWindowSeconds, writable: false, enumerable: false, configurable: false },
                                                expirationSeconds: { value: expirationSeconds, writable: false, enumerable: false, configurable: false },
                                                sequenceNumber: { value: sequenceNumber, writable: false, enumerable: false, configurable: false },
                                                serialNumber: { value: serialNumber, writable: false, enumerable: false, configurable: false },
                                                issuerData: { value: issuerData, writable: false, configurable: false },
                                                identity: { value: identity, writable: false, configurable: false },
                                                encryptionKey: { value: encryptionKey, writable: false, configurable: false },
                                                hmacKey: { value: hmacKey, writable: false, configurable: false },
                                                sessiondata: { value: sessiondata, writable: false, enumerable: false, configurable: false },
                                                verified: { value: verified, writable: false, enumerable: false, configurable: false },
                                                tokendata: { value: tokendata, writable: false, enumerable: false, configurable: false },
                                                signature: { value: signature, writable: false, enumerable: false, configurable: false }
                                            };
                                            Object.defineProperties(this, props);
                                            return this;
                                        }, self);
                                    },
                                    error: function(err) { callback.error(err); },
                                });
                            }, self);
                        },
                        error: function(err) { callback.error(err); },
                    });
                } else {
                    var tokendata = creationData.tokendata;
                    var signature = creationData.signature;
                    var verified = creationData.verified;

                    // The properties.
                    var props = {
                        ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                        renewalWindowSeconds: { value: renewalWindowSeconds, writable: false, enumerable: false, configurable: false },
                        expirationSeconds: { value: expirationSeconds, writable: false, enumerable: false, configurable: false },
                        sequenceNumber: { value: sequenceNumber, writable: false, configurable: false },
                        serialNumber: { value: serialNumber, writable: false, configurable: false },
                        issuerData: { value: issuerData, writable: false, configurable: false },
                        identity: { value: identity, writable: false, configurable: false },
                        encryptionKey: { value: encryptionKey, writable: false, configurable: false },
                        hmacKey: { value: hmacKey, writable: false, configurable: false },
                        sessiondata: { value: sessiondata, writable: false, enumerable: false, configurable: false },
                        verified: { value: verified, writable: false, enumerable: false, configurable: false },
                        tokendata: { value: tokendata, writable: false, enumerable: false, configurable: false },
                        signature: { value: signature, writable: false, enumerable: false, configurable: false }
                    };
                    Object.defineProperties(this, props);
                    return this;
                }
            }, this);
        },

        /**
        * @return {Date} gets the renewal window.
        */
        get renewalWindow() {
            return new Date(this.renewalWindowSeconds * MILLISECONDS_PER_SECOND);
        },

        /**
        * @return {Date} gets the expiration.
        */
        get expiration() {
            return new Date(this.expirationSeconds * MILLISECONDS_PER_SECOND);
        },

        /**
         * @return {boolean} true if the decrypted content is available. (Implies verified.)
         */
        isDecrypted: function isDecrypted() {
            return (this.sessiondata) ? true : false;
        },

        /**
         * @return {boolean} true if the token has been verified.
         */
        isVerified: function isVerified() {
            return this.verified;
        },

        /**
         * Always returns true if this token was issued by a different entity
         * because we cannot know if the local entity time is correct.
         *
         * If this token was issued by the local entity then we assume its
         * clock at that time is in sync with the clock now.
         *
         * @return {boolean} true if the renewal window has been entered.
         */
        isRenewable: function isRenewable(ctx) {
            if (!this.isVerified())
                return true;
            return this.renewalWindow.getTime() <= this.ctx.getTime();
        },

        /**
         * Always returns false if this token was issued by a different entity
         * because we cannot know if the local entity time is correct.
         *
         * If this token was issued by the local entity then we assume its
         * clock at that time is in sync with the clock now.
         *
         * @return {boolean} true if expired.
         */
        isExpired: function isExpired(ctx) {
            if (!this.isVerified())
                return false;
            return this.expiration.getTime() <= this.ctx.getTime();
        },

        /**
         * <p>A master token is considered newer if its sequence number is greater
         * than another master token. If both the sequence numbers are equal, then
         * the master token with the later expiration date is considered newer.</p>
         * 
         * <p>Serial numbers are not taken into consideration when comparing which
         * master token is newer because serial numbers will change when new master
         * tokens are created as opposed to renewed. The caller of this function
         * should already be comparing master tokens that can be used
         * interchangeably (i.e. for the same MSL network).</p>
         *
         * @param {MasterToken} that the master token to compare with.
         * @return {boolean} true if this master token is newer than the provided one.
         */
        isNewerThan: function isNewerThan(that) {
            // If the sequence numbers are equal then compare the expiration dates.
            if (this.sequenceNumber == that.sequenceNumber)
                return this.expiration > that.expiration;

            // If this sequence number is bigger than that sequence number, make
            // sure that sequence number is not less than the cutoff.
            if (this.sequenceNumber > that.sequenceNumber) {
                var cutoff = this.sequenceNumber - MslConstants$MAX_LONG_VALUE + 127;
                return that.sequenceNumber >= cutoff;
            }

            // If this sequence number is smaller than that sequence number, make
            // sure this sequence number is less than the cutoff.
            var cutoff = that.sequenceNumber - MslConstants$MAX_LONG_VALUE + 127;
            return this.sequenceNumber < cutoff;
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            var jsonObj = {};
            jsonObj[KEY_TOKENDATA] = base64$encode(this.tokendata);
            jsonObj[KEY_SIGNATURE] = base64$encode(this.signature);
            return jsonObj;
        },

        /**
         * @param {?} that the reference object with which to compare.
         * @return {boolean} true if the other object is a master token with the same
         *         serial number and sequence number.
         * @see #uniqueKey()
         */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof MasterToken)) return false;
            return this.serialNumber == that.serialNumber &&
                this.sequenceNumber == that.sequenceNumber &&
                this.expiration.getTime() == that.expiration.getTime();
        },

        /**
         * @return {string} a string that uniquely identifies this master token.
         * @see #equals(that)
         */
        uniqueKey: function uniqueKey() {
            return this.serialNumber + ':' + this.sequenceNumber + this.expiration.getTime();
        },
    });

    /**
     * Create a new master token with the specified expiration, identity,
     * serial number, and encryption and HMAC keys.
     *
     * @param {MslContext} ctx MSL context.
     * @param {Date} renewalWindow the renewal window.
     * @param {Date} expiration the expiration.
     * @param {number} sequenceNumber the master token sequence number.
     * @param {number} serialNumber the master token serial number.
     * @param {Object} issuerData the issuer data. May be null.
     * @param {string} identity the singular identity this master token represents.
     * @param {CipherKey} encryptionKey the session encryption key.
     * @param {CipherKey} hmacKey the session HMAC key.
     * @param {CreationData} creationData optional creation data.
     * @param {{result: function(MasterToken), error: function(Error)}}
     *        callback the callback functions that will receive the master token
     *        or any thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the token data.
     */
    MasterToken$create = function MasterToken$create(ctx, renewalWindow, expiration, sequenceNumber, serialNumber, issuerData, identity, encryptionKey, hmacKey, callback) {
        new MasterToken(ctx, renewalWindow, expiration, sequenceNumber, serialNumber, issuerData, identity, encryptionKey, hmacKey, null, callback);
    };

    /**
     * Create a new master token from the provided JSON.
     *
     * @param {MslContext} ctx MSL context.
     * @param {Object} masterTokenJO master token JSON object.
     * @param {{result: function(MasterToken), error: function(Error)}}
     *        callback the callback functions that will receive the master token
     *        or any thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException if there is an error verifying the token data
     *         or extracting the session keys.
     * @throws MslException if the expiration timestamp occurs before the
     *         renewal window, or the sequence number is out of range, or the
     *         serial number is out of range, or the token data or signature is
     *         invalid.
     */
    MasterToken$parse = function MasterToken$parse(ctx, masterTokenJO, callback) {
        AsyncExecutor(callback, function() {
            // Grab the crypto context.
            var cryptoContext = ctx.getMslCryptoContext();

            // Verify the JSON representation.
            var tokendataB64 = masterTokenJO[KEY_TOKENDATA];
            var signatureB64 = masterTokenJO[KEY_SIGNATURE];
            if (typeof tokendataB64 !== 'string' || typeof signatureB64 !== 'string')
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "mastertoken " + JSON.stringify(masterTokenJO));
            var tokendata, signature;
            try {
                tokendata = base64$decode(tokendataB64);
            } catch (e) {
                throw new MslException(MslError.MASTERTOKEN_TOKENDATA_INVALID, "mastertoken " + JSON.stringify(masterTokenJO), e);
            }
            if (!tokendata || tokendata.length == 0)
                throw new MslEncodingException(MslError.MASTERTOKEN_TOKENDATA_MISSING, "mastertoken " + JSON.stringify(masterTokenJO));
            try {
                signature = base64$decode(signatureB64);
            } catch (e) {
                throw new MslException(MslError.MASTERTOKEN_SIGNATURE_INVALID, "mastertoken " + JSON.stringify(masterTokenJO), e);
            }
            cryptoContext.verify(tokendata, signature, {
                result: function(verified) {
                    AsyncExecutor(callback, function() {
                        // Pull the token data.
                        var renewalWindowSeconds, expirationSeconds, sequenceNumber, serialNumber, ciphertextB64;
                        var tokenDataJson = textEncoding$getString(tokendata, MslConstants$DEFAULT_CHARSET);
                        try {
                            var tokenDataJO = JSON.parse(tokenDataJson);
                            renewalWindowSeconds = parseInt(tokenDataJO[KEY_RENEWAL_WINDOW]);
                            expirationSeconds = parseInt(tokenDataJO[KEY_EXPIRATION]);
                            sequenceNumber = parseInt(tokenDataJO[KEY_SEQUENCE_NUMBER]);
                            serialNumber = parseInt(tokenDataJO[KEY_SERIAL_NUMBER]);
                            ciphertextB64 = tokenDataJO[KEY_SESSIONDATA];
                        } catch (e) {
                            if (e instanceof SyntaxError)
                                throw new MslEncodingException(MslError.MASTERTOKEN_TOKENDATA_PARSE_ERROR, "mastertokendata " + tokenDataJson, e);
                            throw e;
                        }

                        // Verify token data.
                        if (!renewalWindowSeconds || renewalWindowSeconds != renewalWindowSeconds ||
                            !expirationSeconds || expirationSeconds != expirationSeconds ||
                            typeof sequenceNumber !== 'number' || sequenceNumber != sequenceNumber ||
                            typeof serialNumber !== 'number' || serialNumber != serialNumber ||
                            typeof ciphertextB64 !== 'string')
                        {
                            throw new MslEncodingException(MslError.MASTERTOKEN_TOKENDATA_PARSE_ERROR, "mastertokendata " + tokenDataJson);
                        }
                        if (expirationSeconds < renewalWindowSeconds)
                            throw new MslException(MslError.MASTERTOKEN_EXPIRES_BEFORE_RENEWAL, "mastertokendata " + tokenDataJson);

                        // Verify sequence number and serial number values.
                        if (sequenceNumber < 0 || sequenceNumber > MslConstants$MAX_LONG_VALUE)
                            throw new MslException(MslError.MASTERTOKEN_SEQUENCE_NUMBER_OUT_OF_RANGE, "mastertokendata " + tokenDataJson);
                        if (serialNumber < 0 || serialNumber > MslConstants$MAX_LONG_VALUE)
                            throw new MslException(MslError.MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE, "mastertokendata " + tokenDataJson);

                        // Convert dates.
                        var renewalWindow = new Date(renewalWindowSeconds * MILLISECONDS_PER_SECOND);
                        var expiration = new Date(expirationSeconds * MILLISECONDS_PER_SECOND);

                        // Construct session data.
                        var ciphertext;
                        try {
                            ciphertext = base64$decode(ciphertextB64);
                        } catch (e) {
                            throw new MslException(MslError.MASTERTOKEN_SESSIONDATA_INVALID, ciphertextB64, e);
                        }
                        if (!ciphertext || ciphertext.length == 0)
                            throw new MslException(MslError.MASTERTOKEN_SESSIONDATA_MISSING, ciphertextB64);
                        if (verified) {
                            cryptoContext.decrypt(ciphertext, {
                                result: function(sessiondata) {
                                    AsyncExecutor(callback, function() {
                                        var issuerData, identity, encryptionKeyB64, hmacKeyB64;
                                        var sessionDataJson = textEncoding$getString(sessiondata, MslConstants$DEFAULT_CHARSET);
                                        try {
                                            var sessionDataJO = JSON.parse(sessionDataJson);
                                            issuerData = sessionDataJO[KEY_ISSUER_DATA];
                                            identity = sessionDataJO[KEY_IDENTITY];
                                            encryptionKeyB64 = sessionDataJO[KEY_ENCRYPTION_KEY];
                                            hmacKeyB64 = sessionDataJO[KEY_HMAC_KEY];
                                        } catch (e) {
                                            if (e instanceof SyntaxError)
                                                throw new MslEncodingException(MslError.MASTERTOKEN_SESSIONDATA_PARSE_ERROR, "sessiondata " + sessionDataJson, e);
                                            throw e;
                                        }

                                        // Verify session data.
                                        if (issuerData && typeof issuerData !== 'object' ||
                                            !identity ||
                                            typeof encryptionKeyB64 !== 'string' ||
                                            typeof hmacKeyB64 !== 'string')
                                        {
                                            throw new MslEncodingException(MslError.MASTERTOKEN_SESSIONDATA_PARSE_ERROR, "sessiondata " + sessionDataJson);
                                        }

                                        // Reconstruct cipher keys.
                                        CipherKey$import(encryptionKeyB64, WebCryptoAlgorithm.AES_CBC, WebCryptoUsage.ENCRYPT_DECRYPT, {
                                            result: function(encryptionKey) {
                                                CipherKey$import(hmacKeyB64, WebCryptoAlgorithm.HMAC_SHA256, WebCryptoUsage.SIGN_VERIFY, {
                                                    result: function(hmacKey) {
                                                        AsyncExecutor(callback, function() {
                                                            // Return the new master token.
                                                            var creationData = new CreationData(sessiondata, tokendata, signature, verified);
                                                            new MasterToken(ctx, renewalWindow, expiration, sequenceNumber, serialNumber, issuerData, identity, encryptionKey, hmacKey, creationData, callback);
                                                        });
                                                    },
                                                    error: function(e) {
                                                        callback.error(new MslCryptoException(MslError.MASTERTOKEN_KEY_CREATION_ERROR, e));
                                                    }
                                                });
                                            },
                                            error: function(e) {
                                                callback.error(new MslCryptoException(MslError.MASTERTOKEN_KEY_CREATION_ERROR, e));
                                            }
                                        });
                                    });
                                },
                                error: function(err) { callback.error(err); },
                            });
                        } else {
                            var sessiondata = null;
                            var issuerData = null;
                            var identity = null;
                            var encryptionKey = null;
                            var hmacKey = null;

                            // Return the new master token.
                            var creationData = new CreationData(sessiondata, tokendata, signature, verified);
                            new MasterToken(ctx, renewalWindow, expiration, sequenceNumber, serialNumber, issuerData, identity, encryptionKey, hmacKey, creationData, callback);
                        }
                    });
                },
                error: function(err) { callback.error(err); }
            });
        });
    };
})();



// -- javascript/tokens/UserIdToken.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A user ID token provides proof of user identity. While there can be
 * multiple versions of a user ID token, this class should encapsulate support
 * for all of those versions.</p>
 *
 * <p>User ID tokens are bound to a specific master token by the master token's
 * serial number.</p>
 *
 * <p>The renewal window indicates the time after which the user ID token will
 * be renewed if requested by the entity. The expiration is the time after
 * which the user ID token will be renewed no matter what.</p>
 *
 * <p>User ID tokens are represented as
 * {@code
 * useridtoken = {
 *   "#mandatory" : [ "tokendata", "signature" ],
 *   "tokendata" : "base64",
 *   "signature" : "base64"
 * }} where:
 * <ul>
 * <li>{@code tokendata} is the Base64-encoded user ID token data (usertokendata)</li>
 * <li>{@code signature} is the Base64-encoded verification data of the user ID token data</li>
 * </ul>
 *
 * <p>The token data is represented as
 * {@code
 * usertokendata = {
 *   "#mandatory" : [ "renewalwindow", "expiration", "mtserialnumber", "serialnumber", "userdata" ],
 *   "renewalwindow" : "int64(0,-)",
 *   "expiration" : "int64(0,-)",
 *   "mtserialnumber" : "int64(0,2^53^)",
 *   "serialnumber" : "int64(0,2^53^)",
 *   "userdata" : "base64"
 * }} where:
 * <ul>
 * <li>{@code renewalwindow} is when the renewal window opens in seconds since the epoch</li>
 * <li>{@code expiration} is the expiration timestamp in seconds since the epoch</li>
 * <li>{@code mtserialnumber} is the master token serial number</li>
 * <li>{@code serialnumber} is the user ID token serial number</li>
 * <li>{@code userdata} is the Base64-encoded encrypted user data (userdata)</li>
 * </ul></p>
 *
 * <p>The decrypted user data is represented as
 * {@code
 * userdata = {
 *   "#mandatory" : [ "user" ],
 *   "issuerdata" : object,
 *   "identity" : "string"
 * }}
 * where:
 * <ul>
 * <li>{@code issuerdata} is the user ID token issuer data</li>
 * <li>{@code identity} is the user identity data</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var UserIdToken;
var UserIdToken$create;
var UserIdToken$parse;

(function() {
    /** Milliseconds per second.
     * @const
     * @type {number}
     */
    var MILLISECONDS_PER_SECOND = 1000;

    /**
     * JSON key token data.
     * @const
     * @type {string}
     */
    var KEY_TOKENDATA = "tokendata";
    /**
     * JSON key signature.
     * @const
     * @type {string}
     */
    var KEY_SIGNATURE = "signature";

    // tokendata
    /**
     * JSON key renewal window timestamp.
     * @const
     * @type {string}
     */
    var KEY_RENEWAL_WINDOW = "renewalwindow";
    /**
     * JSON key expiration timestamp.
     * @const
     * @type {string}
     */
    var KEY_EXPIRATION = "expiration";
    /**
     * JSON key master token serial number.
     * @const
     * @type {string}
     */
    var KEY_MASTER_TOKEN_SERIAL_NUMBER = "mtserialnumber";
    /**
     * JSON key user ID token serial number.
     * @const
     * @type {string}
     */
    var KEY_SERIAL_NUMBER = "serialnumber";
    /**
     * JSON key token user data.
     * @const
     * @type {string}
     */
    var KEY_USERDATA = "userdata";

    // userdata
    /**
     * JSON key issuer data.
     * @const
     * @type {string}
     */
    var KEY_ISSUER_DATA = "issuerdata";
    /**
     * JSON key identity.
     * @const
     * @type {string}
     */
    var KEY_IDENTITY = "identity";

    /**
     * Create a new token data container object.
     *
     * @param {Uint8Array} tokendata raw token data.
     * @param {Uint8Array} signature raw signature.
     * @param {boolean} verified true if verified.
     * @constructor
     */
    function CreationData(tokendata, signature, verified) {
        this.tokendata = tokendata;
        this.signature = signature;
        this.verified = verified;
    };

    UserIdToken = util.Class.create({
        /**
         * Create a new user ID token with the specified Netflix customer ID.
         *
         * @param {MslContext} ctx MSL context.
         * @param {Date} renewalWindow the renewal window.
         * @param {Date} expiration the expiration.
         * @param {MasterToken} masterToken the master token.
         * @param {number} serialNumber the user ID token serial number.
         * @param {?Object} the issuer data. May be null.
         * @param {CustomerKey} customer the Netflix customer.
         * @param {?CreationData} creationData optional creation data.
         * @param {{result: function(UserIdToken), error: function(Error)}}
         *        callback the callback functions that will receive the user ID token
         *        or any thrown exceptions.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the token data.
         */
        init: function init(ctx, renewalWindow, expiration, masterToken, serialNumber, issuerData, customer, creationData, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // The expiration must appear after the renewal window.
                if (expiration.getTime() < renewalWindow.getTime())
                    throw new MslInternalException("Cannot construct a user ID token that expires before its renewal window opens.");
                // A master token must be provided.
                if (!masterToken)
                    throw new MslInternalException("Cannot construct a user ID token without a master token.");
                // The serial number must be within range.
                if (serialNumber < 0 || serialNumber > MslConstants$MAX_LONG_VALUE)
                    throw new MslInternalException("Serial number " + serialNumber + " is outside the valid range.");

                // Renewal window and expiration are in seconds, not milliseconds.
                var renewalWindowSeconds = Math.floor(renewalWindow.getTime() / MILLISECONDS_PER_SECOND);
                var expirationSeconds = Math.floor(expiration.getTime() / MILLISECONDS_PER_SECOND);

                // Extract master token serial number.
                var mtSerialNumber = masterToken.serialNumber;

                // Construct the token data.
                if (!creationData) {
                    // Construct the user data.
                    var userData = {};
                    if (issuerData)
                        userData[KEY_ISSUER_DATA] = issuerData;
                    userData[KEY_IDENTITY] = customer;
                    var userdata = textEncoding$getBytes(JSON.stringify(userData), MslConstants$DEFAULT_CHARSET);

                    // Encrypt the user data.
                    var cryptoContext = ctx.getMslCryptoContext();
                    cryptoContext.encrypt(userdata, {
                        result: function(ciphertext) {
                            AsyncExecutor(callback, function() {
                                // Construct the token data.
                                var tokenDataJO = {};
                                tokenDataJO[KEY_RENEWAL_WINDOW] = renewalWindowSeconds;
                                tokenDataJO[KEY_EXPIRATION] = expirationSeconds;
                                tokenDataJO[KEY_MASTER_TOKEN_SERIAL_NUMBER] = mtSerialNumber;
                                tokenDataJO[KEY_SERIAL_NUMBER] = serialNumber;
                                tokenDataJO[KEY_USERDATA] = base64$encode(ciphertext);
                                var tokendata = textEncoding$getBytes(JSON.stringify(tokenDataJO), MslConstants$DEFAULT_CHARSET);

                                // Sign the token data.
                                cryptoContext.sign(tokendata, {
                                    result: function(signature) {
                                        AsyncExecutor(callback, function() {
                                            var verified = true;

                                            // The properties.
                                            var mtSerialNumber = masterToken.serialNumber;
                                            var props = {
                                                ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                                                renewalWindowSeconds: { value: renewalWindowSeconds, writable: false, enumerable: false, configurable: false },
                                                expirationSeconds: { value: expirationSeconds, writable: false, enumerable: false, configurable: false },
                                                mtSerialNumber: { value: mtSerialNumber, writable: false, configurable: false },
                                                serialNumber: { value: serialNumber, writable: false, configurable: false },
                                                issuerData: { value: issuerData, writable: false, configurable: false },
                                                customer: { value: customer, writable: false, configurable: false },
                                                verified: { value: verified, writable: false, enumerable: false, configurable: false },
                                                tokendata: { value: tokendata, writable: false, enumerable: false, configurable: false },
                                                signature: { value: signature, writable: false, enumerable: false, configurable: false }
                                            };
                                            Object.defineProperties(this, props);
                                            return this;
                                        }, self);
                                    },
                                    error: function(e) {
                                        AsyncExecutor(callback, function() {
                                            if (e instanceof MslException)
                                                e.setEntity(masterToken);
                                            throw e;
                                        }, self);
                                    },
                                });
                            }, self);
                        },
                        error: function(e) {
                            AsyncExecutor(callback, function() {
                                if (e instanceof MslException)
                                    e.setEntity(masterToken);
                                throw e;
                            }, self);
                        },
                    });
                } else {
                    var tokendata = creationData.tokendata;
                    var signature = creationData.signature;
                    var verified = creationData.verified;

                    // The properties.
                    var mtSerialNumber = masterToken.serialNumber;
                    var props = {
                        ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                        renewalWindowSeconds: { value: renewalWindowSeconds, writable: false, enumerable: false, configurable: false },
                        expirationSeconds: { value: expirationSeconds, writable: false, enumerable: false, configurable: false },
                        mtSerialNumber: { value: mtSerialNumber, writable: false, configurable: false },
                        serialNumber: { value: serialNumber, writable: false, configurable: false },
                        issuerData: { value: issuerData, writable: false, configurable: false },
                        customer: { value: customer, writable: false, configurable: false },
                        verified: { value: verified, writable: false, enumerable: false, configurable: false },
                        tokendata: { value: tokendata, writable: false, enumerable: false, configurable: false },
                        signature: { value: signature, writable: false, enumerable: false, configurable: false }
                    };
                    Object.defineProperties(this, props);
                    return this;
                }
            }, this);
        },

        /**
        * @return {Date} gets the renewal window.
        */
        get renewalWindow() {
            return new Date(this.renewalWindowSeconds * MILLISECONDS_PER_SECOND);
        },

        /**
        * @return {Date} gets the expiration.
        */
        get expiration() {
            return new Date(this.expirationSeconds * MILLISECONDS_PER_SECOND);
        },

        /**
         * @return {boolean} true if the token has been verified.
         */
        isVerified: function isVerified() {
            return this.verified;
        },

        /**
         * @return {boolean} true if the decrypted content is available. (Implies verified.)
         */
        isDecrypted: function isDecrypted() {
            return (this.customer) ? true : false;
        },

        /**
         * Always returns true if this token was issued by a different entity
         * because we cannot know if the local entity time is correct.
         *
         * If this token was issued by the local entity then we assume its
         * clock at that time is in sync with the clock now.
         *
         * @return {boolean} true if the renewal window has been entered.
         */
        isRenewable: function isRenewable() {
            return this.renewalWindow.getTime() <= this.ctx.getTime();
        },

        /**
         * Always returns false if this token was issued by a different entity
         * because we cannot know if the local entity time is correct.
         *
         * If this token was issued by the local entity then we assume its
         * clock at that time is in sync with the clock now.
         *
         * @return {boolean} true if expired.
         */
        isExpired: function isExpired() {
            return this.expiration.getTime() <= this.ctx.getTime();
        },

        /**
         * @param {MasterToken} masterToken master token. May be null.
         * @return {boolean} true if this token is bound to the provided master token.
         */
        isBoundTo: function isBoundTo(masterToken) {
            return (masterToken && masterToken.serialNumber == this.mtSerialNumber);
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            var jsonObj = {};
            jsonObj[KEY_TOKENDATA] = base64$encode(this.tokendata);
            jsonObj[KEY_SIGNATURE] = base64$encode(this.signature);
            return jsonObj;
        },

        /**
         * @param {?} that the reference object with which to compare.
         * @return {boolean} true if the other object is a user ID token with the same serial
         *         number bound to the same master token.
         * @see #uniqueKey()
         */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof UserIdToken)) return false;
            return this.serialNumber == that.serialNumber && this.mtSerialNumber == that.mtSerialNumber;
        },

        /**
         * @return {string} a string that uniquely identifies this master token.
         * @see #equals(that)
         */
        uniqueKey: function uniqueKey() {
            return this.serialNumber + ':' + this.mtSerialNumber;
        },
    });

    /**
     * Create a new user ID token with the specified Netflix customer ID.
     *
     * @param {MslContext} ctx MSL context.
     * @param {Date} renewalWindow the renewal window.
     * @param {Date} expiration the expiration.
     * @param {MasterToken} masterToken the master token.
     * @param {number} serialNumber the user ID token serial number.
     * @param {?Object} the issuer data. May be null.
     * @param {CustomerKey} customer the Netflix customer.
     * @param {{result: function(UserIdToken), error: function(Error)}}
     *        callback the callback functions that will receive the user ID token
     *        or any thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the token data.
     */
    UserIdToken$create = function UserIdToken$create(ctx, renewalWindow, expiration, masterToken, serialNumber, issuerData, customer, callback) {
        new UserIdToken(ctx, renewalWindow, expiration, masterToken, serialNumber, issuerData, customer, null, callback);
    };

    /**
     * Create a new user ID token from the provided JSON object. The associated
     * master token must be provided to verify the user ID token.
     *
     * @param {MslContext} ctx MSL context.
     * @param {Object} userIdTokenJO user ID token JSON object.
     * @param {MasterToken} masterToken the master token.
     * @param {{result: function(UserIdToken), error: function(Error)}}
     *        callback the callback functions that will receive the user ID token
     *        or any thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException if there is an error verifying the token
     *         data.
     * @throws MslException if the user ID token master token serial number
     *         does not match the master token serial number, or the expiration
     *         timestamp occurs before the renewal window, or the user data is
     *         missing.
     */
    UserIdToken$parse = function UserIdToken$parse(ctx, userIdTokenJO, masterToken, callback) {
        AsyncExecutor(callback, function() {
            // Grab the crypto context.
            var cryptoContext = ctx.getMslCryptoContext();

            // Verify the JSON representation.
            var tokendataB64 = userIdTokenJO[KEY_TOKENDATA];
            var signatureB64 = userIdTokenJO[KEY_SIGNATURE];
            if (typeof tokendataB64 !== 'string' || typeof signatureB64 !== 'string')
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "useridtoken " + JSON.stringify(userIdTokenJO)).setEntity(masterToken);
            var tokendata, signature;
            try {
                tokendata = base64$decode(tokendataB64);
            } catch (e) {
                throw new MslException(MslError.USERIDTOKEN_TOKENDATA_INVALID, "useridtoken " + JSON.stringify(userIdTokenJO), e).setEntity(masterToken);
            }
            if (!tokendata || tokendata.length == 0)
                throw new MslEncodingException(MslError.USERIDTOKEN_TOKENDATA_MISSING, "useridtoken " + JSON.stringify(userIdTokenJO)).setEntity(masterToken);
            try {
                signature = base64$decode(signatureB64);
            } catch (e) {
                throw new MslException(MslError.USERIDTOKEN_TOKENDATA_INVALID, "useridtoken " + JSON.stringify(userIdTokenJO), e).setEntity(masterToken);
            }
            cryptoContext.verify(tokendata, signature, {
                result: function(verified) {
                    AsyncExecutor(callback, function() {
                        // Pull the token data.
                        var renewalWindowSeconds, expirationSeconds, mtSerialNumber, serialNumber, ciphertextB64;
                        var tokenDataJson = textEncoding$getString(tokendata, MslConstants$DEFAULT_CHARSET);
                        try {
                            var tokenDataJO = JSON.parse(tokenDataJson);
                            renewalWindowSeconds = parseInt(tokenDataJO[KEY_RENEWAL_WINDOW]);
                            expirationSeconds = parseInt(tokenDataJO[KEY_EXPIRATION]);
                            mtSerialNumber = parseInt(tokenDataJO[KEY_MASTER_TOKEN_SERIAL_NUMBER]);
                            serialNumber = parseInt(tokenDataJO[KEY_SERIAL_NUMBER]);
                            ciphertextB64 = tokenDataJO[KEY_USERDATA];
                        } catch (e) {
                            if (e instanceof SyntaxError)
                                throw new MslEncodingException(MslError.USERIDTOKEN_TOKENDATA_PARSE_ERROR, "usertokendata " + tokenDataJson, e).setEntity(masterToken);
                            throw e;
                        }

                        // Verify token data.
                        if (!renewalWindowSeconds || renewalWindowSeconds != renewalWindowSeconds ||
                            !expirationSeconds || expirationSeconds != expirationSeconds ||
                            typeof mtSerialNumber !== 'number' || mtSerialNumber != mtSerialNumber ||
                            typeof serialNumber !== 'number' || serialNumber != serialNumber ||
                            typeof ciphertextB64 !== 'string')
                        {
                            throw new MslEncodingException(MslError.USERIDTOKEN_TOKENDATA_PARSE_ERROR, "usertokendata " + tokenDataJson).setEntity(masterToken);
                        }
                        if (expirationSeconds < renewalWindowSeconds)
                            throw new MslException(MslError.USERIDTOKEN_EXPIRES_BEFORE_RENEWAL, "mastertokendata " + tokenDataJson).setEntity(masterToken);

                        // Verify serial number values.
                        if (mtSerialNumber < 0 || mtSerialNumber > MslConstants$MAX_LONG_VALUE)
                            throw new MslException(MslError.USERIDTOKEN_MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE, "usertokendata " + tokenDataJson).setEntity(masterToken);
                        if (serialNumber < 0 || serialNumber > MslConstants$MAX_LONG_VALUE)
                            throw new MslException(MslError.USERIDTOKEN_SERIAL_NUMBER_OUT_OF_RANGE, "usertokendata " + tokenDataJson).setEntity(masterToken);

                        // Convert dates.
                        var renewalWindow = new Date(renewalWindowSeconds * MILLISECONDS_PER_SECOND);
                        var expiration = new Date(expirationSeconds * MILLISECONDS_PER_SECOND);

                        // Verify serial numbers.
                        if (!masterToken || mtSerialNumber != masterToken.serialNumber)
                            throw new MslException(MslError.USERIDTOKEN_MASTERTOKEN_MISMATCH, "uit mtserialnumber " + mtSerialNumber + "; mt " + JSON.stringify(masterToken)).setEntity(masterToken);

                        // Construct user data.
                        var ciphertext;
                        try {
                            ciphertext = base64$decode(ciphertextB64);
                        } catch (e) {
                            throw new MslException(MslError.USERIDTOKEN_USERDATA_INVALID, ciphertextB64, e).setEntity(masterToken);
                        }
                        if (!ciphertext || ciphertext.length == 0)
                            throw new MslException(MslError.USERIDTOKEN_USERDATA_MISSING, ciphertextB64).setEntity(masterToken);
                        if (verified) {
                            cryptoContext.decrypt(ciphertext, {
                                result: function(userdata) {
                                    AsyncExecutor(callback, function() {
                                        // Pull the user data.
                                        var issuerData, identityJO;
                                        var userdataJson = textEncoding$getString(userdata, MslConstants$DEFAULT_CHARSET);
                                        try {
                                            var userdataJO = JSON.parse(userdataJson);
                                            issuerData = userdataJO[KEY_ISSUER_DATA];
                                            identityJO = userdataJO[KEY_IDENTITY];
                                        } catch (e) {
                                            if (e instanceof SyntaxError)
                                                throw new MslEncodingException(MslError.USERIDTOKEN_USERDATA_PARSE_ERROR, "userdata " + userdataJson).setEntity(masterToken);
                                            throw e;
                                        }

                                        // Verify user data.
                                        if (issuerData && typeof issuerData !== 'object' ||
                                            typeof identityJO !== 'object')
                                        {
                                            throw new MslEncodingException(MslError.USERIDTOKEN_USERDATA_PARSE_ERROR, "userdata " + userdataJson).setEntity(masterToken);
                                        }

                                        var customer;
                                        try {
                                            customer = CustomerKey$parse(identityJO);
                                        } catch (e) {
                                            throw new MslException(MslError.USERIDTOKEN_IDENTITY_INVALID, "userdata " + userdataJson, e).setEntity(masterToken);
                                        }

                                        // Return the new user ID token.
                                        var creationData = new CreationData(tokendata, signature, verified);
                                        new UserIdToken(ctx, renewalWindow, expiration, masterToken, serialNumber, issuerData, customer, creationData, callback);
                                    });
                                },
                                error: function(e) {
                                    AsyncExecutor(callback, function() {
                                        if (e instanceof MslException)
                                            e.setEntity(masterToken);
                                        throw e;
                                    });
                                },
                            });
                        } else {
                            var issuerData = null;
                            var customer = null;

                            // Return the new user ID token.
                            var creationData = new CreationData(tokendata, signature, verified);
                            new UserIdToken(ctx, renewalWindow, expiration, masterToken, serialNumber, issuerData, customer, creationData, callback);
                        }
                    });
                },
                error: function(e) {
                    AsyncExecutor(callback, function() {
                        if (e instanceof MslException)
                            e.setEntity(masterToken);
                        throw e;
                    });
                },
            });
        });
    };
})();




// -- javascript/tokens/ServiceToken.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Service tokens are service-defined tokens carried as part of any MSL
 * message. These tokens should be used to carry service state.</p>
 *
 * <p>Service tokens are optionally bound to a specific master token and user
 * ID token by their serial numbers.</p>
 *
 * <p>Service tokens are either verified or encrypted. Verified tokens carry
 * their data in the clear but are accompanied by a signature allowing the
 * issuer to ensure the data has not been tampered with. Encrypted tokens
 * encrypt their data as well as contain a signature.</p>
 *
 * <p>Service tokens should use application- or service-specific crypto
 * contexts and not the crypto context associated with the entity credentials
 * or master token.</p>
 *
 * <p>Service tokens are represented as
 * {@code
 * servicetoken = {
 *   "#mandatory" : [ "tokendata", "signature" ],
 *   "tokendata" : "base64",
 *   "signature" : "base64"
 * }} where:
 * <ul>
 * <li>{@code tokendata} is the Base64-encoded service token data (servicetokendata)</li>
 * <li>{@code signature} is the Base64-encoded verification data of the service token data</li>
 * </ul></p>
 *
 * <p>The token data is represented as
 * {@code
 * servicetokendata = {
 *   "#mandatory" : [ "name", "mtserialnumber", "uitserialnumber", "encrypted", "servicedata" ],
 *   "name" : "string",
 *   "mtserialnumber" : "int64(0,-)",
 *   "uitserialnumber" : "int64(0,-)",
 *   "encrypted" : "boolean",
 *   "compressionalgo" : "enum(GZIP|LZW)",
 *   "servicedata" : "base64"
 * }} where:
 * <ul>
 * <li>{@code name} is the token name</li>
 * <li>{@code mtserialnumber} is the master token serial number or -1 if unbound</li>
 * <li>{@code utserialnumber} is the user ID token serial number or -1 if unbound</li>
 * <li>{@code encrypted} indicates if the service data is encrypted or not</li>
 * <li>{@code compressionalgo} indicates the algorithm used to compress the data</li>
 * <li>{@code servicedata} is the Base64-encoded optionally encrypted service data</li>
 * </ul></p>
 *
 * <p>Service token names should follow a reverse fully-qualified domain
 * hierarchy. e.g. {@literal com.netflix.service.tokenname}.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var ServiceToken;
var ServiceToken$create;
var ServiceToken$parse;

(function() {
    /**
     * JSON key token data.
     * @const
     * @type {string}
     */
    var KEY_TOKENDATA = "tokendata";
    /**
     * JSON key signature
     * @const
     * @type {string}
     */
    var KEY_SIGNATURE = "signature";

    // tokendata
    /**
     * JSON key token name
     * @const
     * @type {string}
     */
    var KEY_NAME = "name";
    /**
     * JSON key master token serial number
     * @const
     * @type {string}
     */
    var KEY_MASTER_TOKEN_SERIAL_NUMBER = "mtserialnumber";
    /**
     * JSON key user ID token serial number
     * @const
     * @type {string}
     */
    var KEY_USER_ID_TOKEN_SERIAL_NUMBER = "uitserialnumber";
    /**
     * JSON key encrypted
     * @const
     * @type {string}
     */
    var KEY_ENCRYPTED = "encrypted";
    /**
     * JSON key compression algorithm.
     * @const
     * @type {string}
     */
    var KEY_COMPRESSION_ALGORITHM = "compressionalgo";
    /**
     * JSON key service data
     * @const
     * @type {string}
     */
    var KEY_SERVICEDATA = "servicedata";

    /**
     * <p>Select the appropriate crypto context for the service token
     * represented by the provided JSON object.</p>
     * 
     * <p>If the service token name exists as a key in the map of crypto
     * contexts, the mapped crypto context will be returned. Otherwise the
     * default crypto context mapped from the empty string key will be
     * returned. If no explicit or default crypto context exists null will be
     * returned.</p>
     *
     * @param {Object} serviceTokenJO the JSON object.
     * @param {Object.<string,ICryptoContext>} cryptoContexts the map of service token names onto crypto
     *        contexts used to decrypt and verify service tokens.
     * @return {ICryptoContext} the correct crypto context for the service token or null.
     * @throws MslEncodingException if there is a problem parsing the JSON.
     * @throws MslException if the token data is invalid.
     */
    function selectCryptoContext(serviceTokenJO, cryptoContexts) {
        // Grab the tokendata.
        var tokendataB64 = serviceTokenJO[KEY_TOKENDATA];
        if (typeof tokendataB64 !== 'string')
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "servicetoken " + JSON.stringify(serviceTokenJO));
        var tokendata;
        try {
            tokendata = base64$decode(tokendataB64);
        } catch (e) {
            throw new MslException(MslError.SERVICETOKEN_TOKENDATA_INVALID, "servicetoken " + JSON.stringify(serviceTokenJO), e);
        }
        if (!tokendata || tokendata.length == 0)
            throw new MslEncodingException(MslError.SERVICETOKEN_TOKENDATA_MISSING, "servicetoken " + JSON.stringify(serviceTokenJO));
        
        // Extract the service token name.
        var name;
        try {
            var tokenDataJO = JSON.parse(textEncoding$getString(tokendata, MslConstants$DEFAULT_CHARSET));
            name = tokenDataJO[KEY_NAME];
        } catch (e) {
            if (e instanceof SyntaxError)
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "servicetoken " + JSON.stringify(serviceTokenJO), e);
            throw e;
        }
        if (!name)
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "servicetoken " + JSON.stringify(serviceTokenJO));

        // Return the crypto context.
        if (cryptoContexts[name])
            return cryptoContexts[name];
        return cryptoContexts[''];
    };

    /**
     * Create a new token data container object.
     *
     * @param {Uint8Array} tokendata raw tokendata.
     * @param {Uint8Array} signature raw signature.
     * @param {boolean} verified true if verified.
     * @constructor
     */
    function CreationData(tokendata, signature, verified) {
        this.tokendata = tokendata;
        this.signature = signature;
        this.verified = verified;
    };

    ServiceToken = util.Class.create({
        /**
         * <p>Construct a new service token with the specified name and data. If a
         * master token is provided, the service token is bound to the master
         * token's serial number. If a user ID token is provided, the service token
         * is bound to the user ID token's serial number.</p>
         * 
         * <p>For encrypted tokens, the token data is encrypted using the provided
         * crypto context. For verified tokens, the token data is signed using the
         * provided crypto context.</p>
         *
         * @param {MslContext} ctx the MSL context.
         * @param {string} name the service token name--must be unique.
         * @param {Uint8Array} data the service token data (unencrypted).
         * @param {MasterToken} masterToken the master token. May be null.
         * @param {UserIdToken} userIdToken the user ID token. May be null.
         * @param {boolean} encrypted true if the token should be encrypted.
         * @param {MslConstants$CompressionAlgorithm} compressionAlgo the compression algorithm. May be {@code null}
         *        for no compression.
         * @param {ICryptoContext} cryptoContext the crypto context.
         * @param {?CreationData} creationData optional creation data.
         * @param {{result: function(ServiceToken), error: function(Error)}}
         *        callback the callback functions that will receive the service
         *        token or any thrown exceptions.
         * @throws MslEncodingException if there is an error encoding the JSON
         *         data.
         * @throws MslCryptoException if there is an error encrypting or signing
         *         the token data.
         */
        init: function init(ctx, name, data, masterToken, userIdToken, encrypted, compressionAlgo, cryptoContext, creationData, callback) {
            var self = this;
            AsyncExecutor(callback, function() {
                // If both master token and user ID token are provided the user ID
                // token must be bound to the master token.
                if (masterToken && userIdToken && !userIdToken.isBoundTo(masterToken))
                    throw new MslInternalException("Cannot construct a service token bound to a master token and user ID token where the user ID token is not bound to the same master token.");

                // Grab the master token and user ID token serial numbers.
                var mtSerialNumber = (masterToken) ? masterToken.serialNumber : -1;
                var uitSerialNumber = (userIdToken) ? userIdToken.serialNumber : -1;

                // Construct the token data.
                if (!creationData) {
                    // Optionally compress the service data.
                    var plaintext;
                    if (compressionAlgo) {
                        var compressed = MslUtils$compress(compressionAlgo, data);
                        
                        // Only use compression if the compressed data is smaller than the
                        // uncompressed data.
                        if (compressed.length < data.length) {
                            plaintext = compressed;
                        } else {
                            compressionAlgo = null;
                            plaintext = data;
                        }
                    } else {
                        compressionAlgo = null;
                        plaintext = data;
                    }
                    
                    // Start constructing the token data.
                    var tokenDataJO = {};
                    tokenDataJO[KEY_NAME] = name;
                    if (mtSerialNumber != -1)
                        tokenDataJO[KEY_MASTER_TOKEN_SERIAL_NUMBER] = mtSerialNumber;
                    if (uitSerialNumber != -1)
                        tokenDataJO[KEY_USER_ID_TOKEN_SERIAL_NUMBER] = uitSerialNumber;
                    tokenDataJO[KEY_ENCRYPTED] = encrypted;
                    if (compressionAlgo)
                        tokenDataJO[KEY_COMPRESSION_ALGORITHM] = compressionAlgo;

                    // Encrypt the service data if the length is > 0. Otherwise encode
                    // as empty data to indicate this token should be deleted.
                    if (encrypted && plaintext.length > 0) {
                        cryptoContext.encrypt(plaintext, {
                            result: function(ciphertext) {
                                AsyncExecutor(callback, function() {
                                    // Finish constructing the token data.
                                    tokenDataJO[KEY_SERVICEDATA] = base64$encode(ciphertext);
                                    var tokendata = textEncoding$getBytes(JSON.stringify(tokenDataJO), MslConstants$DEFAULT_CHARSET);

                                    // Sign the token data.
                                    cryptoContext.sign(tokendata, {
                                        result: function(signature) {
                                            AsyncExecutor(callback, function() {
                                                var verified = true;

                                                // The properties.
                                                var props = {
                                                    ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                                                    name: { value: name, writable: false, configurable: false },
                                                    mtSerialNumber: { value: mtSerialNumber, writable: false, configurable: false },
                                                    uitSerialNumber: { value: uitSerialNumber, writable: false, configurable: false },
                                                    data: { value: data, writable: false, configurable: false },
                                                    encrypted: { value: encrypted, writable: false, enumerable: false, configurable: false },
                                                    compressionAlgo: { value: compressionAlgo, writable: false, configurable: false },
                                                    verified: { value: verified, writable: false, enumerable: false, configurable: false },
                                                    tokendata: { value: tokendata, writable: false, enumerable: false, configurable: false },
                                                    signature: { value: signature, writable: false, enumerable: false, configurable: false },
                                                };
                                                Object.defineProperties(this, props);
                                                return this;
                                            }, self);
                                        },
                                        error: function(e) {
                                            AsyncExecutor(callback, function() {
                                                if (e instanceof MslException) {
                                                    e.setEntity(masterToken);
                                                    e.setUser(userIdToken);
                                                }
                                                throw e;
                                            });
                                        }
                                    });
                                }, self);
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException) {
                                        e.setEntity(masterToken);
                                        e.setUser(userIdToken);
                                    }
                                    throw e;
                                });
                            }
                        });
                    } else {
                        var ciphertext = plaintext;

                        // Finish constructing the token data.
                        tokenDataJO[KEY_SERVICEDATA] = base64$encode(ciphertext);
                        var tokendata = textEncoding$getBytes(JSON.stringify(tokenDataJO), MslConstants$DEFAULT_CHARSET);

                        // Sign the token data.
                        cryptoContext.sign(tokendata, {
                            result: function(signature) {
                                AsyncExecutor(callback, function() {
                                    var verified = true;

                                    // The properties.
                                    var props = {
                                        ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                                        name: { value: name, writable: false, configurable: false },
                                        mtSerialNumber: { value: mtSerialNumber, writable: false, configurable: false },
                                        uitSerialNumber: { value: uitSerialNumber, writable: false, configurable: false },
                                        data: { value: data, writable: false, configurable: false },
                                        encrypted: { value: encrypted, writable: false, enumerable: false, configurable: false },
                                        compressionAlgo: { value: compressionAlgo, writable: false, configurable: false },
                                        verified: { value: verified, writable: false, enumerable: false, configurable: false },
                                        tokendata: { value: tokendata, writable: false, enumerable: false, configurable: false },
                                        signature: { value: signature, writable: false, enumerable: false, configurable: false },
                                    };
                                    Object.defineProperties(this, props);
                                    return this;
                                }, self);
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException) {
                                        e.setEntity(masterToken);
                                        e.setUser(userIdToken);
                                    }
                                    throw e;
                                });
                            }
                        });
                    }
                } else {
                    var tokendata = creationData.tokendata;
                    var signature = creationData.signature;
                    var verified = creationData.verified;

                    // The properties.
                    var props = {
                        ctx: { value: ctx, writable: false, enumerable: false, configurable: false },
                        name: { value: name, writable: false, configurable: false },
                        mtSerialNumber: { value: mtSerialNumber, writable: false, configurable: false },
                        uitSerialNumber: { value: uitSerialNumber, writable: false, configurable: false },
                        data: { value: data, writable: false, configurable: false },
                        encrypted: { value: encrypted, writable: false, enumerable: false, configurable: false },
                        compressionAlgo: { value: compressionAlgo, writable: false, configurable: false },
                        verified: { value: verified, writable: false, enumerable: false, configurable: false },
                        tokendata: { value: tokendata, writable: false, enumerable: false, configurable: false },
                        signature: { value: signature, writable: false, enumerable: false, configurable: false },
                    };
                    Object.defineProperties(this, props);
                    return this;
                }
            }, this);
        },

        /**
         * @return {boolean} true if the content is encrypted.
         */
        isEncrypted: function isEncrypted() {
            return this.encrypted;
        },

        /**
         * @return {boolean} true if the token has been verified.
         */
        isVerified: function isVerified() {
            return this.verified;
        },

        /**
         * @return {boolean} true if the decrypted content is available. (Implies verified.)
         */
        isDecrypted: function isDecrypted() {
            return (this.data) ? true : false;
        },

        /**
         * @return {boolean} true if this token has been marked for deletion.
         */
        isDeleted: function isDeleted() {
            return this.data && this.data.length == 0;
        },

        /**
         * @return {boolean} true if this token is bound to a master token.
         */
        isMasterTokenBound: function isMasterTokenBound() {
            return this.mtSerialNumber != -1;
        },

        /**
         * @param {MasterToken|UserIdToken} token master token or user ID token. May be null.
         * @return {boolean} true if this token is bound to the provided master token.
         */
        isBoundTo: function isBoundTo(token) {
            if (!token) return false;
            if (token instanceof MasterToken)
                return token.serialNumber == this.mtSerialNumber;
            if (token instanceof UserIdToken)
                return token.serialNumber == this.uitSerialNumber;
            return false;
        },

        /**
         * Returns true if this token is bound to a user ID token. This implies the
         * token is bound to a master token as well.
         *
         * @return {boolean} true if this token is bound to a user ID token.
         */
        isUserIdTokenBound: function isUserIdTokenBound() {
            return this.uitSerialNumber != -1;
        },

        /**
         * @return {boolean} true if this token is not bound to a master token or user ID
         *         token.
         */
        isUnbound: function isUnbound() {
            return this.mtSerialNumber == -1 && this.uitSerialNumber == -1;
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            var jsonObj = {};
            jsonObj[KEY_TOKENDATA] = base64$encode(this.tokendata);
            jsonObj[KEY_SIGNATURE] = base64$encode(this.signature);
            return jsonObj;
        },

        /**
         * @param {?} that the reference object with which to compare.
         * @return {boolean} true if the other object is a service token with the same name
         *         and bound to the same tokens.
         * @see #uniqueKey
         */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof ServiceToken)) return false;
            return this.name == that.name &&
                this.mtSerialNumber == that.mtSerialNumber &&
                this.uitSerialNumber == that.uitSerialNumber;
        },

        /**
         * @return {string} a string that uniquely identifies this master token.
         * @see #equals(that)
         */
        uniqueKey: function uniqueKey() {
            return this.name + ':' + this.mtSerialNumber + ':' + this.uitSerialNumber;
        },
    });

    /**
     * <p>Construct a new service token with the specified name and data. If a
     * master token is provided, the service token is bound to the master
     * token's serial number. If a user ID token is provided, the service token
     * is bound to the user ID token's serial number.</p>
     * 
     * <p>For encrypted tokens, the token data is encrypted using the provided
     * crypto context. For verified tokens, the token data is signed using the
     * provided crypto context.</p>
     *
     * @param {MslContext} ctx the MSL context.
     * @param {string} name the service token name--must be unique.
     * @param {Uint8Array} data the service token data (unencrypted).
     * @param {MasterToken} masterToken the master token. May be null.
     * @param {UserIdToken} userIdToken the user ID token. May be null.
     * @param {boolean} encrypted true if the token should be encrypted.
     * @param {MslConstants$CompressionAlgorithm} compressionAlgo the compression algorithm. May be {@code null}
     *        for no compression.
     * @param {ICryptoContext} cryptoContext the crypto context.
     * @param {{result: function(ServiceToken), error: function(Error)}}
     *        callback the callback functions that will receive the service
     *        token or any thrown exceptions.
     * @throws MslEncodingException if there is an error encoding the JSON
     *         data.
     * @throws MslCryptoException if there is an error encrypting or signing
     *         the token data.
     * @throws MslException if there is an error compressing the data.
     */
    ServiceToken$create = function ServiceToken$create(ctx, name, data, masterToken, userIdToken, encrypted, compressionAlgo, cryptoContext, callback) {
        new ServiceToken(ctx, name, data, masterToken, userIdToken, encrypted, compressionAlgo, cryptoContext, null, callback);
    };

    /**
     * <p>Construct a new service token from the provided JSON object.</p>
     *
     * <p>If a single crypto context is provided, the token data will be
     * decrypted and its signature verified using that crypto context.</p>
     *
     * <p>If a map of crypto contexts is provided then attempt to decrypt and
     * verified the signature of the service token using the appropriate crypto
     * context. If the service token name exists as a key in the map of crypto
     * contexts, the mapped crypto context will be used. Otherwise the default
     * crypto context mapped from the empty string key will be used.</p>
     *
     * <p>If the data cannot be decrypted or the signature cannot be verified,
     * the token will still be created.</p>
     *
     * <p>If the service token is bound to a master token or user ID token it
     * will be verified against the provided master token or user ID tokens
     * which must not be null.</p>
     *
     * @param {MslContext} ctx the MSL context.
     * @param {Object} serviceTokenJO the JSON object.
     * @param {MasterToken} masterToken the master token. May be null.
     * @param {UserIdToken} userIdToken the user ID token. May be null.
     * @param {ICryptoContext|Object.<string,ICryptoContext>} cryptoContext the
     *        crypto context. May be null. Or a map of service token names onto
     *        crypto contexts.
     * @param {{result: function(ServiceToken), error: function(Error)}}
     *        callback the callback functions that will receive the service
     *        token or any thrown exceptions.
     * @throws MslCryptoException if there is a problem decrypting or verifying
     *         the token data.
     * @throws MslEncodingException if there is a problem parsing the JSON.
     * @throws MslException if the service token is bound to a master token or
     *         user ID token and the provided tokens are null or the serial
     *         numbers do not match, or if bound to a user ID token but not to
     *         a master token, or if the service data is missing, or if the
     *         service token master token serial number is out of range, or if
     *         the service token user ID token serial number is out of range,
     *         or if the token data or signature is invalid, or if the
     *         compression algorithm is not known or there is an error
     *         uncompressing the data.
     */
    ServiceToken$parse = function ServiceToken$parse(ctx, serviceTokenJO, masterToken, userIdToken, cryptoContext, callback) {
        AsyncExecutor(callback, function() {
            // Grab the crypto context.
            if (cryptoContext && !(cryptoContext instanceof ICryptoContext))
                cryptoContext = selectCryptoContext(serviceTokenJO, cryptoContext);

            // Verify the JSON representation.
            var tokendataB64 = serviceTokenJO[KEY_TOKENDATA];
            var signatureB64 = serviceTokenJO[KEY_SIGNATURE];
            if (typeof tokendataB64 !== 'string' || typeof signatureB64 !== 'string')
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "servicetoken " + JSON.stringify(serviceTokenJO)).setEntity(masterToken).setEntity(userIdToken);
            var tokendata, signature;
            try {
                tokendata = base64$decode(tokendataB64);
            } catch (e) {
                throw new MslException(MslError.SERVICETOKEN_TOKENDATA_INVALID, "servicetoken " + JSON.stringify(serviceTokenJO), e).setEntity(masterToken).setEntity(userIdToken);
            }
            if (!tokendata || tokendata.length == 0)
                throw new MslEncodingException(MslError.SERVICETOKEN_TOKENDATA_MISSING, "servicetoken " + JSON.stringify(serviceTokenJO)).setEntity(masterToken).setEntity(userIdToken);
            try {
                signature = base64$decode(signatureB64);
            } catch (e) {
                throw new MslException(MslError.SERVICETOKEN_SIGNATURE_INVALID, "servicetoken " + JSON.stringify(serviceTokenJO), e).setEntity(masterToken).setEntity(userIdToken);
            }

            // Pull the token data.
            var name, mtSerialNumber, uitSerialNumber, encrypted, algoName, ciphertextB64;
            var tokenDataJson = textEncoding$getString(tokendata, MslConstants$DEFAULT_CHARSET);
            try {
                var tokenDataJO = JSON.parse(tokenDataJson);
                name = tokenDataJO[KEY_NAME];
                mtSerialNumber = (tokenDataJO[KEY_MASTER_TOKEN_SERIAL_NUMBER])
                    ? parseInt(tokenDataJO[KEY_MASTER_TOKEN_SERIAL_NUMBER])
                    : -1;
                uitSerialNumber = (tokenDataJO[KEY_USER_ID_TOKEN_SERIAL_NUMBER])
                    ? parseInt(tokenDataJO[KEY_USER_ID_TOKEN_SERIAL_NUMBER])
                    : -1;
                // There has to be a master token serial number if there is a
                // user ID token serial number.
                encrypted = tokenDataJO[KEY_ENCRYPTED];
                algoName = tokenDataJO[KEY_COMPRESSION_ALGORITHM];
                ciphertextB64 = tokenDataJO[KEY_SERVICEDATA];
            } catch (e) {
                if (e instanceof SyntaxError)
                    throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "servicetokendata " + tokenDataJson, e).setEntity(masterToken).setEntity(userIdToken);
                throw e;
            }

            // Verify token data.
            if (!name ||
                typeof mtSerialNumber !== 'number' || mtSerialNumber != mtSerialNumber ||
                typeof uitSerialNumber !== 'number' || uitSerialNumber != uitSerialNumber ||
                typeof encrypted !== 'boolean' ||
                (algoName && typeof algoName !== 'string') ||
                typeof ciphertextB64 !== 'string')
            {
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "servicetokendata " + tokenDataJson).setEntity(masterToken).setEntity(userIdToken);
            }

            // Verify serial number values.
            if (tokenDataJO[KEY_MASTER_TOKEN_SERIAL_NUMBER] &&
                mtSerialNumber < 0 || mtSerialNumber > MslConstants$MAX_LONG_VALUE)
            {
                throw new MslException(MslError.SERVICETOKEN_MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE, "servicetokendata " + tokenDataJson).setEntity(masterToken).setEntity(userIdToken);
            }
            if (tokenDataJO[KEY_USER_ID_TOKEN_SERIAL_NUMBER] &&
                uitSerialNumber < 0 || uitSerialNumber > MslConstants$MAX_LONG_VALUE)
            {
                throw new MslException(MslError.SERVICETOKEN_USERIDTOKEN_SERIAL_NUMBER_OUT_OF_RANGE, "servicetokendata " + tokenDataJson).setEntity(masterToken).setEntity(userIdToken);
            }

            // Verify serial numbers match.
            if (mtSerialNumber != -1 && (!masterToken || mtSerialNumber != masterToken.serialNumber))
                throw new MslException(MslError.SERVICETOKEN_MASTERTOKEN_MISMATCH, "st mtserialnumber " + mtSerialNumber + "; mt " + masterToken).setEntity(masterToken).setEntity(userIdToken);
            if (uitSerialNumber != -1 && (!userIdToken || uitSerialNumber != userIdToken.serialNumber))
                throw new MslException(MslError.SERVICETOKEN_USERIDTOKEN_MISMATCH, "st uitserialnumber " + uitSerialNumber + "; uit " + userIdToken).setEntity(masterToken).setEntity(userIdToken);

            // Convert encrypted to the correct type.
            encrypted = (encrypted === true);
            
            // Verify compression algorithm.
            var compressionAlgo;
            if (algoName) {
                if (!MslConstants$CompressionAlgorithm[algoName])
                    throw new MslException(MslError.UNIDENTIFIED_COMPRESSION, algoName);
                compressionAlgo = algoName;
            } else {
                compressionAlgo = null;
            }

            if (cryptoContext) {
                cryptoContext.verify(tokendata, signature, {
                    result: function(verified) {
                        AsyncExecutor(callback, function() {
                            // If encrypted, and we were able to verify the data then we better
                            // be able to decrypt it. (An exception is thrown if decryption
                            // fails.)
                            if (verified) {
                                var ciphertext;
                                try {
                                    ciphertext = base64$decode(ciphertextB64);
                                } catch (e) {
                                    throw new MslException(MslError.SERVICETOKEN_SERVICEDATA_INVALID, "servicetokendata " + tokenDataJson, e).setEntity(masterToken).setEntity(userIdToken);
                                }
                                if (!ciphertext || (ciphertextB64.length != 0 && ciphertext.length == 0))
                                    throw new MslException(MslError.SERVICETOKEN_SERVICEDATA_INVALID, "servicetokendata " + tokenDataJson).setEntity(masterToken).setEntity(userIdToken);
                                if (encrypted && ciphertext.length > 0) {
                                    cryptoContext.decrypt(ciphertext, {
                                        result: function(compressedData) {
                                            AsyncExecutor(callback, function() {
                                                var servicedata = (compressionAlgo)
                                                    ? MslUtils$uncompress(compressionAlgo, compressedData)
                                                    : compressedData;
                                                
                                                // Return the new service token.
                                                var creationData = new CreationData(tokendata, signature, verified);
                                                new ServiceToken(ctx, name, servicedata, (mtSerialNumber != -1) ? masterToken : null, (uitSerialNumber != -1) ? userIdToken : null, encrypted, compressionAlgo, cryptoContext, creationData, callback);
                                            });
                                        },
                                        error: function(e) {
                                            AsyncExecutor(callback, function() {
                                                if (e instanceof MslException) {
                                                    e.setEntity(masterToken);
                                                    e.setUser(userIdToken);
                                                }
                                                throw e;
                                            });
                                        }
                                    });
                                } else {
                                    var compressedData = ciphertext;
                                    var servicedata = (compressionAlgo)
                                        ? MslUtils$uncompress(compressionAlgo, compressedData)
                                        : compressedData;

                                    // Return the new service token.
                                    var creationData = new CreationData(tokendata, signature, verified);
                                    new ServiceToken(ctx, name, servicedata, (mtSerialNumber != -1) ? masterToken : null, (uitSerialNumber != -1) ? userIdToken : null, encrypted, compressionAlgo, cryptoContext, creationData, callback);
                                }
                            } else {
                                var servicedata = (ciphertextB64 == "") ? new Uint8Array(0) : null;

                                // Return the new service token.
                                var creationData = new CreationData(tokendata, signature, verified);
                                new ServiceToken(ctx, name, servicedata, (mtSerialNumber != -1) ? masterToken : null, (uitSerialNumber != -1) ? userIdToken : null, encrypted, compressionAlgo, cryptoContext, creationData, callback);
                            }
                        });
                    },
                    error: function(e) {
                        AsyncExecutor(callback, function() {
                            if (e instanceof MslException) {
                                e.setEntity(masterToken);
                                e.setUser(userIdToken);
                            }
                            throw e;
                        });
                    }
                });
            } else {
                var verified = false;
                var servicedata = (ciphertextB64 == "") ? new Uint8Array(0) : null;

                // Return the new service token.
                var creationData = new CreationData(tokendata, signature, verified);
                new ServiceToken(ctx, name, servicedata, (mtSerialNumber != -1) ? masterToken : null, (uitSerialNumber != -1) ? userIdToken : null, encrypted, compressionAlgo, cryptoContext, creationData, callback);
            }
        });
    };
})();


// -- javascript/userauth/UserAuthenticationScheme.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * User authentication schemes.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @enum {string}
 */
var UserAuthenticationScheme = {
    /** Email/password. */
    EMAIL_PASSWORD: "EMAIL_PASSWORD",
    /** Netflix ID cookies. */
    NETFLIXID : "NETFLIXID",
    /** SSO token. */
    SSO: "SSO",
    /** Switch profiles. */
    SWITCH_PROFILE: "SWITCH_PROFILE",
    /** MDX. */
    MDX: "MDX",
};
Object.freeze(UserAuthenticationScheme);



// -- javascript/userauth/UserAuthenticationData.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>The user authentication data provides proof of user identity.</p>
 *
 * <p>Specific user authentication mechanisms should define their own user
 * authentication data types.</p>
 *
 * <p>User authentication data is represented as
 * {@code
 * userauthdata = {
 *   "#mandatory" : [ "scheme"., "authdata" ],
 *   "scheme" : "string",
 *   "authdata" : object
 * }} where
 * <ul>
 * <li>{@code scheme} is the user authentication scheme</li>
 * <li>{@code authdata} is the scheme-specific authentication data</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var UserAuthenticationData;
var UserAuthenticationData$parse;

(function() {
    /**
     * JSON key user authentication scheme.
     * @const
     * @type {string}
     */
    var KEY_SCHEME = "scheme";
    /**
     * JSON key user authentication data.
     * @const
     * @type {string}
     */
    var KEY_AUTHDATA = "authdata";

    UserAuthenticationData = util.Class.create({
        /**
         * Create a new user authentication data object with the specified user
         * authentication scheme.
         *
         * @param {UserAuthenticationScheme} scheme the user authentication scheme.
         * @constructor
         * @interface
         */
        init: function init(scheme) {
            // The properties.
            var props = {
                scheme: { value: scheme, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /**
         * Returns the scheme-specific user authentication data. This method is
         * expected to succeed unless there is an internal error.
         *
         * @return {Object} the authentication data JSON representation.
         * @throws MslEncodingException if there was an error constructing the
         *         JSON representation.
         */
        getAuthData: function() {},

        /**
         * @param {Object} that the object with which to compare.
         * @return {boolean} true if this object is equal to that object.
         */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof UserAuthenticationData)) return false;
            return this.scheme == that.scheme;
        },

        /** @inheritDoc */
        toJSON: function toJSON() {
            var result = {};
            result[KEY_SCHEME] = this.scheme;
            result[KEY_AUTHDATA] = this.getAuthData();
            return result;
        },
    });

    /**
     * <p>Construct a new user authentication data instance of the correct type
     * from the provided JSON object.</p>
     * 
     * <p>A master token may be required for certain user authentication
     * schemes.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken the master token associated with the user
     *        authentication data. May be {@code null}.
     * @param {Object} userAuthJO the JSON object.
     * @param {{result: function(UserAuthenticationData), error: function(Error)}}
     *        callback the callback functions that will receive the user
     *        authentication data or any thrown exceptions.
     * @return {UserAuthenticationData} the user authentication data concrete instance.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslUserAuthException if there is an error instantiating the user
     *         authentication data.
     * @throws MslCryptoException if there is an error with the entity
     *         authentication data cryptography.
     */
    UserAuthenticationData$parse = function UserAuthenticationData$parse(ctx, masterToken, userAuthJO, callback) {
        AsyncExecutor(callback, function() {
            var scheme = userAuthJO[KEY_SCHEME];
            var authdata = userAuthJO[KEY_AUTHDATA];

            // Verify user authentication data.
            if (!scheme || !authdata)
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "userauthdata " + JSON.stringify(userAuthJO));

            // Verify user authentication scheme.
            if (!UserAuthenticationScheme[scheme])
                throw new MslUserAuthException(MslError.UNIDENTIFIED_USERAUTH_SCHEME, scheme);

            // Construct an instance of the concrete subclass.
            var factory = ctx.getUserAuthenticationFactory(scheme);
            if (!factory)
                throw new MslUserAuthException(MslError.USERAUTH_FACTORY_NOT_FOUND, scheme);
            factory.createData(ctx, masterToken, authdata, callback);
        });
    };
})();



// -- javascript/userauth/UserAuthenticationFactory.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A user authentication factory creates authentication data instances and
 * performs authentication for a specific user authentication scheme.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var UserAuthenticationFactory = util.Class.create({
    /**
     * Create a new user authentication factory for the specified scheme.
     *
     * @param scheme the user authentication scheme.
     * @constructor
     * @interface
     */
    init: function init(scheme) {
        // The properties.
        var props = {
            scheme: { value: scheme, writable: false, configurable: false },
        };
        Object.defineProperties(this, props);
    },

    /**
     * <p>Construct a new user authentication data instance from the provided
     * JSON.</p>
     * 
     * <p>A master token may be required for certain user authentication
     * schemes.</p>
     *
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} the entity master token. May be {@code null}.
     * @param {Object} userAuthJO the JSON object.
     * @param {{result: function(UserAuthenticationData), error: function(Error)}}
     *        callback the callback functions that will receive the user
     *        authentication data or any thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslUserAuthException if there is an error creating the user
     *         authentication data.
     * @throws MslCryptoException if there is an error with the user
     *         authentication data cryptography.
     */
    createData: function(ctx, masterToken, entityAuthJO, callback) {},

    /**
     * <p>Authenticate the user using the provided authentication data.</p>
     * 
     * <p>If a user ID token is provided then also validate the authenticated
     * user against the provided user ID token. This is typically a check to
     * ensure the user identities are equal but not always. The returned
     * customer must be the customer identified by the user ID token.</p>
     *
     * @param {MslContet} ctx MSL context.
     * @param {string} identity the entity identity.
     * @param {UserAuthenticationData} data the user authentication data.
     * @param {?UserIdToken} userIdToken user ID token. May be {@code null}.
     * @return {CustomerKey} the Netflix customer.
     * @throws MslUserAuthException if there is an error authenticating the
     *         user.
     */
    authenticate: function(ctx, identity, data, userIdToken) {},
});



// -- javascript/userauth/NetflixIdAuthenticationData.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>NetflixID cookies-based user authentication data.</p>
 *
 * <p>
 * {@code {
 *   "#mandatory" : [ "netflixid" ],
 *   "netflixid" : "string",
 *   "securenetflixid" : "string"
 * } where:
 * <ul>
 * <li>{@code netflixid} is the Netflix ID cookie</li>
 * <li>{@code securenetflixid} is the Secure Netflix ID cookie</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var NetflixIdAuthenticationData;
var NetflixIdAuthenticationData$parse;

(function() {
    /**
     * JSON NetflixId key.
     * @const
     * @type {string}
     */
    var KEY_NETFLIXID = "netflixid";
    /**
     * JSON Secure NetflixId key.
     * @const
     * @type {string}
     */
    var KEY_SECURENETFLIXID = "securenetflixid";

    NetflixIdAuthenticationData = UserAuthenticationData.extend({
        /**
         * Construct a new NetflixID authentication data instance from the provided
         * NetflixID cookies.
         *
         * @param {string} netflixId the NetflixID cookie.
         * @param {string} secureNetflixId the Secure NetflixID cookie. May be null.
         */
        init: function init(netflixId, secureNetflixId) {
            init.base.call(this, UserAuthenticationScheme.NETFLIXID);

            // The properties.
            var props = {
                netflixId: { value: netflixId, writable: false, configurable: false },
                secureNetflixId: { value: secureNetflixId, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getAuthData: function getAuthData() {
            var result = {};
            result[KEY_NETFLIXID] = this.netflixId;
            if (this.secureNetflixId) result[KEY_SECURENETFLIXID] = this.secureNetflixId;
            return result;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof NetflixIdAuthenticationData)) return false;
            return (equals.base.call(this, that) &&
                    this.netflixId == that.netflixId &&
                    this.secureNetflixId == that.secureNetflixId);
        },
    });

    /**
     * Construct a new NetflixID authentication data instance from the provided
     * JSON representation.
     *
     * @param {Object} netflixIdAuthJO the JSON object.
     * @throws MslEncodingException if there is an error parsing the JSON.
     */
    NetflixIdAuthenticationData$parse = function NetflixIdAuthenticationData$parse(netflixIdAuthJO) {
        var netflixId = netflixIdAuthJO[KEY_NETFLIXID];
        var secureNetflixId = netflixIdAuthJO[KEY_SECURENETFLIXID];

        // Verify authentication data.
        if (!netflixId)
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "NetflixId authdata " + JSON.stringify(netflixIdAuthJO));

        // Return the authentication data.
        return new NetflixIdAuthenticationData(netflixId, secureNetflixId);
    };
})();



// -- javascript/userauth/NetflixIdAuthenticationFactory.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Netflix ID cookies-based user authentication factory.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var NetflixIdAuthenticationFactory = UserAuthenticationFactory.extend({
    /**
     * Construct a new Netflix ID cookies-based user authentication factory.
     */
    init: function init() {
        init.base.call(this, UserAuthenticationScheme.NETFLIXID);
    },

    /** @inheritDoc */
    createData: function createData(ctx, masterToken, userAuthJO, callback) {
        AsyncExecutor(callback, function() {
            return NetflixIdAuthenticationData$parse(userAuthJO);
        });
    },

    /** @inheritDoc */
    authenticate: function authenticate(ctx, identity, data, userIdToken) {
        // Make sure we have the right kind of user authentication data.
        if (!(data instanceof NetflixIdAuthenticationData))
            throw new MslInternalException("Incorrect authentication data type " + data + ".");

        // Extract and check cookie values.
        var netflixId = data.netflixId;
        var secureNetflixId = data.secureNetflixId;
        if (!netflixId || !secureNetflixId)
            throw new MslUserAuthException(MslError.NETFLIXID_COOKIES_BLANK).setUser(data);

        // Nothing to authenticate against.
        throw new MslUserAuthException(MslError.UNSUPPORTED_USERAUTH_DATA, this.scheme).setUser(data);
    },
});



// -- javascript/userauth/EmailPasswordAuthenticationData.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>Email/password-based user authentication data.</p>
 *
 * <p>
 * {@code {
 *   "#mandatory" : [ "email", "password" ],
 *   "email" : "string",
 *   "password" : "string"
 * }} where:
 * <ul>
 * <li>{@code email} is the user email address</li>
 * <li>{@code password} is the user password</li>
 * </ul></p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var EmailPasswordAuthenticationData;
var EmailPasswordAuthenticationData$parse;

(function() {
    /**
     * JSON email key.
     * @const
     * @type {string}
     */
    var KEY_EMAIL = "email";
    /**
     * JSON password key.
     * @const
     * @type {string}
     */
    var KEY_PASSWORD = "password";

    EmailPasswordAuthenticationData = UserAuthenticationData.extend({
        /**
         * Construct a new email/password authentication data instance from the
         * specified email and password.
         *
         * @param {string} email the email address.
         * @param {string} password the password.
         */
        init: function init(email, password) {
            init.base.call(this, UserAuthenticationScheme.EMAIL_PASSWORD);

            // The properties.
            var props = {
                email: { value: email, writable: false, configurable: false },
                password: { value: password, writable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getAuthData: function getAuthData() {
            var result = {};
            result[KEY_EMAIL] = this.email;
            result[KEY_PASSWORD] = this.password;
            return result;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof EmailPasswordAuthenticationData)) return false;
            return (equals.base.call(this, this, that) && this.email == that.email && this.password == that.password);
        },
    });

    /**
     * Construct a new email/password authentication data instance from the
     * provided JSON representation.
     *
     * @param {Object} emailPasswordAuthJO the JSON object.
     * @throws MslEncodingException if there is an error parsing the JSON.
     */
    EmailPasswordAuthenticationData$parse = function EmailPasswordAuthenticationData$parse(emailPasswordAuthJO) {
        var email = emailPasswordAuthJO[KEY_EMAIL];
        var password = emailPasswordAuthJO[KEY_PASSWORD];

        // Verify authentication data.
        if (!email || !password)
            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "email/password authdata " + JSON.stringify(emailPasswordAuthJO));

        // Return the authentication data.
        return new EmailPasswordAuthenticationData(email, password);
    };
})();



// -- javascript/userauth/EmailPasswordAuthenticationFactory.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Email/password-based user authentication factory.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var EmailPasswordAuthenticationFactory = UserAuthenticationFactory.extend({
    /**
     * Construct a new email/password-based user authentication factory.
     */
    init: function init() {
        init.base.call(this, UserAuthenticationScheme.EMAIL_PASSWORD);
    },

    /** @inheritDoc */
    createData: function createData(ctx, masterToken, userAuthJO, callback) {
        AsyncExecutor(callback, function() {
            return EmailPasswordAuthenticationData$parse(userAuthJO);
        });
    },

    /** @inheritDoc */
    authenticate: function authenticate(ctx, identity, data, userIdToken) {
        // Make sure we have the right kind of user authentication data.
        if (!(data instanceof EmailPasswordAuthenticationData))
            throw new MslInternalException("Incorrect authentication data type " + data + ".");

        // Extract and check email and password values.
        var email = data.email;
        var password = data.password;
        if (!email || !password)
            throw new MslUserAuthException(MslError.EMAILPASSWORD_BLANK).setUser(data);

        // Nothing to authenticate against.
        throw new MslUserAuthException(MslError.UNSUPPORTED_USERAUTH_DATA, this.scheme).setUser(data);
    },
});



// -- javascript/userauth/MdxAuthenticationData.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>MDX user authentication data. The authentication data is a mix of target-
 * and controller-produced data.</p>
 * 
 * <p>
 * {@code {
 *   "#mandatory" : [ "pin", "mdxauthdata", "signature" ],
 *   "#conditions" : [ mastertoken xor cticket ],
 *   "mastertoken" : mastertoken,
 *   "cticket" : "base64",
 *   "pin" : "string",
 *   "mdxauthdata" : "base64",
 *   "signature" : "base64"
 * } where: 
 * <ul>
 * <li>{@code mastertoken} is the controller master token</li>
 * <li>{@code cticket} is the Base64-encoded controller CTicket or MSL token construct</li>
 * <li>{@code pin} is the target PIN</li>
 * <li>{@code mdxauthdata} is the controller-produced Base64-encoded MDX authentication data (mdxauthdata)</li>
 * <li>{@code signature} is the controller-produced Base64-encoded verification data of the MDX authentication data</li>
 * </ul></p>
 * 
 * <p>The MSL token construct which may be used instead of the CTicket is
 * defined as follows: 1,[mastertoken],[useridtoken] where the master token and
 * user ID token JSON string representations are Base64-encoded.</p>
 * 
 * <p>The MDX authentication data is entirely controller-produced and
 * represented different depending on the controller type. MSL-based
 * controllers use a master token and compute the signature using the master
 * token HMAC key over the MDX authentication data. NTBA-based controllers use
 * a CTicket and compute the signature using the CTicket HMAC key over the MDX
 * authentication data values in canonical form; canonical form is defined as
 * name1=value&name2=value in alphabetical order by name, with names and values
 * URL-encoded.</p>
 * 
 * <p>MSL-based controllers may also use the legacy NTBA-based authentication
 * data with a MSL token construct instead of a CTicket. The signature is
 * computed using the master token HMAC key over the MDX authentication data
 * values in canonical form.</p>
 * 
 * <p>MSL-based controllers represent the MDX authentication data as JSON
 * {@code
 * mdxauthdata = {
 *   "#mandatory" : [ "useridtoken", "action", "nonce", "pin" ],
 *   "useridtoken" : useridtoken,
 *   "action" : "string",
 *   "nonce" : "int64(0,-)"
 *   "pin" : "base64",
 * } where:
 * <ul>
 * <li>{@code useridtoken} is the controller user ID token</li>
 * <li>{@code action} is expected to be the string value 'userauth'</li>
 * <li>{@code nonce} is the controller authorization nonce</li>
 * <li>{@code pin} is the Base64-encoded master token-based encrypted controller PIN</li>
 * </ul></p>
 * 
 * <p>NTBA-based controllers represent the MDX authentication data as XML
 * {@code
 * mdxauthdata =
 * <registerdata>
 *   <action>regpairrequest</action>
 *   <nonce>531151</nonce>
 *   <pin>aWtza21...</pin>
 * </registerdata>
 * } where:
 * <ul>
 * <li>{@code action} is expected to be the string value 'regpairrequst'</li>
 * <li>{@code nonce} is the controller authorization nonce</li>
 * <li>{@code pin} is the Base64-encoded CTicket-based encrypted controller PIN</li>
 * </ul></p>
 * 
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MdxAuthenticationData;
var MdxAuthenticationData$parse;
var MdxAuthenticationData$Mechanism;

// MSL-based controller authentication data.
var MdxAuthenticationData$MslControllerData;
var MdxAuthenticationData$MslControllerData$create;
var MdxAuthenticationData$MslControllerData$parse;

// NTBA-based controller authentication data.
var MdxAuthenticationData$NtbaControllerData;
var MdxAuthenticationData$NtbaControllerData$create;
var MdxAuthenticationData$NtbaControllerData$parse;

// MSL-based controller legacy authentication data.
var MdxAuthenticationData$MslLegacyControllerData;
var MdxAuthenticationData$MslLegacyControllerData$create;
var MdxAuthenticationData$MslLegacyControllerData$parse;

(function() {
    "use strict";
    
    /**
     * UTF-8 URL encoding.
     * @const
     * @type {string}
     */
    var UTF_8 = "utf-8";
    
    /**
     * MSL-based legacy authentication data version index.
     * @const
     * @type {number}
     */
    var LEGACY_VERSION_INDEX = 0;
    /**
     * MSL-based legacy authentication data master token index.
     * @const
     * @type {number}
     */
    var LEGACY_MASTERTOKEN_INDEX = 1;
    /**
     * MSL-based legacy authentication data user ID token index.
     * @const
     * @type {number}
     */
    var LEGACY_USERIDTOKEN_INDEX = 2;
    /**
     * MSL-based legacy authentication data version 1.
     * @const
     * @type {number}
     */
    var LEGACY_VERSION_1 = "1";
    
    /**
     * JSON key master token.
     * @const
     * @type {string}
     */
    var KEY_MASTER_TOKEN = "mastertoken";
    /**
     * JSON key CTicket.
     * @const
     * @type {string}
     */
    var KEY_CTICKET = "cticket";
    /**
     * JSON/XML key PIN.
     * @const
     * @type {string}
     */
    var KEY_PIN = "pin";
    /**
     * JSON key MDX authentication data.
     * @const
     * @type {string}
     */
    var KEY_MDX_AUTHENTICATION_DATA = "mdxauthdata";
    /**
     * JSON key signature.
     * @const
     * @type {string}
     */
    var KEY_SIGNATURE = "signature";
    
    // mdxauthdata
    /**
     * XML key register data.
     * @const
     * @type {string}
     */
    var KEY_REGISTER_DATA = "registerdata";
    /**
     * JSON key user ID token.
     * @const
     * @type {string}
     */
    var KEY_USER_ID_TOKEN = "useridtoken";
    /**
     * JSON/XML key action.
     * @const
     * @type {string}
     */
    var KEY_ACTION = "action";
    /**
     * JSON/XML key nonce.
     * @const
     * @type {string}
     */
    var KEY_NONCE = "nonce";
    
    /**
     * MDX controller authentication data mechanism.
     * @enum
     */
    var Mechanism = MdxAuthenticationData$Mechanism = {
        /** MSL-based controller authentication data. */
        MSL: "MSL",
        /** NTBA-based controller authentication data. */
        NTBA: "NTBA",
        /** MSL-based controller legacy authentication data. */
        MSL_LEGACY: "MSL_LEGACY",
    };
    
    /**
     * Controller MDX authentication data.
     */
    var ControllerData = util.Class.create({
        /**
         * @return {string} the action.
         */
        getAction: function() {},
        
        /**
         * @return {number} the nonce.
         */
        getNonce: function() {},
        
        /**
         * @return {string} the PIN or {@code null} if the MDX target and thus unknown.
         */
        getPin: function() {},
        
        /**
         * @return {Uint8Array} the signature.
         */
        getSignature: function() {},
        
        /**
         * Returns the authentication data with encrypted PIN.
         * 
         * @return {Uint8Array} the authentication data byte encoding.
         * @throws MslEncodingException if there is an error creating the
         *         encoding.
         */
        getEncoding: function() {},
        
        /**
         * @param {Object} that the object with which to compare.
         * @return {boolean} true if this object is equal to that object.
         */
        equals: function() {},
    });
    
    /**
     * MSL-based controller MDX authentication data.
     */
    var MslControllerData = MdxAuthenticationData$MslControllerData = ControllerData.extend({
        /**
         * Create a new MSL-based authentication data instance with the
         * provided controller data. The controller master token crypto context
         * will be used to compute the signature.
         * 
         * @param {UserIdToken} userIdToken controller user ID token.
         * @param {string} action controller action.
         * @param {number} nonce controller nonce.
         * @param {String} pin controller PIN.
         * @param {?ICryptoContext} cryptoContext controller master token crypto context.
         * @param {?{encoding: Uint8Array, signature: Uint8Array}=} creationData
         *        optional creation data.
         * @param {{result: function(MslControllerData), error: function(Error)}}
         *        callback the callback functions that will receive the
         *        controller authentication data or any thrown exceptions.
         * @throws MslCryptoException if there is an error encrypting the PIN
         *         or computing the signature.
         * @throws MslEncodingException if there is an error encoding the data.
         */
        init: function init(userIdToken, action, nonce, pin, cryptoContext, creationData, callback) {
            var self = this;
            
            AsyncExecutor(callback, function() {
                // Construct the authentication data.
                if (!creationData) {
                    // Encrypt the PIN.
                    cryptoContext.encrypt(textEncoding$getBytes(pin, MslConstants$DEFAULT_CHARSET), {
                        result: function(encryptedPin) {
                            sign(encryptedPin);
                        },
                        error: callback.error,
                    });
                } else {
                    construct(creationData.encoding, creationData.signature);
                }
            }, self);
            
            function sign(encryptedPin) {
                AsyncExecutor(callback, function() {
                    // Compute the signature.
                    var encoding;
                    try {
                        var jsonObj = {};
                        jsonObj[KEY_USER_ID_TOKEN] = userIdToken;
                        jsonObj[KEY_ACTION] = action;
                        jsonObj[KEY_NONCE] = nonce;
                        jsonObj[KEY_PIN] = base64$encode(encryptedPin);
                        encoding = textEncoding$getBytes(JSON.stringify(jsonObj), MslConstants$DEFAULT_CHARSET);
                    } catch (e) {
                        throw new MslEncodingException(MslError.JSON_ENCODE_ERROR, "MSL-based MDX authdata", e);
                    }
                    cryptoContext.sign(encoding, {
                        result: function(signature) {
                            construct(encoding, signature);
                        },
                        error: callback.error,
                    });
                }, self);
            }
            
            function construct(encoding, signature) {
                AsyncExecutor(callback, function() {
                     // The properties.
                    var props = {
                        /** @type {UserIdToken} */
                        _userIdToken: { value: userIdToken, writable: false, enumerable: false, configurable: false },
                        /** @type {string} */
                        _action: { value: action, writable: false, enumerable: false, configurable: false },
                        /** @type {number} */
                        _nonce: { value: nonce, writable: false, enumerable: false, configurable: false },
                        /** @type {string} */
                        _pin: { value: pin, writable: false, enumerable: false, configurable: false },
                        /** @type {Uint8Array} */
                        _encoding: { value: encoding, writable: false, enumerable: false, configurable: false },
                        /** @type {Uint8Array} */
                        _signature: { value: signature, writable: false, enumerable: false, configurable: false },
                    };
                    Object.defineProperties(this, props);
                    return this;
                }, self);
            }
        },
        
        /**
         * @return {UserIdToken} the user ID token.
         */
        getUserIdToken: function getUserIdToken() {
            return this._userIdToken;
        },
        
        /** @inheritDoc */
        getAction: function getAction() {
            return this._action;
        },
        
        /** @inheritDoc */
        getNonce: function getNonce() {
            return this._nonce;
        },
        
        /** @inheritDoc */
        getPin: function getPin() {
            return this._pin;
        },
        
        /** @inheritDoc */
        getSignature: function getSignature() {
            return this._signature;
        },

        /** @inheritDoc */
        getEncoding: function getEncoding() {
            return this._encoding;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof MslControllerData)) return false;
            return this._action == that._action &&
                this._nonce == that._nonce &&
                this._pin == that._pin &&
                this._userIdToken.equals(that._userIdToken);
        },
    });
    
    /** Expose MSL controller action. */
    MdxAuthenticationData$MslControllerData.ACTION = "userauth";
    
    /**
     * Create a new MSL-based authentication data instance with the
     * provided controller data. The controller master token crypto context
     * will be used to compute the signature.
     * 
     * @param {UserIdToken} userIdToken controller user ID token.
     * @param {string} action controller action.
     * @param {number} nonce controller nonce.
     * @param {String} pin controller PIN.
     * @param {ICryptoContext} cryptoContext controller master token crypto context.
     * @param {{result: function(MslControllerData), error: function(Error)}}
     *        callback the callback functions that will receive the
     *        controller authentication data or any thrown exceptions.
     * @throws MslCryptoException if there is an error encrypting the PIN
     *         or computing the signature.
     * @throws MslEncodingException if there is an error encoding the data.
     */
    var MslControllerData$create = MdxAuthenticationData$MslControllerData$create = function MdxAuthenticationData$MslControllerData$create(userIdToken, action, nonce, pin, cryptoContext, callback) {
        new MslControllerData(userIdToken, action, nonce, pin, cryptoContext, null, callback);
    };
    
    /**
     * Create a new MSL-based authentication data instance from the
     * provided controller authentication data.
     * 
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken controller master token.
     * @param {Uint8Array} encoding encoded MSL-based MDX authentication data.
     * @param {Uint8Array} signature authentication data verification data.
     * @param {{result: function(MslControllerData), error: function(Error)}}
     *        callback the callback functions that will receive the
     *        controller authentication data or any thrown exceptions.
     * @throws MslCryptoException if there is an error verifying or
     *         decrypting the data.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslUserAuthException if there is an error with the user ID
     *         token or the user ID token could not be decrypted.
     */
    var MslControllerData$parse = MdxAuthenticationData$MslControllerData$parse = function MdxAuthenticationData$MslControllerData$parse(ctx, masterToken, encoding, signature, callback) {
        AsyncExecutor(callback, function() {
            // Verify the authentication data.
            var cryptoContext;
            try {
                var store = ctx.getMslStore();
                var cachedCryptoContext = store.getCryptoContext(masterToken);
                if (cachedCryptoContext)
                    cryptoContext = cachedCryptoContext;
                else
                    cryptoContext = new SessionCryptoContext(ctx, masterToken);
            } catch (e) {
                if (e instanceof MslMasterTokenException)
                    throw new MslUserAuthException(MslError.USERAUTH_MASTERTOKEN_NOT_DECRYPTED, "MDX authdata " + base64$encode(encoding));
                throw e;
            }
            cryptoContext.verify(encoding, signature, {
                result: function(verified) {
                    AsyncExecutor(callback, function() {
                        if (!verified)
                            throw new MslCryptoException(MslError.MDX_USERAUTH_VERIFICATION_FAILED, "MDX authdata " + base64$encode(encoding));
                        parseAuthData(cryptoContext);
                    });
                },
                error: callback.error,
            });
        });
        
        function parseAuthData(cryptoContext) {
            AsyncExecutor(callback, function() {
                // Parse the authentication data.
                var authdata = textEncoding$getString(encoding, MslConstants$DEFAULT_CHARSET);
                
                // Extract values.
                var userIdTokenJO, action, nonce, encryptedPinB64;
                try {
                    var authdataJO = JSON.parse(authdata);
                    userIdTokenJO = authdataJO[KEY_USER_ID_TOKEN];
                    action = authdataJO[KEY_ACTION];
                    nonce = authdataJO[KEY_NONCE];
                    encryptedPinB64 = authdataJO[KEY_PIN];
                } catch (e) {
                    if (e instanceof SyntaxError)
                        throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "MDX authdata " + authdata, e);
                    throw e;
                }

                // Validate values.
                if (!userIdTokenJO || typeof userIdTokenJO !== 'object' ||
                    !action || typeof action !== 'string' ||
                    !nonce || typeof nonce !== 'number' ||
                    !encryptedPinB64 || typeof encryptedPinB64 !== 'string')
                {
                    throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "MDX authdata " + authdata);
                }

                // Create user ID token.
                UserIdToken$parse(ctx, userIdTokenJO, masterToken, {
                    result: function(userIdToken) {
                        AsyncExecutor(callback, function() {
                            if (!userIdToken.isDecrypted())
                                throw new MslUserAuthException(MslError.USERAUTH_USERIDTOKEN_NOT_DECRYPTED, "MDX authdata " + authdata);
                            decryptPin(cryptoContext, userIdToken, action, nonce, encryptedPinB64);
                        });
                    },
                    error: function(e) {
                        AsyncExecutor(callback, function() {
                            if (e instanceof MslException)
                                throw new MslUserAuthException(MslError.USERAUTH_USERIDTOKEN_INVALID, "MDX authdata " + authdata, e);
                            throw e;
                        });
                    }
                });
            });
        }
        
        function decryptPin(cryptoContext, userIdToken, action, nonce, encryptedPinB64) {
            AsyncExecutor(callback, function() {
                // Decrypt pin.
                var encryptedPin = base64$decode(encryptedPinB64);
                cryptoContext.decrypt(encryptedPin, {
                    result: function(pinBytes) {
                        AsyncExecutor(callback, function() {
                            var pin = textEncoding$getString(pinBytes, MslConstants$DEFAULT_CHARSET);
                            var creationData = { encoding: encoding, signature: signature };
                            new MslControllerData(userIdToken, action, nonce, pin, null, creationData, callback);
                        });
                    },
                    error: callback.error,
                });
            });
        }
    };
    
    /**
     * Returns a simple XML element with the specified name and value. The
     * value is not encoded.
     * 
     * @param {string} element XML element name.
     * @param {string} value XML element value.
     * @return {string} the new XML element.
     */
    function createXmlElement(element, value) {
        return "<" + element + ">" + value + "</" + element + ">";
    }

    /** XML escape character mapping. */
    var XML_CHAR_MAP = {
        '<': '&lt;',
        '>': '&gt;',
        '&': '&amp;',
        '"': '&quot;',
        "'": '&apos;'
    };
    
    /**
     * Escapes a string using XML entities. Only escapes &gt;, &lt;, &quot;,
     * &amp;, and &apos;.
     * 
     * This matches the behavior of
     * {@code org.apache.commons.lang.StringEscapeUtils#escapeXml(java.lang.String)}.
     * 
     * @param {string} value value to escape.
     * @returns the XML escaped value.
     */
    function escapeXml(value) {
        return value.replace(/[<>&"']/g, function(c) { return XML_CHAR_MAP[c]; });
    }
    
    /**
     * Returns the proper URL encoding of a string value. The operation
     * performed conforms to RFC 3986 and the {@code java.net.URLEncoder}
     * class.
     * 
     * @param {string} value value to encode.
     * @returns the URL encoded value.
     */
    function urlEncode(value) {
        return encodeURIComponent(value).replace('%20', '+').replace(/[!'()]/g, escape).replace(/\*/g, "%2A");
    }
    
    /**
     * NTBA-based controller MDX authentication data.
     */
    var NtbaControllerData = MdxAuthenticationData$NtbaControllerData = ControllerData.extend({
        /**
         * Create a new NTBA-based authentication data instance with the
         * provided controller data. The decrypted PIN will be unknown.
         * 
         * @param {string} action controller action.
         * @param {number} nonce controller nonce.
         * @param {string} encryptedPinB64 Base64-encoded controller encrypted PIN.
         * @param {Uint8Array} signature controller-computed signature.
         */
        init: function init(action, nonce, encryptedPinB64, signature) {
            // Construct the encoding.
            var actionXml = createXmlElement(KEY_ACTION, escapeXml(action));
            var nonceXml = createXmlElement(KEY_NONCE, nonce.toString());
            var pinXml = createXmlElement(KEY_PIN, encryptedPinB64);
            var registerDataXml = createXmlElement(KEY_REGISTER_DATA, actionXml + nonceXml + pinXml);
            var encoding = textEncoding$getBytes(registerDataXml, UTF_8);
            
            // The properties.
            var props = {
                /** @type {string} */
                _action: { value: action, writable: false, enumerable: false, configurable: false },
                /** @type {number} */
                _nonce: { value: nonce, writable: false, enumerable: false, configurable: false },
                /** @type {string} */
                _pin: { value: null, writable: false, enumerable: false, configurable: false },
                /** @type {Uint8Array} */
                _encoding: { value: encoding, writable: false, enumerable: false, configurable: false },
                /** @type {Uint8Array} */
                _signature: { value: signature, writable: false, enumerable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },
        
        /** @inheritDoc */
        getAction: function getAction() {
            return this._action;
        },
        
        /** @inheritDoc */
        getNonce: function getNonce() {
            return this._nonce;
        },
        
        /** @inheritDoc */
        getPin: function getPin() {
            return this._pin;
        },
        
        /** @inheritDoc */
        getSignature: function getSignature() {
            return this._signature;
        },

        /** @inheritDoc */
        getEncoding: function getEncoding() {
            return this._encoding;
        },
        
        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof NtbaControllerData)) return false;
            return this._action == that._action &&
                this._nonce == that._nonce &&
                this._pin == that._pin;
        }, 
    });
    
    /** Expose NTBA controller action. */
    MdxAuthenticationData$NtbaControllerData.ACTION = "regpairrequest";
    
    /**
     * Create a new NTBA-based authentication data instance with the
     * provided controller data. The decrypted PIN will be unknown.
     * 
     * @param {string} action controller action.
     * @param {number} nonce controller nonce.
     * @param {string} encryptedPinB64 Base64-encoded controller encrypted PIN.
     * @param {Uint8Array} signature controller-computed signature.
     * @param {{result: function(NtbaControllerData), error: function(Error)}}
     *        callback the callback functions that will receive the
     *        controller authentication data or any thrown exceptions.
     */
    var NtbaControllerData$create = MdxAuthenticationData$NtbaControllerData$create = function MdxAuthenticationData$NtbaControllerData$create(action, nonce, encryptedPinB64, signature, callback) {
        AsyncExecutor(callback, function() {
            return new NtbaControllerData(action, nonce, encryptedPinB64, signature);
        });
    };
    
    /**
     * Create a new NTBA-based authentication data instance from the
     * provided controller authentication data.
     * 
     * @param {CTicket} cTicket controller CTicket.
     * @param {Uint8Array} encoding encoded NTBA-based MDX authentication data.
     * @param {Uint8Array} signature authentication data verification data.
     * @param {{result: function(NtbaControllerData), error: function(Error)}}
     *        callback the callback functions that will receive the
     *        controller authentication data or any thrown exceptions.
     * @throws MslUserAuthException always as this operation is not supported.
     */
    var NtbaControllerData$parse = MdxAuthenticationData$NtbaControllerData$parse = function MdxAuthenticationData$NtbaControllerData$parse(cTicket, encoding, signature, callback) {
        AsyncExecutor(callback, function() {
            throw new MslUserAuthException(MslError.UNSUPPORTED_USERAUTH_MECHANISM, "NtbaControllerData$parse");
        });
    };
    
    /**
     * MSL-based controller MDX legacy authentication data.
     */
    var MslLegacyControllerData = MdxAuthenticationData$MslLegacyControllerData = ControllerData.extend({
        /**
         * Create a new MSL-based legacy authentication data instance with the
         * provided controller data. The controller master token crypto context
         * will be used to compute the signature.
         * 
         * @param {string} action controller action.
         * @param {number} nonce controller nonce.
         * @param {string} pin controller PIN.
         * @param {?ICryptoContext} cryptoContext controller master token crypto context.
         * @param {?{encoding: Uint8Array, signature: Uint8Array}} creationData
         *        optional creation data.
         * @param {{result: function(MslControllerData), error: function(Error)}}
         *        callback the callback functions that will receive the
         *        controller authentication data or any thrown exceptions.
         * @throws MslCryptoException if there is an error encrypting the PIN or
         *         computing the signature.
         */
        init: function init(action, nonce, pin, cryptoContext, creationData, callback) {
            var self = this;
            
            AsyncExecutor(callback, function() {
                // Construct the authentication data.
                if (!creationData) {
                    // Encrypt the PIN.
                    cryptoContext.encrypt(textEncoding$getBytes(pin, UTF_8), {
                        result: function(encryptedPin) {
                            sign(encryptedPin);
                        },
                        error: callback.error,
                    });
                } else {
                    construct(creationData.encoding, creationData.signature);
                }
            }, self);
            
            function sign(encryptedPin) {
                AsyncExecutor(callback, function() {
                    var encryptedPinB64 = base64$encode(encryptedPin);
                    
                    // Construct the encoding.
                    var actionXml = createXmlElement(KEY_ACTION, escapeXml(action));
                    var nonceXml = createXmlElement(KEY_NONCE, nonce.toString());
                    var pinXml = createXmlElement(KEY_PIN, encryptedPinB64);
                    var registerDataXml = createXmlElement(KEY_REGISTER_DATA, actionXml + nonceXml + pinXml);
                    var encoding = textEncoding$getBytes(registerDataXml, UTF_8);
                    
                    // Compute the signature.
                    var canonical = KEY_ACTION + "=" + urlEncode(action) +
                        "&" + KEY_NONCE + "=" + urlEncode(nonce.toString()) +
                        "&" + KEY_PIN + "=" + urlEncode(encryptedPinB64);
                    cryptoContext.sign(textEncoding$getBytes(canonical, UTF_8), {
                        result: function(signature) {
                            construct(encoding, signature);
                        },
                        error: callback.error,
                    });
                }, self);
            }
            
            function construct(encoding, signature) {
                AsyncExecutor(callback, function() {
                     // The properties.
                    var props = {
                        /** @type {string} */
                        _action: { value: action, writable: false, enumerable: false, configurable: false },
                        /** @type {number} */
                        _nonce: { value: nonce, writable: false, enumerable: false, configurable: false },
                        /** @type {string} */
                        _pin: { value: pin, writable: false, enumerable: false, configurable: false },
                        /** @type {Uint8Array} */
                        _encoding: { value: encoding, writable: false, enumerable: false, configurable: false },
                        /** @type {Uint8Array} */
                        _signature: { value: signature, writable: false, enumerable: false, configurable: false },
                    };
                    Object.defineProperties(this, props);
                    return this;
                }, self);
            }
        },
        
        /** @inheritDoc */
        getAction: function getAction() {
            return this._action;
        },
        
        /** @inheritDoc */
        getNonce: function getNonce() {
            return this._nonce;
        },
        
        /** @inheritDoc */
        getPin: function getPin() {
            return this._pin;
        },
        
        /** @inheritDoc */
        getSignature: function getSignature() {
            return this._signature;
        },

        /** @inheritDoc */
        getEncoding: function getEncoding() {
            return this._encoding;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof MslLegacyControllerData)) return false;
            return this._action == that._action &&
                this._nonce == that._nonce &&
                this._pin == that._pin;
        },
    });
    
    /** Expose MSL legacy controller action. */
    MdxAuthenticationData$MslLegacyControllerData.ACTION = MdxAuthenticationData$NtbaControllerData.ACTION;
    
    /**
     * Create a new MSL-based legacy authentication data instance with the
     * provided controller data. The controller master token crypto context
     * will be used to compute the signature.
     * 
     * @param {string} action controller action.
     * @param {number} nonce controller nonce.
     * @param {string} pin controller PIN.
     * @param {?ICryptoContext} cryptoContext controller master token crypto context.
     * @param {{result: function(MslControllerData), error: function(Error)}}
     *        callback the callback functions that will receive the
     *        controller authentication data or any thrown exceptions.
     * @throws MslCryptoException if there is an error encrypting the PIN or
     *         computing the signature.
     */
    var MslLegacyControllerData$create = MdxAuthenticationData$MslLegacyControllerData$create = function MdxAuthenticationData$MslLegacyControllerData$create(action, nonce, pin, cryptoContext, callback) {
        AsyncExecutor(callback, function() {
            new MslLegacyControllerData(action, nonce, pin, cryptoContext, null, callback);
        });
    };
    
    /**
     * Create a new MSL-based legacy authentication data instance with the
     * provided controller authentication data.
     * 
     * @param {MslContext} ctx MSL context.
     * @param {MasterToken} masterToken controller master token.
     * @param {Uint8Array} encoding encoded MSL-based MDX legacy authentication data.
     * @param {Uint8Array} signature authentication data verification data.
     * @param {{result: function(MslControllerData), error: function(Error)}}
     *        callback the callback functions that will receive the
     *        controller authentication data or any thrown exceptions.
     * @throws MslCryptoException if there is an error verifying or
     *         decrypting the data.
     * @throws MslEncodingException if there is an error parsing the XML.
     * @throws MslMasterTokenException if the master token is not trusted.
     */
    var MslLegacyControllerData$parse = MdxAuthenticationData$MslLegacyControllerData$parse = function MdxAuthenticationData$MslLegacyControllerData$parse(ctx, masterToken, encoding, signature, callback) {
        AsyncExecutor(callback, function() {
            // Create the crypto context.
            var store = ctx.getMslStore();
            var cachedCryptoContext = store.getCryptoContext(masterToken);
            var cryptoContext = (cachedCryptoContext) ? cachedCryptoContext : new SessionCryptoContext(ctx, masterToken);
            
            // Parse the authentication data.
            var xml = textEncoding$getString(encoding, UTF_8);
            var parser = new DOMParser();
            var doc = parser.parseFromString(xml, "application/xml");
            var actions = doc.getElementsByTagName(KEY_ACTION);
            var nonces = doc.getElementsByTagName(KEY_NONCE);
            var pins = doc.getElementsByTagName(KEY_PIN);
            var action = (actions && actions.length == 1 && actions[0].firstChild) ? actions[0].firstChild.nodeValue : null;
            var nonce = (nonces && nonces.length == 1 && nonces[0].firstChild) ? parseInt(nonces[0].firstChild.nodeValue) : null;
            var encryptedPinB64 = (pins && pins.length == 1 && pins[0].firstChild) ? pins[0].firstChild.nodeValue : null;
            if (!action || !nonce || !encryptedPinB64)
                throw new MslEncodingException(MslError.XML_PARSE_ERROR, "MDX authdata " + base64$encode(encoding));
            
            // Construct the canonical representation.
            var canonical = KEY_ACTION + "=" + urlEncode(action) +
                "&" + KEY_NONCE + "=" + urlEncode(nonce.toString()) +
                "&" + KEY_PIN + "=" + urlEncode(encryptedPinB64);
            
            // Verify the authentication data.
            cryptoContext.verify(textEncoding$getBytes(canonical, UTF_8), signature, {
                result: function(verified) {
                    AsyncExecutor(callback, function() {
                        if (!verified)
                            throw new MslCryptoException(MslError.MDX_USERAUTH_VERIFICATION_FAILED, "MDX authdata " + base64$encode(encoding));
                        
                        // Decrypt pin.
                        var encryptedPin = base64$decode(encryptedPinB64);
                        cryptoContext.decrypt(encryptedPin, {
                            result: function(decryptedPin) {
                                AsyncExecutor(callback, function() {
                                    var pin = textEncoding$getString(decryptedPin, UTF_8);
                                    var creationData = { encoding: encoding, signature: signature };
                                    new MslLegacyControllerData(action, nonce, pin, null, creationData, callback);
                                });
                            },
                            error: callback.error,
                        });
                    });
                },
                error: callback.error,
            });
        });
    };
    
    MdxAuthenticationData = UserAuthenticationData.extend({
        /**
         * Construct a new MDX authentication data instance from the provided MSL-
         * based controller data.
         * 
         * @param {MslContext} ctx MSL context.
         * @param {string} pin target PIN.
         * @param {MasterToken|Uint8Array|string} controllerToken controller master
         *        token, CTicket (in encrypted binary form), or MSL token
         *        construct.
         * @param {Uint8Array} mdxAuthData controller MDX authentication data encoding.
         * @param {Uint8Array} signature controller MDX authentication data signature.
         * @param {?{controllerAuthData: ControllerData, userIdToken: ?UserIdToken}}
         *        creationData optional creation data.
         */
        init: function init(ctx, pin, controllerToken, mdxAuthData, signature, creationData) {
            init.base.call(this, UserAuthenticationScheme.MDX);

            // Determine the controller token type.
            var mechanism;
            var masterToken = null,
                encryptedCTicket = null,
                mslTokens = null;
            if (typeof controllerToken === 'string') {
                mechanism = Mechanism.MSL_LEGACY;
                mslTokens = controllerToken;
            } else if (controllerToken instanceof Uint8Array) {
                mechanism = Mechanism.NTBA;
                encryptedCTicket = controllerToken;
            } else if (controllerToken instanceof MasterToken) {
                mechanism = Mechanism.MSL;
                masterToken = controllerToken;
            } else {
                throw new TypeError("Controller token " + controllerToken + " is not a master token, encrypted CTicket, or MSL token construct.");
            }
            
            // Extract creation data.
            var action = null,
                controllerPin = null,
                userIdToken = null,
                customer = null;
            if (creationData) {
                var controllerAuthData = creationData.controllerAuthData;
                action = controllerAuthData.getAction();
                controllerPin = controllerAuthData.getPin();
                userIdToken = creationData.userIdToken;
                
                // MSL-based controller authentication data.
                if (controllerAuthData instanceof MslControllerData)
                    customer = controllerAuthData.getUserIdToken().customer;
                
                // MSL-based controller legacy authentication data.
                else if (userIdToken)
                    customer = userIdToken.customer;
            }

            // The properties.
            var props = {
                /** @type {Mechanism} */ 
                mechanism: { value: mechanism, writable: false, configurable: false },
                /** @type {string} */
                action: { value: action, writable: false, configurable: false },
                /** @type {string} */
                targetPin: { value: pin, writable: false, configurable: false },
                /** @type {string} */
                controllerPin: { value: controllerPin, writable: false, configurable: false },
                /** @type {CustomerKey} */
                customer: { value: customer, writable: false, configurable: false },

                // Controller tokens.
                /** @type {MasterToken} */
                _masterToken: { value: masterToken, writable: false, enumerable: false, configurable: false },
                /** @type {Uint8Array} */
                _encryptedCTicket: { value: encryptedCTicket, writable: false, enumerable: false, configurable: false },
                /** @type {string} */
                _mslTokens: { value: mslTokens, writable: false, enumerable: false, configurable: false },

                // Controller authentication data.
                /** @type {Uint8Array} */
                _controllerEncoding: { value: mdxAuthData, writable: false, enumerable: false, configurable: false },
                /** @type {Uint8Array} */
                _signature: { value: signature, writable: false, enumerable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        getAuthData: function getAuthData() {
            var jsonObj = {};
            switch (this.mechanism) {
                case Mechanism.MSL:
                    var masterTokenJo = JSON.parse(JSON.stringify(this._masterToken));
                    jsonObj[KEY_MASTER_TOKEN] = masterTokenJo;
                    break;
                case Mechanism.NTBA:
                    var cTicketB64 = textEncoding$getString(this._encryptedCTicket, UTF_8);
                    jsonObj[KEY_CTICKET] = cTicketB64;
                    break;
                case Mechanism.MSL_LEGACY:
                    jsonObj[KEY_CTICKET] = this._mslTokens;
                    break;
                default:
                    throw new MslInternalException("Unsupported MDX mechanism.");
            }
            jsonObj[KEY_PIN] = this.targetPin;
            jsonObj[KEY_MDX_AUTHENTICATION_DATA] = base64$encode(this._controllerEncoding);
            jsonObj[KEY_SIGNATURE] = base64$encode(this._signature);
            return jsonObj;
        },

        /** @inheritDoc */
        equals: function equals(that) {
            if (this === that) return true;
            if (!(that instanceof MdxAuthenticationData)) return false;
            return equals.base.call(this, that) &&
                (this._masterToken == that._masterToken || (this._masterToken && this._masterToken.equals(that._masterToken))) &&
                (this._encryptedCTicket == that._encryptedCTicket || (this._encryptedCTicket && Arrays$equal(this._encryptedCTicket, that._encryptedCTicket))) &&
                this._mslTokens == that._mslTokens &&
                Arrays$equal(this._controllerEncoding, that._controllerEncoding) &&
                Arrays$equal(this._signature, that._signature);
        },
    });

    /**
     * Construct a new MDX authentication data instance from the provided
     * controller data and target PIN. Both MSL- and NTBA-based controller MDX
     * authentication data is supported.
     * 
     * @param {MslContext} ctx MSL context.
     * @param {object} mdxAuthJO controller-produced MDX authentication data.
     * @param {{result: function(MdxAuthenticationData), error: function(Error)}}
     *        callback the callback functions that will receive the MDX
     *        authentication data or any thrown exceptions.
     * @throws MslEncodingException if there is an error parsing the JSON.
     * @throws MslCryptoException if there is an error verifying or decrypting
     *         the master token or CTicket.
     * @throws MslUserAuthException if there is an error with the master token
     *         or user ID token or the tokens could not be decrypted.
     */
    MdxAuthenticationData$parse = function MdxAuthenticationData$parse(ctx, mdxAuthJO, callback) {
        AsyncExecutor(callback, function() {
            // Grab the target PIN, controller authentication data, and
            // controller signature.
            var pin = mdxAuthJO[KEY_PIN];
            var controllerEncodingB64 = mdxAuthJO[KEY_MDX_AUTHENTICATION_DATA];
            var signatureB64 = mdxAuthJO[KEY_SIGNATURE];
            if (!pin || typeof pin !== 'string' ||
                !controllerEncodingB64 || typeof controllerEncodingB64 !== 'string' ||
                !signatureB64 || typeof signatureB64 !== 'string')
            {
                throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "MDX authdata " + JSON.stringify(mdxAuthJO));
            }
            var controllerEncoding, signature;
            try {
                controllerEncoding = base64$decode(controllerEncodingB64);
                signature = base64$decode(signatureB64);
            } catch (e) {
                throw new MslUserAuthException(MslError.MDX_CONTROLLERDATA_INVALID, "MDX authdata " + JSON.stringify(mdxAuthJO), e);
            }
            
            // MSL-based controller authentication data.
            if (mdxAuthJO[KEY_MASTER_TOKEN]) {
                var masterTokenJo = mdxAuthJO[KEY_MASTER_TOKEN];
                if (!masterTokenJo || typeof masterTokenJo !== 'object')
                    throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "MDX authdata " + JSON.stringify(mdxAuthJO));
                
                parseMslAuthData(pin, masterTokenJo, controllerEncoding, signature);
            }

            // Legacy controller authentication data.
            else if (mdxAuthJO[KEY_CTICKET]) {
                var cTicketString = mdxAuthJO[KEY_CTICKET];
                if (!cTicketString || typeof cTicketString !== 'string')
                    throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "MDX authdata " + JSON.stringify(mdxAuthJO));
                
                // NTBA-based controller.
                if (cTicketString.indexOf(',') == -1)
                    parseNtbaAuthData(pin, cTicketString, controllerEncoding, signature);
                
                // MSL-based controller.
                else
                    parseMslLegacyAuthData(pin, cTicketString, controllerEncoding, signature);
            }
            
            // Unknown controller authentication data.
            else {
                throw new MslUserAuthException(MslError.UNIDENTIFIED_USERAUTH_MECHANISM, "MDX authdata " + JSON.stringify(mdxAuthJO));
            }
        });
        
        function parseMslAuthData(pin, masterTokenJo, controllerEncoding, signature) {
            MasterToken$parse(ctx, masterTokenJo, {
                result: function(masterToken) {
                    AsyncExecutor(callback, function() {
                        if (!masterToken.isDecrypted())
                            throw new MslUserAuthException(MslError.USERAUTH_MASTERTOKEN_NOT_DECRYPTED, "MDX authdata " + mdxAuthJO.toString());

                        // Reconstructed data.
                        MslControllerData$parse(ctx, masterToken, controllerEncoding, signature, {
                            result: function(controllerAuthData) {
                                AsyncExecutor(callback, function() {
                                    var mdxAuthData = controllerAuthData.getEncoding();
                                    var signature = controllerAuthData.getSignature();
                                    var creationData = { controllerAuthData: controllerAuthData, userIdToken: null };
                                    return new MdxAuthenticationData(ctx, pin, masterToken, mdxAuthData, signature, creationData);
                                });
                            },
                            error: callback.error,
                        });
                    });
                },
                error: function(e) {
                    AsyncExecutor(callback, function() {
                        if (e instanceof MslException)
                            throw new MslUserAuthException(MslError.USERAUTH_MASTERTOKEN_INVALID, "MDX authdata " + JSON.stringify(mdxAuthJO), e);
                        throw e;
                    });
                }
            });
        }
        
        function parseNtbaAuthData(pin, cTicketString, controllerEncoding, signature) {
            // Unsupported.
            AsyncExecutor(callback, function() {
                throw new MslUserAuthException(MslError.UNSUPPORTED_USERAUTH_MECHANISM, "NtbaControllerData$parse");
            });
        }
        
        function parseMslLegacyAuthData(pin, cTicketString, controllerEncoding, signature) {
            AsyncExecutor(callback, function() {
                var mslTokens = cTicketString;
                
                // Verify legacy MSL tokens encoding.
                var tokens = mslTokens.split(',');
                if (tokens.length != 3 || tokens[LEGACY_VERSION_INDEX] != LEGACY_VERSION_1)
                    throw new MslUserAuthException(MslError.UNIDENTIFIED_USERAUTH_MECHANISM, "MDX authdata " + JSON.stringify(mdxAuthJO));
                
                // Reconstruct master token.
                //
                // Don't save the master token since this is legacy data.
                reconstructMasterToken(tokens[LEGACY_MASTERTOKEN_INDEX], {
                    result: function(masterToken) {
                        reconstructUserIdToken(tokens[LEGACY_USERIDTOKEN_INDEX], masterToken, {
                            result: function(userIdToken) {
                                // Reconstruct authentication data.
                                MslLegacyControllerData$parse(ctx, masterToken, controllerEncoding, signature, {
                                    result: function(controllerAuthData) {
                                        AsyncExecutor(callback, function() {
                                            var creationData = { controllerAuthData: controllerAuthData, userIdToken: userIdToken };
                                            return new MdxAuthenticationData(ctx, pin, mslTokens, controllerEncoding, signature, creationData);
                                        });
                                    },
                                    error: function(e) {
                                        AsyncExecutor(callback, function() {
                                            if (e instanceof MslMasterTokenException)
                                                throw new MslUserAuthException(MslError.USERAUTH_MASTERTOKEN_NOT_DECRYPTED, "MDX authdata " + JSON.stringify(mdxAuthJO), e);
                                            throw e;
                                        });
                                    }
                                });
                            },
                            error: callback.error,
                        });
                    },
                    error: callback.error
                });
            });
            
            function reconstructMasterToken(tokenB64, callback) {
                AsyncExecutor(callback, function() {
                    var masterTokenBytes;
                    try {
                        masterTokenBytes = base64$decode(tokenB64);
                    } catch (e) {
                        throw new MslUserAuthException(MslError.USERAUTH_MASTERTOKEN_INVALID, "MDX authdata " + JSON.stringify(mdxAuthJO), e);
                    }
                    if (!masterTokenBytes || masterTokenBytes.length == 0)
                        throw new MslUserAuthException(MslError.USERAUTH_MASTERTOKEN_MISSING, "MDX authdata " + JSON.stringify(mdxAuthJO));
                    try {
                        var masterTokenJo = JSON.parse(textEncoding$getString(masterTokenBytes, UTF_8));
                        MasterToken$parse(ctx, masterTokenJo, {
                            result: function(masterToken) {
                                AsyncExecutor(callback, function() {
                                    if (!masterToken.isDecrypted())
                                        throw new MslUserAuthException(MslError.USERAUTH_MASTERTOKEN_NOT_DECRYPTED, "MDX authdata " + mdxAuthJO.toString());
                                    
                                    return masterToken;
                                });
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException)
                                        throw new MslUserAuthException(MslError.USERAUTH_MASTERTOKEN_INVALID, "MDX authdata " + JSON.stringify(mdxAuthJO), e);
                                    throw e;
                                });
                            }
                        });
                    } catch (e) {
                        if (e instanceof SyntaxError)
                            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "MDX authdata " + JSON.stringify(mdxAuthJO), e);
                        throw e;
                    }
                });
            }
            
            function reconstructUserIdToken(tokenB64, masterToken, callback) {
                AsyncExecutor(callback, function() {
                    var userIdTokenBytes;
                    try {
                        userIdTokenBytes = base64$decode(tokenB64);
                    } catch (e) {
                        throw new MslUserAuthException(MslError.USERAUTH_USERIDTOKEN_INVALID, "MDX authdata " + JSON.stringify(mdxAuthJO), e);
                    }
                    if (!userIdTokenBytes || userIdTokenBytes.length == 0)
                        throw new MslUserAuthException(MslError.USERAUTH_USERIDTOKEN_MISSING, "MDX authdata " + JSON.stringify(mdxAuthJO));
                    try {
                        var userIdTokenJo = JSON.parse(textEncoding$getString(userIdTokenBytes, UTF_8));
                        UserIdToken$parse(ctx, userIdTokenJo, masterToken, {
                            result: function(userIdToken) {
                                AsyncExecutor(callback, function() {
                                    if (!userIdToken.isDecrypted())
                                        throw new MslUserAuthException(MslError.USERAUTH_USERIDTOKEN_NOT_DECRYPTED, "MDX authdata " + JSON.stringify(mdxAuthJO));
                                    
                                    return userIdToken;
                                });
                            },
                            error: function(e) {
                                AsyncExecutor(callback, function() {
                                    if (e instanceof MslException)
                                        throw new MslUserAuthException(MslError.USERAUTH_USERIDTOKEN_INVALID, "MDX authdata " + JSON.stringify(mdxAuthJO), e);
                                    throw e;
                                });
                            }
                        });
                    } catch (e) {
                        if (e instanceof SyntaxError)
                            throw new MslEncodingException(MslError.JSON_PARSE_ERROR, "MDX authdata " + JSON.stringify(mdxAuthJO), e);
                        throw e;
                    }
                });
            }
        }
    };
})();



// -- javascript/userauth/MdxAuthenticationFactory.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * MDX user authentication factory.
 * 
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MdxAuthenticationFactory;

(function() {
    "use strict";
    /**
     * MSL-based controller action.
     * @const
     * @type {string}
     */
    var MSL_ACTION = MdxAuthenticationData$MslControllerData.ACTION;
    /**
     * NTBA-based controller action.
     * @const
     * @type {string}
     */
    var NTBA_ACTION = MdxAuthenticationData$NtbaControllerData.ACTION;
    /**
     * MSL-based controller legacy action.
     * @const
     * @type {string}
     */
    var MSL_LEGACY_ACTION = MdxAuthenticationData$MslLegacyControllerData.ACTION;
    
    MdxAuthenticationFactory = UserAuthenticationFactory.extend({
        /**
         * Construct a new MDX user authentication factory.
         */
        init: function init() {
            init.base.call(this, UserAuthenticationScheme.MDX);
        },

        /** @inheritDoc */
        createData: function createData(ctx, masterToken, userAuthJO, callback) {
            MdxAuthenticationData$parse(ctx, userAuthJO, callback);
        },

        /** @inheritDoc */
        authenticate: function authenticate(ctx, identity, data, userIdToken) {
            // Make sure we have the right kind of user authentication data.
            if (!(data instanceof MdxAuthenticationData))
                throw new MslInternalException("Incorrect authentication data type " + data.getClass().getName() + ".");
            
            // Verify authorized action.
            var action = data.action;
            var mechanism = data.mechanism;
            switch (mechanism) {
                case MdxAuthenticationData$Mechanism.MSL:
                    if (MSL_ACTION != action)
                        throw new MslUserAuthException(MslError.MDX_USERAUTH_ACTION_INVALID).setUser(data);
                    break;
                case MdxAuthenticationData$Mechanism.NTBA:
                    if (NTBA_ACTION != action)
                        throw new MslUserAuthException(MslError.MDX_USERAUTH_ACTION_INVALID).setUser(data);
                    break;
                case MdxAuthenticationData$Mechanism.MSL_LEGACY:
                    if (MSL_LEGACY_ACTION != action)
                        throw new MslUserAuthException(MslError.MDX_USERAUTH_ACTION_INVALID).setUser(data);
                    break;
            }

            // Verify PIN match.
            var controllerPin = data.controllerPin;
            var targetPin = data.targetPin;
            if (!controllerPin || !targetPin)
                throw new MslUserAuthException(MslError.MDX_PIN_BLANK).setUser(data);
            if (controllerPin != targetPin)
                throw new MslUserAuthException(MslError.MDX_PIN_MISMATCH).setUser(data);

            // Grab the Netflix customer.
            var customer = data.customer;
            if (!customer)
                throw new MslUserAuthException(MslError.MDX_USER_UNKNOWN).setUser(data);
            
            // If a user ID token was provided validate the user identities.
            if (userIdToken) {
                var uitCustomer = userIdToken.customer;
                if (!customer.equals(uitCustomer))
                    throw new MslUserAuthException(MslError.USERIDTOKEN_USERAUTH_DATA_MISMATCH, "uad customer " + customer + "; uit customer " + uitCustomer).setUser(data);
            }
            
            // Return the customer.
            return customer;
        }
    });
})();


// -- javascript/util/MslContext.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * Re-authentication reason codes.
 * @enum
 */
var MslContext$ReauthCode = {
    /** The master token was rejected as bad or invalid. */
    ENTITY_REAUTH: MslConstants$ResponseCode.ENTITY_REAUTH,
    /** The entity authentication data failed to authenticate the entity. */
    ENTITYDATA_REAUTH: MslConstants$ResponseCode.ENTITYDATA_REAUTH,
};
Object.freeze(MslContext$ReauthCode);

/**
 * <p>The context provides access to all factories, builders, and containers
 * that are needed by the MSL library. There is expected to be one global
 * context per trusted services network or peer-to-peer network. By extension,
 * the MSL store instance returned by the context is expected to be specific to
 * the owning context.</p>
 *
 * @see MslStore
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @interface
 */
var MslContext = util.Class.create({
    /**
     * <p>Returns the local entity time. This need not be the real time as long
     * as it moves forward accurately (i.e. this time value should increase by
     * one second for each second of elapsed real time).</p>
     *
     * <p>It is advisable that this time value be persistently stored so that
     * it does not roll back at next application launch. This is not necessary
     * but it will ensure issued tokens are eventually renewed.</p>
     *
     * @return {number} the local entity time in milliseconds since the epoch.
     */
    getTime: function() {},

    /**
     * <p>Returns a random number generator.</p>
     * 
     * <p>It is extremely important to provide a secure (pseudo-)random number
     * generator with a good source of entropy. Many random number generators,
     * including those found in the Java Runtime Environment, JavaScript, and
     * operating systems do not provide sufficient randomness.</p>
     * 
     * <p>If in doubt, performing an {@code XOR} on the output of two or more
     * independent random sources can be used to provide better random
     * values.</p>
     *
     * @return {Random} a random number generator.
     */
    getRandom: function() {},

    /**
     * Returns true if the context is operating in a peer-to-peer network. The
     * message processing logic is slightly different in peer-to-peer networks.
     *
     * @return {boolean} true if in peer-to-peer mode.
     */
    isPeerToPeer: function() {},

    /**
     * Returns the message capabilities for this entity.
     *
     * @return {MessageCapabilities} this entity's message capabilities.
     */
    getMessageCapabilities: function() {},

    /**
     * <p>Returns the entity authentication data for this entity. This is used
     * to authenticate messages prior to generation of a master token.</p>
     * 
     * <p>This method should never return {@code null} but may do so in the one
     * situation when the {@code reauthCode} parameter is provided and the
     * application knows that the request being sent can no longer succeed
     * because the existing master token, user ID token, or service tokens are
     * no longer valid. This will abort the request.</p>
     * 
     * <p>If the {@code reauthCode} parameter is equal to
     * {@link ReauthCode#ENTITY_REAUTH} then the existing master token has been
     * rejected, along with its bound user ID tokens and service tokens.</p>
     * 
     * <p>If the {@code reauthCode} parameter is equal to
     * {@link ReauthCode#ENTITYDATA_REAUTH} then new entity re-authentication
     * data should be returned for this and all subsequent calls.</p>
     * 
     * <p>The entity authentication scheme must never change.</p>
     * 
     * <p>This method will be called multiple times.</p>
     *
     * @param {MslControl$ReauthCode} reauthCode non-{@code null} if the master token or entity
     *        authentication data was rejected. If the entity authentication
     *        data was rejected then new entity authentication data is
     *        required.
     * @param {{result: function(?EntityAuthenticationData), error: function(Error)}}
     *        callback the callback that will receive the entity authentication
     *        data or null or any thrown exceptions.
     */
    getEntityAuthenticationData: function(reauthCode, callback) {},

    /**
     * <p>Returns the primary crypto context used for MSL-level crypto
     * operations. This is used for the master tokens and user ID tokens.</p>
     * 
     * <p>Trusted network clients should return a crypto context that always
     * returns false for verification. The other crypto context methods will
     * not be used by trusted network clients.</p>
     *
     * @return {ICryptoContext} the primary MSL crypto context.
     * @throws MslCryptoException if there is an error creating the crypto
     *         context.
     */
    getMslCryptoContext: function() {},

    /**
     * Returns the entity authentication factory for the specified scheme.
     *
     * @param {EntityAuthenticationScheme} scheme the entity authentication scheme.
     * @return {EntityAuthenticationFactory} the entity authentication factory, or null if no factory is
     *         available.
     */
    getEntityAuthenticationFactory: function(scheme) {},

    /**
     * Returns the user authentication factory for the specified scheme.
     *
     * Trusted network clients should always return null.
     *
     * @param {UserAuthenticationScheme} scheme the user authentication scheme.
     * @return {UserAuthenticationFactory} the user authentication factory, or null if no factory is
     *         available.
     */
    getUserAuthenticationFactory: function(scheme) {},

    /**
     * Returns the token factory.
     *
     * This method will not be called by trusted network clients.
     *
     * @return {TokenFactory} the token factory.
     */
    getTokenFactory: function() {},

    /**
     * Returns the key exchange factory for the specified scheme.
     *
     * @param {KeyExchangeScheme} scheme the key exchange scheme.
     * @return {KeyExchangeFactory} the key exchange factory, or null if no factory is available.
     */
    getKeyExchangeFactory: function(scheme) {},

    /**
     * Returns the supported key exchange factories in order of preferred use.
     * This should return an immutable collection.
     *
     * @return {Array.<KeyExchangeFactory>} the key exchange factories, or the empty set.
     */
    getKeyExchangeFactories: function() {},

    /**
     * Returns the MSL store specific to this MSL context.
     *
     * @return {MslStore} the MSL store.
     */
    getMslStore: function() {},
});



// -- javascript/util/MslStore.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>The Message Security Layer store manages the local store of master tokens
 * identifying the local entity, user ID tokens identifying local users, and
 * all service tokens issued by the local entity or remote entities. It also
 * provides methods for identifying the tokens that should be included in a
 * message and accessing crypto contexts associated with master tokens.<p>
 *
 * <p>Applications may wish to ensure the store contains only the newest master
 * token and user ID tokens for the known users at application startup and
 * shutdown.</p>
 *
 * <p>Implementations must be thread-safe.</p>
 *
 * @see MslContext
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @interface
*/
var MslStore = util.Class.create({
    /**
     * Save a master token and its associated crypto context. This replaces any
     * existing association. Passing in a null crypto context is the same as
     * calling {@link #removeCryptoContext(MasterToken)}.
     *
     * @param {MasterToken} masterToken the master token.
     * @param {ICryptoContext} cryptoContext the crypto context. May be null.
     */
    setCryptoContext: function(masterToken, cryptoContext) {},

    /**
     * Return the newest saved master token in this store.
     *
     * @return {MasterToken} the newest saved master token or null.
     */
    getMasterToken: function() {},
    
    /**
     * Return the next non-replayable ID of the provided master token.
     * 
     * Each call to this function should return the next largest number. The
     * next largest number after {@link MslConstants#MAX_LONG_VALUE} is zero
     * (0).
     * 
     * @return {number} the next non-replayable ID.
     */
    getNonReplayableId: function(masterToken) {},

    /**
     * Return the crypto context associated with the provided master token.
     *
     * @param {MasterToken} masterToken the master token.
     * @return {ICryptoContext} the crypto context for the master token or null if not found.
     */
    getCryptoContext: function(masterToken) {},

    /**
     * Remove a master token and its associated crypto context. This also
     * removes any stored user ID tokens and service tokens that are no longer
     * bound to a known master token.
     *
     * @param {MasterToken} masterToken the master token.
     */
    removeCryptoContext: function(masterToken) {},

    /**
     * Removes all master tokens and crypto contexts and bound user ID tokens
     * and their bound service tokens.
     */
    clearCryptoContexts: function() {},

    /**
     * Add a user ID token to the store, replacing any existing user ID token
     * of the same user. The local user ID has no meeting external to the
     * store.
     *
     * @param {String} userId local user ID.
     * @param {UserIdToken} userIdToken the user ID token.
     * @throws MslException if the user ID token is not bound to any stored
     *         master token.
     */
    addUserIdToken: function(userId, userIdToken) {},

    /**
     * Returns the user ID token, if any, for the specified local user ID.
     *
     * @param {String} userId local user ID.
     * @return the user ID token for the local user ID or null.
     */
    getUserIdToken: function(userId) {},

    /**
     * Remove a user ID token. This also removes any service tokens no longer
     * bound to a known user ID token.
     *
     * @param {UserIdToken} userIdToken the user ID token.
     */
    removeUserIdToken: function(userIdToken) {},

    /**
     * Removes all user ID tokens and user ID token bound service tokens.
     */
    clearUserIdTokens: function() {},

    /**
     * Add a set of service tokens to the store.
     *
     * @param {Array.<ServiceToken>} tokens the service tokens.
     * @throws MslException if a service token is master token bound to a
     *         master token not found in the store or if a service token is
     *         user ID token bound to a user ID token not found in the store.
     */
    addServiceTokens: function(tokens) {},

    /**
     * <p>Return the set of service tokens that are applicable to the provided
     * pair of master token and user ID token. The base set consists of the
     * service tokens that are not bound to any master token or user ID
     * token.</p>
     * 
     * <p>If a master token is provided, the service tokens that are bound to
     * the master token and not bound to any user ID token are also
     * provided.</p>
     * 
     * <p>If a master token and user ID token is provided, the service tokens
     * that are bound to both the master token and user ID token are also
     * provided.</p>
     *
     * @param {MasterToken} masterToken the master token. May be null.
     * @param {UserIdToken} userIdToken the user ID token. May be null.
     * @return {Array.<ServiceToken>} the set of service tokens applicable to the message.
     * @throws MslException if the user ID token is not bound to the master
     *         token or a user ID token is provided without also providing a
     *         master token.
     */
    getServiceTokens: function(masterToken, userIdToken) {},

    /**
     * <p>Remove all service tokens matching all the specified parameters.</p>
     * 
     * <p>If a name is provided, only tokens with that name are removed. If a
     * master token is provided, only tokens bound to that master token are
     * removed. If a user ID token is provided, only tokens bound to that user
     * ID token are removed.</p>
     * 
     * <p>For example, if a name and master token is provided, only tokens with
     * that name and bound to that master token are removed.</p>
     * 
     * <p>If no parameters are provided, no tokens are removed.</p>
     *
     * @param {String} name service token name. May be null.
     * @param {MasterToken} masterToken master token. May be null.
     * @param {UserIdToken} userIdToken user ID token. May be null.
     * @throws MslException if the user ID token is not bound to the master
     *         token.
     */
    removeServiceTokens: function(name, masterToken, userIdToken) {},

    /**
     * Removes all service tokens.
     */
    clearServiceTokens: function() {},
});



// -- javascript/util/MslUtils.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * Utility methods.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var MslUtils$compress;
var MslUtils$uncompress;

(function() {
    "use strict";

    // Shortcuts
    var CompressionAlgorithm = MslConstants$CompressionAlgorithm;

    /**
     * Compress the provided data using the specified compression algorithm.
     *
     * @param {CompressionAlgorithm} compressionAlgo the compression algorithm.
     * @param {Uint8Array} data the data to compress.
     * @return {Uint8Array} the compressed data or null if the compressed data
     *         would be larger than the uncompressed data.
     * @throws MslException if there is an error compressing the data.
     */
    MslUtils$compress = function MslUtils$compress(compressionAlgo, data) {
        // Populate the initial dictionary to use in lzw$compress.  Pass as argument as a work around for bug on Windows 10.
        var dictionary = {};

        switch (compressionAlgo) {
        case CompressionAlgorithm.LZW:
            return lzw$compress(data, dictionary);
        case CompressionAlgorithm.GZIP:
            return gzip$compress(data);
        default:
            throw new MslException(MslError.UNSUPPORTED_COMPRESSION, compressionAlgo);
        }
    };

    /**
     * Uncompress the provided data using the specified compression algorithm.
     *
     * @param {CompressionAlgorithm} compressionAlgo the compression algorithm.
     * @param {Uint8Array} data the data to uncompress.
     * @return {Uint8Array} the uncompressed data.
     * @throws MslException if there is an error uncompressing the data.
     */
    MslUtils$uncompress = function MslUtils$uncompress(compressionAlgo, data, callback) {
        switch (compressionAlgo) {
        case CompressionAlgorithm.LZW:
            return lzw$uncompress(data);
        case CompressionAlgorithm.GZIP:
            return gzip$uncompress(data);
        default:
            throw new MslException(MslError.UNSUPPORTED_COMPRESSION, compressionAlgo.name());
        }
    };
})();


// -- javascript/util/NullMslStore.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A MSL store where all operations are no-ops.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @implements {MslStore}
 */
var NullMslStore = MslStore.extend({
    /** @inheritDoc */
    setCryptoContext: function setCryptoContext(masterToken, cryptoContext) {},

    /** @inheritDoc */
    getMasterToken: function getMasterToken() { return null; },
    
    /** @inheritDoc */
    getNonReplayableId: function getNonReplayableId(masterToken) { return 1; },

    /** @inheritDoc */
    getCryptoContext: function getCryptoContext(masterToken) { return null; },

    /** @inheritDoc */
    removeCryptoContext: function removeCryptoContext(masterToken) {},

    /** @inheritDoc */
    clearCryptoContexts: function clearCryptoContexts() {},

    /** @inheritDoc */
    addUserIdToken: function addUserIdToken(userId, userIdToken) {},

    /** @inheritDoc */
    getUserIdToken: function getUserIdToken(userId) { return null; },

    /** @inheritDoc */
    removeUserIdToken: function removeUserIdToken(userIdToken) {},

    /** @inheritDoc */
    clearUserIdTokens: function clearUserIdTokens() {},

    /** @inheritDoc */
    addServiceTokens: function addServiceTokens(tokens) {},

    /** @inheritDoc */
    getServiceTokens: function getServiceTokens(masterToken, userIdToken) {
        // Validate arguments.
        if (userIdToken) {
            if (!masterToken)
                throw new MslException(MslError.USERIDTOKEN_MASTERTOKEN_NULL);
            if (!userIdToken.isBoundTo(masterToken))
                throw new MslException(MslError.USERIDTOKEN_MASTERTOKEN_MISMATCH, "uit mtserialnumber " + userIdToken.mtSerialNumber + "; mt " + masterToken.serialNumber);
        }
        return [];
    },

    /** @inheritDoc */
    removeServiceTokens: function removeServiceTokens(name, masterToken, userIdToken) {
        // Validate arguments.
        if (userIdToken && masterToken && !userIdToken.isBoundTo(masterToken))
            throw new MslException(MslError.USERIDTOKEN_MASTERTOKEN_MISMATCH, "uit mtserialnumber " + userIdToken.masterTokenSerialNumber + "; mt " + masterToken.serialNumber);
    },

    /** @inheritDoc */
    clearServiceTokens: function clearServiceTokens() {},
});



// -- javascript/util/SimpleMslStore.js
/**
 * Copyright (c) 2012 Netflix, Inc.  All rights reserved.
 */

/**
 * <p>A simple MSL store that maintains state.</p>
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 * @implements {MslStore}
 */
var SimpleMslStore;
(function() {
    "use strict";

    /**
     * Increments the provided non-replayable ID by 1, wrapping around to zero
     * if the provided value is equal to {@link MslConstants#MAX_LONG_VALUE}.
     *
     * @param {number} id the non-replayable ID to increment.
     * @return {number} the non-replayable ID + 1.
     * @throws MslInternalException if the provided non-replayable ID is out of
     *         range.
     */
    function incrementNonReplayableId(id) {
        if (id < 0 || id > MslConstants$MAX_LONG_VALUE)
            throw new MslInternalException("Non-replayable ID " + id + " is outside the valid range.");
        return (id == MslConstants$MAX_LONG_VALUE) ? 0 : id + 1;
    }

    SimpleMslStore = MslStore.extend({
        /**
         * Create a new simple MSL store.
         */
        init: function init() {
            init.base.call(this);

            /**
             * Map of master token keys onto master tokens.
             * @type {Object.<string,MasterToken>}
             */
            var masterTokens = {};
            /**
             * Map of master token keys onto crypto contexts.
             * @type {Object.<string,ICryptoContext>}
             */
            var cryptoContexts = {};
            /**
             * Map of local user IDs onto User ID tokens.
             * @type {Object.<string,UserIdToken>}
             */
            var userIdTokens = {};

            /**
             * Map of master token serial numbers onto non-replayable IDs.
             * @type {Object.<number,number>}
             */
            var nonReplayableIds = {};

            /**
             * Map of service token keys onto of unbound service tokens.
             * @type {Object.<string,ServiceToken>}
             */
            var unboundServiceTokens = {};
            /**
             * Map of master token serial numbers onto a map of service token keys
             * onto master token bound service tokens.
             * @type {Object.<number,Object.<string,ServiceToken>>}
             */
            var mtServiceTokens = {};
            /**
             * Map of user ID token serial numbers onto a map of service token keys
             * onto user ID token bound service tokens.
             * @type {Object.<number,Object.<string,ServiceToken>>}
             */
            var uitServiceTokens = {};

            // The properties.
            var props = {
                masterTokens: { value: masterTokens, writable: false, enumerable: false, configurable: false },
                cryptoContexts: { value: cryptoContexts, writable: false, enumerable: false, configurable: false },
                userIdTokens: { value: userIdTokens, writable: false, enumerable: false, configurable: false },
                nonReplayableIds: { value: nonReplayableIds, writable: false, enumerable: false, configurable: false },
                unboundServiceTokens: { value: unboundServiceTokens, writable: false, enumerable: false, configurable: false },
                mtServiceTokens: { value: mtServiceTokens, writable: false, enumerable: false, configurable: false },
                uitServiceTokens: { value: uitServiceTokens, writable: false, enumerable: false, configurable: false },
            };
            Object.defineProperties(this, props);
        },

        /** @inheritDoc */
        setCryptoContext: function setCryptoContext(masterToken, cryptoContext) {
            if (!cryptoContext) {
                this.removeCryptoContext(masterToken);
            } else {
                var key = masterToken.uniqueKey();
                this.masterTokens[key] = masterToken;
                this.cryptoContexts[key] = cryptoContext;
            }
        },

        /** @inheritDoc */
        getMasterToken: function getMasterToken() {
            var masterToken = null;
            for (var key in this.masterTokens) {
                var storedMasterToken = this.masterTokens[key];
                if (!masterToken || storedMasterToken.isNewerThan(masterToken))
                    masterToken = storedMasterToken;
            }
            return masterToken;
        },

        /** @inheritDoc */
        getNonReplayableId: function getNonReplayableId(masterToken) {
            // Return the next largest non-replayable ID, or 1 if there is none.
            var serialNumber = masterToken.serialNumber;
            var currentId = (this.nonReplayableIds[serialNumber] !== undefined)
                ? this.nonReplayableIds[serialNumber]
                : 0;
            var nextId = incrementNonReplayableId(currentId);
            this.nonReplayableIds[serialNumber] = nextId;
            return nextId;
        },

        /** @inheritDoc */
        getCryptoContext: function getCryptoContext(masterToken) {
            return this.cryptoContexts[masterToken.uniqueKey()];
        },

        /** @inheritDoc */
        removeCryptoContext: function removeCryptoContext(masterToken) {
            var keyToRemove = masterToken.uniqueKey();
            if (this.masterTokens[keyToRemove]) {
                delete this.masterTokens[keyToRemove];
                delete this.cryptoContexts[keyToRemove];

                // Remove bound user ID tokens, service tokens, and the non-
                // replayable ID if we no longer have a master token with the same
                // serial number.
                var serialNumber = masterToken.serialNumber;
                for (var key in this.masterTokens) {
                    var token = this.masterTokens[key];
                    if (token.serialNumber == serialNumber)
                        return;
                }

                // Remove the non-replayable ID.
                delete this.nonReplayableIds[serialNumber];

                // Remove bound user ID tokens and service tokens.
                var userIds = Object.keys(this.userIdTokens);
                userIds.forEach(function(userId) {
                    var userIdToken = this.userIdTokens[userId];
                    if (userIdToken.isBoundTo(masterToken))
                        this.removeUserIdToken(userIdToken);
                }, this);
                try {
                    this.removeServiceTokens(null, masterToken, null);
                } catch (e) {
                    // This should not happen since we are only providing a
                    // master token.
                    if (e instanceof MslException)
                        throw new MslInternalException("Unexpected exception while removing master token bound service tokens.", e);
                    throw e;
                }
            }
        },

        /** @inheritDoc */
        clearCryptoContexts: function clearCryptoContexts() {
            var maps = [this.masterTokens, this.cryptoContexts, this.nonReplayableIds, this.userIdTokens, this.uitServiceTokens, this.mtServiceTokens];
            maps.forEach(function(map) {
                for (var key in map)
                    delete map[key];
            }, this);
        },

        /** @inheritDoc */
        addUserIdToken: function addUserIdToken(userId, userIdToken) {
            var foundMasterToken = false;
            for (var key in this.masterTokens) {
                var masterToken = this.masterTokens[key];
                if (userIdToken.isBoundTo(masterToken)) {
                    foundMasterToken = true;
                    break;
                }
            }
            if (!foundMasterToken)
                throw new MslException(MslError.USERIDTOKEN_MASTERTOKEN_NOT_FOUND, "uit mtserialnumber " + userIdToken.mtSerialNumber);
            this.userIdTokens[userId] = userIdToken;
        },

        /** @inheritDoc */
        getUserIdToken: function getUserIdToken(userId) {
            return this.userIdTokens[userId];
        },

        /** @inheritDoc */
        removeUserIdToken: function removeUserIdToken(userIdToken) {
            // Find the master token this user ID token is bound to.
            var masterToken = null;
            for (var key in this.masterTokens) {
                var token = this.masterTokens[key];
                if (userIdToken.isBoundTo(token)) {
                    masterToken = token;
                    break;
                }
            }

            // If we didn't find a master token we shouldn't be able to find a user
            // ID token, but it doesn't hurt to try anyway and clean things up.
            var userIds = Object.keys(this.userIdTokens);
            userIds.forEach(function(userId) {
                if (this.userIdTokens[userId].equals(userIdToken)) {
                    delete this.userIdTokens[userId];
                    try {
                        this.removeServiceTokens(null, masterToken, userIdToken);
                    } catch (e) {
                        if (e instanceof MslException)
                            // This should not happen since we have already confirmed
                            // that the user ID token is bound to the master token.
                            throw new MslInternalException("Unexpected exception while removing user ID token bound service tokens.", e);
                        throw e;
                    }
                }
            }, this);
        },

        /** @inheritDoc */
        clearUserIdTokens: function clearUserIdTokens() {
            for (var userId in this.userIdTokens) {
                var userIdToken = this.userIdTokens[userId];
                try {
                    this.removeServiceTokens(null, null, userIdToken);
                } catch (e) {
                    if (e instanceof MslException)
                        // This should not happen since we are only providing a user ID
                        // token.
                        throw new MslInternalException("Unexpected exception while removing user ID token bound service tokens.", e);
                    throw e;
                }
                delete this.userIdTokens[userId];
            }
        },

        /** @inheritDoc */
        addServiceTokens: function addServiceTokens(tokens) {
            tokens.forEach(function(token) {
                // Unbound?
                if (token.isUnbound()) {
                    this.unboundServiceTokens[token.uniqueKey()] = token;
                    return;
                }

                // Verify we recognize the bound service tokens.
                if (token.isMasterTokenBound()) {
                    var foundMasterToken = false;
                    for (var key in this.masterTokens) {
                        var masterToken = this.masterTokens[key];
                        if (token.isBoundTo(masterToken)) {
                            foundMasterToken = true;
                            break;
                        }
                    }
                    if (!foundMasterToken)
                        throw new MslException(MslError.SERVICETOKEN_MASTERTOKEN_NOT_FOUND, "st mtserialnumber " + token.mtSerialNumber);
                }
                if (token.isUserIdTokenBound()) {
                    var foundUserIdToken = false;
                    for (var userId in this.userIdTokens) {
                        var userIdToken = this.userIdTokens[userId];
                        if (token.isBoundTo(userIdToken)) {
                            foundUserIdToken = true;
                            break;
                        }
                    }
                    if (!foundUserIdToken)
                        throw new MslException(MslError.SERVICETOKEN_USERIDTOKEN_NOT_FOUND, "st uitserialnumber " + token.uitSerialNumber);
                }

                // Master token bound?
                if (token.isMasterTokenBound()) {
                    var tokenSet = this.mtServiceTokens[token.mtSerialNumber];
                    if (!tokenSet)
                        tokenSet = {};
                    tokenSet[token.uniqueKey()] = token;
                    this.mtServiceTokens[token.mtSerialNumber] = tokenSet;
                }

                // User ID token bound?
                if (token.isUserIdTokenBound()) {
                    var tokenSet = this.uitServiceTokens[token.uitSerialNumber];
                    if (!tokenSet)
                        tokenSet = {};
                    tokenSet[token.uniqueKey()] = token;
                    this.uitServiceTokens[token.uitSerialNumber] = tokenSet;
                }
            }, this);
        },

        /** @inheritDoc */
        getServiceTokens: function getServiceTokens(masterToken, userIdToken) {
            // Validate arguments.
            if (userIdToken) {
                if (!masterToken)
                    throw new MslException(MslError.USERIDTOKEN_MASTERTOKEN_NULL);
                if (!userIdToken.isBoundTo(masterToken))
                    throw new MslException(MslError.USERIDTOKEN_MASTERTOKEN_MISMATCH, "uit mtserialnumber " + userIdToken.mtSerialNumber + "; mt " + masterToken.serialNumber);
            }

            // Grab service tokens. We start with the set of unbound service
            // tokens.
            var serviceTokens = {};
            for (var key in this.unboundServiceTokens) {
                var unboundToken = this.unboundServiceTokens[key];
                serviceTokens[unboundToken.uniqueKey()] = unboundToken;
            }
            // If we have a master token add the set of master token bound service
            // tokens that are not bound to any user ID tokens.
            if (masterToken) {
                var mtTokens = this.mtServiceTokens[masterToken.serialNumber];
                if (mtTokens) {
                    for (var key in mtTokens) {
                        var mtToken = mtTokens[key];
                        if (!mtToken.isUserIdTokenBound())
                            serviceTokens[key] = mtToken;
                    }
                }
            }
            // If we have a user ID token (and because of the check above a master
            // token) add the set of user ID token bound service tokens that are
            // also bound to the same master token.
            if (userIdToken) {
                var uitTokens = this.uitServiceTokens[userIdToken.serialNumber];
                if (uitTokens) {
                    for (var key in uitTokens) {
                        var uitToken = uitTokens[key];
                        if (uitToken.isBoundTo(masterToken))
                            serviceTokens[key] = uitToken;
                    }
                }
            }

            // Convert the map of service tokens into an array.
            var list = [];
            for (var key in serviceTokens)
                list.push(serviceTokens[key]);
            return list;
        },

        /** @inheritDoc */
        removeServiceTokens: function removeServiceTokens(name, masterToken, userIdToken) {
            // Validate arguments.
            if (userIdToken && masterToken && !userIdToken.isBoundTo(masterToken))
                throw new MslException(MslError.USERIDTOKEN_MASTERTOKEN_MISMATCH, "uit mtserialnumber " + userIdToken.mtSerialNumber + "; mt " + masterToken.serialNumber);

            // If only a name was provided remove all tokens with that name.
            if (name && !masterToken && !userIdToken) {
                // Remove all unbound tokens with the specified name.
                var unboundKeys = Object.keys(this.unboundServiceTokens);
                unboundKeys.forEach(function(key) {
                    var unboundToken = this.unboundServiceTokens[key];
                    if (unboundToken.name == name)
                        delete this.unboundServiceTokens[key];
                }, this);

                // Remove all master bound tokens with the specified name.
                for (var mtSerialNumber in this.mtServiceTokens) {
                    var tokenSet = this.mtServiceTokens[mtSerialNumber];
                    var mtBoundKeys = Object.keys(tokenSet);
                    mtBoundKeys.forEach(function(key) {
                        var token = tokenSet[key];

                        // Skip if the name was provided and it does not match.
                        if (token.name != name)
                            return;

                        // Remove the token.
                        delete tokenSet[key];
                    }, this);
                    this.mtServiceTokens[mtSerialNumber] = tokenSet;
                }

                // Remove all user ID tokens with the specified name.
                for (var uitSerialNumber in this.uitServiceTokens) {
                    var tokenSet = this.uitServiceTokens[uitSerialNumber];
                    var uitBoundKeys = Object.keys(tokenSet);
                    uitBoundKeys.forEach(function(key) {
                        var token = tokenSet[key];

                        // Skip if the name was provided and it does not match.
                        if (token.name != name)
                            return;

                        // Remove the token.
                        delete tokenSet[key];
                    }, this);
                    this.uitServiceTokens[uitSerialNumber] = tokenSet;
                }
            }

            // If a master token was provided but no user ID token was provided,
            // remove all tokens bound to the master token. If a name was also
            // provided then limit removal to tokens with the specified name.
            if (masterToken && !userIdToken) {
                var tokenSet = this.mtServiceTokens[masterToken.serialNumber];
                if (tokenSet) {
                    var mtBoundKeys = Object.keys(tokenSet);
                    mtBoundKeys.forEach(function(key) {
                        var token = tokenSet[key];

                        // Skip if the name was provided and it does not match.
                        if (name && token.name != name)
                            return;

                        // Remove the token.
                        delete tokenSet[key];
                    }, this);
                    this.mtServiceTokens[masterToken.serialNumber] = tokenSet;
                }

                // Remove all user ID tokens (with the specified name if any).
                for (var uitSerialNumber in this.uitServiceTokens) {
                    var uitTokenSet = this.uitServiceTokens[uitSerialNumber];
                    var uitBoundKeys = Object.keys(uitTokenSet);
                    uitBoundKeys.forEach(function(key) {
                        var token = uitTokenSet[key];

                        // Skip if the name was provided and it does not match.
                        if (name && token.name != name)
                            return;

                        // Skip if the token is not bound to the master token.
                        if (!token.isBoundTo(masterToken))
                            return;

                        // Remove the token.
                        delete uitTokenSet[key];
                    }, this);
                    this.uitServiceTokens[uitSerialNumber] = uitTokenSet;
                }
            }

            // If a user ID token was provided remove all tokens bound to the user
            // ID token. If a name was also provided then limit removal to tokens
            // with the specified name. If a master token was also provided then
            // limit removal to tokens bound to the master token.
            if (userIdToken) {
                var tokenSet = this.uitServiceTokens[userIdToken.serialNumber];
                if (tokenSet) {
                    var uitBoundKeys = Object.keys(tokenSet);
                    uitBoundKeys.forEach(function(key) {
                        var token = tokenSet[key];

                        // Skip if the name was provided and it does not match.
                        if (name && token.name != name)
                            return;

                        // Skip if the master token was provided and the token is
                        // not bound to it.
                        if (masterToken && !token.isBoundTo(masterToken))
                            return;

                        // Remove the token.
                        delete tokenSet[key];
                    }, this);
                    this.uitServiceTokens[userIdToken.serialNumber] = tokenSet;
                }
            }
        },

        /** @inheritDoc */
        clearServiceTokens: function clearServiceTokens() {
            var maps = [this.unboundServiceTokens, this.mtServiceTokens, this.uitServiceTokens];
            maps.forEach(function(map) {
                for (var key in map)
                    delete map[key];
            }, this);
        }
    });
})();



// -- NccpWrapCryptoContextRepository.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * The crypto context repository provides access to wrapping key crypto
 * contexts and is used by the key exchange factory to deliver new wrapping
 * key data to the application. The wrapping key data can then be used in
 * future key request data.
 */
var NccpWrapCryptoContextRepository = WrapCryptoContextRepository.extend({

    init: function init() {
        init.base.call(this);
        Object.defineProperties(this, {
            _contextMap: { value: {}, writable: false, enumerable: false, configurable: false },
        });
    },

    /**
     * Add a new wrapping key crypto context and wrap data. The wrap data
     * should be used in key request data to request a new wrapping key
     * wrapped with this wrapping key.
     * 
     * @param {Uint8Array} wrapdata wrapping key wrap data.
     * @param {ICryptoContext} cryptoContext wrapping key crypto context.
     */
    addCryptoContext: function addCryptoContext(wrapdata, cryptoContext) {
        if (cryptoContext && wrapdata && wrapdata.length) {
            var key = base64$encode(wrapdata);
            this._contextMap[key] = cryptoContext;
        }
    },
    
    /**
     * Return the wrapping key crypto context identified by the specified
     * wrap data.
     * 
     * @param {Uint8Array} wrapdata wrapping key wrap data.
     * @return {ICryptoContext} the wrapping key crypto context or null if none exists.
     */
    getCryptoContext: function getCryptoContext(wrapdata) {
        if (wrapdata && wrapdata.length) {
            var key = base64$encode(wrapdata);
            return this._contextMap[key] || null;
        } else {
            return null;
        }
    },
    
    /**
     * Remove the wrapping key crypto context and wrap data identified by
     * the specified key wrap data. This is called after calling
     * {@link #addCryptoContext(byte[], ICryptoContext)} to
     * indicate the old wrapping key should no longer be necessary.
     * 
     * @param {Uint8Array} wrapdata wrapping key wrap data.
     */
     removeCryptoContext: function removeCryptoContext(wrapdata) {
         if (wrapdata && wrapdata.length) {
             var key = base64$encode(wrapdata);
             delete this._contextMap[key]
         }
     },
});



// -- NccpModelGroupAuthenticationFactory.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * Model group keys entity authentication factory.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var NccpModelGroupAuthenticationFactory = ModelGroupAuthenticationFactory.extend({
    /**
     * Construct a new model group keys authentication factory instance.
     *
     * @param {string} identity my local identity.
     * @param {CipherKey} kde MGK-derived encryption key
     * @param {CipherKey} kdh MGK-derived hmac key
     * @param {CipherKey} kdw MGK-derived wrapping key
     */
    init: function init(esn, kde, kdh, kdw) {
        init.base.call(this, esn);

        Object.defineProperties(this, {
            _kde: { value: kde, writable: false, enumerable: false, configurable: false },
            _kdh: { value: kdh, writable: false, enumerable: false, configurable: false },
            _kdw: { value: kdw, writable: false, enumerable: false, configurable: false }
        });
    },

    /** @inheritDoc */
    getCryptoContext: function (ctx, authdata) {
        // Make sure we have the right kind of entity authentication data.
        if (!(authdata instanceof ModelGroupAuthenticationData))
            throw new MslInternalException("Incorrect authentication data type " + JSON.stringify(authdata) + ".");

        // If the authdata is not for me then we can't do anything with it.
        if (authdata.identity != this.localIdentity)
            throw new MslEntityAuthException(MslError.ENTITY_NOT_FOUND, "mgk " + authdata.identity);

        // Return the crypto context.
        return new SymmetricCryptoContext(ctx, this.localIdentity, this._kde, this._kdh, this._kdw);
    }
});



// -- NccpPresharedAuthenticationFactory.js
/**
 * Copyright (c) 2013 Netflix, Inc.  All rights reserved.
 */

/**
 * Preshared keys entity authentication factory.
 *
 * @author Wesley Miaw <wmiaw@netflix.com>
 */
var NccpPresharedAuthenticationFactory = PresharedAuthenticationFactory.extend({
    /**
     * Construct a new preshared keys authentication factory instance.
     *
     * @param {string} identity my local identity.
     * @param {CipherKey} kpe PSK encryption key
     * @param {CipherKey} kph PSK hmac key
     * @param {CipherKey} kpw PSK wrapping key
     */
    init: function init(esn, kpe, kph, kpw) {
        init.base.call(this, esn);

        Object.defineProperties(this, {
            _kpe: { value: kpe, writable: false, enumerable: false, configurable: false },
            _kph: { value: kph, writable: false, enumerable: false, configurable: false },
            _kpw: { value: kpw, writable: false, enumerable: false, configurable: false }
        });
    },

    /** @inheritDoc */
    getCryptoContext: function (ctx, authdata) {
        // Make sure we have the right kind of entity authentication data.
        if (!(authdata instanceof PresharedAuthenticationData))
            throw new MslInternalException("Incorrect authentication data type " + JSON.stringify(authdata) + ".");

        // If the authdata is not for me then we can't do anything with it.
        if (authdata.identity != this.localIdentity)
            throw new MslEntityAuthException(MslError.ENTITY_NOT_FOUND, "psk " + authdata.identity);

        // Return the crypto context.
        return new SymmetricCryptoContext(ctx, this.localIdentity, this._kpe, this._kph, this._kpw);
    }
});



// -- NccpMslStore.js
var NccpMslStore = SimpleMslStore.extend({

    /** @inheritDoc */
    init: function init(log, esn, keyRequestData, createKeyRequestData, systemKeyName, systemKeyWrapFormat) {
        init.base.call(this);
        this._log = log;
        this._esn = esn;
        this._keyRequestData = keyRequestData;
        this._createKeyRequestData = createKeyRequestData;
        this._systemKeyName = systemKeyName;
        this._systemKeyWrapFormat = systemKeyWrapFormat;
    },

    /** @inheritDoc */
    setCryptoContext: function setCryptoContext(masterToken, cryptoContext, isLoadingState) {
        var self = this;
        self._log.trace('Adding MasterToken', { 'SequenceNumber': masterToken.sequenceNumber, 'SerialNumber': masterToken.serialNumber, 'Expiration': masterToken.expiration.getTime() });
        setCryptoContext.base.call(this, masterToken, cryptoContext);
        if (!isLoadingState) {
            var createKeyRequestData = self._createKeyRequestData;
            // this means we are refreshing master token, and if we can, refresh the key request data
            if (createKeyRequestData) {
                self._log.trace('Generating new keyx request data');
                createKeyRequestData().then(
                    function (keyRequestData) {
                        self._keyRequestData = keyRequestData;
                    },
                    function (e) {
                        self._log.error('Unable to generate new keyx request data', '' + e);
                    }
                );
            }
        }
    },

    /** @inheritDoc */
    addUserIdToken: function addUserIdToken(userId, userIdToken) {
        this._log.trace('Adding UserIdToken', { 'UserId': userId, 'SerialNumber': userIdToken.serialNumber, 'MTSerialNumber': userIdToken.mtSerialNumber, 'Expiration': userIdToken.expiration.getTime() });
        addUserIdToken.base.call(this, userId, userIdToken);
    },

    /** @inheritDoc */
    addServiceTokens: function addServiceTokens(tokens) {
        addServiceTokens.base.call(this, tokens.filter(function (token) {
            // some of the tokens are managed manually, and should not be store in the store
            return !NccpMslStore$playbackServiceTokenNames[token.name];
        }));
    },

    getKeyRequestData: function getKeyRequestData() {
        return this._keyRequestData;
    },

    /**
     * Return the state that can be persisted.
     */
    getStoreState: function getStoreState(callback) {
        var self = this;
        AsyncExecutor(callback, function () {
            var masterToken = self.getMasterToken();
            if (!masterToken) {
                callback.result(null);
                return;
            }
            self.getKeysForStore(masterToken, {
                result: function (storeState) {
                    AsyncExecutor(callback, function () {
                        var userIdTokens = self.userIdTokens;
                        var userList = Object.keys(userIdTokens).map(function (userId) {
                            var userIdToken = userIdTokens[userId];
                            return {
                                userId: userId,
                                userIdTokenJSON: userIdTokens[userId].toJSON(),
                                serviceTokenJSONList: self.getServiceTokens(masterToken, userIdToken).map(NccpMslStore$mapToJSON)
                            };
                        });
                        storeState.esn = self._esn;
                        storeState.masterTokenJSON = masterToken.toJSON();
                        storeState.userList = userList;
                        var keyRequestStoreData = self._keyRequestData.storeData;
                        keyRequestStoreData && Object.keys(keyRequestStoreData).forEach(function (k) {
                            storeState[k] = keyRequestStoreData[k];
                        });
                        return storeState;
                    });
                },
                timeout: callback.timeout,
                error: callback.error
            });
        });
    },

    getKeysForStore: function getKeysForStore_msCrypto(masterToken, callback) {
        var self = this;
        AsyncExecutor(callback, function () {
            var symmetricCryptoContext = self.getCryptoContext(masterToken);
            // we expect this to be a SymmetricCryptoContext which has encryptionKey and hmacKey
            var keys = {
                encryptionKey: symmetricCryptoContext.encryptionKey,
                hmacKey: symmetricCryptoContext.hmacKey
            };
            if (keys.encryptionKey && keys.hmacKey) {
                if (self._systemKeyWrapFormat) {
                    // some browsers will wrap the key and store the data
                    self.wrapKeysWithSystemKey(keys, callback);
                } else {
                    // others, which implement structured clone, can store actual key object in indexedDB
                    return keys;
                }
            } else {
                throw new MslException(MslError.INTERNAL_EXCEPTION, "Unable to get CryptoContext keys");
            }
        });
    },

    wrapKeysWithSystemKey: function (keys, callback) {
        var self = this;
        NccpMslStore$getSystemKey(this._systemKeyName, {
            result: function (systemKey) {
                AsyncExecutor(callback, function () {

                    var encryptionKey = keys.encryptionKey,
                        hmacKey = keys.hmacKey,
                        wrappedEncryptionKey = encryptionKey[NccpMslStore$_wrappedBySystemKeyArg],
                        wrappedHmacKey = hmacKey[NccpMslStore$_wrappedBySystemKeyArg];

                    // use the caches version if we have it
                    if (wrappedEncryptionKey && wrappedHmacKey) {
                        return {
                            wrappedEncryptionKey: wrappedEncryptionKey,
                            wrappedHmacKey: wrappedHmacKey
                        };
                    }

                    Promise.resolve()
                    .then(function () {
                        return Promise.all([
                            mslCrypto['wrapKey'](self._systemKeyWrapFormat, encryptionKey, systemKey, systemKey.algorithm),
                            mslCrypto['wrapKey'](self._systemKeyWrapFormat, hmacKey, systemKey, systemKey.algorithm)
                        ]);
                    })
                    .then(function (result) {
                        wrappedEncryptionKey = base64$encode(result[0]);
                        encryptionKey[NccpMslStore$_wrappedBySystemKeyArg] = wrappedEncryptionKey;

                        wrappedHmacKey = base64$encode(result[1]);
                        hmacKey[NccpMslStore$_wrappedBySystemKeyArg] = wrappedHmacKey;

                        callback.result({
                            wrappedEncryptionKey: wrappedEncryptionKey,
                            wrappedHmacKey: wrappedHmacKey
                        });
                    })
                    .catch(function (e) {
                        callback.error(new MslException(MslError.INTERNAL_EXCEPTION, "Error wrapping key with SYSTEM key", e));
                    });
                });
            },
            timeout: callback.timeout,
            error: callback.error
        });
    },

    unwrapKeysWithSystemKey: function (storeState, callback) {
        var self = this;
        NccpMslStore$getSystemKey(this._systemKeyName, {
            result: function (systemKey) {
                AsyncExecutor(callback, function () {
                    var wrappedEncryptionKey = base64$decode(storeState.wrappedEncryptionKey);
                    var wrappedHmacKey = base64$decode(storeState.wrappedHmacKey);

                    Promise.resolve()
                    .then(function () {
                        return Promise.all([
                            mslCrypto['unwrapKey'](self._systemKeyWrapFormat, wrappedEncryptionKey, systemKey, systemKey.algorithm, WebCryptoAlgorithm.AES_CBC, false, WebCryptoUsage.ENCRYPT_DECRYPT),
                            mslCrypto['unwrapKey'](self._systemKeyWrapFormat, wrappedHmacKey, systemKey, systemKey.algorithm, WebCryptoAlgorithm.HMAC_SHA256, false, WebCryptoUsage.SIGN_VERIFY)
                        ]);
                    })
                    .then(function (keys) {
                        var encryptionKey = keys[0];
                        var hmacKey = keys[1];
                        encryptionKey[NccpMslStore$_wrappedBySystemKeyArg] = storeState.wrappedEncryptionKey;
                        hmacKey[NccpMslStore$_wrappedBySystemKeyArg] = storeState.wrappedHmacKey;
                        callback.result({
                            encryptionKey: encryptionKey,
                            hmacKey: hmacKey
                        });
                    })
                    .catch(function (e) {
                        callback.error(new MslException(MslError.INTERNAL_EXCEPTION, "Error unwrapping with SYSTEM key", e));
                    });
                });
            },
            timeout: callback.timeout,
            error: callback.error
        });
    },

    /**
     * Loads from the persisted state
     */
    loadStoreState: function loadStoreState(mslConfig, mslContext, storeState, callback) {
        var mslStore = this,
            log = mslStore._log;

        // make sure ESN matches, we do this to handle rare scenario of ESN changing and MslStore still being there
        if (storeState.esn != mslStore._esn) {
            log.error('ESN mismatch, starting fresh');
            callback.error();
            return;
        }

        loadMasterToken({
            result: function (masterToken) {
                // load the user tokens ONLY if master token was loaded
                loadUserTokens(masterToken, callback);
            },
            timeout: callback.timeout,
            error: callback.error
        });

        function loadMasterToken(callback) {
            var complete;
            var masterToken;
            var loadedEncryptionKey;
            var loadedHmacKey;

            if (storeState.masterTokenJSON) {

                // ---- load masterToken
                // TODO: can we log a error for when we can't parse this?
                MasterToken$parse(mslContext, storeState.masterTokenJSON, {
                    result: function (mt) {
                        masterToken = mt;
                        tryComplete();
                    },
                    timeout: function () {
                        completeWithError('Timeout parsing MasterToken');
                    },
                    error: function (e) {
                        completeWithError('Error parsing MasterToken', e);
                    }
                });

                if (mslStore._systemKeyWrapFormat) {

                    // We should no longer do this as the new WebCrypto will have no
                    // way to get a SYSTEM key and browsers should implement a secure
                    // store for our session keys

                    // unwrapping also verifies the keys
                    mslStore.unwrapKeysWithSystemKey(storeState, {
                        result: function (keys) {
                            loadedEncryptionKey = keys.encryptionKey;
                            loadedHmacKey = keys.hmacKey;
                            tryComplete();
                        },
                        timeout: function () {
                            completeWithError('Timeout unwrapping keys');
                        },
                        error: function (e) {
                            completeWithError('Error unwrapping keys', e);
                        }
                    });

                } else {
                    // if we just load the keys, sanity check them (if it survived being stored/restored)
                    Promise.resolve()
                        .then(function(){
                            return mslCrypto['encrypt']({ 'name': WebCryptoAlgorithm.AES_CBC['name'], 'iv': new Uint8Array(16) }, storeState.encryptionKey, new Uint8Array(1));
                        })
                        .then(function (result) {
                            loadedEncryptionKey = storeState.encryptionKey;
                        })
                        .catch(function (e) {
                            completeWithError('Error loading encryptionKey');
                        })
                        .then(function () {
                            return mslCrypto['sign'](WebCryptoAlgorithm.HMAC_SHA256, storeState.hmacKey, new Uint8Array(1));
                        })
                        .then(function (result) {
                            loadedHmacKey = storeState.hmacKey;
                            tryComplete();
                        })
                        .catch(function (e) {
                            completeWithError('Error loading hmacKey');
                        });
                }

            } else {
                completeWithError('Persisted store is corrupt');
            }

            function tryComplete() {
                if (complete) {
                    return;
                }

                if (masterToken && loadedEncryptionKey && loadedHmacKey) {
                    complete = true;
                    var cryptoContext = new SessionCryptoContext(mslContext, masterToken, mslConfig.esn, { rawKey: loadedEncryptionKey }, { rawKey: loadedHmacKey });
                    mslStore.setCryptoContext(masterToken, cryptoContext, true);
                    callback.result(masterToken);
                }
            };

            function completeWithError(message, arg) {
                log.error(message, arg && ('' + arg));
                if (complete) {
                    return;
                }
                complete = true;
                callback.error();
            };
        };

        function loadUserTokens(masterToken, callback) {
            var userList;
            try {
                userList = storeState.userList.slice();
            }
            catch (e) {
            }

            if (!userList) {
                callback.result();
                return;
            }

            (function loadNextUserToken() {
                var user = userList.shift();
                if (user) {
                    UserIdToken$parse(mslContext, user.userIdTokenJSON, masterToken, {
                        result: function (userIdToken) {
                            try {
                                mslStore.addUserIdToken(user.userId, userIdToken);
                                loadServiceTokens(masterToken, userIdToken, user.serviceTokenJSONList, {
                                    result: loadNextUserToken,
                                    timeout: loadNextUserToken,
                                    error: loadNextUserToken
                                });
                            }
                            catch (e) {
                                loadNextUserToken();
                            }
                        },
                        timeout: loadNextUserToken,
                        error: loadNextUserToken
                    });
                } else {
                    callback.result();
                }
            })();
        };

        function loadServiceTokens(masterToken, userIdToken, serviceTokens, callback) {
            var serviceTokenList;
            try {
                serviceTokenList = serviceTokens.slice();
            }
            catch (e) {
            }

            if (!serviceTokenList) {
                callback.result();
                return;
            }

            var cryptoContext = mslStore.getCryptoContext(masterToken);

            (function loadNextServiceToken() {
                var serviceTokenJSON = serviceTokenList.shift();
                if (serviceTokenJSON) {
                    ServiceToken$parse(mslContext, serviceTokenJSON, masterToken, userIdToken, cryptoContext, {
                        result: function (serviceToken) {
                            mslStore.addServiceTokens([serviceToken]);
                            loadNextServiceToken();
                        },
                        timeout: function () {
                            loadNextServiceToken();
                        },
                        error: function () {
                            loadNextServiceToken();
                        }
                    });
                } else {
                    callback.result();
                }
            })();
        };

    }

});

function NccpMslStore$mapToJSON(token) {
    return token.toJSON();
};

var NccpMslStore$playbackServiceTokenNames = {
    'streaming.servicetokens.movie': true,
    'streaming.servicetokens.license': true
};

var NccpMslStore$_wrappedBySystemKeyArg = '$netflix$msl$wrapsys';
var NccpMslStore$_systemKey;
function NccpMslStore$getSystemKey(systemKeyName, callback) {
    if (NccpMslStore$_systemKey) {
        callback.result(NccpMslStore$_systemKey);
    } else {
        Promise.resolve()
        .then(function () {
            // KeyDescovery style
            return mslCrypto['getKeyByName'](systemKeyName);
        })
        .catch(function(){
            // ChromeOS-style
            return mslCrypto['generateKey']({ 'name': systemKeyName }, false, ['wrapKey', 'unwrapKey']);
        })
        .then(function (result) {
            NccpMslStore$_systemKey = result;
            callback.result(NccpMslStore$_systemKey);
        })
        .catch(function (e) {
            callback.error(new MslException(MslError.INTERNAL_EXCEPTION, "Unable to get system key"));
        });
    }
};



// -- NccpMslContext.js
var NccpMslContext = MslContext.extend({
    /** Create a new test MSL context for Nccp. */
    init: function init(mslStore, serverIdentity, idenityPublicKey, entityAuthFactories, entityAuthData, keyExchangeFactories) {
        // Set message capabilities.
        var capabilities = new MessageCapabilities([MslConstants$CompressionAlgorithm.LZW]);

        // Add the server factory for verifying server identity (common for all MSL clients)
        var entityAuthRsaStore = new RsaStore();
        entityAuthRsaStore.addPublicKey(serverIdentity, idenityPublicKey);
        entityAuthFactories[EntityAuthenticationScheme.RSA] = new RsaAuthenticationFactory(entityAuthRsaStore);

        // Set up user authentication factories.
        var userAuthFactories = {};
        userAuthFactories[UserAuthenticationScheme.EMAIL_PASSWORD] = new EmailPasswordAuthenticationFactory();
        userAuthFactories[UserAuthenticationScheme.NETFLIXID] = new NetflixIdAuthenticationFactory();
        userAuthFactories[UserAuthenticationScheme.MDX] = new MdxAuthenticationFactory();

        // This is only used for peer-to-peer,
        // for talking to server, use a special 'noop' implementation
        var mslCryptoContext = new ClientMslCryptoContext();

        // The properties.
        var props = {
            _mslCryptoContext: { value: mslCryptoContext, writable: true, enumerable: false, configurable: false },
            _capabilities: { value: capabilities, writable: false, enumerable: false, configurable: false },
            _entityAuthData: { value: entityAuthData, writable: true, enumerable: false, configurable: false },
            _entityAuthFactories: { value: entityAuthFactories, writable: false, enumerable: false, configurable: false },
            _userAuthFactories: { value: userAuthFactories, writable: false, enumerable: false, configurable: false },
            _keyExchangeFactories: { value: keyExchangeFactories, writable: false, enumerable: false, configurable: false },
            _store: { value: mslStore, writable: false, enumerable: false, configurable: false }
        };
        Object.defineProperties(this, props);
    },

    /** @inheritDoc */
    getTime: function getTime() {
        return Date.now();
    },

    /** @inheritDoc */
    getRandom: function getRandom() {
        return new Random();
    },

    /** @inheritDoc */
    isPeerToPeer: function isPeerToPeer() {
        return false;
    },

    /** @inheritDoc */
    getMessageCapabilities: function () {
        return this._capabilities;
    },

    /** @inheritDoc */
    getEntityAuthenticationData: function (reauth, callback) {
        callback.result(this._entityAuthData);
    },

    /** @inheritDoc */
    getMslCryptoContext: function () {
        return this._mslCryptoContext;
    },

    /** @inheritDoc */
    getEntityAuthenticationFactory: function (scheme) {
        return this._entityAuthFactories[scheme];
    },

    /** @inheritDoc */
    getUserAuthenticationFactory: function (scheme) {
        return this._userAuthFactories[scheme];
    },

    /** @inheritDoc */
    getTokenFactory: function () {
        return null;
    },

    /** @inheritDoc */
    getKeyExchangeFactory: function (scheme) {
        return this._keyExchangeFactories.filter(function (factory) {
            return factory.scheme == scheme;
        })[0];
    },

    /** @inheritDoc */
    getKeyExchangeFactories: function () {
        return this._keyExchangeFactories;
    },

    /** @inheritDoc */
    getMslStore: function () {
        return this._store;
    }

});



// -- NccpMessageContext.js
/**
* MSL Message contet for Nccp.
*/
var NccpMessageContext = MessageContext.extend({

    init: function init(log, mslContext, mslRequest, keyRequestData) {
        this._log = log;
        this._mslContext = mslContext;
        this._mslRequest = mslRequest;
        this._keyRequestData = keyRequestData;
    },

    /** @inheritDoc */
    getCryptoContexts: function () {
        // don't need to return anything since we don't create any service tokens
        return {};
    },

    /** @inheritDoc */
    isEncrypted: function () {
        return !!this._mslRequest.encrypted;
    },

    /** @inheritDoc */
    isNonReplayable: function () {
        return !!this._mslRequest.nonReplayable;
    },

    /** @inheritDoc */
    isRequestingTokens: function() {
        // FIXME: check this:
        // Mick says that all the transactions we use request service tokens
        // Wes says only auth and license do, but he may be forgetting user tokens
        return true;
    },

    /** @inheritDoc */
    getUserId: function () {
        var userId = this._mslRequest.userId;
        return userId || null;
    },

    /** @inheritDoc */
    getUserAuthData: function (reauthCode, renewable, required, callback) {
        var mslRequest = this._mslRequest;
        var mslContext = this._mslContext;
        // FIXME: required parameter must handled differently depending on the implementation
        AsyncExecutor(callback, function () {
            if (reauthCode) {
                // we can't handle reauth; renewable parm ignored
                return null;
            }
            if (mslRequest.email) {
                // if we have email, always use email/password reg
                return new EmailPasswordAuthenticationData(mslRequest.email, mslRequest.password);
            }
            if (mslRequest.netflixId) {
                // if the cookie is given, then use it always
                return new NetflixIdAuthenticationData(mslRequest.netflixId, mslRequest.secureNetflixId);
            }
            if (mslRequest.mdxControllerToken) {
                // if there is a mdx controller token, then this is mdx auth
                var controllerData = new MdxAuthenticationData$NtbaControllerData('regpairrequest', mslRequest.mdxNonce, mslRequest.mdxEncryptedPinB64, mslRequest.mdxSignature);
                var mdxAuthData = controllerData.getEncoding();
                return new MdxAuthenticationData(mslContext, mslRequest.mdxPin, mslRequest.mdxControllerToken, mdxAuthData, mslRequest.mdxSignature);
            }
            if (mslRequest.useNetflixUserAuthData) {
                return new NetflixIdAuthenticationData();
            }
            return null;
        });
    },

    /** @inheritDoc */
    getCustomer: function () {
        return null;
    },

    /** @inheritDoc */
    getKeyRequestData: function (callback) {
        // only send keyx data if we are allowed o refresh tokens
        callback.result(this._mslRequest.allowTokenRefresh ? [this._keyRequestData] : []);
    },

    /** @inheritDoc */
    updateServiceTokens: function (builder, handshake, callback) {
        var self = this;
        var log = this._log;
        var serviceTokens = (this._mslRequest.serviceTokens || []).slice();
        var mslContext = self._mslContext;
        var mslStore = mslContext.getMslStore();
        var masterToken = builder.builder.getMasterToken();
        var userId = self.getUserId();
        var userIdToken = mslStore.getUserIdToken(userId);
        (function addNextToken() {
            var token = serviceTokens.shift();
            if (token) {
                try {
                    // token can be the serialized version, in which case we need to parse it
                    if (token instanceof ServiceToken) {
                        builder.addPrimaryServiceToken(token);
                        addNextToken();
                    } else {
                        ServiceToken$parse(mslContext, token, masterToken, userIdToken, null, {
                            result: function (token) {
                                try {
                                    builder.addPrimaryServiceToken(token);
                                } catch(e) {
                                    log.warn('Exception adding service token', '' + e);
                                }
                                addNextToken();
                            },
                            timeout: function () {
                                log.warn('Timeout parsing service token');
                                addNextToken();
                            },
                            error: function (e) {
                                log.warn('Error parsing service token', '' + e);
                                addNextToken();
                            }
                        });
                    }
                } catch(e) {
                    log.warn('Exception processing service token', '' + e);
                    addNextToken();
                }
            } else {
                callback.result(true);
            }
        })();
    },

    /** @inheritDoc */
    write: function (output, timeout, callback) {
        var data = textEncoding$getBytes(this._mslRequest.body);
        output.write(data, 0, data.length, timeout, {
            result: function (numWritten) {
                if (numWritten != data.length) {
                    callback.error(new MslIoException('Not all data was written to output.'));
                    return;
                }
                output.flush(timeout, {
                    result: function () {
                        callback.result(true);
                    },
                    timeout: function () {
                        callback.timeout();
                    },
                    error: function (e) {
                        callback.error(e);
                    }
                });
            },
            timeout: function () {
                callback.timeout();
            },
            error: function (e) {
                callback.error(e);
            }
        });
    },

    /** @inheritDoc */
    getDebugContext: function () {
        this._dc || (this._dc = new NccpMessageDebugContext(this._log, this._mslRequest));
        return this._dc;
    },

});

var NccpMessageDebugContext = MessageDebugContext.extend({

    init: function init(log, mslRequest) {
        this._log = log;
        this._mslRequest = mslRequest;
    },

    /** @inheritDoc */
    sentHeader: function sentHeader(header) {
        this._log.trace(
            'Sent MSL header',
            NccpMessageDebugContext$getLogFields(this._mslRequest, header),
            header.serviceTokens && header.serviceTokens.map(NccpMessageDebugContext$mapToUniqueKey).join('\n')
        );
    },

    /** @inheritDoc */
    receivedHeader: function receivedHeader(header) {
        var logFields = NccpMessageDebugContext$getLogFields(this._mslRequest, header);
        var errorCode = header.errorCode;
        if (errorCode) {
            this._log.warn('Received MSL error header', logFields, {
                'errorCode': errorCode, 
                'errorMessage': header.errorMessage,
                'internalCode': header.internalCode,
            });
        } else {
            this._log.trace('Received MSL header', logFields);
        }
    }

});

function NccpMessageDebugContext$getLogFields(mslRequest, header) {
    var masterToken = header.masterToken;
    var userIdToken = header.userIdToken;
    var serviceTokens = header.serviceTokens;
    return {
        'NccpMethod': mslRequest.method,
        'UserId': mslRequest.userId,
        'UT': userIdToken && userIdToken.serialNumber,
        'MT': masterToken && (masterToken.serialNumber + ':' + masterToken.sequenceNumber),
        'STCount': serviceTokens && serviceTokens.length
    };
}

function NccpMessageDebugContext$mapToUniqueKey(token) {
    return token.uniqueKey();
}



// -- MslClient.js
/**
 * @constructor
 */
function MslClient(log, mslControl, mslContext, mslStore) {

    var _shouldPersistHandlers = [];

    // public interface

    this.addEventHandler = _addEventHandler;
    this.send = _send;
    this.hasUserIdToken = _hasUserIdToken;
    this.removeUserIdToken = _removeUserIdToken;
    this.isErrorReauth = _isErrorReauth;
    this.isErrorHeader = _isErrorHeader;
    this.getErrorCode = _getErrorCode;
    this.getStateForMdx = _getStateForMdx;
    this.buildPlayDataRequest = _buildPlayDataRequest;

    // private implementation

    function _addEventHandler(eventName, handler) {
        switch (eventName) {
            case 'shouldpersist':
                _shouldPersistHandlers.push(handler);
                break;
        }
    }

    /**
     * Sends a request to MSL client library.
     * On success the returned Promise will resolve to:
     * <code>{
     *     success: Boolean|true,
     *     body: String
     * }
     * </code>
     *
     * On failure the returned Promise will reject to:
     * <code> {
     *     success: Boolean|false,
     *     error: Object
     * }
     * </code>
     *
     * On timeout the returned Promise will reject to:
     * <code> {
     *     success: Boolean|false,
     * }
     * </code>
     *
     * @param  {{
     *     method: String,
     *     allowTokenRefresh: boolean,
     *     timeout: Number,
     *     url: String
     * }} mslRequest the information needed to perform the request
     * @return {Object} a promise that is fulfilled on success, failure or timeout
     */
    function _send(mslRequest) {

        return new Promise(function(resolve, reject) {
            var onSuccess = function(stream) {
                var messageHeader = stream && stream.getMessageHeader();
                log.trace('Received MSL response', {
                    'Method': mslRequest.method
                });

                if (!stream) {
                    reject({
                        success: false,
                        error: new MslException(MslError.INTERNAL_EXCEPTION, 'Null response stream'),
                        description: 'Null response stream'
                    });
                    return;
                }

                if (mslRequest.allowTokenRefresh) {
                    _persistStore();
                }

                var errorHeader = stream.getErrorHeader();
                if (errorHeader) {
                    _errorHandler(errorHeader, mslRequest.userId);
                    reject({
                        success: false,
                        error: errorHeader,
                    });
                    return;
                }

                _readAll(stream, timeout, {
                    result: function(r) {
                        resolve({
                            success: true,
                            body: textEncoding$getString(r)
                        });
                    },
                    timeout: function() {
                        reject({
                            success: false,
                            subCode: ErrorSubCodes.MSL_READ_TIMEOUT
                        });
                    },
                    error: function(e) {
                        reject({
                            success: false,
                            error: e
                        });
                    }
                });
            };

            var onError = function(err) {
                reject({
                    success: false,
                    error: err
                });
            };

            var onTimeout = function() {
                reject({
                    success: false,
                    subCode: ErrorSubCodes.MSL_REQUEST_TIMEOUT
                });
            };

            var timeout = mslRequest.timeout,
                msgCtx = new NccpMessageContext(log, mslContext, mslRequest, mslStore.getKeyRequestData()),
                url = new Url(mslRequest.url);

            log.trace('Sending MSL request');

            mslControl.request(
                // * @param {MslContext} ctx MSL context.
                mslContext,
                // * @param {MessageContext} msgCtx message context.
                msgCtx,
                // * @param {Url} remoteEntity remote entity URL.
                url,
                // * @param {number} timeout connect and read timeout in milliseconds.
                timeout,
                // * @param {result: function(MessageInputStream), timeout: function(), error: function(Error)}
                {
                    result: onSuccess,
                    timeout: onTimeout,
                    error: onError
                });
        });
    }

    function _errorHandler(errorHeader, accountKey) {
        if (errorHeader.errorCode === MslConstants$ResponseCode.ENTITY_REAUTH || 
            errorHeader.errorCode === MslConstants$ResponseCode.ENTITYDATA_REAUTH) {

            mslStore.clearCryptoContexts();
            _persistStore();
        } else if (errorHeader.errorCode === MslConstants$ResponseCode.USER_REAUTH || 
                   errorHeader.errorCode === MslConstants$ResponseCode.USERDATA_REAUTH) {

            _removeUserIdToken(accountKey);
        }     
    }

    function _hasUserIdToken(accountKey) {
        return !!mslStore.getUserIdToken(accountKey);
    }

    function _removeUserIdToken(accountKey) {
        var userIdToken = mslStore.getUserIdToken(accountKey);
        if (userIdToken) {
            mslStore.removeUserIdToken(userIdToken);
            _persistStore();
        }
    }

    function _isErrorReauth(e) {
        return e && (e.errorCode == MslConstants$ResponseCode.USERDATA_REAUTH);
    }

    function _isErrorHeader(e) {
        return e instanceof ErrorHeader;
    }

    function _getErrorCode(e) {
        return e && e.errorCode;
    }

    function _getStateForMdx(userId) {
        var masterToken = mslStore.getMasterToken();
        var userIdToken = mslStore.getUserIdToken(userId);
        var cryptoContext = mslStore.getCryptoContext(masterToken);
        return {
            masterToken: masterToken,
            userIdToken: userIdToken,
            cryptoContext: cryptoContext
        };
    }

    function _readAll(stream, timeout, callback) {
        var readArrays = [];
        (function readMore() {
            stream.read(-1, timeout, {
                result: function(r) {
                    AsyncExecutor(callback, function() {
                        if (r) {
                            readArrays.push(r);
                            readMore();
                        } else {
                            switch (readArrays.length) {
                                case 0:
                                    // nothign was read
                                    return new Uint8Array(0);
                                case 1:
                                    // common case, avoid copying the data
                                    return readArrays[0];
                                default:
                                    return Arrays$concat(readArrays);
                            }
                        }
                    });
                },
                timeout: function() {
                    callback.timeout();
                },
                error: function(e) {
                    callback.error(e);
                }
            });
        })();
    }

    function _persistStore() {
        mslStore.getStoreState({
            result: function(storeState) {
                // storeState may be null (e.g. clearCryptoContexts)
                var handlers = _shouldPersistHandlers.slice();
                for (var i = 0; i < handlers.length; i++) {
                    handlers[i]({
                        storeState: storeState
                    });
                }
            },

            timeout: function() {
                log.error('Timeout getting store state', '' + e);
            },

            error: function(e) {
                log.error('Error getting store state', '' + e);
            }
        });
    }

    function _buildPlayDataRequest(mslRequest, callback) {
        var url = new UrlInterceptor();

        mslControl.request(mslContext, new NccpMessageContext(log, mslContext, mslRequest), url, mslRequest.timeout, {
            result: function() {
                callback.result(url.getRequest());
            },
            error: function() {
                callback.result(url.getRequest());
            },
            timeout: function() {
                callback.timeout();
            }
        });
    }
}



// -- createMslClient.js
var contextFactories = {};

function createMslClient(mslConfig, callback) {
    var log = mslConfig.log,
        complete,
        error,
        idenityPublicKey,
        mslStore,
        mslContext,
        notifyMilestone = mslConfig.notifyMilestone || function () { };

    Promise.resolve()
    .then(function () {
        // check if we have WebCrypto. Do this check on cryptoSubtle, because the mslCrypto wrapper will be there no matter what.
        if (!cryptoSubtle || !cryptoSubtle['generateKey'] || !cryptoSubtle['importKey'] || !cryptoSubtle['unwrapKey']) {
            throw new MslException(MslError.INTERNAL_EXCEPTION, 'No WebCrypto');
        }

        // detect legacy (non-Promise) version of WebCrypto
        // use generateKey to create AES-CBC key, this is a simple operation that is available on all platforms
        var op = cryptoSubtle['generateKey']({ 'name': 'AES-CBC', 'length': 128 }, true, WebCryptoUsage.ENCRYPT_DECRYPT);
        MslCrypto$setWebCryptoVersion(op.then ? MslCrypto$WebCryptoVersion.V2014_02 : MslCrypto$WebCryptoVersion.LEGACY);

        // import the key for verifying server identity
        notifyMilestone('mslisik');
        return mslCrypto['importKey']('spki', mslConfig.serverIdentityKeyData, WebCryptoAlgorithm.RSASSA_SHA256, false, ['verify']);
    })
    .then(function (key) {
        // create the key for verifying server identity
        return new Promise(function (resolve, reject) {
            PublicKey$create(key, {
                result: resolve,
                error: function () {
                    reject(new MslException(MslError.KEY_IMPORT_ERROR, 'Unable to create server identity verification key'));
                }
            });
        });
    })
    .then(function (publicKey) {
        idenityPublicKey = publicKey;
        var contextFactory = contextFactories[mslConfig.authenticationType];
        if (contextFactory) {
            notifyMilestone('mslcc');
            return contextFactory(mslConfig);
        } else {
            throw new MslException(MslError.INTERNAL_EXCEPTION, 'Invalid authenticationType: ' + mslConfig.authenticationType);
        }
    })
    .then(function (context) {
        mslStore = new NccpMslStore(log, mslConfig.esn, context.keyRequestData, context.createKeyRequestData, mslConfig.authenticationKeyNames['s'], mslConfig.systemKeyWrapFormat);
        mslContext = new NccpMslContext(mslStore, mslConfig.serverIdentityId, idenityPublicKey, context.entityAuthFactories, context.entityAuthData, context.keyExchangeFactories);

        var storeState = mslConfig.storeState;
        if (storeState) {
            notifyMilestone('mslss');
            log.info('Loading store state');
            return new Promise(function (resolve, reject) {
                // keep going, even if store fails to load
                mslStore.loadStoreState(mslConfig, mslContext, storeState, {
                    result: resolve,
                    timeout: resolve,
                    error: resolve
                });
            });
        } else {
            log.info('No store state, starting fresh');
        }
    })
    .then(function () {
        var mslControl = new MslControl();
        notifyMilestone('msldone');
        callback.result(new MslClient(log, mslControl, mslContext, mslStore));
    })
    .catch(function (e) {
        callback.error(e);
    });
}





// -- contextFactoryForPresharedKeys.js
function contextFactoryForPresharedKeys(mslConfig, scheme, AuthenticationFactory, AuthenticationData, LadderExchange, LadderExchange$RequestData) {

    function getCipherKey(configKeyName) {
        var keyName;
        return Promise.resolve()
        .then(function () {
            keyName = mslConfig.authenticationKeyNames[configKeyName];
            if (!keyName) {
                throw new MslException(MslError.KEY_IMPORT_ERROR, 'Invalid config keyName ' + configKeyName);
            }
            return mslCrypto['getKeyByName'](keyName);
        })
        .then(function (result) {
            return new Promise(function (resolve, reject) {
                CipherKey$create(result, {
                    result: resolve,
                    error: function () {
                        reject(new MslException(MslError.KEY_IMPORT_ERROR, 'Unable to create ' + keyName + ' CipherKey'));
                    }
                });
            });
        })
        .catch(function (e) {
            throw new MslException(MslError.KEY_IMPORT_ERROR, 'Unable to import ' + keyName, e);
        });
    }

    return Promise.resolve()
    .then(function () {
        if (!mslCrypto['getKeyByName']) {
            throw new MslException(MslError.INTERNAL_EXCEPTION, 'No WebCrypto cryptokeys');
        }

        return Promise.all([
            getCipherKey('e'),
            getCipherKey('h'),
            getCipherKey('w')
        ])
    })
    .then(function (keys) {
        var entityAuthFactories = {};
        entityAuthFactories[scheme] = new AuthenticationFactory(mslConfig.esn, keys[0], keys[1], keys[2]);
        // Set up entity authentication data
        var entityAuthData = new AuthenticationData(mslConfig.esn);
        // Set up key exchange factories.
        var repository = new NccpWrapCryptoContextRepository();
        var keyExchangeFactories = [new LadderExchange(repository)];
        var keyRequestData = new LadderExchange$RequestData(scheme);
        return {
            entityAuthFactories: entityAuthFactories,
            entityAuthData: entityAuthData,
            keyExchangeFactories: keyExchangeFactories,
            keyRequestData: keyRequestData
        };
    });

};


// -- contextFactory-PSK.js
contextFactories['PSK'] = function contextFactories_PSK(mslConfig) {

    return contextFactoryForPresharedKeys(
        mslConfig,
        EntityAuthenticationScheme.PSK,
        NccpPresharedAuthenticationFactory,
        PresharedAuthenticationData,
        NetflixJsonWebKeyLadderExchange,
        NetflixJsonWebKeyLadderExchange$RequestData
    );

};


// -- contextFactory-MGK.js
contextFactories['MGK'] = function contextFactories_MGK(mslConfig) {

    return contextFactoryForPresharedKeys(
        mslConfig,
        EntityAuthenticationScheme.MGK,
        NccpModelGroupAuthenticationFactory,
        ModelGroupAuthenticationData,
        NetflixJsonWebKeyLadderExchange,
        NetflixJsonWebKeyLadderExchange$RequestData
    );

};


// -- contextFactory-MGK_WITH_FALLBACK.js
contextFactories['MGK_WITH_FALLBACK'] = function contextFactories_MGK_WITH_FALLBACK(mslConfig) {
    var authenticationType;
    switch(mslConfig.esnPrefix) {
        case 'GOOGEUR001':
        case 'GOOGLEXX01':
            // for old known devices, fallback to PSK
            authenticationType = 'PSK';
            break;
        default:
            // by default, go MGK
            authenticationType = 'MGK';
            break;
    }
    var contextFactory = contextFactories[authenticationType];
    if (!contextFactory) {
        throw new MslException(MslError.INTERNAL_EXCEPTION, 'Invalid fallback authenticationType: ' + authenticationType);
    }
    return contextFactory(mslConfig);
};


// -- contextFactory-MGK_JWE.js
contextFactories['MGK_JWE'] = function contextFactories_MGK_JWE(mslConfig) {

    return contextFactoryForPresharedKeys(
        mslConfig,
        EntityAuthenticationScheme.MGK,
        NccpModelGroupAuthenticationFactory,
        ModelGroupAuthenticationData,
        NetflixJsonWebEncryptionLadderExchange,
        NetflixJsonWebEncryptionLadderExchange$RequestData
    );

};


// -- contextFactoryForAsymmetricWrappedExchange.js
function contextFactoryForAsymmetricWrappedExchange(mslConfig, algorithm, mechanism) {

    // we can store keyx keys, only if we don't have a system key (which implies that there is structured clone support)
    var canStoreKeys = !mslConfig.systemKeyWrapFormat;

    function createKeyRequestData() {
        return Promise.resolve()
        .then(function () {
            return mslCrypto['generateKey'](algorithm, false, ['wrapKey', 'unwrapKey']);
        })
        .then(function (result) {
            return createKeyRequestDataFromKeyPair(result['publicKey'], result['privateKey']);
        });
    }

    function createKeyRequestDataFromKeyPair(publicKey, privateKey) {
        return Promise.all([
            new Promise(function (resolve, reject) {
                PublicKey$create(publicKey, {
                    result: resolve,
                    error: function (e) {
                        reject(new MslException(MslError.INTERNAL_EXCEPTION, 'Unable to create keyx public key', e));
                    }
                });
            }),
            new Promise(function (resolve, reject) {
                PrivateKey$create(privateKey, {
                    result: resolve,
                    error: function (e) {
                        reject(new MslException(MslError.INTERNAL_EXCEPTION, 'Unable to create keyx private key', e));
                    }
                });
            })
        ])
        .then(function (keys) {
            var requestData = new AsymmetricWrappedExchange$RequestData('rsaKeypairId', mechanism, keys[0], keys[1]);
            if (canStoreKeys) {
                // augment it with data we want stored in MSL store
                requestData.storeData = {
                    'keyxPublicKey': publicKey,
                    'keyxPrivateKey': privateKey
                };
            }
            return requestData;
        });
    }

    return Promise.resolve()
    .then(function () {
        var storeState = mslConfig.storeState;
        var keyxPublicKey = storeState && storeState['keyxPublicKey'];
        var keyxPrivateKey = storeState && storeState['keyxPrivateKey'];
        if (canStoreKeys && keyxPublicKey && keyxPrivateKey) {
            // if we have stored keyx key pair, use that instead of generating
            return createKeyRequestDataFromKeyPair(keyxPublicKey, keyxPrivateKey);
        } else {
            return createKeyRequestData();
        }
    })
    .then(function (keyRequestData) {
        var entityAuthFactories = {};
        entityAuthFactories[EntityAuthenticationScheme.NONE] = new UnauthenticatedAuthenticationFactory();
        // Set up entity authentication data
        var entityAuthData = new UnauthenticatedAuthenticationData(mslConfig.esn);
        // Set up key exchange factories.
        var keyExchangeFactories = [new AsymmetricWrappedExchange()];;
        return {
            entityAuthFactories: entityAuthFactories,
            entityAuthData: entityAuthData,
            keyExchangeFactories: keyExchangeFactories,
            keyRequestData: keyRequestData,
            createKeyRequestData: canStoreKeys ? createKeyRequestData : undefined
        };
    });

};


// -- contextFactory-JWK_RSA.js
contextFactories['JWK_RSA'] = function contextFactories_JWK_RSA(mslConfig) {

    return contextFactoryForAsymmetricWrappedExchange(
        mslConfig,
        { 'name': 'RSA-OAEP', 'modulusLength': 2048, 'publicExponent': new Uint8Array([0x01, 0x00, 0x01]), 'hash': { 'name': 'SHA-1' } },
        AsymmetricWrappedExchange$Mechanism.JWK_RSA
    );

};


// -- contextFactory-JWK_RSAES.js
contextFactories['JWK_RSAES'] = function contextFactories_JWK_RSAES(mslConfig) {

    return contextFactoryForAsymmetricWrappedExchange(
        mslConfig,
        { 'name': 'RSAES-PKCS1-v1_5', 'modulusLength': 2048, 'publicExponent': new Uint8Array([0x01, 0x00, 0x01]) },
        AsymmetricWrappedExchange$Mechanism.JWK_RSAES
    );

};


// -- contextFactory-JWEJS_RSA.js
contextFactories['JWEJS_RSA'] = function contextFactories_JWEJS_RSA(mslConfig) {

    return contextFactoryForAsymmetricWrappedExchange(
        mslConfig,
        { 'name': 'RSA-OAEP', 'modulusLength': 2048, 'publicExponent': new Uint8Array([0x01, 0x00, 0x01]) },
        AsymmetricWrappedExchange$Mechanism.JWEJS_RSA
    );

};


    window['netflix'] = window['netflix'] || {};
    window['netflix']['msl'] = {
        createMslClient: createMslClient,
        IHttpLocation: IHttpLocation,
        MslIoException: MslIoException
    };

})(window);


// -- player.js
/** 
* @param {*=}t
* @param {*=}n
* @param {*=}r
*/
(function e(t, n, r) {
	/** 
	* @param {*=}o
	* @param {*=}u 
	*/
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = (typeof require) == "function" ? require : undefined;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }
    var i = typeof require == "function" ? require : undefined;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s
})
({1:[function(require,module,exports){
/**
* @param {undefined=} undefined
*/
(function (window, undefined) {
    /**
    * @const
    */
    var VERSION = '2016.805.9.2235.CHROME.lgml-davidaragonVH8';

    /**
    * @const
    */
    var DEBUG = true;
    /**
    * @const
    */
    var ASE  = true;

    /**
    * @const
    */
    var DEV = false;

// -- common/constants.js
/** @const */
var NOOP = function () { };
/** @const */
var BADOP = function () { debug$assert(); };
/** @const */
var RETURN_TRUE = function () { return true; };
/** @const */
var SUCCESS = { success: true };
/** @const */
var MILLISECONDS_PER_SECOND = 1000;
/** @const */
var SECONDS_IN_DAY = 60*60*24;
/** @const */
var SECONDS_IN_WEEK = 60*60*24*7;
/** @const */
var MEDIA_TIME_PER_MILLISECOND = 10000;
/** @const */
var MEDIA_TIME_PER_SECOND = 10000000;
/** 
* @const 
* How high can VBR (variable bitrate) stream get
*/
var VBR_CEIL = 1.5;
// kilobits per second TO bytes per millisecond
/** @const */
var KBPStoBPMS = 1024 / 8000;
// bytes per millisecond TO kilobits per second
/** @const */
var BPMStoKBPS = 8000 / 1024;
// bytes to kilobits
/** @const */
var BYTES_TO_KILOBIT = 128;
// no movie can be longer than this, 1 week
/** @const */
var MAX_MEDIA_TIME = 14515200000;
/** @const */
var MAX_RESOLUTION = 100000;
/** @const */
var ORDERPROPERTY = '$netflix$player$order';
/** @const */
var ORDERPROPERTY$early = -1;
/** @const */
var ORDERPROPERTY$late = 1;
/** @const */
var DEFAULT_LANGUAGES = ['en-US'];
/** @const */
var BYTEtoBITS = 8;

/** @const */
var audioProfile$HEAAC = 'heaac-2-dash';
/** @const */
var audioProfile$DDPLUS_20 = 'ddplus-2.0-dash';
/** @const */
var audioProfile$DDPLUS = 'ddplus-5.1-dash';
/** @const */
var audioProfile$HEAAC_DRM = 'playready-heaac-2-dash';
/** @const */
var audioProfile$HEAAC_ENC = 'heaac-2-dash-enc';
/** @const */
var audioProfile$DDPLUS_20_ENC = 'ddplus-2.0-dash-enc';
/** @const */
var audioProfile$DDPLUS_ENC = 'ddplus-5.1-dash-enc';
/** @const */
var audioProfile$HEAAC_DRM_ENC = 'playready-heaac-2-dash-enc';

/** @const */
var videoProfile$H264_BPL30 = 'playready-h264bpl30-dash';
/** @const */
var videoProfile$H264_MPL30 = 'playready-h264mpl30-dash';
/** @const */
var videoProfile$H264_MPL31 = 'playready-h264mpl31-dash';
/** @const */
var videoProfile$H264_MPL40 = 'playready-h264mpl40-dash';
/** @const */
var videoProfile$HEVC_MAIN10_MPL30 = 'hevc-main10-L30-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN10_MPL31 = 'hevc-main10-L31-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN10_MPL40 = 'hevc-main10-L40-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN10_MPL41 = 'hevc-main10-L41-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN10_MPL50 = 'hevc-main10-L50-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN10_MPL51 = 'hevc-main10-L51-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN_MPL30 = 'hevc-main-L30-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN_MPL31 = 'hevc-main-L31-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN_MPL40 = 'hevc-main-L40-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN_MPL41 = 'hevc-main-L41-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN_MPL50 = 'hevc-main-L50-dash-cenc';
/** @const */
var videoProfile$HEVC_MAIN_MPL51 = 'hevc-main-L51-dash-cenc';

// HEVC Main10 - Per Resolution Keys
/** @const */
var videoProfile$HEVC_MAIN10_MPL30_PRK = 'hevc-main10-L30-dash-cenc-prk';
/** @const */
var videoProfile$HEVC_MAIN10_MPL31_PRK = 'hevc-main10-L31-dash-cenc-prk';
/** @const */
var videoProfile$HEVC_MAIN10_MPL40_PRK = 'hevc-main10-L40-dash-cenc-prk';
/** @const */
var videoProfile$HEVC_MAIN10_MPL41_PRK = 'hevc-main10-L41-dash-cenc-prk';

// HEVC Main Temporal Layer
/** @const */
var videoProfile$HEVC_MAIN_MPL30_31_tl = 'hevc-main-L30-L31-dash-cenc-tl';

/** @const */
var videoProfile$HEVC_MAIN_MPL31_40_tl = 'hevc-main-L31-L40-dash-cenc-tl';

/** @const */
var videoProfile$HEVC_MAIN_MPL40_41_tl = 'hevc-main-L40-L41-dash-cenc-tl';

/** @const */
var videoProfile$HEVC_MAIN_MPL50_51_tl = 'hevc-main-L50-L51-dash-cenc-tl';

// HEVC Main10 Temporal Layer
/** @const */
var videoProfile$HEVC_MAIN10_MPL30_31_tl = 'hevc-main10-L30-L31-dash-cenc-tl';

/** @const */
var videoProfile$HEVC_MAIN10_MPL31_40_tl = 'hevc-main10-L31-L40-dash-cenc-tl';

/** @const */
var videoProfile$HEVC_MAIN10_MPL40_41_tl = 'hevc-main10-L40-L41-dash-cenc-tl';
/** @const */
var videoProfile$HEVC_MAIN10_MPL50_51_tl = 'hevc-main10-L50-L51-dash-cenc-tl';

// DOLBY VISION HEVC Codecs
/** @const */
var videoProfile$DV_MAIN10_MPL30 = 'hevc-dv-main10-L30-dash-cenc';
/** @const */
var videoProfile$DV_MAIN10_MPL31 = 'hevc-dv-main10-L31-dash-cenc';
/** @const */
var videoProfile$DV_MAIN10_MPL40 = 'hevc-dv-main10-L40-dash-cenc';
/** @const */
var videoProfile$DV_MAIN10_MPL41 = 'hevc-dv-main10-L41-dash-cenc';
/** @const */
var videoProfile$DV_MAIN10_MPL50 = 'hevc-dv-main10-L50-dash-cenc';
/** @const */
var videoProfile$DV_MAIN10_MPL51 = 'hevc-dv-main10-L51-dash-cenc';

// HDR10 HEVC Codecs
/** @const */
var videoProfile$HDR_MAIN10_MPL30 = 'hevc-hdr-main10-L30-dash-cenc';
/** @const */
var videoProfile$HDR_MAIN10_MPL31 = 'hevc-hdr-main10-L31-dash-cenc';
/** @const */
var videoProfile$HDR_MAIN10_MPL40 = 'hevc-hdr-main10-L40-dash-cenc';
/** @const */
var videoProfile$HDR_MAIN10_MPL41 = 'hevc-hdr-main10-L41-dash-cenc';
/** @const */
var videoProfile$HDR_MAIN10_MPL50 = 'hevc-hdr-main10-L50-dash-cenc';
/** @const */
var videoProfile$HDR_MAIN10_MPL51 = 'hevc-hdr-main10-L51-dash-cenc';

var videoProfiles$SDSet = [
    videoProfile$H264_MPL30
];

var videoProfiles$HDSet = [
    videoProfile$H264_MPL31,
    videoProfile$H264_MPL40
];

var videoProfiles$UHDSet = [
    videoProfile$HEVC_MAIN_MPL30,
    videoProfile$HEVC_MAIN_MPL31,
    videoProfile$HEVC_MAIN_MPL40,
    videoProfile$HEVC_MAIN_MPL41,
    videoProfile$HEVC_MAIN_MPL50,
    videoProfile$HEVC_MAIN_MPL51
];

var videoProfiles$UHD_Main10Set = [
    videoProfile$HEVC_MAIN10_MPL30,
    videoProfile$HEVC_MAIN10_MPL31,
    videoProfile$HEVC_MAIN10_MPL40,
    videoProfile$HEVC_MAIN10_MPL41,
    videoProfile$HEVC_MAIN10_MPL50,
    videoProfile$HEVC_MAIN10_MPL51
];

// All DV profiles, SFR and HFR
var videoProfiles$DV_Complete_Set = [
    videoProfile$DV_MAIN10_MPL30,
    videoProfile$DV_MAIN10_MPL40,
    videoProfile$DV_MAIN10_MPL50,
    videoProfile$DV_MAIN10_MPL31,
    videoProfile$DV_MAIN10_MPL41,
    videoProfile$DV_MAIN10_MPL51    
];

// All SFR DV profiles, and all HFR except 4k
var videoProfiles$DV_no_HFR_4k_Set = [
    videoProfile$DV_MAIN10_MPL30,
    videoProfile$DV_MAIN10_MPL31,    
    videoProfile$DV_MAIN10_MPL40,
    videoProfile$DV_MAIN10_MPL50,
    videoProfile$DV_MAIN10_MPL41
];

var videoProfiles$H264Set = videoProfiles$SDSet.concat(videoProfiles$HDSet);
var videoProfiles$H265MainSet = videoProfiles$UHDSet;
var videoProfiles$H265Main10Set = videoProfiles$UHD_Main10Set;

/** @const */
var timedTextProfile$SIMPLESDH = 'simplesdh';
/** @const */
var timedTextProfile$DFXP_LS_SDH = 'dfxp-ls-sdh';
/** @const */
var timedTextProfile$NFLX_CMISC = 'nflx-cmisc';
/** @const */
var timedTextProfile$SIMPLESDH_ENC = 'simplesdh-enc';
/** @const */
var timedTextProfile$DFXP_LS_SDH_ENC = 'dfxp-ls-sdh-enc';
/** @const */
var timedTextProfile$NFLX_CMISC_ENC = 'nflx-cmisc-enc';

/** @const */
var MAX_UINT16 = 0xffff;
var SIXTY_FOUR_KB = 65536;
var Number$MAXVAL = Number.MAX_VALUE;

/** @const */
var AuthenticationType$CTicket = 'CTicket';
/** @const */
var AuthenticationType$NetflixID = 'NetflixID';
/** @const */
var AuthenticationType$ESNH = 'ESNH';
/** @const */
var AuthenticationType$PSK = 'PSK';
/** @const */
var AuthenticationType$MGK = 'MGK';
/** @const */
var AuthenticationType$MGK_WITH_FALLBACK = 'MGK_WITH_FALLBACK';
/** @const */
var AuthenticationType$MGK_JWE = 'MGK_JWE';
/** @const */
var AuthenticationType$JWEJS_RSA = 'JWEJS_RSA';
/** @const */
var AuthenticationType$JWK_RSA = 'JWK_RSA';
/** @const */
var AuthenticationType$JWK_RSAES = 'JWK_RSAES';

/** @const */
var DrmType$PLAYREADY = 'playready';
/** @const */
var DrmType$WIDEVINE = 'widevine';
/** @const */
var DrmType$FPS = 'fps';
/** @const */
var DrmType$PRIMETIME = 'primetime';
/** @const */
var DrmType$CLEARKEY = 'clearkey';

/** @const */
var MEDIA_TYPE_AUDIO_HEAAC = 'audio/mp4; codecs="mp4a.40.5"';
/** @const */
var MEDIA_TYPE_AUDIO_DDPLUS = 'audio/mp4; codecs="mp4a.a6"';
/** @const */
var MEDIA_TYPE_VIDEO_H264 = 'video/mp4; codecs="avc1.640028"';
/** @const */
var MEDIA_TYPE_VIDEO_H265 = 'video/mp4; codecs="hev1.2.6.L153.B0"';
/** @const */
var MEDIA_TYPE_VIDEO_DV = 'video/mp4; codecs="dvhe.01000000"';

/** @const */
var DrmSystemId$PLAYREADY = '9A04F079-9840-4286-AB92-E65BE0885F95';
/** @const */
var DrmSystemId$WIDEVINE = '29701FE4-3CC7-4A34-8C5B-AE90C7439A47';
/** @const */
var DrmSystemId$WIDEVINE2 = 'EDEF8BA9-79D6-4ACE-A3C8-27DCD51D21ED';
/** @const */
var DrmSystemId$PRIMETIME = 'F239E769-EFA3-4850-9C16-A903C6932EFB';

/** @const */
var Box$netflixHeaderTypes = ['4E657466-6C69-7850-6966-665374726D21', '4E657466-6C69-7848-6165-6465722E7632'];
/** @const */
var Box$sampleEncryptionType = 'A2394F52-5A9B-4F14-A244-6C427C648DF4';
/** @const */
var Box$netflixVideoFrameType = '4E657466-6C69-7846-7261-6D6552617465';
/** @const */
var Box$trackEncryptionType = '8974DBCE-7BE7-4C51-84F9-7148F9882554';

// known box types for codecs
/** @const */
var Box$CODEC_MP4A = 'mp4a'; // clear AAC audio
/** @const */
var Box$CODEC_ENCA = 'enca'; // encrypted AAC audio
/** @const */
var Box$CODEC_EC3  = 'ec-3'; // clear DD+ audio
/** @const */
var Box$CODEC_AVC1 = 'avc1'; // clear H264 video
/** @const */
var Box$CODEC_ENCV = 'encv'; // encrypted H264 video
/** @const */
var Box$CODEC_HEVC = 'hvcC'; // encrypted HEVC (H265) video
/** @const */
var Box$CODEC_HEV1 = 'hev1'; // Dolby Vision Base Layer
/** @const */
var Box$CODEC_DVHE = 'dvhe'; // Dolby Vision (Enhancement layer)





// -- shortcuts.js
var navigator = window['navigator'],
    userAgent = navigator['userAgent'],
    location = window['location'],
    screen = window['screen'],
    performance = window['performance'],
    document = window['document'],
    documentElement = document['documentElement'],

    Array = window['Array'],
    arrayPrototype = Array.prototype,
    sort = arrayPrototype.sort,
    map = arrayPrototype.map,
    slice = arrayPrototype.slice,
    every = arrayPrototype.every,
    reduce = arrayPrototype.reduce,
    filter = arrayPrototype.filter,
    forEach = arrayPrototype.forEach,
    pop = arrayPrototype.pop,

    Object = window['Object'],
    Object$create = Object['create'],
    Object$keys = Object['keys'],

    Date = window['Date'],
    Date$now = Date['now'],

    String = window['String'],
    String$fromCharCode = String['fromCharCode'],

    parseInt = window['parseInt'],
    parseFloat = window['parseFloat'],
    Math = window['Math'],
    Math$floor = Math.floor,
    Math$ceil = Math.ceil,
    Math$round = Math.round,
    Math$max = Math.max,
    Math$min = Math.min,
    Math$random = Math.random,
    Math$abs = Math.abs,
    Math$pow = Math.pow,
    Math$sqrt = Math.sqrt,

    Error = window['Error'],
    JSON = window['JSON'],
    escape = window['escape'],
    unescape = window['unescape'],
    btoa = window['btoa'],
    atob = window['atob'],
    encodeURIComponent = window['encodeURIComponent'],
    decodeURIComponent = window['decodeURIComponent'],

    XMLHttpRequest = window['XMLHttpRequest'],
    Uint8Array = window['Uint8Array'],
    Promise = window['Promise'],

    URL = window['URL'] || window['webkitURL'],
    HTMLVideoElement = window['HTMLVideoElement'],
    MediaSource = window['MediaSource'] || window['WebKitMediaSource'],
    MediaKeys = window['WebKitMediaKeys'] || window['MSMediaKeys'] || window['MediaKeys'],

    XMLSerializer = window['XMLSerializer'],
    DOMParser = window['DOMParser'],
    XPathResult = window['XPathResult'],

    crypto = window['nfCrypto'] || window['webkitCrypto'] || window['msCrypto'] || window['crypto'],
    cryptoSubtle = crypto && (crypto['webkitSubtle'] || crypto['subtle']),
    cryptokeys = window['nfCryptokeys'] || window['webkitCryptokeys'] || window['msCryptokeys'] || window['cryptokeys'],

    indexedDB,
    indexedDBAccessException,
    localStorage,
    localStorageAccessException,
    PERSISTENT = window['PERSISTENT'],
    TEMPORARY = window['TEMPORARY'],
    requestFileSystem = window['requestFileSystem'] || window['webkitRequestFileSystem'],
    Blob = window['Blob'],
    FileReader = window['FileReader'],
    persistentStorage = navigator['persistentStorage'] || navigator['webkitPersistentStorage'],
    // Do not load the window.webkitStorageInfo if navigator.webkitPersistentStorage exists (This was changed in Chrome R28)
    storageInfo = persistentStorage ? undefined : (window['storageInfo'] || window['webkitStorageInfo']);

try {
    // IE can throw when accessing localStorage, we haven't seen indexedDB throw, but they use same internal mechanism
    indexedDB = window['indexedDB'];
}
catch (e) {
    indexedDBAccessException = e || 'noex';
}

try {
    // IE can throw on this operation
    localStorage = window['localStorage'];
}
catch (e) {
    localStorageAccessException = e || 'noex';
}



// -- common/isType.js
var cts = require(9);
var IsType = new cts.DefaultIsType();

var isDefined = IsType.definedAndNotNull;
var isObject  = IsType.anObject;
var isValidObject = IsType.aValidObject;
var isArray = IsType.anArray;
var isUint8Array = IsType.anUint8Array;
var isNumber = IsType.aNumber;
var isInt = IsType.anInt;
var isUInt = IsType.anUInt;
var isPositiveInt = IsType.aPositiveInt;
var isByte = IsType.aByte;
var isFloat = IsType.aFloat;
var isUrl = IsType.anUrl;
var isString = IsType.aString;
var isValidString = IsType.aValidString;
var isBool = IsType.aBool;
var isFunction = IsType.aFunction;


// -- common/utilities-shared.js
// common set of utilities that is shared between gibbon and player

/**
* @param {Object} o
* @param {function(string, Object=)} handler
*/
function enumerateOwnProperties(o, handler) {
    for (var k in o) {
        o.hasOwnProperty(k) && handler(k, o[k]);
    }
}

/**
* @param {Object} o
* @param {Object=} o2
* @param {{makeLowerCase,prefix,onlyIfDefined}=} options
*/
function mixIn(o, o2, options) {
    if (o2) {
        if (options) {
            var makeLowerCase = options.makeLowerCase,
                prefix = options.prefix,
                onlyIfDefined = options.onlyIfDefined;

            enumerateOwnProperties(o2, function (k, v) {
                if (!onlyIfDefined || isDefined(v)) {
                    o[(prefix || '') + (makeLowerCase ? k.toLowerCase() : k)] = v;
                }
            });

        } else {
            // keep simple and common case simple
            enumerateOwnProperties(o2, function (k, v) {
                o[k] = v;
            });
        }
    }
    return o;
}

/**
* @param {Object} o
* @param {string} methodName
* @param {*=} returnValue
* @param {...*} arg
*
* Call a method only if object exists and has the method
*/
function callIfPresent(o, methodName, returnValue, arg) {
    if (o) {
        var f = o[methodName];
        if (isFunction(f)) {
            returnValue = f['apply'](o, slice['call'](arguments, 3));
        }
    }
    return returnValue;
}

/**
* clones the properties of an object (only the top level properties)
*
* @param {Object} o
*/
function shallowCopy(o) {
    var cloned = {};
    enumerateOwnProperties(o, function (k, v) {
        cloned[k] = v;
    });
    return cloned;
}

/**
* Returns the first value that neither undefined or null. Similar to a || c || b but respects 0-s and ''-s
*
* @param {...*} arg
*/
function coalesce(arg) {
    var i = 0,
        length = arguments.length;

    while (i < length) {
        var v = arguments[i++];
        if (isDefined(v)) {
            return v;
        }
    }
}

function arraySortByProperty(a, propertyKey) {
    // [].sort is actually much slower than doing it this way...

    var i,
        keepGoing = true,
        o;

    while (keepGoing) {
        keepGoing = false;
        i = a.length;
        while (--i) {
            o = a[i];
            if (o[propertyKey] < a[i - 1][propertyKey]) {
                a[i] = a[i - 1];
                a[i - 1] = o;
                keepGoing = true;
            }
        }
    }
}

function arrayToHashSet(a) {
    var o = {},
        i = a.length;
    while (i--) {
        o[a[i]] = true;
    }
    return o;
}

/**
* @param {string} s
*/
function parseInt10(s) {
    return parseInt(s, 10);
}

/**
* @param {string} s
*/
function parseBoolean(s) {
    return (/^true$/i).test(s);
}

function randomInt(min, max) {
    return Math$round(min + Math$random() * (max - min));
}

/**
* @param {*} o
*/
function stringifyJsonPretty(o) {
    return JSON.stringify(o, null, '  ');
}

var htmlEncode = (function () {
    var map = {
        '&': '&amp;',
        '\'': '&#39;',
        '"': '&quot;',
        '<': '&lt;',
        '>': '&gt;'
    };
    var regex = /[&'"<>]/g;
    function mapper(tag) {
        debug$assert(map[tag] !== undefined);
        return map[tag];
    };
    return function (s) {
        return s.replace(regex, mapper);
    };
})();

var trim = (function () {
    var regex = /^\s+|\s+$/gm;
    return function (s) {
        return s.replace(regex, '');
    };
})();

function makeArray(elt) {
    return Array.isArray(elt) ? elt : [elt];
}

function exceptionToString(e) {
    if (e) {
        // stack has the exception, don't duplicate it
        var stack = e['stack'];
        var number = e['number'];
        var message = e['message'];
        if (!message) {
            message = '' + e;
        }
        var s;
        if (stack) {
            s = '' + stack;
            if (s.indexOf(message) != 0) {
                s = message + '\n' + s;
            }
        } else {
            s = message;
        }
        if (number) {
            // some exceptions have a "number", track that to
            s += '\nnumber:' + number;
        }
        return s;
    }
}

function NccpClient$formatMillisecond(time) {
    return isNumber(time) ? time.toFixed(0) : '';
}

function NccpClient$formatSeconds(time) {
    return isNumber(time) ? (time / 1000).toFixed(0) : '';
}

function NccpClient$formatInt(i) {
    return isNumber(i) ? i.toFixed() : '';
}

// this may be used for older browsers only as most of the array methods are being made available now on typed arrays too.
function convertTypedArraytoArray(uint8arr) {
    var arr = [];
    for (var i = 0; i < uint8arr.length; i++) {
        arr[i] = uint8arr[i];
    }
    return arr;
}


// -- platform/platform.js
/** 
* Should config overrides be allowed from querystring in RELEASE mode?
* @const
* @type {boolean}
*/
var ALLOW_QUERY_STRING_CONFIG_OVERRIDES;

/** 
* Should we use DPI plugin
* @const
* @type {boolean}
*/
var NRDDPI;

/** 
* Should we use PepperCrypto plugin
* @const
* @type {boolean}
*/
var PEPPERCRYPTO;

/** 
* Should we use MSL
* @const
* @type {boolean}
*/
var MSL;

/** 
* @const 
* @type {string}
*/
var ERROR_PREFIX;

/** 
* @const 
* @type {string}
*/
var ESN_PREFIX;

/** 
* @const 
* @type {boolean}
*/
var GENERATE_DEVICEID;

/** 
* @const 
* @type {boolean}
*/
var DEVICEID_VIA_WEBCRYPTO_GETKEYBYNAME;

/** 
* @const 
* @type {boolean}
*/
var DEVICEID_VIA_WEBCRYPTO_GETDEVICEID;

/** 
* @const 
* @type {string}
*/
var DEVICE_MODEL;

/** 
* @const 
* @type {string}
*/
var DEVICE_CATEGORY;

/** 
* @const 
* @type {string}
*/
var DEVICE_SDKVERSION;

/** 
* @const 
* @type {string}
*/
var DEVICE_FRIENDLY_NAME;

/** 
* @const 
* @type {string} "lver" sent in nccp logblobs
*/
var NCCP_LOG_VERSION;


/** 
* @const 
* @type {number}
*/
var DEVICE_RENDER_HEIGHT;

/** 
* @const 
* @type {number}
*/
var DEVICE_RENDER_WIDTH;

/** 
* @const 
* @type {boolean}
*/
var KEYBOARD_PRESENT;

/** 
* @const 
* @type {boolean}
*/
var NO_SCRIPT_TAG;

/** 
* @const 
* @type {string}
*/
var NCCP_NETTYPE;

/** 
* @const
* @type {boolean}
*/
var NRDP_USES_BROWSER_ACCOUNT;

/** 
* @const
* @type {boolean}
*/
var NRDP_ALWAYS_FIRE_UNDERFLOW;

/** 
* @const
* @type {boolean}
*/
var SUPERHD_SUPPORT_IS_BASED_ON_RESOLUTION;

/** 
* @const
* @type {boolean}
*/
var REMOTE_ATTESTATION_IMPLIES_HW_ACCELERATION;

/** 
* @const
* @type {string}
*/
var PLUGIN_ELEMENT_STYLE;

/** 
* @const
* @type {Object}
*/
var PLATFORM_EXTRA_INFO;

/** 
* @const
* @type {Object}
*/
var PLATFORM_CONFIG_OVERRIDES;

/** 
* @const
* @type {Function}
*/
var PLATFORM_ENABLE_HEVC;

/** 
* @const
* @type {Function}
*/
var PLATFORM_ENABLE_HDR;

/** 
* @const
* @type {Function}
*/
var PLATFORM_MEDIA_OUTPUT_DESCRIPTORS;

/** 
* @const
* @type {Function}
*/
var PLATFORM_SECURITY_DESCRIPTORS;

/** 
* @const
* @type {Function}
*/
var PLATFORM_EME;

/** 
* @const
* @type {string}
*/
var PLATFORM_CONFIG_DEFAULT$authenticationType;

/** 
* @const
* @type {string}
*/
var PLATFORM_CONFIG_DEFAULT$authenticationTypeTest;

/** 
* @const
* @type {Object|undefined}
*/
var PLATFORM_CONFIG_DEFAULT$authenticationKeyNames;

/** 
* @const
* @type {string|undefined}
*/
var PLATFORM_CONFIG_DEFAULT$systemKeyWrapFormat;

/** 
* @const
* @type {Array.<string>}
*/
var PLATFORM_CONFIG_DEFAULT$audioProfiles;

/** 
* @const
* @type {Array.<string>}
*/
var PLATFORM_CONFIG_DEFAULT$videoProfiles;

/** 
* @const
* @type {Array.<string>}
*/
var PLATFORM_CONFIG_DEFAULT$timedTextProfiles;

/** 
* @const
* @type {Array.<string>}
*/
var PLATFORM_CONFIG_DEFAULT$audioProfilesEncrypted;

/** 
* @const
* @type {Array.<string>}
*/
var PLATFORM_CONFIG_DEFAULT$timedTextProfilesEncrypted;

/** 
* @const
* @type {Function}
*/
var PLATFORM_CONFIG_DEFAULT$getKeySystemId;

/** 
* @const
* @type {string}
*/
var PLATFORM_CONFIG_DEFAULT$canHDCP;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$enforceSinglePlayback;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$enforceSingleSession;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$requireNetflixId;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$requireSecureNetflixId;

/** 
* @const
* @type {number}
*/
var PLATFORM_CONFIG_DEFAULT$maxBufferSizeMilliseconds;

/** 
* @const
* @type {number}
*/
var PLATFORM_CONFIG_DEFAULT$maxBufferSizeBytes;

/**
 * @const
 * @type {number}
 */
var PLATFORM_CONFIG_DEFAULT$aseAudioBufferSizeBytes;

/**
 * @const
 * @type {number}
 */
var PLATFORM_CONFIG_DEFAULT$aseVideoBufferSizeBytes;

/** 
* @const
* @type {number}
*/
var PLATFORM_CONFIG_DEFAULT$maxDecoderBufferMilliseconds;

/** 
* @const
* @type {number}
*/
var PLATFORM_CONFIG_DEFAULT$maxImageSubsBufferSizeBytes;

/** 
* @const
* @type {number}
*/
var PLATFORM_CONFIG_DEFAULT$logDisplayMaxEntryCount;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$trackingLogEnabled;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$playdataPrepareRequest;

/** 
* @const
* @type {Array.<string>}
*/
var PLATFORM_CONFIG_DEFAULT$ignorePsshList;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$workaroundAudioKeyFrame;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$callEndOfStream;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$clearVideoSrc;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$preferOldEme;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$clipLongVideo;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$setVideoElementSize;

/** 
* @const
* @type {string}
*/
var PLATFORM_CONFIG_DEFAULT$storageType;

/** 
* @const
* @type {number}
*/
var PLATFORM_CONFIG_DEFAULT$storageMinimumSize;

/** 
* @const
* @type {boolean}
*/
var PLATFORM_CONFIG_DEFAULT$renderTimedText;

/** 
* @const
* @type {Object}
*/
var PLATFORM_CONFIG_DEFAULT$timedTextFontFamilyMapping;

/** 
* @const
* @type {number}
*/
var PLATFORM_CONFIG_DEFAULT$timedTextSimpleFallbackThreshold;

var EmeSession;
var DrmRequests;

/**
 * @const
 * @type {string}
 */
var PLATFORM_CONFIG_DEFAULT$serverCertificateForEme;

/**
 * @const
 * @type {string}
 */
var PLATFORM_CONFIG_DEFAULT$supportedVideoCodecs;

/**
 * @const
 * @type {Function}
 */
var PLATFORM_CONFIG_DEFAULT$VideoCapabilitiesFunction;

/**
 * @const
 * @type {boolean}
 */
var PLATFORM_CONFIG_DEFAULT$secureUrls;

/**
 * @const
 * @type {boolean}
 */
var PLATFORM_CONFIG_DEFAULT$validatePinProtection;

// -- platform-CHROME.js
// Chrome
var isChromeOs = /CrOS/.test(userAgent);
var isOpera = /OPR/.test(userAgent);
var nf_utils = require(4);

NRDDPI = false;
PEPPERCRYPTO = false;
MSL = true;
ERROR_PREFIX = isChromeOs ? 'C' : isOpera ? 'O' : 'M';

ESN_PREFIX =
    /OPR/.test(userAgent) ? 'NFCDOP-01-':
    /Windows NT/.test(userAgent) ? 'NFCDCH-02-' :
    /Intel Mac OS X/.test(userAgent) ? 'NFCDCH-MC-' :
    /CrOS/.test(userAgent) ? 'NFCDCH-01-' :
    'NFCDCH-LX-'; // default to Linux

GENERATE_DEVICEID = true;
DEVICE_MODEL = isChromeOs ? 'chromeos-cadmium' : isOpera ? 'opera-cadmium' : 'chrome-cadmium';
DEVICE_CATEGORY = 'browser';
DEVICE_FRIENDLY_NAME = DEVICE_MODEL;
KEYBOARD_PRESENT = true;

NRDP_USES_BROWSER_ACCOUNT = true;

REMOTE_ATTESTATION_IMPLIES_HW_ACCELERATION = /CrOS/.test(userAgent);
SUPERHD_SUPPORT_IS_BASED_ON_RESOLUTION = false;

PLATFORM_CONFIG_DEFAULT$authenticationType = AuthenticationType$JWK_RSA;
PLATFORM_CONFIG_DEFAULT$authenticationTypeTest = PLATFORM_CONFIG_DEFAULT$authenticationType;
PLATFORM_CONFIG_DEFAULT$audioProfiles = [audioProfile$HEAAC];
PLATFORM_CONFIG_DEFAULT$videoProfiles = [videoProfile$H264_MPL30, videoProfile$H264_MPL31];
if(isChromeOs){
    PLATFORM_CONFIG_DEFAULT$videoProfiles.push(videoProfile$H264_MPL40);
}
PLATFORM_CONFIG_DEFAULT$timedTextProfiles = [timedTextProfile$DFXP_LS_SDH, timedTextProfile$SIMPLESDH, timedTextProfile$NFLX_CMISC];
PLATFORM_CONFIG_DEFAULT$audioProfilesEncrypted = [audioProfile$HEAAC_ENC];
PLATFORM_CONFIG_DEFAULT$timedTextProfilesEncrypted = [timedTextProfile$DFXP_LS_SDH_ENC, timedTextProfile$SIMPLESDH_ENC, timedTextProfile$NFLX_CMISC_ENC];
PLATFORM_CONFIG_DEFAULT$getKeySystemId = function() { return 'com.widevine.alpha'; }
PLATFORM_CONFIG_DEFAULT$enforceSinglePlayback = true;
PLATFORM_CONFIG_DEFAULT$enforceSingleSession = false;
PLATFORM_CONFIG_DEFAULT$requireNetflixId = false;
PLATFORM_CONFIG_DEFAULT$requireSecureNetflixId = false;
PLATFORM_CONFIG_DEFAULT$maxBufferSizeMilliseconds = 232000;
PLATFORM_CONFIG_DEFAULT$maxBufferSizeBytes = 0;
PLATFORM_CONFIG_DEFAULT$aseAudioBufferSizeBytes = 2880000; // 240 seconds of audio
PLATFORM_CONFIG_DEFAULT$aseVideoBufferSizeBytes = 335544320; // 240 seconds of video
PLATFORM_CONFIG_DEFAULT$maxDecoderBufferMilliseconds = 15000;
PLATFORM_CONFIG_DEFAULT$maxImageSubsBufferSizeBytes = 6 * 1024 * 1024;
PLATFORM_CONFIG_DEFAULT$logDisplayMaxEntryCount = DEBUG ? -1 : 1000;
PLATFORM_CONFIG_DEFAULT$trackingLogEnabled = true;
PLATFORM_CONFIG_DEFAULT$playdataPrepareRequest = false;
PLATFORM_CONFIG_DEFAULT$workaroundAudioKeyFrame = false;
PLATFORM_CONFIG_DEFAULT$callEndOfStream = !!window['MediaSource']; // do this, for new MSE api (R31+)
PLATFORM_CONFIG_DEFAULT$clearVideoSrc = true;
PLATFORM_CONFIG_DEFAULT$preferOldEme = true;
PLATFORM_CONFIG_DEFAULT$clipLongVideo = !window['MediaSource']; // apply workaround only for old API for old MSE api (R30-)
PLATFORM_CONFIG_DEFAULT$storageType = 'idb';
PLATFORM_CONFIG_DEFAULT$storageMinimumSize = 0;
PLATFORM_CONFIG_DEFAULT$VideoCapabilitiesFunction = DeviceCapabilities$AllProfiles;
PLATFORM_CONFIG_DEFAULT$secureUrls = true;
PLATFORM_CONFIG_DEFAULT$validatePinProtection = false;

PLATFORM_CONFIG_DEFAULT$renderTimedText = true;

// TODO: check fonts from ChromeOS and update this list, might not need the fallbacks
PLATFORM_CONFIG_DEFAULT$timedTextFontFamilyMapping = {
    'MONOSPACED_SERIF': 'font-family:Courier New,Arial,Helvetica;font-weight:bolder',
    'MONOSPACED_SANS_SERIF': 'font-family:Consolas,Lucida Console,Menlo,Monaco,Arial,Helvetica;font-weight:bolder',
    'PROPORTIONAL_SERIF': 'font-family:Georgia,Times New Roman,Arial,Helvetica;font-weight:bolder',
    'PROPORTIONAL_SANS_SERIF': 'font-family:Arial,Helvetica;font-weight:bolder',
    'CASUAL': 'font-family:Gabriola,Segoe Print,Comic Sans MS,Chalkboard,Arial,Helvetica;font-weight:bolder',
    'CURSIVE': 'font-family:Lucida Handwriting,Brush Script MT,Segoe Script,Arial,Helvetica;font-weight:bolder',
    'SMALL_CAPITALS': 'font-family:Copperplate Gothic,Copperplate Gothic Bold,Copperplate,Arial,Helvetica;font-variant:small-caps;font-weight:bolder'
};

PLATFORM_CONFIG_OVERRIDES = {
    'droppedFrameRateFilterEnabled': true,
    'promiseBasedEme': true,
    'workaroundValueForSeekIssue': 500, 
    'captureKeyStatusData': true,
    'logMediaPipelineStatus': true,
    'enableCongestionService': true,
    'prepareCadmium': true,
    'periodicPrepareLogsIntervalMilliseconds': 10 * 60 * 1000,
    'enableLdlPrefetch': true,
    'doNotPerformLdlOnPlaybackStart': true
};

// being set via config too since config is not reliable and it will cause fatal playback error.
applyConfigOverridesForChrome(50, PLATFORM_CONFIG_OVERRIDES, {'useSetServerCertificateApi': true});

function PLATFORM_EXTRA_INFO$checkPlugin(property, regexp) {
    try {
        var plugins = navigator['plugins'];
        var length = plugins.length;
        var i;
        for (i = 0; i < length; i++) {
            if (regexp.test(plugins[i][property])) {
                return plugins[i];
            }
        }
        return false;
    }
    catch (e) {
    }
}

function PLATFORM_EXTRA_INFO$checkWidevingPlugin() {
    var plugin = PLATFORM_EXTRA_INFO$checkPlugin('filename', /widevinecdm/i);
    if (plugin) {
        try {
            var matches = plugin['description'].match(/version: ([0-9.]+)/);
            if (matches && matches[1]) {
                return matches[1];
            }
        }
        catch (e) {
        }
        return 'true';
    }
    return 'false';
}



// for chrome, capture whether there is a widevine plugin
var PLATFORM_EXTRA_INFO$wvp = PLATFORM_EXTRA_INFO$checkWidevingPlugin();

// gather extra information about platform, so we can identify variations of chrome such as Chromium without h264 support
PLATFORM_EXTRA_INFO = {

    'wvp': PLATFORM_EXTRA_INFO$wvp,

    // for chrome, capture whether there is a widevine plugin
    'wvp2': PLATFORM_EXTRA_INFO$wvp || (function () {
        // if there was no widevine plugin, try refreshing the plugins and trying again
        // unless the tab is closed/reoppened, the list of plugins won't refresh automatically
        try {
            navigator['plugins']['refresh']();
            return PLATFORM_EXTRA_INFO$checkWidevingPlugin();
        } catch (e) {
        }
    })(),

    // check for couple of more plugins, which can help us differentiate between Chromium and Chrome
    'crdvp': !!PLATFORM_EXTRA_INFO$checkPlugin('name', /Chrome Remote Desktop Viewer/i),
    'cvp': !!PLATFORM_EXTRA_INFO$checkPlugin('name', /Chromoting Viewer/i),

    'itsh264': (function () {
        try {
            return MediaSource['isTypeSupported'](MEDIA_TYPE_VIDEO_H264);
        }
        catch (e) {
        }
    })(),

    'cpth264': (function () {
        try {
            return nf_utils.createElement('VIDEO')['canPlayType'](MEDIA_TYPE_VIDEO_H264);
        }
        catch (e) {
        }
    })(),

    'cpth264wv': (function () {
        try {
            if(isPromiseBasedEmeSupported()){
                checkViaMediaKeySystemAccess();
            }else{
                return createElement('VIDEO')['canPlayType'](MEDIA_TYPE_VIDEO_H264, 'com.widevine.alpha');    
            }
        }
        catch (e) {
        }
    })(),

};

PLATFORM_MEDIA_OUTPUT_DESCRIPTORS = function(context) {
    return Promise.resolve();
};

PLATFORM_SECURITY_DESCRIPTORS = function(context) {
    return Promise.resolve();
};

PLATFORM_EME = function() {
    return {
        session: require(3),
        request: require(2)
    }
}

function checkViaMediaKeySystemAccess() {
    var prop = 'cpth264wv',
        keySystemId = 'com.widevine.alpha',
        emeOptions = [{
            'distinctiveIdentifier': 'not-allowed',
            'videoCapabilities': [{
                'contentType': MEDIA_TYPE_VIDEO_H264,
                'robustness': "HW_SECURE_DECODE"
            }, {
                'contentType': MEDIA_TYPE_VIDEO_H264,
                'robustness': "SW_SECURE_DECODE"
            }],
            'audioCapabilities': [{
                'contentType': MEDIA_TYPE_AUDIO_HEAAC,
                'robustness': "SW_SECURE_CRYPTO"
            }]
        }];
    try {
        navigator['requestMediaKeySystemAccess']('com.widevine.alpha', emeOptions)
            .then(function(mediaKeySystemAccess) {
                var configuration = mediaKeySystemAccess['getConfiguration'](),
                    videoCapabilities = configuration['videoCapabilities'],
                    audioCapabilities = configuration['audioCapabilities'];
                if(audioCapabilities && audioCapabilities.length){
                    var robustnessList = getRobustnessList(audioCapabilities);
                    if(robustnessList.indexOf('SW_SECURE_CRYPTO') >= 0){
                        PLATFORM_EXTRA_INFO['cptheaacwv_sw_cryp'] = true;
                    }
                }

                if (videoCapabilities && videoCapabilities.length) {
                    PLATFORM_EXTRA_INFO[prop] = true;
                    var robustnessList = getRobustnessList(videoCapabilities);
                    if (robustnessList.indexOf("SW_SECURE_DECODE") >= 0) {
                        PLATFORM_EXTRA_INFO['cpth264wv_sw_dec'] = true
                    }
                    if (robustnessList.indexOf("HW_SECURE_DECODE") >= 0) {
                        PLATFORM_EXTRA_INFO['cpth264wv_hw_dec'] = true
                    }
                } else {
                    PLATFORM_EXTRA_INFO[prop] = false;
                }
            })
            .catch(function() {
                PLATFORM_EXTRA_INFO[prop] = false;
            })
    } catch (e) {

    }

}
function getRobustnessList(capabilities){
    return capabilities.map(function(c){
        return c['robustness'];
    });
}

PLATFORM_CONFIG_DEFAULT$serverCertificateForEme = 
    'Cr0CCAMSEOVEukALwQ8307Y2+LVP+0MYh/HPkwUijgIwggEKAoIBAQDm875btoWUbGqQD8eAGuBlGY+Pxo8YF1LQR+Ex0pDONMet8EHslcZRBKNQ/09RZFTP0vrYimyYiBmk9GG+S0wB3'+
    'CRITgweNE15cD33MQYyS3zpBd4z+sCJam2+jj1ZA4uijE2dxGC+gRBRnw9WoPyw7D8RuhGSJ95OEtzg3Ho+mEsxuE5xg9LM4+Zuro/9msz2bFgJUjQUVHo5j+k4qLWu4ObugFmc9DLIAoh'+
    'L58UR5k0XnvizulOHbMMxdzna9lwTw/4SALadEV/CZXBmswUtBgATDKNqjXwokohncpdsWSauH6vfS6FXwizQoZJ9TdjSGC60rUB2t+aYDm74cIuxAgMBAAE6EHRlc3QubmV0ZmxpeC5jb'+
    '20SgAOE0y8yWw2Win6M2/bw7+aqVuQPwzS/YG5ySYvwCGQd0Dltr3hpik98WijUODUr6PxMn1ZYXOLo3eED6xYGM7Riza8XskRdCfF8xjj7L7/THPbixyn4mULsttSmWFhexzXnSeKqQHu'+
    'oKmerqu0nu39iW3pcxDV/K7E6aaSr5ID0SCi7KRcL9BCUCz1g9c43sNj46BhMCWJSm0mx1XFDcoKZWhpj5FAgU4Q4e6f+S8eX39nf6D6SJRb4ap7Znzn7preIvmS93xWjm75I6UBVQGo6p'+
    'n4qWNCgLYlGGCQCUm5tg566j+/g5jvYZkTJvbiZFwtjMW5njbSRwB3W4CrKoyxw4qsJNSaZRTKAvSjTKdqVDXV/U5HK7SaBA6iJ981/aforXbd2vZlRXO/2S+Maa2mHULzsD+S5l4/YGpS'+
    't7PnkCe25F+nAovtl/ogZgjMeEdFyd/9YMYjOS4krYmwp3yJ7m9ZzYCQ6I8RQN4x/yLlHG5RH/+WNLNUs6JAZ0fFdCmw=';





// -- imports.js
var DataStream = require(91);

var mp4reader = require(96),
    parseMp4 = mp4reader.readAllBoxes;

var CadmiumTypescript = require(9);

var DefaultThroughputTracker = CadmiumTypescript.DefaultThroughputTracker;
var CDNThroughputTrackerImpl = CadmiumTypescript.CDNThroughputTrackerImpl;
var CDNDownloadImpl = CadmiumTypescript.CDNDownloadImpl;
var DefaultThroughputConfig = CadmiumTypescript.DefaultThroughputConfig;
var DefaultDownload = CadmiumTypescript.DefaultDownload;
var DefaultRange = CadmiumTypescript.DefaultRange;
var DefaultClock = CadmiumTypescript.DefaultClock;
var DefaultDispatcher = CadmiumTypescript.DefaultDispatcher;
var DefaultIdProvider = CadmiumTypescript.DefaultIdProvider;
var DefaultRandomGenerator = CadmiumTypescript.DefaultRandomGenerator;
var DefaultLogger = CadmiumTypescript.DefaultLogger;
var DefaultSystemClock = CadmiumTypescript.DefaultSystemClock;
var Enums = CadmiumTypescript.Enums;
 
var utf8 = new CadmiumTypescript.Utf8Encoder(),
    utf8$getString = utf8.encode,
    utf8$getBytes = utf8.decode;

var base16 = new CadmiumTypescript.Base16Encoder(),
    base16$encode = base16.encode,
    base16$decode = base16.decode,
    base16$fromInt = base16.fromInt,
    base16$toUInt = base16.toUInt;

var base64 = new CadmiumTypescript.Base64Encoder(),
    base64$encode = function(bytesOrString) {
        var a = isString(bytesOrString) ? utf8$getBytes(bytesOrString) : bytesOrString;
        return base64.encode(a);
    },
    base64$decode = base64.decode,
    base64$decodeAsText = function(s) {
        return utf8$getString(base64$decode(s));
    };


var ErrorCodes = CadmiumTypescript.ErrorCodes,
    ErrorCodes$isNCCP = function(errorCode) {
        return errorCode >= 7100 && errorCode < 7200;
    },
    ErrorCodes$isNotSevere = function(errorCode) {
        // log these as sev=info
        return errorCode == ErrorCodes.PAUSE_TIMEOUT || errorCode == ErrorCodes.INACTIVITY_TIMEOUT;
    };

var ErrorSubCodes = CadmiumTypescript.ErrorSubCodes,
    ErrorSubCodes$isHTTP = function(errorSubCode) {
        return 1100 <= errorSubCode && errorSubCode <= 1199;
    },
    ErrorSubCodes$isNCCP = function(errorSubCode) {
        return 1300 <= errorSubCode && errorSubCode <= 1399;
    },
    ErrorSubCodes$isMsl = function(errorSubCode) {
        return 1900 <= errorSubCode && errorSubCode <= 1999;
    },
    ErrorSubCodes$toErrorWithBase = function(code, base) {
        var i = parseInt10(code);
        if (code >= 1 && code <= 9) {
            return base + code;
        }
        return base;
    },
    ErrorSubCodes$toMediaErrorSubCode = function(code) {
        return ErrorSubCodes$toErrorWithBase(code, ErrorSubCodes.MSE_MEDIA_ERR_BASE);
    },
    ErrorSubCodes$toMediaKeyErrorSubCode = function(code) {
        return ErrorSubCodes$toErrorWithBase(code, ErrorSubCodes.EME_MEDIA_KEYERR_BASE);
    },
    ErrorSubCodes$errorResultToLogFields = function(errorResult) {
        var fields = {};
        fields['ErrorSubCode'] = errorResult['errorSubCode'] || ErrorSubCodes.UNKNOWN;
        if (errorResult['errorExternalCode']) {
            fields['ErrorExternalCode'] = errorResult['errorExternalCode'];
        }
        if (errorResult['errorDetails']) {
            fields['ErrorDetails'] = errorResult['errorDetails'];
        }
        return fields;
    };
    
var ErrorExtCodes = CadmiumTypescript.ErrorExtCodes;

var SubtitleManager = require(98);
var SubtitleTracker = CadmiumTypescript.SubtitleTracker;

var LocalStorage = CadmiumTypescript.LocalStorage;
var utils = require(4);
var createElement = utils.createElement;


// -- common/log.js
var log = {

    'addSink': function (sink) {
        log$_sinks.push(sink);
    },

    'removeSink': function (sink) {
        log$_sinks.splice(log$_sinks.indexOf(sink), 1);
    },

    'write': function (logLevel, message, fields) {
        if (DEBUG && logLevel <= LogLevel['ERROR'] && debug$breakOnError) debugger;

        var entry = {
            playback: this.playback,
            'level': logLevel,
            'message': message,
            'fields': fields || {},
            'time': clock$getTime(),
            'index': log$_index++,
            'category': this.category || 'General'
        };

        if (this.doNotSendToNccp) {
            entry.doNotSendToNccp = true;
        }

        for (var i = 0; i < log$_sinks.length; i++) {
            log$_sinks[i](entry);
        }
    },

    /**
    * @param {string} message
    * @param {...string|Object} fields 
    */
    fatal: function (message, fields) {
        this['write'](LogLevel['FATAL'], message, log$_buildFields(arguments));
    },

    /**
    * @param {string} message
    * @param {...string|Object} fields 
    */
    error: function (message, fields) {
        this['write'](LogLevel['ERROR'], message, log$_buildFields(arguments));
    },

    /**
    * @param {string} message
    * @param {...string|Object} fields 
    */
    warn: function (message, fields) {
        this['write'](LogLevel['WARN'], message, log$_buildFields(arguments));
    },

    /**
    * @param {string} message
    * @param {...string|Object} fields 
    */
    info: function (message, fields) {
        this['write'](LogLevel['INFO'], message, log$_buildFields(arguments));
    },

    /**
    * @param {string} message
    * @param {...string|Object} fields 
    */
    trace: function (message, fields) {
        this['write'](LogLevel['TRACE'], message, log$_buildFields(arguments));
    },

    /**
    * @param {string} message
    * @param {...string|Object} fields 
    */
    debug: function (message, fields) {
        this['write'](LogLevel['DEBUG'], message, log$_buildFields(arguments));
    },

    /**
     * @param {string} message
     * @param {...string|Object} fields
     */
    log: function (message, fields) {
        this['write'](LogLevel['DEBUG'], message, log$_buildFields(arguments));
    }
};

// make the log survive obfuscation
// but maintain ability to call these methods in obfuscated code without ['xx'] syntax
log['fatal'] = log.fatal;
log['error'] = log.error;
log['warn'] = log.warn;
log['info'] = log.info;
log['trace'] = log.trace;
log['debug'] = log.debug;
log['log'] = log.log;

/**
* @constructor
*/
(log.CategoryLog = function (category) {
    this.category = category;
}).prototype = log;

/**
* @constructor
*/
function PlaybackLog(playback) {
    // copy selective fields from playback
    this.playback = {
        index: playback.index,
        xid: playback.xid,
        loadTime: playback.loadTime,
        movieId: playback.movieId,
        logVerbosePlaybackInfo: playback.logVerbosePlaybackInfo,
        getRelativeTime: Playback.prototype.getRelativeTime
    };

    /**
    * @constructor
    */
    this.CategoryLog = function (category) {
        this.category = category;
    }
    this.CategoryLog.prototype = this;
}
PlaybackLog.prototype = log;

var LogLevel = {
    'MIN': 0,
    'FATAL': 0,
    'ERROR': 1,
    'WARN': 2,
    'INFO': 3,
    'TRACE': 4,
    'DEBUG': 5,
    'MAX': 5
};

var log$_sinks = [];
var log$_index = 0;

var log$_errorRegex = /^\w*Error$/;

function log$_buildFields(args) {
    var l = args.length,
        arg,
        index = 1;
    if (l > index) {
        arg = log$_toFields(args[index], '');
        if (l == index + 1) {
            // most common case, don't make extra obejcts etc
            return arg;
        } else {
            var fields = {};
            while (index < l) {
                mixIn(fields, arg);
                arg = log$_toFields(args[++index], isDefined(fields['Details']) ? fields['Details'] : '');
            }
            return fields;
        }
    }
}

function log$_toFields(o, details) {
    // convert:
    //   object -> object
    //   string -> { 'Details': string }
    //   Error -> { 'Exception': Error.message || '' + Error, 'StackTrace': Error.stack } 
    if (isValidObject(o)) {
        if (o.logFields) {
            return o.logFields;
        }
        if (isFunction(o.getLogFields)) {
            return o.getLogFields();
        }
        if (log$_errorRegex.test(o.name)) {
            return { 'Exception': o.message || ('' + o), 'StackTrace': o.stack || 'nostack' };
        } else {
            return o;
        }
    }
    if (isDefined(o)) {
        return { 'Details': (details === '' ? '' : details + ', ') + o };
    }
    return {};
}

function log$buildHeader() {
    return 'Version: ' + VERSION + (DEBUG ? ' DEBUG' : '') + '\n' +
        (device ? ('Esn: ' + device.esn + '\n') : '') +
        'JsSid: ' + JSSID + ', Epoch: ' + clock$getEpoch() + ', Start: ' + clock$getAppEpoch() + ', TimeZone: ' + (new Date()).getTimezoneOffset() + '\n' +
        'Href: ' + location['href'] + '\n' +
        'UserAgent: ' + navigator.userAgent + '\n' +
        '--------------------------------------------------------------------------------\n'
}

var log$entryToString$NEW_LINE = /[\r\n]+ */g;
var log$entryToString$SPECIAL_FIELDS = arrayToHashSet(['Details', 'Exception', 'StackTrace']);
var log$entryToString$LEVEL_TO_SHORT_TEXT = {
    0: 'F',
    1: 'E',
    2: 'W',
    3: 'I',
    4: 'T',
    5: 'D'
};

function log$entryToString(entry, logStack, logDetails) {
    var fields = entry['fields'] || {};
    var message = '' + entry['message'];
    enumerateOwnProperties(fields, function (k, v) {
        if (!log$entryToString$SPECIAL_FIELDS.hasOwnProperty(k)) {
            message += ', ' + k + ': ' + v;
        }
    });

    message = message.replace(log$entryToString$NEW_LINE, ' ');

    var result = (entry['time'] / 1000.0).toFixed(3) + '|' + ((entry.playback && entry.playback.index) || 0) + '|' + (log$entryToString$LEVEL_TO_SHORT_TEXT[entry['level']] || entry['level']) + '|' + entry['category'] + '| ' + message;

    if (fields['Exception']) {
        result += '\r\n' + fields['Exception'];
    }

    if (logStack && fields['StackTrace']) {
        result += '\r\n' + fields['StackTrace'];
    }
    if (logDetails && fields['Details']) {
        result += '\r\n' + fields['Details'];
    }

    return result;
}



// -- dependencyinjection.js
// var di = require('di4js');

// di.autowired(false).
//     register('dispatcher').as(DefaultDispatcher).
// 	register('systemClock').as(DefaultSystemClock).
//     register('clock').as(DefaultClock).
//         withConstructor().
//             param().ref('systemClock').
// 	register('random').as(DefaultRandomGenerator).
//     register('idProvider').as(DefaultIdProvider).
// 		withConstructor().
// 			param().ref('clock').
// 			param().ref('random');


// -- common/utilities.js
// does o2 have all the properties of o1, and they have same value?
// Note: this only checks properties of o1, so result of ({a: 1, b: 2}, {a: 1, b: 2, c:3 }) is still true
function compareByProperties(o1, o2) {
    if (o1 === o2) {
        return true;
    }
    if (!o1 || !o2) {
        return false;
    }
    for (var k in o1) {
        if (o1.hasOwnProperty(k)) {
            // if o2 doesn't have this property, or it's different... we are done, return false
            if (!o2.hasOwnProperty(k) || o1[k] !== o2[k]) {
                return false;
            }
        }
    }
    return true;
}

function compareArrays(a1, a2) {
    if (a1.length == a2.length) {
        var i = a1.length;
        while (i--) {
            if (a1[i] != a2[i]) {
                return false;
            }
        }
        return true;
    }
    return false;
}

function randomArrayElement(a) {
    if (a) {
        var l = a.length;
        if (l) {
            var i = randomInt(0, l - 1);
            return a[i];
        }
    }
}

/**
* Check whether two arrays contain the same elements, regardless of order.
*/
function containSameElements(s1, s2) {
    if (s1.length != s2.length) return false;
    s1.sort();
    s2.sort();
    for (var i = s1.length; i--;) {
        if (s1[i] !== s2[i]) {
            return false;
        }
    }
    return true;
}

function addSingleEventListener(o, eventName, handler) {
    function singleHandler() {
        o['removeEventListener'](eventName, singleHandler);
        handler.apply(this, arguments);
    }
    o['addEventListener'](eventName, singleHandler);
}

function readCookies() {
    var a = document.cookie.split('; '),
        l = a.length,
        i,
        s,
        splitAt,
        cookies = {};

    // if cookie is encoutered multiple time, override the older one.
    // this helps us deal with set cookie bugs where two cookies are set with different domain, and we end up with two cookies in the list
    for (i = 0; i < l; i++) {
        s = trim(a[i]);
        if (s) {
            splitAt = s.indexOf('=');
            if (splitAt > 0) {
                cookies[s.substr(0, splitAt)] = s.substr(splitAt + 1);
            }
        }
    }

    return cookies;
}

function getQueryString() {
    var s,
        splitAt,
        _queryString = getQueryString._queryString;

    if(_queryString){
        return _queryString;
    }

    s = location['search'].substr(1);
    splitAt = s.indexOf('#');
    if (splitAt >= 0) {
        s = s.substr(0, splitAt);
    }

    var queryString = parseQueryString(s);

    getQueryString._queryString = queryString;

    return queryString;
}

function parseQueryString(s) {
    var plusRegExp = /[+]/g,
        a = (s || '').split('&'),
        queryString = {},
        splitAt;

    for (var i = 0; i < a.length; i++) {
        s = trim(a[i]);
        splitAt = s.indexOf('=');
        if (splitAt >= 0) {
            queryString[decodeURIComponent(s.substr(0, splitAt).replace(plusRegExp, '%20')).toLowerCase()] = decodeURIComponent(s.substr(splitAt + 1).replace(plusRegExp, '%20'));
        } else {
            queryString[s.toLowerCase()] = null;
        }
    }

    return queryString;
}

function objectToQueryString(o) {
    var qs = '';
    enumerateOwnProperties(o, function (k, v) {
        if (qs) {
            qs += '&';
        }
        debug$assert(isString(v) || isNumber(v) || isBool(v));
        qs += encodeURIComponent(k) + '=' + encodeURIComponent(v);
    });
    return qs;
}

function getFunctionName(f) {
    var funcNameRegex = /function (.{1,})\(/;
    var results = (funcNameRegex).exec(f.toString());
    return (results && results.length > 1) ? results[1] : '';
}

function getConstructorName(o) {
    return getFunctionName(o.constructor);
}

function objectToStringTrace(o) {
    var s = '';
    if (isArray(o) || isUint8Array(o)) {
        s = reduce.call(o, function (s, c) { return s + ((c >= 32 && c < 128) ? String$fromCharCode(c) : '.'); }, '')
    } else if (isString(o)) {
        s = o;
    } else {
        enumerateOwnProperties(o, function (k, v) {
            s += (s ? ', ' : '') + '{' + k + ': ' + (isFunction(v) ? (getFunctionName(v) || 'function') : v) + '}';
        });
    }
    return '[' + getConstructorName(o) + ' ' + s + ']';
}

function prependChild(parentElement, childElement) {
    if (parentElement['firstChild']) {
        parentElement['insertBefore'](childElement, parentElement['firstChild']);
    } else {
        parentElement['appendChild'](childElement);
    }
}

function createCssText(o) {
    var cssText = '';
    enumerateOwnProperties(o, function (k, v) {
        cssText += (cssText ? ';' : '') + k + ':' + v;
    });
    return cssText;
}

// given set of arrays
// interpolates based on first param
function interpolateArrays(entries, v) {
    var current = entries[0];
    if (v <= current[0]) {
        return current.slice(1);
    }

    var i = 1;
    var next;
    while ((next = entries[i++])) {
        if (v <= next[0]) {
            // interpolate
            var p = (v - current[0]) / (next[0] - current[0]);
            var interpolated = [];
            var length = Math$max(current.length, next.length);
            for (var j = 1; j < current.length; j++) {
                interpolated.push((current[j] || 0) + p * ((next[j] || 0) - (current[j] || 0)));
            }
            return interpolated;
        }
        current = next;
    }

    return current.slice(1);
}
/**
 * Checks to see if the elements in a smaller array are included in a larger array. All elements
 * in both arrays must be strings or numbers, otherwise false is returned.
 * @param smallerArray array to check for containment within larger array.
 * @param largerArray array of strings or numbers
 * @returns {boolean} returns true if smaller array is included in the larger array.
 */
function Array$isASubsetOf(smallerArray, largerArray) {
    var largerSet = {};

    // Create a set from the large array using an object map.
    for (var i = 0; i < largerArray.length; i++){
        var element = largerArray[i];
        if (typeof element != "string" && typeof element != "number") {
            return false;
        }
        largerSet[largerArray[i]] = 1;
    }

    // Check if any smallArray elements are outside of the larger array.
    for (var i = 0; i < smallerArray.length; i++){
        var element = smallerArray[i];
        if (!largerSet[element]) {
            return false;
        }
    }
    // Subset verified.
    return true;
}
function Array$pushIfDoesntContain(a, o) {
    if (a.indexOf(o) < 0) {
        a.push(o);
    }
}

function Array$sortNumbers(a) {
    return sort.call(a, function (a, b) { return a - b; });
}

function Array$sum(arr) {
    var sum = 0;
    var i = arr.length;
    while(i--) {
        sum += arr[i];
    }
    return sum;
}

/**
* Finds the maximum value of a numeric or object array. For object a array uses a callback
* to identify the value to maximize.
* @param {Array} array - Array of numbers, or array of objects.
* @param {Function=} f - (optional) When an array of objects is passed in, this callback determines which field to use for max comparisons
* @return {Number} the maximum value for numeric arrays, or the maximum value of a specific field for an array of objects.
*/
function Array$max(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;
    if (arguments.length === 1) { // Numeric array
        while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
        while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else { // Object array
        while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
        while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
}

/**
* Finds the minimum value of a numeric or object array. For object a array uses a callback
* to identify the value to minimize.
* @param {Array} array - Array of numbers, or array of objects.
* @param {Function=} f - (optional)  When an array of objects is passed in, this callback determines which field to use for min comparisons
* @return {Number} the minimum value for numeric arrays, or the minimum value of a specific field for an array of objects.
*/
function Array$min(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;
    if (arguments.length === 1) { // Numeric array
        while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
        while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else { // Object array
        while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
        while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
}

/**
* Converts an object with oncomplete/onerror handlers to a Promise. Or if input is a promise, it's returned intact.
*
* @param {Object} op - Either an object with oncomplete/onerror, or a Promise
* @return {Object} a promise
*/
function op2promise(op) {
    if (isFunction(op['then'])) {
        // it's a promise, return as it is
        return op;
    } else {
        // convert to a Promise
        return new Promise(function (resolve, reject) {
            op['oncomplete'] = function () {
                resolve(op['result']);
            };
            op['onerror'] = function () {
                reject(op['error']);
            };
        });
    }
}

/**
* @param {Array.<number>} availableBitrates
* @param {Array.<string>} filter example ['1050-', '235+']
* @return {Array} subset of availableBitrates
*/
function filterBitrates(availableBitrates, filter) {
    availableBitrates = availableBitrates.slice();
    Array$sortNumbers(availableBitrates);

    var result = [];

    if (!filter || !filter.length) {
        return availableBitrates;
    }

    if (!availableBitrates.length) {
        return [];
    }

    function checkThenPush(bitrate) {
        if ((result.indexOf(bitrate) < 0) && isNumber(bitrate)) {
            result.push(bitrate);
        }
    };

    var i = filter.length;
    var j;
    var candidate;
    try {
        while (i--) {
            var entry = '' + filter[i];
            // this will handle stripping the postfix '1000-' is still 1000
            var bitrate = parseInt10(entry);

            switch (entry[entry.length - 1]) {
                case '-':
                    j = availableBitrates.length;
                    while (j--) {
                        candidate = availableBitrates[j];
                        if (candidate < bitrate) {
                            checkThenPush(candidate);
                            break;
                        }
                    }
                    break;
                case '+':
                    for (j = 0; j < availableBitrates.length; j++) {
                        candidate = availableBitrates[j];
                        if (candidate > bitrate) {
                            checkThenPush(candidate);
                            break;
                        }
                    }
                    break;
                default:
                    if (availableBitrates.indexOf(bitrate) >= 0) {
                        checkThenPush(bitrate);
                    }
                    break;
            }
        }
    } catch (e) {
    }

    if (!result.length) {
        result.push(availableBitrates[0]);
    }

    Array$sortNumbers(result);
    return result;
}

/**
* Returns {width, height} that fits inside provided width/height while maintaining the provided aspect ratio
*/
function fitWithAspect(width, height, aspect) {
    var constrainedWidth,
        constrainedHeight;

    if (width / height > aspect) {
        constrainedWidth = Math$round(height * aspect);
        constrainedHeight = height;
    } else {
        constrainedWidth = width;
        constrainedHeight = Math$round(width / aspect);
    }

    return {
        width: constrainedWidth,
        height: constrainedHeight
    };
}

// compute standard deviaation for a list of numbers
function computeStandardDev(listOfValues, sampleSize, average) {
    var vals = [];
    for (var i=0; i<sampleSize; i++) {
        vals.push(Math$pow((listOfValues[i] - average), 2));
    }
    return Math$sqrt(Array$sum(vals)/vals.length);
}

// calculate a given percentile based on a sorted list of values
function calculatePercentile(sortedValues, percentile) {
    var count = sortedValues.length;
    var index = (count - 1) * percentile + 1;

    if (index === 1) {
        return sortedValues[0];
    } else if (index == count) {
        return sortedValues[count - 1];
    } else {
        var k = Math$floor(index);
        var delta = index - k;
        return sortedValues[k - 1] + delta * (sortedValues[k] - sortedValues[k - 1]);
    }
}

/**
* @param {number} versionNumber
* @param {Object} source
* @param {Object} delta
*/
function applyConfigOverridesForChrome(versionNumber, source, delta) {
    var version = getChromeVersionNumber(userAgent);
    if (version >= versionNumber) {
        mixIn(source, delta);
    }
}
/**
* @param {String} str
* @return {number|null}
*/
function getChromeVersionNumber(str) {
    var matches = str.match(/Chrome\/(\d*)\./);
    return matches && (matches[1] | 0);
}

/**
* Given list of objects with "type" property, return first match. Typically used for mp4 boxes.
*/
function firstWithType(boxes, types) {
    types = isArray(types) ? types : [types];
    var length = boxes.length;
    for(var i = 0; i < length; i++) {
        for(var j = 0; j < types.length; j++) {
            if (boxes[i].type == types[j]) {
                return boxes[i];
            }
        }
    }
    throw new Error('Box not found ' + types);
}

/**
* Gets the key id from a moov box for mp4 streams.
*/
function Box$getKeyId(moovBox) {
    var sampleEntryBox = moovBox.getDescendant('trak/mdia/minf/stbl/stsd/' + Box$CODEC_ENCA + '|' + Box$CODEC_ENCV);
    var sinfBox = sampleEntryBox.children.filter(function (box) {
        return box.type == 'sinf' && box.firstChildByType['schm'].schemeType == 'cenc';
    })[0];
    return sinfBox.getDescendant('schi/tenc').keyId;
}

/**
* Converts keyId in to Guid format used by Microsoft
* @param {Array} keyId
*/
function Box$convertKeyIdToGuid(keyId) {
    // See http://en.wikipedia.org/wiki/Globally_unique_identifier#Binary_encoding for why only some bytes are swapped
    var guid = new Uint8Array(keyId);

    function swap(i, j) {
        var t = guid[i];
        guid[i] = guid[j];
        guid[j] = t;
    }

    swap(0, 3);
    swap(1, 2);
    swap(4, 5);
    swap(6, 7);

    return guid;
}

/**
*  @return {boolean}
*/
function isPromiseBasedEmeSupported() {
    return isFunction(navigator['requestMediaKeySystemAccess']);
}

/**
*  @param {Object} config
*  @return {boolean}
*/
function isLimitedDurationLicenseSupported(config) {
    return isPromiseBasedEmeSupported() || config.supportsLimitedDurationLicense;
}

function pluck(prop) {
    return function(o) {
        return o && o[prop]
    }
}

/**
* for IE only. IE does not have an implementation for ArrayBuffer.prototype.slice()
*/
if( !isFunction(ArrayBuffer.prototype.slice) ){
    /**
    * @param {number=} begin the index we begin to slice
    * @param {number=} end the index we end the slice
    */
    ArrayBuffer.prototype.slice = function slice_ie ( begin, end ){
        if (begin === void 0) {
            begin = 0;
        }

        //If `end` is unspecified, the new ArrayBuffer contains all
        //bytes from `begin` to the end of this ArrayBuffer.
        if (end === void 0) {
            end = this.byteLength;
        }

        //Chrome converts the values to integers via flooring
        begin = Math.floor(begin);
        end = Math.floor(end);

        //If either `begin` or `end` is negative, it refers to an
        //index from the end of the array, as opposed to from the beginning.
        if (begin < 0) {
            begin += this.byteLength;
        }
        if (end < 0) {
            end += this.byteLength;
        }

        //The range specified by the `begin` and `end` values is clamped to the
        //valid index range for the current array.
        begin = Math.min(Math.max(0, begin), this.byteLength);
        end = Math.min(Math.max(0, end), this.byteLength);

        //If the computed length of the new ArrayBuffer would be negative, it
        //is clamped to zero.
        if (end - begin <= 0) {
            return new ArrayBuffer(0);
        }

        var result = new ArrayBuffer(end - begin);
        var resultBytes = new Uint8Array(result);
        var sourceBytes = new Uint8Array(this, begin, end - begin);

        resultBytes.set(sourceBytes);

        return result;
    };
}

/**
*  @param {string|null} url
*/
function isUrlHttps(url){
    return url && url.toLowerCase().indexOf('https') == 0;
}

function getEndianness() {
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);
    b[0] = 0xa1;
    b[1] = 0xb2;
    b[2] = 0xc3;
    b[3] = 0xd4;
    if (c[0] == 0xd4c3b2a1) {
        return "LE";
    } else if (c[0] == 0xa1b2c3d4) {
        return "BE";
    } else {
        return 'undefined'
    }

}

// use the browser Performance API to get the download time for the player js asset
function getPlayerDownloadTime() {
    try {
        var timings = performance['getEntries']('resource');
        var re = /playercore.*js/;
        var downloads = timings.filter(function(t) {
            return re.exec(t['name']) !== null;
        });

        if (downloads && (downloads.length > 0)) {
            var playerDownloadTime = Math$round(downloads[0]['duration']);
            return JSON.stringify(playerDownloadTime);
        }
    } catch (e) {
        //performance getEntries is not supported
    }
}


// -- common/Number.js
function Number$clamp(number, min, max) {
    return number >= min ? (number <= max ? number : max) : min;
}

function Number$scale(number, from1, from2, to1, to2) {
    return ((number - from1) * (to2 - to1) / (from2 - from1)) + to1;
}

function Number$formatMillisecond(milliseconds) {
    if (isNumber(milliseconds)) {
        return (milliseconds / 1000).toFixed(3);
    }
}


// -- common/String.js
// pads the text with padWith so it's at least minLength
function String$padRight(text, padWith, minLength) {
    var count = (minLength - text.length) / padWith.length;
    var result = text;
    while (count-- > 0) {
        result += padWith;
    }
    return result;
}

/**
* if string is longer than maxLength, clip and add tail
*
* @param {string=} tail
*/
function String$dotdotdot(text, maxLength, tail) {
    tail = isString(tail) ? tail : '...';
    if (text.length <= maxLength) {
        return text;
    } else {
        var overflow = text.length + tail.length - maxLength;
        return text.substr(0, text.length - overflow) + tail;
    }
}
/**
* Replace tokens in formatString with passed in args.
* @param {string} formatString 
* @param {...*} var_args
*/
function String$format(formatString, var_args) {
    var args = slice.call(arguments,1);
    return formatString.replace(/{(\d+)}/g, function (match, number) {
        return typeof args[number] != 'undefined'
            ? args[number]
            : match;
    });
}
/**
* Converts a string into an ArrayBuffer
* @param {string} text
*/
function String$stringToArrayBuffer(text) {
    var length = text.length;
    var uint16Array = new Uint16Array(length);
    for (var i=0; i < length; i++) {
        uint16Array[i] = text.charCodeAt(i);
    }

    return uint16Array.buffer; 
}
/**
 * utf8 encode a string into a Uint8Array.
 * @param rawMessage The string to encode.
 * @returns {Uint8Array} for utf8 encoded string.
 */
function utf8Encode(rawMessage) {
    var uintarray = new Uint8Array(rawMessage.length);
    Array.prototype.forEach.call(rawMessage, function(char, i) { uintarray[i] = char.charCodeAt(0); });
    return uintarray;
}



// -- common/Function.js
/**
* @param {function(function({object}))} asyncFunction 
*
* Allows multiple callers to call same async function, and get the same result back.
* asyncFunction will be executed only once.
*
* asyncFunction should have a following signature: function asyncFunction(callback)
*/
function Function$makeMulticast(asyncFunction) {
    var _pendingCallbacks = [],
        _executed,
        _calledBack,
        _result;

    function _callPendingCallbacks() {
        if (_calledBack) {
            var callback;
            while (callback = _pendingCallbacks.pop()) {
                callback(_result);
            }
        }
    };

    function _asyncFunctionCallback(result) {
        _calledBack = true;
        _result = result;
        _callPendingCallbacks();
    };

    return function (callback) {
        _pendingCallbacks.push(callback);
        if (!_executed) {
            _executed = true;
            asyncFunction(_asyncFunctionCallback);
        }
        _callPendingCallbacks();
    };
}


// -- common/dispatch.js
// wrap the Timeout and Interval, so they can be minified and mocked

function dispatch(code) {
    return window.setTimeout(code, 0);
}

function setTimeout(code, delay) {
    return window.setTimeout(code, delay);
}

function clearTimeout(timeoutID) {
    window.clearTimeout(timeoutID);
}

function setInterval(code, delay) {
    return window.setInterval(code, delay);
}

function clearInterval(intervalID) {
    window.clearInterval(intervalID);
}


// -- common/clock.js
var _rand = new DefaultRandomGenerator();
var _sysClock = new DefaultSystemClock();
var _clock = new DefaultClock(_sysClock);// di.resolve('clock');
var _idProvider = new DefaultIdProvider(_clock, _rand);//di.resolve('idProvider');
var JSSID = '' + clock$createId();

function clock$getTime() {
    return _clock.getElapsedRuntimeMilliseconds();
}

function clock$getEpoch() {
    return _clock.getEpochSeconds();
}

function clock$getAppEpoch() {
    return _clock.getLaunchTimeSeconds();
}

function clock$createId() {
    return _idProvider.createId();
}

function clock$genesis() {
    return _clock.getGenesisMilliseconds();
}

function clock$getPreciseEpoch(){
    return _sysClock.getEpochMilliseconds();
}

function clock$getPreciseAppEpoch(){
    return clock$genesis();
}



// -- common/debug.js
// For release debug.assert and debug.log are emptty functions
// so the closure compiler removes all calls to them

var debug$breakOnError = false;// true;
var cadmiumDebug = new CadmiumTypescript.DebugImpl(DEBUG, function () { return debug$breakOnError }, log, IsType, function () { debugger; })

var debug$assert = cadmiumDebug.assert.bind(cadmiumDebug);
var debug$assertDefined = cadmiumDebug.assertDefined.bind(cadmiumDebug);
var debug$assertNotNull = cadmiumDebug.assertDefinedAndNotNull.bind(cadmiumDebug);
var debug$assertString = cadmiumDebug.assertString.bind(cadmiumDebug);
var debug$assertValidString = cadmiumDebug.assertValidString.bind(cadmiumDebug);
var debug$assertStringOrNull = cadmiumDebug.assertStringOrNullOrUndefined.bind(cadmiumDebug);
var debug$assertNumber = cadmiumDebug.assertNumber.bind(cadmiumDebug);
var debug$assertInt = cadmiumDebug.assertInt.bind(cadmiumDebug);
var debug$assertUInt = cadmiumDebug.assertUInt.bind(cadmiumDebug);
var debug$assertPositiveInt = cadmiumDebug.assertPositiveInt.bind(cadmiumDebug);
var debug$assertBool = cadmiumDebug.assertBool.bind(cadmiumDebug);
var debug$assertFunction = cadmiumDebug.assertFunction.bind(cadmiumDebug);
var debug$invalidOperation = cadmiumDebug.invalidOperation.bind(cadmiumDebug);


// -- common/Throttle.js
/**
* @constructor
*/
function Throttle(cooldown) {
    debug$assertUInt(cooldown);

    var _self = this,
        _lastExecution = -cooldown,
        _pendingCallback,
        _timeoutId;

    this.getCooldown = function _getCooldown() {
        return cooldown;
    };

    this.setCooldown = function _setCooldown(newCooldown) {
        cooldown = newCooldown;
    };

    function _onTimeout(localCooldown) {
        _timeoutId = null;
        _tryExecute(localCooldown || cooldown);
    }

    function _tryExecute(cooldown) {
        var now = clock$getTime();

        if (_pendingCallback) {
            var remaining = cooldown - (now - _lastExecution);
            if (remaining <= 0) {
                var callback = _pendingCallback;
                _pendingCallback = null;
                _lastExecution = now;
                callback();
            }
            else {
                _timeoutId = _timeoutId || setTimeout(_onTimeout.bind(this, cooldown), remaining);
            }
        };
    }

    /**
    * @param {Function=} callback
    */
    this.schedule = function schedule(callback) {
        _pendingCallback = callback;
        // never run it synch
        _timeoutId = _timeoutId || dispatch(_onTimeout);
    };

    this.scheduleIfIdle = function scheduleIfIdle(callback) {
        if (!_pendingCallback) {
            _self.schedule(callback);
        }
    };

    // Cancel any scheduled invocations and instead invoke callback immediately (although async)
    this.scheduleImmediate = function(callback) {
        _self.dispose();
        dispatch(callback);
    };

    this.dispose = function _dispose() {
        _timeoutId && clearTimeout(_timeoutId);
		_timeoutId = null;
    };
}

/**
* @constructor
*/
function GetterThrottle(getterFunction, minInterval) {
    var _getter = getterFunction,
        _lastExecutionTime = 0,
        _minInterval = minInterval,
        _cachedValue;

    this.get = function _get() {
        var now = clock$getTime();
        if (!_cachedValue || (now - _lastExecutionTime) > _minInterval) {
            _lastExecutionTime = now;
            _cachedValue = _getter();
        }

        return _cachedValue;
    };

    // Clear the cached value;
    this.clear = function _clear() {
        _cachedValue = undefined;
    };
}

/**
 * Provide a facility to delay the firing of a callback until a quiet period has elapsed.
 * @constructor
 */
function Debouncer(quietPeriod) {
    debug$assertUInt(quietPeriod);
    var _timeoutId;

    /**
     * Schedule a callback which will restart the quietPeriod timer preempting
     * the previous timer.  The callback will only fire if at least the quietPeriod time
     * has elapsed without another callback being scheduled.
     * @param callback
     */
    this.schedule = function schedule(callback) {
        // If we have an existing timer, clear it in preparation to start it over.
        if (_timeoutId) {
            this.dispose();
        }
        _timeoutId = setTimeout(callback, quietPeriod);
    };

    this.dispose = function _dispose() {
        _timeoutId && clearTimeout(_timeoutId);
        _timeoutId = null;
    };
}



// -- common/EventSource.js
var EventSource$counter = 0;
/**
* @constructor
*/
function EventSource() {
    var _eventRoot = {},
        _id = '$es$' + (EventSource$counter++);

   
    mixIn(this,  /** @lends {EventSource.prototype} */  {
        addListener: _addListener,
        removeListener: _removeListener,
        hasAnyListeners: _hasAnyListeners,
        fire: _fire,
        shortCircuitFire: _shortCircuitFire,
        dispose: _dispose,
        on: _addListener
    });

    // --------------------------------------------------------------------------------
    // -- private implementation

    /**
    * @param {number=} order
    */
    function _addListener(eventName, handler, order) {
        var orderProperty = ORDERPROPERTY + _id + '$' + eventName;
        if (_eventRoot) {
            var handlers = _eventRoot[eventName] ? _eventRoot[eventName].slice() : [];
            if (order) {
                handler[orderProperty] = order;
            }
            if (handlers.indexOf(handler) < 0) {
                handlers.push(handler);
                handlers.sort(function sortByOrderProperty(a, b) {
                    return (a[orderProperty] || 0) - (b[orderProperty] || 0);
                });
            }
            _eventRoot[eventName] = handlers;
        }
    }

    function _removeListener(eventName, handler) {
        if (_eventRoot) {
            if (_eventRoot[eventName]) {
                var handlers = _eventRoot[eventName].slice();
                var index;
                while ((index = handlers.indexOf(handler)) >= 0) {
                    handlers.splice(index, 1);
                }
                _eventRoot[eventName] = handlers;
            }
        }
    }
    /**
    * @param {string|number} eventName
    * @param {Object=} args
    * @param {boolean=} shouldDispatch
    */
    function _fire(eventName, args, shouldDispatch) {
        if (_eventRoot) {
            var handlers = _getEventHandlers(eventName);
            for (var i = 0; i < handlers.length; i++) {
                if (shouldDispatch) {
                    (function () {
                        var handler = handlers[i];
                        dispatch(function () { handler(args); });
                    })();
                }
                else {
                    handlers[i].call(this, args);
                }
            };
        }
    }
    
    /**
    * @param {string|number} eventName
    * @param {Object=} args
    */   
    function _shortCircuitFire(eventName, args) {
        if (_eventRoot) {
            var handlers = _getEventHandlers(eventName);
            args = args || {};

            for (var i = 0; i < handlers.length && !args.handled; i++) {
                handlers[i](args);
            };
        }
    }

    function _hasAnyListeners(eventName) {
        return _eventRoot && !!_getEventHandlers(eventName).length;
    }

    function _getEventHandlers(eventName) {
        // get or create-then-get
        return _eventRoot[eventName] || (_eventRoot[eventName] = []);
    }

    function _dispose() {
        _eventRoot = undefined;
    }
}






// -- common/globalEvents.js
var globalEvents = new EventSource();

var globalEvents$beforeunload = 1,
    globalEvents$keydown = 2,
    globalEvents$resize = 3,
    globalEvents$hiddenchanged = 4;

dispatch(function () {
    var jQuery = window['jQuery'],
        jQueryWindow = jQuery && jQuery(window),
        netflix = window['netflix'],
        addBeforeUnloadHandler = netflix && netflix['cadmium'] && netflix['cadmium']['addBeforeUnloadHandler'],
        hidden = document['hidden'];

    function addWindowEventListener(eventName, handler) {
        if (jQueryWindow) {
            // jQuery eats some events, so subscrbed through it if it exists
            jQueryWindow['on'](eventName, handler);
        } else {
            // subscribe on window
            window.addEventListener(eventName, handler);
        }
    };

    // when window closes, release all locks
    if (addBeforeUnloadHandler) {
        addBeforeUnloadHandler(function (e) {
            // if there is a shared handler, use it
            globalEvents.fire(globalEvents$beforeunload, e);
        });
    } else {
        addWindowEventListener('beforeunload', function (e) {
            globalEvents.fire(globalEvents$beforeunload, e);
        });
    }

    addWindowEventListener('keydown', function (e) {
        globalEvents.fire(globalEvents$keydown, e);
    });

    addWindowEventListener('resize', function () {
        globalEvents.fire(globalEvents$resize);
    });

    document.addEventListener('visibilitychange', function () {
        if (hidden !== document['hidden']) {
            hidden = document['hidden'];
            globalEvents.fire(globalEvents$hiddenchanged);
        }
    });
});



// -- common/logDisplay.js
var logDisplay = (function () {
    var CSS_COMMON = 'position:fixed;left:10px;top:30px;right:10px;z-index:10000;color:#000;',
        CSS_FULL = CSS_COMMON + ';bottom:10px',
        CSS_SMALL = CSS_COMMON + ';height:30%',
        ELEMENT_STYLE = 'display:inline-block;border:1px solid black;padding:3px;';

    var _updateThrottle = new Throttle(1000),
        _element = createElement('DIV', CSS_FULL, undefined, { 'class': 'player-log' }),
        _textareaStyleCommon = 'position:absolute;resize:none;box-sizing:border-box;width:100%;height:100%;margin:0;color:#040;font-size:11px;font-family:monospace;overflow:scroll',
        _textareaStyle = _textareaStyleCommon + ';background-color:rgba(255,255,255,0.6)',
        _textareaFocusedStyle = _textareaStyleCommon + ';background-color:rgba(255,255,255,0.86)',
        _textarea = createElement('TEXTAREA', _textareaStyle),
        _controls = createElement('DIV', 'position:absolute;top:2px;right:2px;opacity:0.8;background-color:white'),
        _entries = [],
        _isSmall = true,
        _textareaFocused;

    _textarea.setAttribute('wrap', 'off');
    _textarea.setAttribute('readonly', 'readonly');
    _textarea.addEventListener('focus', function () { _textareaFocused = true; _update(false); _textarea.style.cssText = _textareaFocusedStyle; });
    _textarea.addEventListener('blur', function () { _textareaFocused = false; _update(false); _textarea.style.cssText = _textareaStyle; });
    _element.appendChild(_textarea);
    _element.appendChild(_controls);

    function _show() {
        if (document.body) {
            if (!_isVisible()) {
                document.body.appendChild(_element);
                _update(true);
            }
        }
    };

    function _hide() {
        if (_isVisible()) document.body.removeChild(_element);
    };

    function _toggle() {
        _isVisible() ? _hide() : _show();
    };

    function _isVisible() {
        return _element.parentNode == document.body;
    };

    function _throttledUpdate() {
        _updateThrottle.schedule(_update);
    };

    /**
    * @param {boolean=} scroll
    */
    function _update(scroll) {
        var logLevel = parseInt10(_levelElement.value),
            filter = _filterElement.value ? new RegExp(_filterElement.value) : null,
            details = _detailsElement.checked,
            s = '',
            entry,
            entryText,
            i,
            length = _entries.length;
        for (i = 0; i < length; i++) {
            entry = _entries[i];
            if (entry['level'] <= logLevel) {
                entryText = log$entryToString(entry, details, details);
                if (!filter || filter.test(entryText)) {
                    s += entryText + '\n';
                }
            }
        }

        _textarea.value = log$buildHeader() + s;

        _element.style.cssText = _isSmall ? CSS_SMALL : CSS_FULL;

        if (scroll) {
            dispatch(function () {
                _textarea.scrollTop = _textarea.scrollHeight;
            });
        }
    };

    function _clear() {
        _entries = [];
        _update();
    };

    var _levelElement = createElement('SELECT', null,
        '<option value="1">Error</option>' +
        '<option value="2">Warn</option>' +
        '<option value="3" selected>Info</option>' +
        '<option value="4">Trace</option>' +
        '<option value="5">Debug</option>'
    );
    _levelElement.addEventListener('change', _update, false);
    _controls.appendChild(_levelElement);

    var _detailsElement = createElement('INPUT', ELEMENT_STYLE);
    _detailsElement.setAttribute('type', 'checkbox');
    _detailsElement.setAttribute('checked', 'true');
    _detailsElement.setAttribute('title', 'Details');
    _detailsElement.addEventListener('change', _update, false);
    _controls.appendChild(_detailsElement);

    var _filterElement = createElement('INPUT', ELEMENT_STYLE + ';width:150px');
    _filterElement.addEventListener('keydown', _throttledUpdate, false);
    _filterElement.addEventListener('change', _throttledUpdate, false);
    _filterElement.setAttribute('title', 'Filter (RegEx)');
    _controls.appendChild(_filterElement);

    var _updateElement = createElement('BUTTON', ELEMENT_STYLE, 'Update');
    _updateElement.addEventListener('click', _update, false);
    _controls.appendChild(_updateElement);

    var _clearElement = createElement('BUTTON', ELEMENT_STYLE, 'Clear');
    _clearElement.addEventListener('click', _clear, false);
    _controls.appendChild(_clearElement);

    var _minElement = createElement('BUTTON', ELEMENT_STYLE, 'M');
    _minElement.addEventListener('click', _minMax, false);
    _controls.appendChild(_minElement);

    var _closeElement = createElement('BUTTON', ELEMENT_STYLE, 'X');
    _closeElement.addEventListener('click', _hide, false);
    _controls.appendChild(_closeElement);

    function _minMax() {
        _isSmall = !_isSmall;
        _update();
    };

    globalEvents.addListener(globalEvents$keydown, function (event) {
        if (event.ctrlKey && event.altKey && event.shiftKey && event.keyCode == 76) {
            _isSmall = false;
            _toggle();
        }
    });

    log['addSink'](function (entry) {
        _entries.push(entry);
        if (config) {   
            var logDisplayMaxEntryCount = config.logDisplayMaxEntryCount;
            if (logDisplayMaxEntryCount >= 0 && _entries.length > logDisplayMaxEntryCount) {
                _entries.shift();
            }
            if (DEBUG) {
                if (entry['level'] <= config.logDisplayAutoshowLevel) {
                    if (!_isVisible()) {
                        _isSmall = true;
                    }
                    _show();
                }
            }
        }
        if (_isVisible() && !_textareaFocused) {
            _throttledUpdate();
        } else {
            _updateThrottle.schedule();
        }
    });

    return {
        show: function () {
            _isSmall = false;
            _show();
        },
        hide: _hide,
        toggle:  function () {
            _isSmall = false;
            _toggle();
        }
    };
})();


// -- common/logToConsole.js
log['addSink'](function logToConsoleSink(entry) {
    var level = entry['level'];
    if ((!config) || (level <= config.logToConsoleLevel)) {
        var s = log$entryToString(entry, true, true);
        var console = window['console'];
        if (level <= 1) {
            console['error'](s);
        } else if (level <= 2) {
            console['warn'](s);
        } else {
            console['log'](s);
        }
    }
});


// -- common/ReaderWriterLock.js
/**
* @constructor
* 
* TODO: synchronises lock between all browser tabs
*/
function ReaderWriterLock(name) {
    var _readLockIds = [],
        _writeLockId,
        _pending = [],
        _idCounter = 1;

    
    mixIn(this, /** @lends {ReaderWriterLock.prototype} */ {
        acquireLock: _acquireLock,
        releaseLock: _releaseLock
    });

    function _acquireLock(isWrite, callback) {
        _pending.push({
            isWrite: isWrite,
            callback: callback
        });
        _checkPending();
    }

    function _releaseLock(lockId) {
        var readLockIndex = _readLockIds.indexOf(lockId);
        if (readLockIndex >= 0) {
            _readLockIds.splice(readLockIndex, 1);
        } else if (lockId == _writeLockId) {
            _writeLockId = undefined;
        } else {
            debug$assert(false, 'lock released without being acquired');
        }
        dispatch(_checkPending);
    }

    function _checkPending() {
        var i = 0,
            pending,
            lockId;

        while (!_writeLockId && (pending = _pending[i])) {
            if (_readLockIds.length <= 0 || !pending.isWrite) {
                _pending.splice(i, 1);
                lockId = _idCounter++;
                if (pending.isWrite) {
                    _writeLockId = lockId;
                } else {
                    _readLockIds.push(lockId);
                }
                pending.callback({
                    success: true,
                    lockId: lockId,
                    releaseLock: function releaseLock() {
                        _releaseLock(lockId);
                    }
                });
            }
            i++;
        }
    }
}


// -- common/ObservableProperty.js
var ObservableProperty$counter = 0;
/**
* @constructor
* @param {*=} defaultValue
* @param {function(Object=)=} handler1
*/
function ObservableProperty(defaultValue, handler1) {
    var _self = this,
        _handlers = handler1 ? [handler1] : [],
        _id = '$op$' + (ObservableProperty$counter++);

    mixIn(_self,
    /** @lends {ObservableProperty.prototype} */
    {
        value: defaultValue,

        addListener: _addListener,
        removeListener: _removeListener,
        set: _set
    });

    // --------------------------------------------------------------------------------
    // -- private implementation

    /**
    * @param {number=} order
    */
    function _addListener(handler, order) {
        debug$assertFunction(handler);
        debug$assert(_handlers.indexOf(handler) < 0);

        // duplicate before modifying, so if add/remove can work properly when called from handlers
        handler[ORDERPROPERTY + _id] = order;
        _handlers = _handlers.slice();
        _handlers.push(handler);
        _handlers.sort(sortByOrderProperty);
    }

    function _removeListener(handler) {
        debug$assertFunction(handler);

        // duplicate before modifying, so if add/remove can work properly when called from handlers
        _handlers = _handlers.slice();
        var index;
        if ((index = _handlers.indexOf(handler)) >= 0) {
            _handlers.splice(index, 1);
        }
    }

    /**
    * @param {*} newValue
    * @param {Object=} customArgs
    */
    function _set(newValue, customArgs) {
        if (_self.value === newValue)
            return;

        var args = {
            oldValue: _self.value,
            newValue: newValue
        };

        customArgs && mixIn(args, customArgs);

        _self.value = newValue;

        // copy the variable so add and remove can modify it
        var handlers = _handlers,
            length = handlers.length;
        for (var i = 0; i < length; i++) {
            handlers[i](args);
        }
    }

    function sortByOrderProperty(a, b) {
        return (a[ORDERPROPERTY + _id] || 0) - (b[ORDERPROPERTY + _id] || 0);
    }
}


// -- common/OneWayCounter.js
/**
* @constructor
* Counter that deals with resets. [1, 10, 20, 5, 6, 2, 3] -> [1, 10, 20, 25, 26, 28, 29]
*/
function OneWayCounter() {
}

mixIn(OneWayCounter.prototype, /** @lends {OneWayCounter.prototype} */ ({

    hasCount: false,
    thisCount: 0,
    totalCount: 0,
    ignoreCount: 0,

    ignoring: false,
    ignoreFrom: 0,

    addObservation: function addObservation(n) {
        if (isNumber(n)) {
            if (n < this.thisCount) {
                this.totalCount += this.thisCount;
            }
            this.thisCount = n;
            this.hasCount = true;
        }
    },

    getCount: function getCount() {
        if (this.hasCount) {
            if (this.ignoring) {
                return this.ignoreFrom - this.ignoreCount;
            } else {
                return this.totalCount + this.thisCount - this.ignoreCount;
            }
        }
    },

    startIgnoring: function () {
        if (!this.ignoring) {
            if (this.hasCount) {
                this.ignoreFrom = this.totalCount + this.thisCount;
            }
            this.ignoring = true;
        }
    },

    stopIgnoring: function () {
        if (this.ignoring) {
            if (this.hasCount) {
                this.ignoreCount += this.totalCount + this.thisCount - this.ignoreFrom;
            }
            this.ignoreFrom = 0;
            this.ignoring = false;
        }
    }

}));


// -- common/TimeoutMonitor.js
/**
* @constructor
*/
function TimeoutMonitor(timeoutMilliseconds, handler) {
    var _timeoutId;

    
    mixIn(this, /** @lends {TimeoutMonitor.prototype} */ {
        ensureTimer: _ensureTimer,
        stopTimer: _stopTimer
    });

    function _ensureTimer() {
        if (!_timeoutId) {
            _timeoutId = setTimeout(handler, timeoutMilliseconds);
        }
    };

    function _stopTimer() {
        if (_timeoutId) {
            clearTimeout(_timeoutId);
            _timeoutId = undefined;
        }
    };
}


// -- common/DataStream-asn1.js
/**
* Writes Uint8Array into stream as ASN.1 octed.
*/
DataStream.prototype.writeAsn1Octet = function DataStream_writeAsn1Octed(array) {
    var outputStream = this,
        inputStream = new DataStream(array),
        i,
        remaining,
        remainingBlocks;

    function writeToOutput(bytes) {
        outputStream.writeFromStream(inputStream, bytes);
    }

    while (1) {
        remaining = inputStream.getRemaining();
        remainingBlocks = remaining >>> 14;
        if (remainingBlocks) {
            // remaining size is larger than a "block"
            // write the size as number of blocks
            // [11000XXX], XXX is the number blocks ( 1 block = 1 * 0x4000 = 16k, 2 blocks = 2 * 0x4000 = 32k, 3 ...= 48k, 4 ...= 64k)
            remainingBlocks = Math$min(4, remainingBlocks);
            debug$assert(remainingBlocks >= 1);

            outputStream.writeByte(0xC0 | remainingBlocks);
            writeToOutput(remainingBlocks * 0x4000);
            // Note: event if [remaining] is divisible by 0x4000, we still want to continue to write out a "0"-sized entry
            continue;
        } else {
            debug$assert(remaining < 0x4000);
            // there is less than one "block" (16k) remaining
            // write the size as number of bytes
            if (remaining < 0x80) {
                // [.XXXXXXX] is written as [0XXXXXXX]
                outputStream.writeByte(remaining);
                writeToOutput(remaining);
            } else {
                // [..XXXXXX XXXXXXXX] is written as [10XXXXXX XXXXXXXX]
                outputStream.writeNumber(remaining | 0x8000, 2);
                writeToOutput(remaining);
            }
        }

        break;
    }
};

/**
* Reads ASN.1 encoded octed and retruns it as Uint8Array.
*/
DataStream.prototype.readAsn1Octet = function DataStream_readAsn1Octed() {
    var dis = this,
        buffer = [],
        outputStream = new DataStream(buffer),
        n;

    function writeToOutput(bytes) {
        outputStream.writeFromStream(dis, bytes);
    };

    while (1) {
        n = dis.readByte();
        if (!(n & 0x80)) {
            // [0XXXXXXX], length is 7 bits
            writeToOutput(n);
        } else {
            // [1XXXXXXX]
            if ((n & 0xC0) == 0x80) {
                // [10XXXXXX XXXXXXXX], read another byte, length is 6+8 bits
                n &= 0x3F;
                n = (n << 8) + dis.readByte();
                writeToOutput(n);
            } else {
                // [11XXXXXX], length is in stored as block (0x4000 byte each) count
                n &= 0x3F;
                if (n > 0 && n <= 4) {
                    writeToOutput(n * 0x4000);
                    // and keep reading
                    continue;
                } else {
                    throw new Error('bad asn1');
                }
            }
        }

        break;
    }

    return new Uint8Array(buffer);
};


// -- common/csv.js
var makeCsv;
var csvEncode;

(function () {
    var map = {
        '"': '""',
        '\r': '',
        '\n': ' '
    };
    var regex = /["\r\n]/g;
    var needsQuotesRegex = /[", ]/;
    function mapper(tag) {
        debug$assert(map[tag] !== undefined);
        return map[tag];
    }

    csvEncode = function(s) {
        if (!isDefined(s)){
            return '';
        }
        if (isNumber(s)) {
            return s;
        }
        if (isString(s)) {
            return s.replace(regex, mapper);
        }
        if (isBool(s)) {
            return s;
        }
        if (isNaN(s)) {
            return 'NaN';
        }
        return '';
    };

    makeCsv = function (o) {
        var enc = csvEncode,
            csvString = '';
        enumerateOwnProperties(o, function (k, v) {
            var pair = enc(k) + '=' + enc(v);
            if (needsQuotesRegex.test(pair)) {
                pair = '"' + pair + '"';
            }
            if (csvString) {
                csvString += ',' + pair;
            } else {
                csvString = pair;
            }
        });
        return csvString;
    };
})();


// -- common/PlayerError.js
/**
* @constructor
* @param {number} errorCode
* @param {*=} errorResult
* @param {*=} errorExternalCode
*/
function PlayerError(errorCode, errorResult, errorExternalCode) {
    debug$assert(errorCode && errorCode != ErrorCodes.UNKNOWN, 'There should always be a specific error code');

    this.errorCode = errorCode || ErrorCodes.UNKNOWN;

    if (errorResult && isObject(errorResult)) {
        this.errorSubCode = errorResult.errorSubCode || errorResult.subCode;
        this.errorExternalCode = errorResult.errorExternalCode || errorResult.extCode;
        this.errorEdgeCode = errorResult.errorEdgeCode || errorResult.edgeCode;
        this.errorDetails = errorResult.errorDetails;
        this.displayMessage = errorResult.errorDisplayMessage;
        this.errorMslCode = errorResult.errorMslCode;

        // and special case NCCP and HTTP error codes which we need to report as they are
        this.errorHttpCode = errorResult.errorHttpCode;
        this.nccpMethod = errorResult.method;

        debug$assert(!this.errorHttpCode || this.errorHttpCode == this.errorExternalCode);

    } else {
        this.errorSubCode = errorResult;
        this.errorExternalCode = errorExternalCode;
    }

    var stack = this.stack = [this.errorCode];
    if (this.errorSubCode) {
        stack.push(this.errorSubCode);
    } else {
        if (this.errorExternalCode) {
            stack.push(ErrorSubCodes.UNKNOWN);
        }
    }
    if (this.errorExternalCode) {
        stack.push(this.errorExternalCode);
    }

    this.displayCode = ERROR_PREFIX + stack.join('-');
}

PlayerError.prototype.toString = function () {
    var e = this;
    var s = '[PlayerError #' + e.displayCode + ']';
    if (DEBUG) {
        var codeStr,
            subCodeStr;

        enumerateOwnProperties(ErrorCodes, function (k, v) {
            if (v == e.stack[0]) {
                codeStr = k;
            }
        });

        enumerateOwnProperties(ErrorSubCodes, function (k, v) {
            if (v == e.stack[1]) {
                subCodeStr = k;
            }
        });

        s += ' [PlayerErrorString: ' + codeStr + (subCodeStr ? '-' + subCodeStr : '') + ']';
    }

    e.errorDetails && (s += ' ' + e.errorDetails);
    e.displayMessage && (s += ' (CustomMessage: ' + e.displayMessage + ')');
    return s;
};

/**
* Converts this error into an object that can be passed to the public API (UI)
*/
PlayerError.prototype.toPublic = function () {
    var playerError = this;
    /** @type {Array.<string>}  */
    var messageIdList;

    if (playerError.displayMessage) {
        // presence of displayMessge, indicates that it's a custom error from NCCP
        messageIdList = ['streaming_error'];
    }

    if (!messageIdList && MediaElement$getDrmType() === DrmType$PLAYREADY) {
        if (playerError.errorExternalCode == '80080017') {
            // FOR IE11 ony, we get this external code when in admin mode
            messageIdList = ['admin_mode_not_supported', 'platform_error'];
        }

        if (playerError.errorExternalCode === '8004CD12') {
            // For this HWDRM error show the play button instead of an error
            messageIdList = ['pause_timeout'];
        }
    }

    // For WideVine only, map creation failure for mediaKeysSystemAccess and 
    // mediaKeys to the same DRM specific message
    if (!messageIdList && MediaElement$getDrmType() === DrmType$WIDEVINE ) {
        if (playerError.errorCode === ErrorCodes.EME_CREATE_MEDIAKEYS_SYSTEMACCESS_FAILED ||
            playerError.errorCode === ErrorCodes.EME_CREATE_MEDIAKEYS_FAILED){
            messageIdList = ['no_cdm', 'platform_error', 'plugin_error'];
        }
    }

    // For PrimeTime only, map creation failure for mediaKeysSystemAccess to a DRM specific message
    if (!messageIdList && MediaElement$getDrmType() === DrmType$PRIMETIME ) {
        if (playerError.errorCode === ErrorCodes.EME_CREATE_MEDIAKEYS_SYSTEMACCESS_FAILED){
            messageIdList = ['no_cdm_ff', 'platform_error', 'plugin_error'];
        }
    }

    if (!messageIdList) {
        switch (playerError.errorCode) {
            case ErrorCodes.PAUSE_TIMEOUT:
            case ErrorCodes.INACTIVITY_TIMEOUT:
            case ErrorCodes.AUTHORIZATION_EXPIRED:
            case ErrorCodes.PLAY_MSE_EME_KEY_STATUS_CHANGE_EXPIRED:
                messageIdList = ['pause_timeout'];
                break;

            case ErrorCodes.INIT_PLAYBACK_LOCK:
            case ErrorCodes.INIT_SESSION_LOCK:
                if (!playerError.errorSubCode) {
                    // Presense of subcode indicates that there was an issue accessing the local storage (exception, etc)
                    // We should show multiple_tabs message only if we were able to access the storage, but there was an active lock (no sub code)
                    messageIdList = ['multiple_tabs'];
                } else {
                    // if there is an error, then it's a platform error: "check your browser or os settings"
                    messageIdList = ['platform_error'];
                }
                break;

            case ErrorCodes.INIT_NETFLIXID_MISSING:
            case ErrorCodes.INIT_NETFLIXID_INVALID:
            case ErrorCodes.INIT_SECURENETFLIXID_MISSING:
                messageIdList = ['should_signout_and_signin'];
                break;

            case ErrorCodes.INIT_COMPONENT_DEVICE:
            case ErrorCodes.PLAY_MSE_NOTSUPPORTED:
            case ErrorCodes.PLAY_MSE_EME_NOTSUPPORTED:
            case ErrorCodes.PLAY_MSE_SOURCEADD:
            case ErrorCodes.PLAY_MSE_CREATE_MEDIAKEYS:
                messageIdList = ['platform_error', 'plugin_error'];
                break;

            case ErrorCodes.PLAY_MSE_GENERATEKEYREQUEST:
                messageIdList = ['no_cdm', 'platform_error', 'plugin_error'];
                break;

            case ErrorCodes.PLAY_MSE_EME_TYPE_NOTSUPPORTED:
                if (!playerError.errorSubCode) {
                    messageIdList = ['no_cdm', 'platform_error', 'plugin_error'];
                } else {
                    messageIdList = ['platform_error', 'plugin_error'];
                }
                break;

            case ErrorCodes.PLAY_MSE_EVENT_KEYERROR:
                switch (playerError.errorExternalCode) {
                    case 'FFFFD000':
                        // FOR Safari ony, we get this external code which means that device is missing a serial number and should be taken to Genius bar
                        messageIdList = ['device_needs_service', 'platform_error'];
                        break;
                    case '48444350':
                        // FOR Safari ony, we get this external code which means that there is non-HDCP monitor or airplay 
                        messageIdList = ['unsupported_output', 'platform_error'];
                        break;
                    case '00000024':
                        // Chrome reports error code 24 (file system errror, can't read tokenId) when in private mode
                        messageIdList = ['private_mode'];
                        break;
                }
                break;
            case ErrorCodes.PLAY_MSE_EME_KEY_STATUS_CHANGE_OUTPUT_NOT_ALLOWED:
                messageIdList = ['unsupported_output'];
                break;    
        }
    }

    if (!messageIdList && ErrorSubCodes$isHTTP(playerError.errorSubCode)) {
        if (playerError.errorSubCode == ErrorSubCodes.HTTP_PROXY) {
            messageIdList = ['geo'];
        } else {
            messageIdList = ['internet_connection_problem'];            
        }
    }

    if (!messageIdList) {
        switch (playerError.errorSubCode) {
            case ErrorSubCodes.WEBCRYPTO_MISSING:
                messageIdList = ['should_upgrade'];
                break;
            case ErrorSubCodes.NCCP_PROTOCOL_INVALIDDEVICECREDENTIALS:
            case ErrorSubCodes.MSL_ERROR_REAUTH:
                messageIdList = ['should_signout_and_signin'];
                break;
            case ErrorSubCodes.NCCP_PROTOCOL_REDIRECT_LOOP:
                messageIdList = ['internet_connection_problem'];
                break;
            case ErrorSubCodes.STORAGE_QUOTA_NOT_GRANTED:
            case ErrorSubCodes.STORAGE_QUOTA_TO_SMALL:
            case ErrorSubCodes.STORAGE_FS_REQUESTFILESYSTEM:
                messageIdList = ['storage_quota'];
                break;
            case ErrorSubCodes.PLUGIN_LOAD_MISSING:
            case ErrorSubCodes.PLUGIN_LOAD_ERROR:
            case ErrorSubCodes.PLUGIN_LOAD_TIMEOUT:
            case ErrorSubCodes.PLUGIN_LOAD_EXCEPTION:
            case ErrorSubCodes.DEVICE_NO_ESN:
                messageIdList = ['platform_error', 'plugin_error'];
                break;
            case ErrorSubCodes.DEVICE_ERROR_GETTING_ESN:
            case ErrorSubCodes.INDEXDB_NOT_SUPPORTED:
            case ErrorSubCodes.INDEXDB_OPEN_NULL:
                messageIdList = ['private_mode'];
                break;
        }
    }

    switch (playerError.errorSubCode) {
        case ErrorSubCodes.INDEXDB_OPEN_TIMEOUT:
        case ErrorSubCodes.STORAGE_LOAD_TIMEOUT:
        case ErrorSubCodes.STORAGE_SAVE_TIMEOUT:
        case ErrorSubCodes.STORAGE_DELETE_TIMEOUT:
            if (config.allowPleaseCallMessage) {
                messageIdList = ['please_call'];
            }
            break;
    }

    messageIdList = messageIdList || [];
    messageIdList.push(ERROR_PREFIX + playerError.errorCode);
    if (playerError.errorSubCode) {
        messageIdList.push('' + playerError.errorSubCode);
    }

    var publicError = {
        'display': {
            'code': playerError.displayCode,
            'text': playerError.displayMessage
        },

        'messageIdList': messageIdList
    };

    if (playerError.errorMslCode) {
        publicError['mslErrorCode'] = playerError.errorMslCode;
    }

    return publicError;
};

/**
* @param {number} errorCode
* @param {*=} errorResult
* @param {*=} errorExternalCode
*/
function PlayerError$createPublicError(errorCode, errorResult, errorExternalCode) {
    return (new PlayerError(errorCode, errorResult, errorExternalCode)).toPublic();
}



// -- common/loadAsync.js
// loads asynchronous components of the library

var loadAsync;

/**
* @param {number} componentErrorCode
* @param {function(function({object}))} loadFunction 
*/
var loadAsync$register;

var loadAsync$startTime;
var loadAsync$endTime;
// various async components can add timings to here for debugging
var loadAsync$milestones = {};

(function () {
    var _log = new log.CategoryLog('loadAsync'),
        _toLoad = [],
        _registrationsClosed;

    loadAsync$register = function (componentErrorCode, loadFunction) {
        debug$assert(!_registrationsClosed);
        _toLoad.push({
            loadFunction: loadFunction,
            componentErrorCode: componentErrorCode
        });
    };

    loadAsync = Function$makeMulticast(function (callback) {
        loadAsync$startTime = clock$getTime();

        // which component we started loading last?
        var lastComponentErrorCode = 0;

        _registrationsClosed = true;

        var timeoutMonitor = new TimeoutMonitor(config.asyncLoadTimeout, function () {
            _log.error('Load timed out');
            wrapup({ errorCode: lastComponentErrorCode, errorSubCode: ErrorSubCodes.ASYNCLOAD_TIMEOUT });
        });

        function loadNextComponent() {
            var nextToLoad,
                loadFunction,
                componentErrorCode;
            if (nextToLoad = _toLoad.shift()) {
                try {
                    loadFunction = nextToLoad.loadFunction;
                    lastComponentErrorCode = componentErrorCode = nextToLoad.componentErrorCode;

                    DEBUG && _log.debug('Loading component', { 'Function': getFunctionName(loadFunction) });

                    timeoutMonitor.stopTimer();
                    timeoutMonitor.ensureTimer();
                    loadFunction(function (result) {
                        if (result.success) {
                            loadNextComponent();
                        } else {
                            result.errorCode = result.errorCode || componentErrorCode;
                            wrapup(result);
                        }
                    });
                }
                catch (e) {
                    _log.error('Exception while loading component', e);
                    wrapup({ errorCode: componentErrorCode, errorSubCode: ErrorSubCodes.ASYNCLOAD_EXCEPTION, errorDetails: '' + e });
                }
            } else {
                wrapup(SUCCESS);
            }
        };
        loadNextComponent();

        function wrapup(result) {
            loadAsync$endTime = clock$getTime();
            wrapup = NOOP;
            timeoutMonitor.stopTimer();
            callback(result);
        };
    });
})();

function loadAsync$notifyMilestone(name) {
    debug$assert(loadAsync$milestones[name] === undefined);
    loadAsync$milestones[name] = clock$getTime();
}


// -- common/loadPlugin.js
/**
* navPlugin is navigator.plugins['PluginName']
*/
function loadPlugin(navPlugin, callback) {
    var _log = new log.CategoryLog('Plugin'),
        navPluginType;

    debug$assert(navPlugin);

    function doCallback(result) {
        var cb = callback;
        callback = NOOP;
        cb(result);
    };

    if (navPlugin) {
        navPluginType = navPlugin[0].type;
    } else {
        doCallback({ errorSubCode: ErrorSubCodes.PLUGIN_LOAD_MISSING });
        return;
    }

    _log.info('Injecting plugin OBJECT', { 'Type': navPluginType });
    var o = createElement(
        'OBJECT',
        PLUGIN_ELEMENT_STYLE,
        undefined,
        {
            'type': navPluginType,
            'class': 'netflix-plugin'
        }
    );
    o['addEventListener']('message', onMessage);
    function onMessage(event) {
        try {
            var messageJson = event['data'];

            DEBUG && _log.debug('Message from plugin', messageJson);

            var message = JSON.parse(messageJson),
                method = message['method'],
                success = message['success'],
                payload = message['payload'];

            debug$assert(method == 'ready');

            if (method == 'ready') {
                o['removeEventListener']('message', onMessage);
                timeoutMonitor.stopTimer();
                dispatch(function () {
                    _log.info('Plugin sent ready message');
                    if (success) {
                        doCallback({
                            'success': true,
                            'pluginObject': o,
                            'pluginVersion': payload && payload.version
                        });
                    } else {
                        doCallback({ errorSubCode: ErrorSubCodes.PLUGIN_LOAD_ERROR, errorExternalCode: message['errorCode'] });
                    }
                });
            }
        }
        catch (e) {
            _log.error('Exception while parsing message from plugin', e);
            doCallback({ errorSubCode: ErrorSubCodes.PLUGIN_LOAD_EXCEPTION });
        }
    };

    var timeoutMonitor = new TimeoutMonitor(8000, function () {
        _log.error('Plugin load timeout');
        doCallback({ errorSubCode: ErrorSubCodes.PLUGIN_LOAD_TIMEOUT });
    });

    document.body.appendChild(o);
    timeoutMonitor.ensureTimer();
};

function loadPlugin$createMockPluginLoader(mockPluginUrl) {
    if ((DEBUG || DEV) && isUrl(mockPluginUrl)) {
        return function loadMockPlugin(callback) {
            var scriptTag = createElement('script');
            scriptTag['setAttribute']('type', 'text/javascript');
            scriptTag['setAttribute']('src', mockPluginUrl);
            scriptTag['onload'] = function () {
                var f = window['netflixLoadMockPlugin'];
                if (f) {
                    f(new log.CategoryLog('MockPlugin'), callback);
                } else {
                    callback({ errorSubCode: ErrorSubCodes.PLUGIN_LOAD_MISSING });
                }
            };
            scriptTag['onerror'] = function () {
                callback({ errorSubCode: ErrorSubCodes.PLUGIN_LOAD_MISSING });
            }
            document['head']['appendChild'](scriptTag);
        };
    }
}

/**
* Given a call plugin object, returns a method with following signature: callPlugin(method, args, function(result) {});
*/
function loadPlugin$createCallMethod(pluginObject) {
    var _log = new log.CategoryLog('Plugin'),
        _invokeIndex = 1,
        _invokeCallbacks = {};

    function _handleMessage(event) {
        try {
            var messageJson = event['data'];

            DEBUG && _log.debug('Message from plugin', messageJson);

            var message = JSON.parse(messageJson),
                idx = message['idx'],
                success = message['success'],
                payload = message['payload'],
                callback = _invokeCallbacks[idx];

            if (callback) {
                if (success) {
                    callback({
                        success: true,
                        args: payload
                    });
                } else {
                    callback({
                        success: false,
                        errorSubCode: ErrorSubCodes.PLUGIN_CALLBACK_ERROR,
                        errorDetails: message['errorMessage'],
                        errorExternalCode: message['errorCode']
                    });
                }
            }
        }
        catch (e) {
            _log.error('Exception while parsing message from plugin', e);
        }
    };

    pluginObject['addEventListener']('message', _handleMessage, false);

    return function callPlugin(method, args, callback) {
        try {
            var idx = _invokeIndex++;
            var message = {
                'idx': idx,
                'method': method
            };
            message['argsObj'] = args || {};

            var timeoutMonitor = new TimeoutMonitor(8000, function () {
                _log.error('Plugin never called back', { 'Method': method });
                delete _invokeCallbacks[idx];
                callback({ errorSubCode: ErrorSubCodes.PLUGIN_CALLBACK_TIMEOUT });
            });
            timeoutMonitor.ensureTimer();

            function onComplete(result) {
                var args = result.args;
                if (result.success) {
                    DEBUG && _log.debug('Plugin called back', { 'Method': method }, args && stringifyJsonPretty(args));
                } else {
                    _log.info('Plugin called back with error', { 'Method': method }, ErrorSubCodes$errorResultToLogFields(result));
                }
                timeoutMonitor.stopTimer();
                delete _invokeCallbacks[idx];
                callback(result);
            }

            var messageJson = JSON.stringify(message);
            _invokeCallbacks[idx] = onComplete;
            DEBUG && _log.debug('Calling plugin', { 'Method': method }, stringifyJsonPretty(message));
            pluginObject['postMessage'](messageJson);
        }
        catch (e) {
            _log.error('Exception calling plugin', e);
            callback({ errorSubCode: ErrorSubCodes.PLUGIN_EXCEPTION });
        }
    };
};


// -- common/ipAddress.js
/** @const */
var IPv4_REGEX = /^[0-9.]*$/;
/** @const */
var IPv6_REGEX = /^([a-fA-F0-9]*:){2}[a-fA-F0-9:.]*$/;
/** @const */
var IPAddress$PADDING = '0000000000000000';

// if the address is valid, it will return it, else the return value will be undefined
function IPAddress$getValidIPv4(address) {
    debug$assertValidString(address);
    if (!isString(address) || !IPv4_REGEX.test(address)) {
        return;
    }

    var parts = address.split('.');
    // there are fewer than four parts to the address
    if (parts.length !== 4) {
        return;
    }

    // check that each address part has a valid value
    for (var i = 0; i < parts.length; i++) {
        var parsedOctet = parseInt10(parts[i]);
        if (parsedOctet < 0 || !isUInt(parsedOctet, 0, 255) ||
            (parts[i].length !== 1 && parts[i].indexOf('0') === 0)) {
            return;
        }
    }
    return address;
}

// return an integer representatio of a valid IPv4 address
function IPAddress$IPv4ToInt(address) {
    var res = 0;
    // check that the input is a valid IPv4 address
    if (IPAddress$getValidIPv4(address) === address) {
        var parts = address.split('.');
        res += parseInt10(parts[0]) << 24;
        res += parseInt10(parts[1]) << 16;
        res += parseInt10(parts[2]) << 8;
        res += parseInt10(parts[3]);
        return res;
    }
}

// if the address is valid (IPv6), it will return it in expanded form, else the return value will be undefined
function IPAddress$getValidIPv6(address) {
    debug$assertValidString(address);
    // string doesn't match the most general REGEX for IPv6 addresses
    if (!isString(address) || !address.match(IPv6_REGEX)) {
        return;
    }

    // deal with address that has the last two hextets in IPv4 form
    var parts =  address.split(':');
    if (parts[parts.length - 1].indexOf('.') !== -1) {
        var converted = IPAddress$dottedQuadNotation(parts[parts.length - 1]);
        var tmp = parts.pop();
        parts.push(converted[0]);
        parts.push(converted[1]);
        address = parts.join(':');
    }

    // deal with compressed notation for '0000' hextets
    // there can be only one occurence of '::'
    var splitDoubleColon = address.split('::');
    if (splitDoubleColon.length > 2 ||
        (splitDoubleColon.length === 1 && parts.length !== 8)) {
        return;
    }

    var ipArr;
    // expand compressed hextets
    if (splitDoubleColon.length > 1) {
        ipArr = IPAddress$expandZeros(splitDoubleColon);
    } else {
        ipArr = parts;
    }

    // not enough hextets
    var numHextets = ipArr.length;
    if (numHextets !== 8) {
        return;
    }

    // values should be withing [0, 65535]
    while (numHextets--) {
        var hexVal = parseInt(ipArr[numHextets], 16);
        if (!isUInt(hexVal, 0, MAX_UINT16)) {
            return;
        }
    }

    // address was fully expanded to the colon notation
    return ipArr.join(':');
}


// helper to deal with IPv4 address inside an IPv6 address
function IPAddress$dottedQuadNotation(ipv4part) {
    var ipv4 = IPAddress$IPv4ToInt(ipv4part);

    // convert to unsigned int
    var bits = ipv4 >>> 0;

    // take IPv4 bits and stuff them in two hextets
    var hextets = [];
    hextets.push(((bits >>> 16) & 0xffff).toString(16));
    hextets.push((bits & 0xffff).toString(16));

    return hextets;
}

// Helper to expand zero-hextets ('0000')
function IPAddress$expandZeros(toExpand) {
    var left = toExpand[0].split(':');
    var right = toExpand[1].split(':');

    if (left.length === 1 && left[0] === '') {
        left = [];
    }
    if (right.length === 1 && right[0] === '') {
        right = [];
    }

    var gap = 8 - (left.length + right.length);

    if (gap < 1) {
        return [];
    }

    var i;
    for (i=0; i<gap; i++) {
        left.push('0');
    }

    for (i=0; i<right.length; i++) {
        left.push(right[i]);
    }

    return left;
}

function IPAddress$isInSameSubnet(addr_a, addr_b, bitmaskSize) {
    // one or both of the addresses are not valid IPv6 or IPv4
    var a_ipv4 = IPAddress$getValidIPv4(addr_a);
    var a_ipv6 = IPAddress$getValidIPv6(addr_a);
    var b_ipv4 = IPAddress$getValidIPv4(addr_b);
    var b_ipv6 = IPAddress$getValidIPv6(addr_b);

    if ((!a_ipv4 && !a_ipv6) || (!b_ipv4 && !b_ipv6)) {
        return false;
    }

    // if addresses are not the same type, subnet checking does not make sense
    if ((a_ipv4  && !b_ipv4) || (a_ipv6 && !b_ipv6)) {
        return false;
    }

    // for IPv4 just use a 32-bit mask
    if (addr_a === a_ipv4) {
        var bitmask = IPAddress$createIpv4Mask(bitmaskSize);

        if ((IPAddress$IPv4ToInt(addr_a) & bitmask) !== (IPAddress$IPv4ToInt(addr_b) & bitmask)) {
            return false;
        }
        return true;
    } else if (addr_a === a_ipv6) {
        // for IPv6 compare string hextets and individual bits (for mask with a partial last hextet)

        addr_a = addr_a.split(':');
        addr_b = addr_b.split(':');
        var hextetsToCompare = Math$floor(bitmaskSize/IPAddress$PADDING.length);

        // compare as many full hextets as possible
        while (hextetsToCompare--) {
            if (addr_a[hextetsToCompare] !== addr_b[hextetsToCompare]) {
                return false;
            }
        }

        // compare last hextet that only has some bits set
        var bits = bitmaskSize%IPAddress$PADDING.length;
        if (bits !== 0) {
            var bits_a = parseInt(addr_a[hextetsToCompare], 16).toString(2);
            var bits_b = parseInt(addr_b[hextetsToCompare], 16).toString(2);
            bits_a = IPAddress$PADDING.substring(0, IPAddress$PADDING.length - bits_a.length) + bits_a;
            bits_b = IPAddress$PADDING.substring(0, IPAddress$PADDING.length - bits_b.length) + bits_b;

            for (var j=0; j<bits; j++) {
                if (bits_a[j] !== bits_b[j]) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}

// create a IPv4 subnet mask based on a number of bits
function IPAddress$createIpv4Mask(maskSize) {
    return -1<<(32-maskSize);
}



// -- common/RecurringTimer.js
/**
* @constructor
*/
function RecurringTimer(timeoutMilliseconds, handler) {
    var _timerId;

    this.setTimer = _setTimer;
    this.clearTimer = _clearTimer;

    function _setTimer() {
        if (!_timerId) {
            _timerId = setInterval(handler, timeoutMilliseconds);
        }
    }

    function _clearTimer() {
        if (_timerId) {
            clearInterval(_timerId);
            _timerId = undefined;
        }
    }
}


// -- common/Collections.js
var buckets = {};
(function collections() {
    'use strict';

    /**
     * Default function to compare element order.
     * @function
     * @private
     */
    buckets.defaultCompare = function defaultCompare(a, b) {
        if (a < b) {
            return -1;
        }
        if (a === b) {
            return 0;
        }
        return 1;
    };
    /**
     * Default function to test equality.
     * @function
     * @private
     */
    buckets.defaultEquals = function defaultEquals(a, b) {
        return a === b;
    };

    /**
     * Default function to convert an object to a string.
     * @function
     * @private
     */
    buckets.defaultToString = function defaultToString(item) {
        if (item === null) {
            return 'BUCKETS_NULL';
        }
        if (buckets.isUndefined(item)) {
            return 'BUCKETS_UNDEFINED';
        }
        if (buckets.isString(item)) {
            return item;
        }
        return item.toString();
    };

    /**
     * Checks if the given argument is a function.
     * @function
     * @private
     */
    buckets.isFunction = function isFunction(func) {
        return (typeof func) === 'function';
    };

    /**
     * Checks if the given argument is undefined.
     * @function
     * @private
     */
    buckets.isUndefined = function isUndefined(obj) {
        return (obj === undefined);
    };

    /**
     * Checks if the given argument is a string.
     * @function
     * @private
     */
    buckets.isString = function isString(obj) {
        return Object.prototype.toString.call(obj) === '[object String]';
    };

    /**
     * Reverses a compare function.
     * @function
     * @private
     */
    buckets.reverseCompareFunction = function reverseCompareFunction(compareFunction) {
        if (!buckets.isFunction(compareFunction)) {
            return function(a, b) {
                if (a < b) {
                    return 1;
                }
                if (a === b) {
                    return 0;
                }
                return -1;
            };
        }
        return function(d, v) {
            return compareFunction(d, v) * -1;
        };

    };

    /**
     * Returns an equal function given a compare function.
     * @function
     * @private
     */
    buckets.compareToEquals = function compareToEquals(compareFunction) {
        return function(a, b) {
            return compareFunction(a, b) === 0;
        };
    };

    /**
     * Creates an empty Linked List.
     * @class A linked list is a data structure consisting of a group of nodes
     * which together represent a sequence.
     * @constructor
     */
    buckets.LinkedList = function() {

        /**
         * First node in the list
         * @type {Object}
         * @private
         */
        this.firstNode = null;

        /**
         * Last node in the list
         * @type {Object}
         * @private
         */
        this.lastNode = null;

        /**
         * Number of elements in the list
         * @type {number}
         * @private
         */
        this.nElements = 0;
    };


    /**
     * Adds an element to this list.
     * @param {Object} item Element to be added.
     * @param {number=} index Optional index to add the element. If no index is specified
     * the element is added to the end of this list.
     * @return {boolean} True if the element was added or false if the index is invalid
     * or if the element is undefined.
     */
    buckets.LinkedList.prototype.add = function add(item, index) {
        if (buckets.isUndefined(index)) {
            index = this.nElements;
        }
        if (index < 0 || index > this.nElements || buckets.isUndefined(item)) {
            return false;
        }
        var newNode = this.createNode(item);
        if (this.nElements === 0) {
            // First node in the list.
            this.firstNode = newNode;
            this.lastNode = newNode;
        } else if (index === this.nElements) {
            // Insert at the end.
            this.lastNode.next = newNode;
            this.lastNode = newNode;
        } else if (index === 0) {
            // Change first node.
            newNode.next = this.firstNode;
            this.firstNode = newNode;
        } else {
            var prev = this.nodeAtIndex(index - 1);
            newNode.next = prev.next;
            prev.next = newNode;
        }
        this.nElements++;
        return true;
    };

    /**
     * Returns the first element in this list.
     * @return {*} The first element of the list or undefined if the list is
     * empty.
     */
    buckets.LinkedList.prototype.first = function first() {
        if (this.firstNode !== null) {
            return this.firstNode.element;
        }
        return undefined;
    };

    /**
     * Returns the last element in this list.
     * @return {*} The last element in the list or undefined if the list is
     * empty.
     */
    buckets.LinkedList.prototype.last = function last() {
        if (this.lastNode !== null) {
            return this.lastNode.element;
        }
        return undefined;
    };


    /**
     * Returns the element at the specified position in this list.
     * @param {number} index Desired index.
     * @return {*} The element at the given index or undefined if the index is
     * out of bounds.
     */
    buckets.LinkedList.prototype.elementAtIndex = function elementAtIndex(index) {

        var node = this.nodeAtIndex(index);
        if (node === null) {
            return undefined;
        }
        return node.element;
    };

    /**
     * Returns the index of the first occurrence of the
     * specified element, or -1 if the List does not contain this element.
     * <p>If the elements inside this list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * var petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item Element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction Optional
     * function used to check if two elements are equal.
     * @return {number} The index in this list of the first occurrence
     * of the specified element, or -1 if this list does not contain the
     * element.
     */
    buckets.LinkedList.prototype.indexOf = function indexOf(item, equalsFunction) {

        var equalsF = equalsFunction || buckets.defaultEquals;
        if (buckets.isUndefined(item)) {
            return -1;
        }
        var currentNode = this.firstNode;
        var index = 0;
        while (currentNode !== null) {
            if (equalsF(currentNode.element, item)) {
                return index;
            }
            index++;
            currentNode = currentNode.next;
        }
        return -1;
    };

    /**
     * Returns true if this list contains the specified element.
     * <p>If the elements inside the list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * var petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item Element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction Optional
     * function used to check if two elements are equal.
     * @return {boolean} True if this list contains the specified element, false
     * otherwise.
     */
    buckets.LinkedList.prototype.contains = function contains(item, equalsFunction) {
        return (this.indexOf(item, equalsFunction) >= 0);
    };

    /**
     * Removes the first occurrence of the specified element in this list.
     * <p>If the elements inside the list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * var petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item Element to be removed from this list, if present.
     * @return {boolean} True if the list contained the specified element.
     */
    buckets.LinkedList.prototype.remove = function remove(item, equalsFunction) {
        var equalsF = equalsFunction || buckets.defaultEquals;
        if (this.nElements < 1 || buckets.isUndefined(item)) {
            return false;
        }
        var previous = null;
        var currentNode = this.firstNode;
        while (currentNode !== null) {

            if (equalsF(currentNode.element, item)) {

                if (currentNode === this.firstNode) {
                    this.firstNode = this.firstNode.next;
                    if (currentNode === this.lastNode) {
                        this.lastNode = null;
                    }
                } else if (currentNode === this.lastNode) {
                    this.lastNode = previous;
                    previous.next = currentNode.next;
                    currentNode.next = null;
                } else {
                    previous.next = currentNode.next;
                    currentNode.next = null;
                }
                this.nElements--;
                return true;
            }
            previous = currentNode;
            currentNode = currentNode.next;
        }
        return false;
    };

    /**
     * Removes all the elements from this list.
     */
    buckets.LinkedList.prototype.clear = function clear() {
        this.firstNode = null;
        this.lastNode = null;
        this.nElements = 0;
    };

    /**
     * Returns true if this list is equal to the given list.
     * Two lists are equal if they have the same elements in the same order.
     * @param {Object} other The other list.
     * @param {function(Object,Object):boolean=} equalsFunction Optional
     * function to check if two elements are equal. If the elements in the lists
     * are custom objects you should provide a function, otherwise
     * the === operator is used to check equality between elements.
     * @return {boolean} true if this list is equal to the given list.
     */
    buckets.LinkedList.prototype.equals = function equals(other, equalsFunction) {
        var eqF = equalsFunction || buckets.defaultEquals;
        if (!(other instanceof buckets.LinkedList)) {
            return false;
        }
        if (this.size() !== other.size()) {
            return false;
        }
        return this.equalsAux(this.firstNode, other.firstNode, eqF);
    };

    /**
     * @private
     */
    buckets.LinkedList.prototype.equalsAux = function equalsAux(n1, n2, eqF) {
        while (n1 !== null) {
            if (!eqF(n1.element, n2.element)) {
                return false;
            }
            n1 = n1.next;
            n2 = n2.next;
        }
        return true;
    };

    /**
     * Removes the element at the specified position in this list.
     * @param {number} index Given index.
     * @return {*} Removed element or undefined if the index is out of bounds.
     */
    buckets.LinkedList.prototype.removeElementAtIndex = function removeElementAtIndex(index) {

        if (index < 0 || index >= this.nElements) {
            return undefined;
        }
        var element;
        if (this.nElements === 1) {
            //First node in the list.
            element = this.firstNode.element;
            this.firstNode = null;
            this.lastNode = null;
        } else {
            var previous = this.nodeAtIndex(index - 1);
            if (previous === null) {
                element = this.firstNode.element;
                this.firstNode = this.firstNode.next;
            } else if (previous.next === this.lastNode) {
                element = this.lastNode.element;
                this.lastNode = previous;
            }
            if (previous !== null) {
                element = previous.next.element;
                previous.next = previous.next.next;
            }
        }
        this.nElements--;
        return element;
    };

    /**
     * Executes the provided function once per  element present in this list in order.
     * @param {function(Object):*} callback Function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false inside the callback.
     */
    buckets.LinkedList.prototype.forEach = function forEach(callback) {
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            if (callback(currentNode.element) === false) {
                break;
            }
            currentNode = currentNode.next;
        }
    };

    /**
     * Reverses the order of the elements in this linked list (makes the last
     * element first, and the first element last).
     */
    buckets.LinkedList.prototype.reverse = function reverse() {
        var previous = null;
        var current = this.firstNode;
        var temp = null;
        while (current !== null) {
            temp = current.next;
            current.next = previous;
            previous = current;
            current = temp;
        }
        temp = this.firstNode;
        this.firstNode = this.lastNode;
        this.lastNode = temp;
    };


    /**
     * Returns an array containing all of the elements in this list in proper
     * sequence.
     * @return {Array.<*>} An array containing all of the elements in this list,
     * in proper sequence.
     */
    buckets.LinkedList.prototype.toArray = function toArray() {
        var array = [];
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            array.push(currentNode.element);
            currentNode = currentNode.next;
        }
        return array;
    };
    /**
     * Returns the number of elements in this list.
     * @return {number} the number of elements in this list.
     */
    buckets.LinkedList.prototype.size = function size() {
        return this.nElements;
    };

    /**
     * Returns true if this list contains no elements.
     * @return {boolean} true if this list contains no elements.
     */
    buckets.LinkedList.prototype.isEmpty = function isEmpty() {
        return this.nElements <= 0;
    };

    /**
     * @private
     */
    buckets.LinkedList.prototype.nodeAtIndex = function nodeAtIndex(index) {

        if (index < 0 || index >= this.nElements) {
            return null;
        }
        if (index === (this.nElements - 1)) {
            return this.lastNode;
        }
        var node = this.firstNode;
        for (var i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    };
    /**
     * @private
     */
    buckets.LinkedList.prototype.createNode = function createNode(item) {
        return {
            element: item,
            next: null
        };
    };

    /**
     * Creates an empty queue.
     * @class A queue is a First-In-First-Out (FIFO) data structure, the first
     * element added to the queue will be the first one to be removed. This
     * implementation uses a linked list as a container.
     * @constructor
     */
    buckets.Queue = function () {

        /**
         * List containing the elements.
         * @type Object
         * @private
         */
        this.list = new buckets.LinkedList();
    };
    /**
     * Inserts the specified element into the end of this queue.
     * @param {Object} elem The element to insert.
     * @return {boolean} True if the element was inserted, or false if it is undefined.
     */
    buckets.Queue.prototype.enqueue = function enqueue(elem) {
        return this.list.add(elem);
    };

    /**
     * Retrieves and removes the head of this queue.
     * @return {*} The head of this queue, or undefined if this queue is empty.
     */
    buckets.Queue.prototype.dequeue = function dequeue() {
        if (this.list.size() !== 0) {
            var el = this.list.first();
            this.list.removeElementAtIndex(0);
            return el;
        }
        return undefined;
    };
    /**
     * Retrieves, but does not remove, the head of this queue.
     * @return {*} The head of this queue, or undefined if this queue is empty.
     */
    buckets.Queue.prototype.peek = function peek() {

        if (this.list.size() !== 0) {
            return this.list.first();
        }
        return undefined;
    };

    /**
     * Returns the number of elements in this queue.
     * @return {number} The number of elements in this queue.
     */
    buckets.Queue.prototype.size = function size() {
        return this.list.size();
    };

    /**
     * Returns true if this queue contains the specified element.
     * <p>If the elements inside this stack are
     * not comparable with the === operator, a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * var petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} elem Element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction Optional
     * function to check if two elements are equal.
     * @return {boolean} True if this queue contains the specified element,
     * false otherwise.
     */
    buckets.Queue.prototype.contains = function contains(elem, equalsFunction) {
        return this.list.contains(elem, equalsFunction);
    };

    /**
     * Checks if this queue is empty.
     * @return {boolean} True if and only if this queue contains no items; false
     * otherwise.
     */
    buckets.Queue.prototype.isEmpty = function isEmpty() {
        return this.list.size() <= 0;
    };

    /**
     * Removes all the elements from this queue.
     */
    buckets.Queue.prototype.clear = function clear() {
        this.list.clear();
    };

    /**
     * Executes the provided function once for each element present in this queue in
     * FIFO order.
     * @param {function(Object):*} callback Function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false inside the callback.
     */
    buckets.Queue.prototype.forEach = function forEach(callback) {
        this.list.forEach(callback);
    };
}());


// -- common/logToRemote.js
// debug only log sink, that logs to remove http listener
(DEBUG || DEV) && loadAsync$register(0, function asyncLoadLogRemote(callback) {
    var logToRemoteUrl = config.logToRemoteUrl;
    if (logToRemoteUrl) {
        var flushThrottle = new Throttle(2000);
        var buffer = '';

        log['addSink'](function logToRemoteSink(entry) {
            var level = entry['level'];
            if (level <= config.logToRemoteLevel) {
                buffer += log$entryToString(entry, true, true) + '\n';
                flushThrottle.schedule(flush);
            }
        });

        function flush() {
            if (buffer) {
                var data = buffer;
                buffer = '';

                var xhr = new XMLHttpRequest();
                xhr.open('POST', logToRemoteUrl, true);
                xhr.send(data);
            }
        }
    }
    callback(SUCCESS);
});


/* ----------------- run this code with Node on remote machine --------------------

var http = require('http');
http.createServer(function (request, response) {
    var requestBody = '';

    if (request.method == 'POST') {
        request.on('data', function (data) {
            requestBody += data;
        });
        request.on('end', function () {
            sendResponse();
        });
    } else {
        sendResponse();
    }

    function sendResponse() {
        console.log(requestBody || request.method);
        response.writeHeader(200, {
            'Content-Type': 'text/plain',
            'Access-Control-Allow-Origin': request.headers['origin'],
            'Allow': 'POST, GET, OPTIONS'
        });
        response.end();
    }

}).listen(8889);

----------------- run this code with node on remote machine -------------------- */


// -- common/Protobuf.js
/**
 *  @param {Uint8Array} uInt8Array
 */
function isRemoteAttestationPresentInChallenge(uInt8Array) {

    var signedMessage = extractProtoBuf(uInt8Array),
        type = getProtoFieldValue(signedMessage, 1);

    if (type == 1) {
        if (signedMessage[5] && signedMessage[5].value) {
            return true;
        }
    }
}

/**
 *  @param {Uint8Array} uInt8Array
 */
function isRemoteAttestationPresentInResponse(uInt8Array) {

    var signedMessage = extractProtoBuf(uInt8Array),
        type = getProtoFieldValue(signedMessage, 1);

    if (type == 2) {
        var lic = extractProtoBuf(uInt8Array, signedMessage[2].start, signedMessage[2].value);
        if (getProtoFieldValue(lic, 5)) {
            return true;
        }
    }
}

/**
 * This will decode the Protobuf as per "http://depotsearch.netflix.com/source/xref/stash/DW/widevine-server/dev/server/src/main/jni2/public/protos/license_protocol.proto"
 * @param {Uint8Array} uInt8Array
 * @param {number=} startIndex
 * @param {number=} len
 *
 */
function extractProtoBuf(uInt8Array, startIndex, len) {

    var start = startIndex || 0,
        length = len || uInt8Array.length,
        tag,
        offset = start,
        wireType,
        fieldId,
        fieldInfo,
        msg = {};

    while (offset < start + length) {
        tag = uInt8Array[offset];
        wireType = tag & 7;
        fieldId = tag >> 3;
        fieldInfo = getProtoBytes(uInt8Array, offset);
        if (!fieldInfo.count) {
            throw new Error('Parsing error. bytes length is 0 for the tag ' + tag);
        }

        offset += (fieldInfo.count + 1);
        if (wireType == 2) {
            offset += fieldInfo.value;
        }

        msg[fieldId] = {
            fieldId: fieldId,
            wireType: wireType,
            value: fieldInfo.value, // value if wireType is 0 or length of bytes if wireType is 2
            count: fieldInfo.count,
            start: fieldInfo.start // starting offset of the value or payload bytes
        };
    }

    return msg;
}

/**
 * @param {Uint8Array} uInt8Array
 * @param {number=} offset
 */
function getProtoBytes(uInt8Array, offset) {

    var start = offset + 1,
        len = uInt8Array.length,
        counter = start,
        n = 0,
        fieldInfo = {},
        arr = [],
        val,
        last7,
        value = 0;

    if (start >= len) {
        throw new Error('Invalid Range for Protobuf - ' + 'start: ' + start + ' , len: ' + len);
    }

    while (counter < len) {
        n++;
        val = uInt8Array[counter];
        last7 = val & 0x7F;
        arr.push(last7);

        if (!(val & 0x80)) {
            break;
        }
        counter++;
    }

    debug$assert(arr.length);

    for (var x = arr.length - 1; x >= 0; x--) {
        value = value << 7;
        value = value | arr[x];
    }

    fieldInfo.count = n;
    fieldInfo.value = value;
    fieldInfo.start = offset + n + 1;

    return fieldInfo;
}

/**
 * @param {Object} o
 * @param {number} fieldId
 */
function getProtoFieldValue(o, fieldId) {
    var field;
    if (o) {
        field = o[fieldId];
        if (field) {
            return field.value;
        }
    }
}


// -- common/UserAgentParser.js
/**
* Parses a Browser UserAgent string and provides convenient access to it's products. Does not currently support product comments.
* Expects the UserAgent to conform to http://tools.ietf.org/html/rfc7231#section-5.5.3
* @constructor
* @param {string} userAgent as described by http://tools.ietf.org/html/rfc7231#section-5.5.3
*/
function UserAgentParser(userAgent) {
	this.userAgent = userAgent;
}

/**
* @return {Object<string, string>} An object of products with the product token as the key and the product-version as the value
* Product comments are not returned
*/
UserAgentParser.prototype.getProducts = function () {
	var products = {};
	var productsRegex = /[^\/ ]+\/[^\/ ]+/g;
	var productsMatch = this.userAgent.match(productsRegex);
	
	if (productsMatch) {
		productsMatch.forEach(function (productMatch) {
			var pair = productMatch.split('/');
			products[pair[0]] = pair[1];
		});
	}
	
	return products;
}


// -- dfxp/parseDfxp.js
// parses a dfxp from an JSON representation of the dfxp xml
//
// inputs:
//    arg1: json representation of DFXP XML
//    arg2: aspect ratio of the video or the target render area, region margins will be adjusted accordingly
//    arg3: styleDefaultsRaw (for example {'charColor': 'red'}) style defaults (applied BEFORE dfxp)
//    arg4: styleOverridesRaw (for example {'charColor': 'red'}) user style overrides (applied AFTER dfxp)
//    arg5: callback 
//
// Calls back with either {success: true, entries: [...]), or {success:false}
// entries is an array of non-overlapping time-slices that look like following:
//
// entry = {
//   id: unique slice identifier,
//   startTime: time in milliseconds,
//   endTime: time in milliseconds,
//   blocks: [block, block, block, ...]
// }
// block = {
//   id: unique block identifier,
//   region: {
//     id: unique region id, 
//     horizontalAlignment: left|center|right,
//     verticalAlignment: top|center|bottom,
//     marginTop: 0.0 - 1.0 portion of container height,
//     marginLeft: 0.0 - 1.0 portion of container width,
//     marginBottom: 0.0 - 1.0 portion of container height,
//     marginRight: 0.0 - 1.0 portion of container width
//   },
//   textNodes: [textNode, textNode, textNode, ...]
// }
// textNode = {
//   text: string text, can be empty
//   lineBreaks: number of leading line breaks before this node
//   style: {
//      characterStyle: MONOSPACED_SERIF, PROPORTIONAL_SERIF, MONOSPACED_SANS_SERIF, PROPORTIONAL_SANS_SERIF, CASUAL, CURSIVE, SMALL_CAPITALS,
//      characterSize: 0.0 - 1.0 portion of container height,
//      characterColor: #ff0011,
//      characterOpacity: 0.0 - 1.0,
//      characterEdgeAttributes: NONE, RAISED, DEPRESSED, UNIFORM, DROP_SHADOW,
//      characterEdgeColor: #ff0011,
//      characterEdgeWidth: number in pixels (should be respected only for UNIFORM), 
//      characterEdgeBlur: number in pixels (should be respected only for UNIFORM),
//      characterItalic: true|false,
//      characterUnderline: true|false,
//      backgroundColor: #ff0011,
//      backgroundOpacity: 0.0 - 1.0,
//      windowColor: #ff0011,
//      windowOpacity: 0.0 - 1.0,
//   }
// }
//

var parseDfxp = (function () {
    var _idCounter = 1;

    var alignment$CENTER = 'center',
        alignment$TOP = 'top',
        alignment$LEFT = 'left',
        alignment$RIGHT = 'right',
        alignment$BOTTOM = 'bottom',
        VERTICAL_ALIGNMENT_MAP = {
            'before': alignment$TOP,
            'center': alignment$CENTER,
            'after': alignment$BOTTOM
        },
        HORIZONTAL_ALIGNMENT_MAP = {
            'left': alignment$LEFT,
            'start': alignment$LEFT,
            'center': alignment$CENTER,
            'right': alignment$RIGHT,
            'end': alignment$RIGHT
        },
        SIMPLESDH_REGION = {
            'id': _idCounter++,
            'verticalAlignment': alignment$BOTTOM,
            'horizontalAlignment': alignment$CENTER,
            'marginTop': .1,
            'marginLeft': .1,
            'marginRight': .1,
            'marginBottom': .1
        },
        DEFAULT_REGION = {
            'id': _idCounter++,
            'verticalAlignment': alignment$TOP,
            'horizontalAlignment': alignment$LEFT,
            'marginTop': 0,
            'marginLeft': 0,
            'marginRight': 0,
            'marginBottom': 0
        },
        INLINE_STYLE_ATTRIBUTE_KEYS = [
            'fontFamily',
            'fontSize',
            'fontStyle',
            'textDecoration',
            'color',
            'opacity',
            'backgroundColor',
            'textOutline'
        ],
        STYLE_ATTRIBUTE_KEYS = INLINE_STYLE_ATTRIBUTE_KEYS.concat([
            'style',
            'region'
        ]),
        REGION_ATTRIBUTE_KEYS = [
            'region',
            'textAlign',
            'displayAlign',
            'extent',
            'origin'
        ];

    var _time = /^([0-9]+):([0-9]+):([0-9.]+)$/,
        _isBR = /^br$/i,
        _isFontSize = /^[0-9]{1,3}%$/,
        _minFontSize = 25,
        _maxFontSize = 200,
        _startsWithDigit = /^[0-9]/,
        _maxPixelSize = 100;

    function _parseColor(colorRaw) {
        // sanitize the color to '#aaff11' hex format
        if (isValidString(colorRaw)) {
            var color = colorRaw.toLowerCase();
            if (color[0] == '#') {
                if (color.length == 7) {
                    // return unchanged
                    return color;
                }
                if (color.length == 4) {
                    // parse #fff
                    return '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
                }
            }
            return parseDfxp$colorMapping[color];
        }
    }

    function _parseOpacity(opacityRaw) {
        return _parseMappedFloat(opacityRaw, parseDfxp$opacityMapping, 1);
    };

    function _parseCharacterSize(sizeRaw) {
        return _parseMappedFloat(sizeRaw, parseDfxp$sizeMapping, 2);
    };

    function _parseMappedFloat(raw, map, max) {
        var f = map[raw];
        if (!(f >= 0)) {
            f = parseFloat(raw);
        }
        if (f >= 0) {
            return Math$min(f, max);
        }
    }

    function _parseTime(s, tickRate) {
        var sLength = s.length;
        var lastChar = s[sLength - 1];
        // Note: " | 0" is fast way to do Math.floor
        if (lastChar === 't') {
            // ends with "......t"
            return (parseFloat(s) * tickRate) | 0;
        } else if (lastChar === 's') {
            if (s[sLength - 2] === 'm') {
                // ends with "......ms"
                return parseFloat(s) | 0;
            } else {
                // ends with "......s"
                return (parseFloat(s) * MILLISECONDS_PER_SECOND) | 0;
            }
        }
        var matches;
        matches = s.match(_time);
        if (matches && matches.length >= 4) {
            return ((parseInt(matches[1], 10) * 3600 + parseInt(matches[2], 10) * 60 + parseFloat(matches[3])) * MILLISECONDS_PER_SECOND) | 0;
        };
        throw new Error('dfxp-badtime');
    };

    function _cascadeAttributes(attributes, baseStyleAttributes, namedStyles, namedRegionStyles, keys) {
        var styleAttributes;
        if (attributes) {
            var styleName = attributes['style'],
                namedStyle = styleName ? namedStyles[styleName] : undefined,
                regionName = attributes['region'],
                namedRegion = regionName ? namedRegionStyles[regionName] : undefined;

            var keysLength = keys.length,
                i = keysLength,
                k,
                v,
                j,
                jk,
                jv;

            for (i = 0; i < keysLength; i++) {
                k = keys[i];
                v = attributes[k];
                if (v === undefined && namedStyle) {
                    v = namedStyle[k];
                }
                if (v === undefined && namedRegion) {
                    v = namedRegion[k];
                }
                if (v !== undefined && v !== baseStyleAttributes[k]) {
                    // make a copy only if we need to overwrite something
                    if (!styleAttributes) {
                        // shallowCopy relevant attributes from baseStyleAttributes
                        // do this in line for speed sake
                        styleAttributes = {};
                        for (j = 0; j < keysLength; j++) {
                            jk = keys[j];
                            jv = baseStyleAttributes[jk];
                            if (jv !== undefined) {
                                styleAttributes[jk] = jv;
                            }
                        }
                    }
                    styleAttributes[k] = v;
                }
            }
        }
        return styleAttributes || baseStyleAttributes;
    };

    function _cascadeStyleAttributes(attributes, baseStyleAttributes, namedStyles, namedRegionStyles) {
        return _cascadeAttributes(attributes, baseStyleAttributes, namedStyles, namedRegionStyles, STYLE_ATTRIBUTE_KEYS);
    };

    function _cascadeRegionAttributes(attributes, baseStyleAttributes, namedStyles, namedRegionStyles) {
        return _cascadeAttributes(attributes, baseStyleAttributes, namedStyles, namedRegionStyles, REGION_ATTRIBUTE_KEYS);
    };

    function _parseTextNodes(pNode, stylePrototype, namedStylePrototypes, commonStyleAttributes, namedStyles, namedRegionStyles, styleDefaults, styleOverrides, baseFontSize) {
        var textNodes = [],
            lineBreaks = 0;

        function pushNodesRec(node, baseStyleAttributes, baseStyleHasInlineStyles) {
            var styleAttributes = node[xml$ATTRIBUTES];

            // start out with a pre-made style for named style / region combination
            var styleName = styleAttributes['style'] || baseStyleAttributes['style'] || '';
            var regionName = styleAttributes['region'] || baseStyleAttributes['region'] || '';
            var prototoypeName;
            var style;
            if (styleName || regionName) {
                prototoypeName = styleName + '/' + regionName;
                style = namedStylePrototypes[prototoypeName]
            } else {
                style = stylePrototype;
            }

            // create and cache a style for named style + named region
            // we will most likely use it again
            // it's important to ignore in-line styles for this, so don't use baseStyleAttributes
            if (!style) {
                style = stylePrototype;
                var prototypedStyleAttribtues;
                // first make a style for named style
                prototypedStyleAttribtues = shallowCopy(commonStyleAttributes);
                mixIn(prototypedStyleAttribtues, namedStyles[styleName]);
                style = _buildPrototypedStyle(style, prototypedStyleAttribtues, styleDefaults, styleOverrides, baseFontSize);
                namedStylePrototypes[styleName + '/'] = style;
                if (regionName) {
                    // if there is a region, make one for style + region
                    mixIn(prototypedStyleAttribtues, namedRegionStyles[regionName]);
                    mixIn(prototypedStyleAttribtues, namedStyles[styleName]);
                    style = _buildPrototypedStyle(style, prototypedStyleAttribtues, styleDefaults, styleOverrides, baseFontSize);
                    namedStylePrototypes[prototoypeName] = style;
                }
            }

            // if there are in-line styles, create a derivative style using the current style as it's prototype
            // if there are no in-line styles, shortcircuit and just use the prorotype (this is a very common scenario)
            var hasInlineStyles = baseStyleHasInlineStyles || _hasInlineStyle(styleAttributes);
            if (hasInlineStyles) {
                styleAttributes = _cascadeStyleAttributes(styleAttributes, baseStyleAttributes, namedStyles, namedRegionStyles);
                style = _buildPrototypedStyle(style, styleAttributes, styleDefaults, styleOverrides, baseFontSize);
            }

            var children = node[xml$CHILDREN];
            var childrenLength = children && children.length;
            for (var i = 0; i < childrenLength; i++) {
                var child = children[i];
                if (!isObject(child)) {
                    textNodes.push({
                        'text': child,
                        'lineBreaks': lineBreaks,
                        'style': style
                    });
                    lineBreaks = 0;
                } else if (_isBR.test(child[xml$NAME])) {
                    lineBreaks++;
                } else {
                    pushNodesRec(child, styleAttributes, hasInlineStyles);
                }
            }
        };
        pushNodesRec(pNode, commonStyleAttributes, false);

        if (lineBreaks > 0) {
            // make sure to capture "last" <br /> if there is one, using prorotype style is ok for this one
            textNodes.push({
                'text': '',
                'lineBreaks': lineBreaks,
                'style': stylePrototype
            });
        }

        return textNodes;
    };

    function _applyRegionAttributes(region, aspectDiff, displayAlign, textAlign, origin, extent, cellResolution, cachedOriginAndExtent) {
        var a, s;

        if (displayAlign) {
            s = VERTICAL_ALIGNMENT_MAP[displayAlign] || alignment$TOP;
            if (region['verticalAlignment'] !== s) {
                region['verticalAlignment'] = s;
            }
        }

        if (textAlign) {
            s = HORIZONTAL_ALIGNMENT_MAP[textAlign] || alignment$LEFT;
            if (region['horizontalAlignment'] !== s) {
                region['horizontalAlignment'] = s
            }
        }

        var marginLeft;
        var marginTop;
        var cachedOrigin;
        if (origin) {
            cachedOrigin = cachedOriginAndExtent[origin];
            if (!cachedOrigin) {
                a = origin.split(' ');
                marginLeft = (_parseMargin(a[0], cellResolution.x) || 0);
                marginTop = (_parseMargin(a[1], cellResolution.y) || 0);
                cachedOrigin = {
                    entryCount: 0,
                    marginLeft: marginLeft,
                    marginTop: marginTop,
                    adjustedMarginLeft: marginLeft * aspectDiff.hScale + aspectDiff.hMargin,
                    adjustedMarginTop: marginTop * aspectDiff.vScale + aspectDiff.vMargin
                };
                if (cachedOriginAndExtent.entryCount < 30) {
                    // guard against caching to many
                    cachedOriginAndExtent.entryCount++;
                    cachedOriginAndExtent[origin] = cachedOrigin;
                }
            } else {
                marginLeft = cachedOrigin.marginLeft;
                marginTop = cachedOrigin.marginTop;
            }

            region['marginLeft'] = cachedOrigin.adjustedMarginLeft;
            region['marginTop'] = cachedOrigin.adjustedMarginTop;
        } else {
            marginLeft = 0;
            marginTop = 0;
            cachedOrigin = cachedOriginAndExtent['default'];
            if (!cachedOrigin) {
                cachedOriginAndExtent['default'] = cachedOrigin = {
                    entryCount: 0
                };
            }
        }

        if (extent) {
            var cachedExtent = cachedOrigin[extent];
            if (!cachedExtent) {
                a = extent.split(' ');
                cachedExtent = {
                    adjustedMarginRight: (1 - (marginLeft + (_parseMargin(a[0], cellResolution.x) || 0))) * aspectDiff.hScale + aspectDiff.hMargin,
                    adjustedMarginBottom: (1 - (marginTop + (_parseMargin(a[1], cellResolution.y) || 0))) * aspectDiff.vScale + aspectDiff.vMargin
                };
                if (cachedOrigin.entryCount < 30) {
                    // guard against caching to many
                    cachedOrigin.entryCount++;
                    cachedOrigin[extent] = cachedExtent;
                }
            };

            region['marginRight'] = cachedExtent.adjustedMarginRight;
            region['marginBottom'] = cachedExtent.adjustedMarginBottom;
        }
    };

    function _buildNamedRegion(styleAttribtues, aspectDiff, defaultRegion, cellResolution, cachedExtents) {
        var displayAlign = styleAttribtues['displayAlign'],
            textAlign = styleAttribtues['textAlign'],
            origin = styleAttribtues['origin'],
            extent = styleAttribtues['extent'];

        var region = shallowCopy(defaultRegion);
        _applyRegionAttributes(region, aspectDiff, displayAlign, textAlign, origin, extent, cellResolution, cachedExtents);
        region['id'] = _idCounter++;
        return region;
    };

    function _buildStyle(attributes, styleDefaults, styleOverrides, baseFontSize) {
        var fontScaler = _parseCharacterSize(styleOverrides['characterSize'] || styleDefaults['characterSize']) || 1;  // font scaler for defaults or overrides
        fontScaler *= _parseFontSize(attributes['fontSize']) / 100 || 1;  // font scaler for dfxp is in %

        var textOutline = attributes['textOutline']; // as defined in the spec: (none | <color>? <length> <length>?)
        var outlineWidth;
        var outlineBlur;
        var outlineColor;
        if (textOutline && textOutline != 'none') {
            var a = textOutline.split(' ');
            var oulineWidthIndex;
            if (_startsWithDigit.test(a)) {
                oulineWidthIndex = 0;
                outlineColor = attributes['color'];
            } else {
                oulineWidthIndex = 1;
                outlineColor = _parseColor(a[0]);
            }
            outlineWidth = _parsePixelSize(a[oulineWidthIndex]);
            outlineBlur = _parsePixelSize(a[oulineWidthIndex + 1]);
        }

        // TODO: better handling for opacity, dfxp spec defines a single opacity for whole thing

        return {
            'characterStyle':
                styleOverrides['characterStyle'] ||
                parseDfxp$styleMapping[attributes['fontFamily']] ||
                styleDefaults['characterStyle'],
            'characterSize': fontScaler * baseFontSize,
            'characterColor': _parseColor(
                styleOverrides['characterColor'] ||
                attributes['color'] ||
                styleDefaults['characterColor']),
            'characterOpacity': _parseOpacity(coalesce(
                styleOverrides['characterOpacity'],
                attributes['opacity'],
                styleDefaults['characterOpacity'])),

            'characterEdgeAttributes':
                styleOverrides['characterEdgeAttributes'] ||
                (textOutline && (
                    textOutline === 'none' ? parseDfxp$characterEdgeType$NONE :
                    outlineBlur ? parseDfxp$characterEdgeType$DROP_SHADOW :
                    parseDfxp$characterEdgeType$UNIFORM)
                ) ||
                styleDefaults['characterEdgeAttributes'],
            'characterEdgeColor': _parseColor(
                styleOverrides['characterEdgeColor'] ||
                outlineColor ||
                styleDefaults['characterEdgeColor']),
            'characterEdgeWidth': outlineWidth,
            'characterEdgeBlur': outlineBlur,

            'characterItalic': attributes['fontStyle'] === 'italic',
            'characterUnderline': attributes['textDecoration'] === 'underline',

            'backgroundColor': _parseColor(
                styleOverrides['backgroundColor'] ||
                attributes['backgroundColor'] ||
                styleDefaults['backgroundColor']),
            'backgroundOpacity': _parseOpacity(coalesce(
                styleOverrides['backgroundOpacity'],
                attributes['opacity'],
                styleDefaults['backgroundOpacity']))
        };
    };

    function _hasInlineStyle(attributes) {
        var i = INLINE_STYLE_ATTRIBUTE_KEYS.length;
        while (i--) {
            if (attributes[INLINE_STYLE_ATTRIBUTE_KEYS[i]] !== undefined) {
                return true;
            }
        }
    };

    function _buildPrototypedStyle(stylePrototype, attributes, styleDefaults, styleOverrides, baseFontSize) {
        var styleDerivative = _buildStyle(attributes, styleDefaults, styleOverrides, baseFontSize);
        // let's see if we can use the stylePrototype directly
        var style;
        enumerateOwnProperties(styleDerivative, function (k, v) {
            if (v !== stylePrototype[k]) {
                // copy only properties that are different from prototype
                if (!style) {
                    style = Object$create(stylePrototype);
                }
                style[k] = v;
            }
        });

        // if we didn't create a derivative style, use the prototype
        return style || stylePrototype;
    };

    function _buildRegion(pNode, baseStyleAttributes, namedStyles, namedRegions, namedRegionStyles, aspectDiff, defaultRegion, cellResolution, cachedOriginAndExtent) {
        var region,
            inlineAttributes = pNode[xml$ATTRIBUTES],
            cascadedAttributes = _cascadeRegionAttributes(pNode[xml$ATTRIBUTES], baseStyleAttributes, namedStyles, namedRegionStyles),
            regionName = cascadedAttributes['region'],
            displayAlign = inlineAttributes['displayAlign'], // inherited: NO
            textAlign = cascadedAttributes['textAlign'], // inherited: YES
            origin = inlineAttributes['origin'], // inherited: NO
            extent = inlineAttributes['extent']; // inherited: NO

        if (regionName || displayAlign || textAlign || origin || extent) {
            // if there is ANY region property defined, assume extended profile
            region = namedRegions[regionName];

            if (region) {
                region = Object$create(region);
            } else {
                if (displayAlign || origin || extent) {
                    // anonymous regions, inherit the default region
                    // anonymous regions are not mutually exclusive,
                    // so we must increment the regionId
                    region = Object$create(DEFAULT_REGION);
                    region['id'] = _idCounter++;
                } else {
                    // textAlign only case, is mutually exclusive,
                    // so don't increment the regionId
                    region = Object$create(SIMPLESDH_REGION);
                }
            }

            // mixIn other attributes, if there are any
            _applyRegionAttributes(region, aspectDiff, displayAlign, textAlign, origin, extent, cellResolution, cachedOriginAndExtent);
        } else {
            // otherwise, use the simple sdh (bottom/center) one
            region = SIMPLESDH_REGION;
        }

        return region;
    };

    function _parseFontSize(fontSize) {
        if (fontSize) {
            if (_isFontSize.test(fontSize)) {
                return Number$clamp(parseInt10(fontSize), _minFontSize, _maxFontSize);
            }
        }
    };

    function _parsePixelSize(pixelSize) {
        var size = parseInt10(pixelSize);
        return isUInt(size, 0, _maxPixelSize) ? size : 0;
    };

    function _parseMargin(margin, cellCount) {
        var lastChar = margin[margin.length - 1];
        if (lastChar === '%') {
            return Number$clamp(parseFloat(margin) * 0.01, 0, 1);
        }
        if (lastChar === 'c') {
            return Number$clamp(parseInt10(margin) / cellCount, 0, 1);
        }
    };

    function _getEarliestEndTime(blocks) {
        var i = blocks.length;
        var endTime = blocks[--i]['endTime'];
        while (i--) {
            endTime = Math$min(blocks[i]['endTime'], endTime);
        }
        return endTime;
    };

    function _updateColorAttributes(attributes) {
        enumerateOwnProperties(attributes, function (k, v) {
            if (k.toLowerCase().indexOf('color') >= 0) {
                attributes[k] = _parseColor(v);
            }
        });
    }

    /**
    * How much to scale and add extra margin to convert from local aspect to the video (or rendered area) aspect.
    */
    function _parseAspectDiff(dfxpAttributes, videoAspectRaw) {
        var aspectExtent = dfxpAttributes['extent'],
            aspectPixelAspectRatio = dfxpAttributes['pixelAspectRatio'],
            a,
            a2,
            w,
            h;

        var ret = {
            hMargin: 0,
            hScale: 1,
            vMargin: 0,
            vScale: 1
        };

        if (aspectExtent) {
            // if there is aspectExtent, take it into account

            a = aspectExtent.split(' ');
            if (a.length >= 2) {
                a2 = (aspectPixelAspectRatio || '').split(' ');
                w = parseFloat(a[0]) * (parseFloat(a2[0]) || 1);
                h = parseFloat(a[1]) * (parseFloat(a2[1]) || 1);
            }

            var aspect = (w > 0 && h > 0) ? (w / h) : (1280 / 720);
            var videoAspect = videoAspectRaw || (1280 / 720);
            var scale = aspect / videoAspect;

            // be resilient, if we end up with bad number or small difference don't do anything
            if (Math$abs(videoAspect - aspect) > 0.01) {

                if (videoAspect >= aspect) {
                    // scale the width, and add margins from left and right
                    //    _________________________
                    //   |     |             |     |
                    //   |     |             |     |
                    //   |     |             |     |
                    //   |<--->|             |<--->|
                    //   |     |             |     |
                    //   |     |             |     |
                    //   |_____|_____________|_____|
                    //
                    ret.hMargin = (1 - scale) / 2;
                    ret.hScale = scale;
                } else {
                    // scale the height, and add margins from top and bottom
                    //    _________________________
                    //   |                         |
                    //   |_________________________|
                    //   |                         |
                    //   |                         |
                    //   |                         |
                    //   |                         |
                    //   |_________________________|
                    //   |                         |
                    //   |_________________________|
                    //
                    // TODO: calculate the right margin and scale for this scenario (this scenario isn't yet used)
                    debug$assert(false, 'not implemented');
                }

            }
        }

        return ret;

    };

    function _parseCellResolution(dfxpAttributes, videoAspect) {
        var a,
            cellResolution = dfxpAttributes['cellResolution'];

        if (cellResolution) {
            a = cellResolution.split(' ');
            if (a.length >= 2) {
                var x = parseInt10(a[0]);
                var y = parseInt10(a[1]);
                if (x > 0 && y > 0) {
                    return { x: x, y: y };
                }
            }
        }

        var extent = dfxpAttributes['extent'],
            xPixel,
            yPixel;
        if (extent) {
            a = extent.split(' ');
            if (a.length >= 2) {
                var xExtent = parseInt10(a[0]);
                var yExtent = parseInt10(a[1]);

                var pixelAspectRatio = dfxpAttributes['pixelAspectRatio'];
                if (pixelAspectRatio) {
                    a = pixelAspectRatio.split(' ');
                    xPixel = parseInt10(a[0]);
                    yPixel = parseInt10(a[1]);
                }

                if (xExtent && yExtent) {
                    var rootContainerAspectRatio = (xExtent * (xPixel || 1)) / (yExtent * (yPixel || 1));
                    if (rootContainerAspectRatio > 1.5) {
                        return parseDfxp$cellResolution$52x19;  // 16:9
                    }

                    return parseDfxp$cellResolution$40x19; // 4:3
                }
            }
        }

        if (videoAspect > 1.5) {
            return parseDfxp$cellResolution$52x19;  // 16:9
        }

        return parseDfxp$cellResolution$40x19; // 4:3
    };

    return function parseDfxp(dfxpObj, videoAspect, styleDefaultsRaw, styleOverridesRaw, callback) {
        var returnValue = {
            abort: function parseDfxp_abort() {
                timeoutId && clearTimeout(timeoutId);
            }
        };

        try {
            var dfxpAttributes = dfxpObj[xml$ATTRIBUTES],
                tickRate = MILLISECONDS_PER_SECOND / (parseInt10(dfxpAttributes['tickRate']) || 1),
                // the spec defines the default font to fit in the cell, 
                // but for sake of backwards compatability, unless cells are defined explicitly
                // we will default to a size that we have in simplesdh profiles
                aspectDiff = _parseAspectDiff(dfxpAttributes, videoAspect),
                defaultRegion = mixIn(DEFAULT_REGION, {
                    'marginLeft': aspectDiff.hMargin,
                    'marginTop': aspectDiff.vMargin,
                    'marginRight': aspectDiff.hMargin,
                    'marginBottom': aspectDiff.vMargin
                }),
                namedStyles = {},
                namedRegionStyles = {},
                namedRegions = {},
                attributes,
                styleAttributes,
                styleNode,
                head = dfxpObj['head'],
                body = dfxpObj['body'],
                cellResolution = _parseCellResolution(dfxpAttributes, videoAspect),
                baseFontSize = (1 / cellResolution.y) * aspectDiff.vScale;

            var styleDefaults = mixIn({
                'characterStyle': 'PROPORTIONAL_SANS_SERIF',
                'characterColor': '#EBEB64',
                'characterEdgeAttributes': parseDfxp$characterEdgeType$DROP_SHADOW,
                'characterEdgeColor': '#000000',
                'characterSize': 1.0
            }, styleDefaultsRaw, { onlyIfDefined: true });

            var styleOverrides = styleOverridesRaw || {};

            var cachedOriginAndExtent = {
                entryCount: 0
            };

            if (head) {
                var stylingNode = head['styling'];
                if (stylingNode) {
                    styleNode = stylingNode['style'];
                    while (styleNode) {
                        attributes = styleNode[xml$ATTRIBUTES];
                        _updateColorAttributes(attributes);
                        namedStyles[attributes['id']] = attributes;
                        styleNode = styleNode[xml$SIBLING];
                    }
                }

                var layoutNode = head['layout'];
                if (layoutNode) {
                    var regionNode = layoutNode['region'];
                    while (regionNode) {
                        attributes = regionNode[xml$ATTRIBUTES];
                        var regionName = attributes['id'];

                        // parse the style attribtues for the region
                        // ... referenced style
                        styleAttributes = shallowCopy(namedStyles[attributes['style']]);
                        // ... styles in attributes
                        styleAttributes = mixIn(styleAttributes, attributes);
                        // ... styles in <style> chidlren nodes
                        styleNode = regionNode['style'];
                        while (styleNode) {
                            mixIn(styleAttributes, styleNode[xml$ATTRIBUTES]);
                            styleNode = styleNode[xml$SIBLING];
                        }

                        _updateColorAttributes(styleAttributes);

                        namedRegionStyles[regionName] = styleAttributes;

                        namedRegions[regionName] = _buildNamedRegion(styleAttributes, aspectDiff, defaultRegion, cellResolution, cachedOriginAndExtent);
                        regionNode = regionNode[xml$SIBLING];
                    }
                }
            }

            var divNode = body['div'],
                pNode = divNode['p'],
                blocks = [];

            // pick up body and div style attributes for all nodes
            var commonStyleAttributes = {};
            commonStyleAttributes = _cascadeStyleAttributes(body[xml$ATTRIBUTES], commonStyleAttributes, namedStyles, namedRegionStyles);
            commonStyleAttributes = _cascadeStyleAttributes(divNode[xml$ATTRIBUTES], commonStyleAttributes, namedStyles, namedRegionStyles);

            // pick up body and div region attributes for all nodes
            var commonRegionAttributes = {};
            commonRegionAttributes = _cascadeRegionAttributes(body[xml$ATTRIBUTES], commonRegionAttributes, namedStyles, namedRegionStyles);
            commonRegionAttributes = _cascadeRegionAttributes(divNode[xml$ATTRIBUTES], commonRegionAttributes, namedStyles, namedRegionStyles);

            // build a style prototype which ALL nodes will share
            var stylePrototype = _buildStyle(commonStyleAttributes, styleDefaults, styleOverrides, baseFontSize);
            // add the properties which are always the same and are not parsed via _buildStyle
            mixIn(stylePrototype, {
                'windowColor': _parseColor(
                   styleOverrides['windowColor'] ||
                   styleDefaults['windowColor']),

                'windowOpacity': _parseOpacity(coalesce(
                    styleOverrides['windowOpacity'],
                    styleDefaults['windowOpacity'])),

                'cellResolution': cellResolution
            }, { onlyIfDefined: true });

            // there will be common styles made for style+region excluding in-line styles and cached here
            var namedStylePrototypes = {};

            // help garbage collector collect <p> nodes as we process them
            // all we need to do is severe the link between <div> and it's children <p> list,  
            // and as we walk over <p>-s as a linked list, we automagically drop references to ones we passed
            // NOTE: this DOES DESTROY the original data structure
            divNode['p'] = undefined;
            divNode[xml$CHILDREN] = [];
        }
        catch (exception) {
            doCallback({
                errorSubCode: ErrorSubCodes.FORMAT_DFXP,
                errorDetails: exceptionToString(exception)
            });
            return;
        }

        var lastDispatch = Date$now();
        var timeoutId;
        timeoutId = setTimeout(process, 1);
        function process() {
            // go over the linked list of <p>-s, and convert them to blocks
            try {
                var now;
                while (pNode) {
                    attributes = pNode[xml$ATTRIBUTES];
                    blocks.push({
                        'id': (_idCounter++),
                        'startTime': _parseTime(attributes['begin'], tickRate),
                        'endTime': _parseTime(attributes['end'], tickRate),
                        'region': _buildRegion(pNode, commonRegionAttributes, namedStyles, namedRegions, namedRegionStyles, aspectDiff, defaultRegion, cellResolution, cachedOriginAndExtent),
                        'textNodes': _parseTextNodes(pNode, stylePrototype, namedStylePrototypes, commonStyleAttributes, namedStyles, namedRegionStyles, styleDefaults, styleOverrides, baseFontSize)
                    });
                    pNode = pNode[xml$SIBLING];
                    now = Date$now();
                    if (now - lastDispatch > 100) {
                        lastDispatch = Date.now();
                        timeoutId = setTimeout(process, 1);
                        return;
                    }
                }
            }
            catch (exception) {
                doCallback({
                    errorSubCode: ErrorSubCodes.FORMAT_DFXP,
                    errorDetails: exceptionToString(exception)
                });
                return;
            }
            timeoutId = setTimeout(wrapup, 1);
        };

        function wrapup() {
            try {
                // now let's convert blocks to entries where each entry can have multiple blocks
                if (!blocks.length) {
                    // no blocks means no entries
                    doCallback({
                        success: true,
                        entries: []
                    });
                    return;
                }

                // blocks.sort is actually much slower than doing it this way...
                arraySortByProperty(blocks, 'startTime');

                var entries = [],
                    entryBlocks = [],
                    nextBlock = blocks[0],
                    earliestEndTime,
                    time = blocks[0]['startTime'],
                    i,
                    j;

                i = 1;

                function pushEntry(startTime, endTime) {
                    var block,
                        blocks = [],
                        map = {},
                        regionId;

                    // remove the overlapping regions
                    var i = entryBlocks.length;
                    while (i--) {
                        block = entryBlocks[i];
                        regionId = block['region']['id'];
                        if (!map[regionId]) {
                            map[regionId] = 1;
                            blocks.unshift(block);
                        }
                    }

                    // did we end-up with an entry identical to the last one?
                    var lastEntry = entries[entries.length - 1];
                    if (lastEntry && lastEntry['endTime'] == startTime && compareArrays(lastEntry['blocks'], blocks)) {
                        lastEntry['endTime'] = endTime;
                    } else {
                        entries.push({
                            'id': (_idCounter++),
                            'startTime': startTime,
                            'endTime': endTime,
                            'blocks': blocks
                        });
                    }
                };

                while (entryBlocks.length || nextBlock) {
                    // make sure we have at least one block, 
                    // and push all the subsequent blocks that start at current time
                    while (!entryBlocks.length || (nextBlock && nextBlock['startTime'] == time)) {
                        entryBlocks.push(nextBlock);
                        time = nextBlock['startTime'];
                        nextBlock = blocks[i++];
                    }

                    earliestEndTime = _getEarliestEndTime(entryBlocks);
                    if (!nextBlock || earliestEndTime <= nextBlock['startTime']) {
                        // one of active blocks ends before next once starts, make an entry
                        pushEntry(time, earliestEndTime);
                        time = earliestEndTime;
                        j = entryBlocks.length;
                        while (j--) {
                            if (entryBlocks[j]['endTime'] <= time) {
                                entryBlocks.splice(j, 1);
                            }
                        }
                    } else {
                        // there is a next block, and it starts before any of the active ones end
                        pushEntry(time, nextBlock['startTime']);
                        time = nextBlock['startTime'];
                        entryBlocks.push(nextBlock);
                        nextBlock = blocks[i++];
                    }
                }

                i = entries.length;
                while (i--) {
                    entries[i]['index'] = i;
                    entries[i]['previous'] = entries[i - 1];
                    entries[i]['next'] = entries[i + 1];
                }
            }
            catch (exception) {
                doCallback({
                    errorSubCode: ErrorSubCodes.FORMAT_DFXP,
                    errorDetails: exceptionToString(exception)
                });
                return;
            }

            doCallback({
                success: true,
                entries: entries
            });
        };

        function doCallback(result) {
            setTimeout(function parseDfxp_callTheCallback() {
                // kill the closure
                returnValue.abort = NOOP;
                // actuall call the callback
                callback(result);
            }, 1);
        };

        return returnValue;
    };

})();

var parseDfxp$styleMapping = {
    'default': 'PROPORTIONAL_SANS_SERIF',
    'monospaceSansSerif': 'MONOSPACED_SANS_SERIF',
    'monospaceSerif': 'MONOSPACED_SERIF',
    'proportionalSansSerif': 'PROPORTIONAL_SANS_SERIF',
    'proportionalSerif': 'PROPORTIONAL_SERIF',
    'casual': 'CASUAL',
    'cursive': 'CURSIVE',
    'smallCapitals': 'SMALL_CAPITALS',

    // not what we have, but dfxp also defines...
    'monospace': 'MONOSPACED_SANS_SERIF',
    'sansSerif': 'PROPORTIONAL_SANS_SERIF',
    'serif': 'PROPORTIONAL_SERIF'
};

var parseDfxp$sizeMapping = {
    'SMALL': 0.5,
    'MEDIUM': 1.0,
    'LARGE': 2.0
};

var parseDfxp$opacityMapping = {
    'NONE': 0.0,
    'SEMI_TRANSPARENT': 0.5,
    'OPAQUE': 1.0
};

var parseDfxp$colorMapping = {
    'black': '#000000',
    'silver': '#c0c0c0',
    'gray': '#808080',
    'white': '#ffffff',
    'maroon': '#800000',
    'red': '#ff0000',
    'purple': '#800080',
    'fuchsia': '#ff00ff',
    'magenta': '#ff00ff',
    'green': '#00ff00',
    'lime': '#00ff00',
    'olive': '#808000',
    'yellow': '#ffff00',
    'navy': '#000080',
    'blue': '#0000ff',
    'teal': '#008080',
    'aqua': '#00ffff',
    'cyan': '#00ffff',
    'orange': '#ffa500',
    'pink': '#ffc0cb'
};

var parseDfxp$characterEdgeType$NONE = 'NONE',
    parseDfxp$characterEdgeType$RAISED = 'RAISED',
    parseDfxp$characterEdgeType$DEPRESSED = 'DEPRESSED',
    parseDfxp$characterEdgeType$UNIFORM = 'UNIFORM',
    parseDfxp$characterEdgeType$DROP_SHADOW = 'DROP_SHADOW';

var parseDfxp$cellResolution$40x19 = { x: 40, y: 19 },
    parseDfxp$cellResolution$52x19 = { x: 52, y: 19 };



// -- dfxp/parseDfxpXml.js
function parseDfxpXml(xml, videoAspect, styleDefaultsRaw, styleOverridesRaw, callback) {
    xml2js(xml, function (result) {
        if (result.success) {
            var dfxpObject = result.object;
            parseDfxp(dfxpObject, videoAspect, styleDefaultsRaw, styleOverridesRaw, function (result) {
                if (result.success) {
                    callback({
                        success: true,
                        entries: result.entries
                    });
                } else {
                    callback(result);
                }
            });
        } else {
            callback(result);
        }
    });
};


// -- dfxp/TimedTextTimer.js
/**
* @constructor
*/
function TimedTextTimer() {
    var _self = this,
        _updatedForMediaTime,
        _timerIsActive,
        _activeEntry,
        _nextEntry,
        _timeoutId,
        _entries,
        _duration,
        _timeToIndex;

    // --------------------------------------------------------------------------------
    // -- public exports

    mixIn(_self,
    /** @lends {TimedTextTimer.prototype} */
    {
        // sets the list of entries parsed via parseDfxp
        setEntries: _setEntries,

        // should be set before calling start, returns pts in milliseconds
        getMediaTime: undefined,

        // start the timer or force sync with media time
        // should be called when playback starts or resumes
        start: _start,

        // stop the timer, should be called when paused or when playback ends
        stop: _stop,

        // returns the entry to be displayed, might be undefined if nothing should be displayed
        getActiveEntry: _getActiveEntry,

        // called when this.activeEntry is changed
        onactiveentryupdated: undefined
    });


    // --------------------------------------------------------------------------------
    // -- private implementation

    function _setEntries(entries) {
        var entriesLength = entries && entries.length;
        _updatedForMediaTime = undefined;
        _activeEntry = undefined;
        _nextEntry = undefined;
        _entries = entries;
        _duration = entriesLength && Math$max.apply(null, entries.map(function(entry) { return entry['endTime']; }));
        _timeToIndex = entriesLength && (entriesLength / _duration);
        _update();
    };

    function _start() {
        _timerIsActive = true;
        _update();
    };

    function _stop() {
        _timerIsActive = false;
        _stopTimer();
    };

    function _getActiveEntry() {
        _update(true);
        return _activeEntry;
    };

    /**
    * @param {boolean=} supressUpdateEvent
    */
    function _update(supressUpdateEvent) {
        var mediaTime = _self.getMediaTime();
        if (_updatedForMediaTime == mediaTime) return;

        var activeEntry;
        var nextEntry;

        // let's make nextEntry be either the active one, or the one to be activated next

        // if we are past last time, don't do anything
        if (mediaTime < _duration) {
            // start with the latest known "lastEntry" or try to ballpark where we might be
            // TODO: would be nice to do a binary search here
            nextEntry = _nextEntry || _entries[Math$floor(mediaTime * _timeToIndex)] || _entries[0];
        }

        if (nextEntry) {
            // go right, untill we find an entry that ends in future
            while (nextEntry && nextEntry['endTime'] < mediaTime) {
                nextEntry = nextEntry['next'];
            }

            // go left, untill the one before this one has ended 
            // in other words, this one is the "current" or "next"
            while (nextEntry && nextEntry['previous'] && nextEntry['previous']['endTime'] >= mediaTime) {
                nextEntry = nextEntry['previous'];
            }
        }

        if (nextEntry) {
            if (nextEntry['startTime'] <= mediaTime && mediaTime <= nextEntry['endTime']) {
                // show the entry, and set a timer to hide it when we reach it's end time
                activeEntry = nextEntry;
                _updateLater(nextEntry['endTime'] - mediaTime);
            } else {
                // hide the entry, and set a timer to show the next one
                _updateLater(nextEntry['startTime'] - mediaTime);
            }
        }

        // remember the next entry, so we minimize the time we spend walking the stack
        _nextEntry = nextEntry;
        _updatedForMediaTime = mediaTime;
        if (_activeEntry != activeEntry) {
            _activeEntry = activeEntry;
            (!supressUpdateEvent && _self.onactiveentryupdated) && _self.onactiveentryupdated();
        }
    };

    function _updateLater(ms) {
        _stopTimer();
        if (_timerIsActive && ms > 0) {
            // wait a little more than told to, so we pass the given threshold for sure
            // also to deal with mediaTime progressing tiny bit slower than real time 
            _timeoutId = setTimeout(_onTimeout, ms + TimedTextTimer$NEGLIGIBLE_TIME);
        }
    };

    function _onTimeout() {
        _timeoutId = undefined;
        _update();
    };

    function _stopTimer() {
        if (_timeoutId) {
            clearTimeout(_timeoutId);
            _timeoutId = undefined;
        }
    };

};

var TimedTextTimer$NEGLIGIBLE_TIME = 10;


// -- dfxp/entry2html.js

// Note: entry2html is depricated, TimedTextHtmlPresenter should be used instead
/**
* @param {number=} scale
*/
function entry2html$getBlockInnerHTML(block, containerSize, fontFamilyMap, fontSizeInfoMap, scale) {
    var contentHtml = '';
    block['textNodes'].forEach(function (textNode) {
        contentHtml += entry2html$textNode2html(textNode, fontFamilyMap, containerSize, fontSizeInfoMap, scale);
    });
    return contentHtml;
};

function entry2html$getWindowInnerHTML(blocks, rectList, windowSizeInPixels, windowColor, containerSize) {
    var windowHTML = '',
        containerWidth = containerSize.width,
        containerHeight = containerSize.height,
        i = rectList.length;

    while (i--) {
        var rect = rectList[i],
            block = blocks[i],
            region = block && block['region'],
            style = 'position:absolute;background:' + windowColor + ';' +
                'width:' + Math$round(rect.width + (windowSizeInPixels * 2)) + "px;" +
                'height:' + Math$round(rect.height + (windowSizeInPixels * 2)) + "px;";

        var positionStyle = entry2html$getPositionStyle(region, rect, containerWidth, containerHeight, windowSizeInPixels);
        enumerateOwnProperties(positionStyle, function (k, v) {
            style += k + ':' + v + ';';
        });

        windowHTML += '<div style="' + style + '"></div>';
    }

    return windowHTML;
};

function entry2html$getPositionStyle(region, rect, containerWidth, containerHeight, borderSizeInPixels) {
    var style = {};

    if (region['horizontalAlignment'] == 'right') {
        // glue to right side, for better debounced resizing
        style['right'] = ((containerWidth - rect.left - rect.width - borderSizeInPixels) * 100 / containerWidth) + '%';
    } else {
        style['left'] = ((rect.left - borderSizeInPixels) * 100 / containerWidth) + '%';
    }
    if (region['verticalAlignment'] == 'bottom') {
        // glue to bottom, for better debounced resizing
        style['bottom'] = ((containerHeight - rect.top - rect.height - borderSizeInPixels) * 100 / containerHeight) + '%';
    } else {
        style['top'] = ((rect.top - borderSizeInPixels) * 100 / containerHeight) + '%';
    }

    return style;
};

function entry2html$calculateLineHeight(fontSizeInfo, cellResolution) {
    if (fontSizeInfo && cellResolution) {
        var targetAspectRatio;
        if (cellResolution.x === 40 && cellResolution.y === 19) {
            targetAspectRatio = (4 / 3) / (40 / 19);
        } else if (cellResolution.x === 52 && cellResolution.y === 19) {
            targetAspectRatio = (16 / 9) / (52 / 19);
        }

        if (targetAspectRatio) {
            return (fontSizeInfo.width / fontSizeInfo.fontSize) / targetAspectRatio;
        }
    }
};

/**
* @param {number=} scale
*/
function entry2html$textNode2html(textNode, fontFamilyMap, containerSize, fontSizeInfoMap, scale) {
    var text = textNode['text'];
    var style = textNode['style'];

    var html = htmlEncode(textNode['text']);

    var brCount = textNode['lineBreaks'];
    while (brCount--) {
        html = '<br />' + html;
    }

    return entry2html$applyStyle(html, style, fontFamilyMap, containerSize, fontSizeInfoMap, scale);
};

/**
* @param {number=} scale
*/
function entry2html$applyStyle(html, style, fontFamilyMap, containerSize, fontSizeInfoMap, scale) {
    var textNodeFontFamily = style['characterStyle'];
    var fontSizeInfo = fontSizeInfoMap[textNodeFontFamily];
    var isMonospace = textNodeFontFamily.indexOf('MONOSPACE') >= 0;
    var lineHeight = isMonospace ?
        entry2html$calculateLineHeight(fontSizeInfo, style['cellResolution']) || fontSizeInfo.lineHeight :
        fontSizeInfo.lineHeight;

    var fontSizeInPixels = style['characterSize'] * containerSize.height / (lineHeight || 1);
    if (scale > 0) {
        // if we are scaing, we need to floor the font size
        // because we are scaling down to fit the screen
        fontSizeInPixels = Math$floor(fontSizeInPixels * scale);
    } else {
        fontSizeInPixels = Math$round(fontSizeInPixels);
    }

    var css = {
        'font-size': fontSizeInPixels + 'px',
        'line-height': 'normal',
        'font-weight': 'normal',
    };
    if (style['characterItalic']) css['font-style'] = 'italic';
    if (style['characterUnderline']) css['text-decoration'] = 'underline';
    if (style['characterColor']) css['color'] = style['characterColor'];

    if (style['backgroundColor'] && style['backgroundOpacity'] !== 0) {
        css['background-color'] = entry2html$hexToRgba(style['backgroundColor'], style['backgroundOpacity']);
    }

    var characterEdgeAttributes = style['characterEdgeAttributes'];
    var characterEdgeColor = style['characterEdgeColor'] || '#000000';
    switch (characterEdgeAttributes) {
        case parseDfxp$characterEdgeType$DROP_SHADOW:
            css['text-shadow'] = characterEdgeColor + ' 0px 0px 13px';
            break;
        case parseDfxp$characterEdgeType$UNIFORM:
            // TODO: respect characterEdgeWidth and characterEdgeBlur
            css['text-shadow'] = '-1px 0px ' + characterEdgeColor + ',0px 1px ' + characterEdgeColor + ',1px 0px ' + characterEdgeColor + ',0px -1px ' + characterEdgeColor;
            break;
        case parseDfxp$characterEdgeType$RAISED:
            css['text-shadow'] = '-1px -1px white, 0px -1px white, -1px 0px white, 1px 1px black, 0px 1px black, 1px 0px black';
            break;
        case parseDfxp$characterEdgeType$DEPRESSED:
            css['text-shadow'] = '1px 1px white, 0px 1px white, 1px 0px white, -1px -1px black, 0px -1px black, -1px 0px black';
            break;
    }

    var cssText = createCssText(css);

    var characterStyle = style['characterStyle'] || 'PROPORTIONAL_SANS_SERIF';
    var fontFamilyCss = fontFamilyMap[characterStyle];
    if (fontFamilyCss) {
        cssText += ';' + fontFamilyCss;
    }
    var htmlWithStyle = html;

    // build HTML for the node
    var characterOpacity = style['characterOpacity'];
    if (characterOpacity > 0 && characterOpacity < 1) {
        // it's necessary to make a separate element and set it's opacity
        // otherwise you would see the text shadow through the font
        htmlWithStyle = '<span style="opacity:' + characterOpacity + '">' + htmlWithStyle + '</span>';
    }

    htmlWithStyle = '<span style="' + cssText + '">' + htmlWithStyle + '</span>';

    return htmlWithStyle;
};

function entry2html$hexToRgba(hexColor, opacity) {
    opacity = opacity !== undefined ? opacity : 1;
    hexColor = hexColor.substring(1);
    var colorInt = parseInt(hexColor, 16);
    return 'rgba(' + ((colorInt >> 16) & 255) + ',' + ((colorInt >> 8) & 255) + ',' + (colorInt & 255) + ',' + opacity + ')';
};

function entry2html$getBlockStyle(block) {
    var region = block['region'];

    var css = {
        'display': 'block',
        'white-space': 'nowrap'
    };

    switch (region['horizontalAlignment']) {
        case 'left':
            css['text-align'] = 'left';
            break;
        case 'right':
            css['text-align'] = 'right';
            break;
        case 'center':
        default:
            css['text-align'] = 'center';
            break;
    }

    return createCssText(css);
};



// -- dfxp/TimedTextHtmlPresenter.js
/**
* @constructor
*
* Renders entries into a DOM element
*/
function TimedTextHtmlPresenter(fontFamilyMap) {
    var _self = this,
        _elementCss = {
            'position': 'absolute',
            'left': '0',
            'top': '0',
            'right': '0',
            'bottom': '0',
            'display': 'block'
        },
        _element = createElement('DIV', undefined, undefined, { 'class': 'player-timedtext' }),
        _entry,
        _aspect,
        _fontSizeInfo = _getFontSizeInfo(fontFamilyMap),
        _bounds;

    _element['onselectstart'] = function () { return false; };

    // --------------------------------------------------------------------------------
    // -- public exports

    mixIn(_self,
    /** @lends {TimedTextHtmlPresenter.prototype} */
    {

        // returns an element that should be inserted into the DOM in front of the video
        getElement: _getElement,

        // set the aspect ratio of the element, this is typically video aspect ratio
        setAspect: _setAspect,

        // sets the entry to be rendered
        setEntry: _setEntry,

        // should be called when element size is changed
        // called automatically during setEntry
        render: _render,

        //sets the bounds for collision detection
        setTimedTextBounds: _setTimedTextBounds

    });

    // --------------------------------------------------------------------------------
    // -- private implementation
    
    function _setTimedTextBounds(bounds){
        _bounds = bounds;
        _render();
    }

    function _getElement() {
        return _element;
    };

    function _getFontSizeInfo(fontFamilyMap) {
        var fontSizeInfo = {};

        enumerateOwnProperties(fontFamilyMap, function (fontFamily, fontFamilyFonts) {
            var referenceText = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
            var textHeight = 1000;
            fontSizeInfo[fontFamily] = _measureFontSize(referenceText, fontFamilyFonts, textHeight);
        });

        return fontSizeInfo;
    };

    function _setAspect(aspect) {
        _aspect = aspect;
    };

    function _setEntry(entry) {
        _entry = entry;
        _render();
    };

    function _render() {
        var elementParent = _element['parentNode'],
            parentWidth = elementParent && elementParent.clientWidth,
            parentHeight = elementParent && elementParent.clientHeight,
            wMargin = 0,
            hMargin = 0,
            containerSize = {
                width: parentWidth,
                height: parentHeight
            },
            nodeList,
            i;

        if (parentWidth > 0 && parentHeight > 0 && _entry) {

            if (_aspect) {
                // adjust aspect, if there is aspect defined
                containerSize = fitWithAspect(parentWidth, parentHeight, _aspect);
                wMargin = Math$round((parentWidth - containerSize.width) / 2),
                hMargin = Math$round((parentHeight - containerSize.height) / 2);
            }

            var blocks = _entry['blocks'];
            nodeList = blocks && blocks.map(function (block) {
                var innerHTML = entry2html$getBlockInnerHTML(block, containerSize, fontFamilyMap, _fontSizeInfo);
                var style = entry2html$getBlockStyle(block) + ';position:absolute';
                return createElement('div', style, innerHTML, TimedTextHtmlPresenter$DESCENDANT_ATTRIBTUES);
            });
        }

        mixIn(_elementCss, {
            'left': wMargin + 'px',
            'right': wMargin + 'px',
            'top': hMargin + 'px',
            'bottom': hMargin + 'px'
        });

        _element['style']['display'] = 'none';
        _element.innerHTML = '';

        if (nodeList && nodeList.length) {

            var containerWidth = containerSize.width,
                containerHeight = containerSize.height;

            // append the nodes
            nodeList.forEach(function (node) {
                _element['appendChild'](node);
            });

            var cssText = createCssText(_elementCss);

            // trigger re-flow (but no painting)
            _element['style']['cssText'] = cssText + ';visibility:hidden;z-index:-1';

            // now that elements are in the DOM, we can know their dimensions. 
            // and we do need dimensions for "center" positioned elements
            // that's why we calculate top/left here
            var rectList = [];
            var rect;
            var node;
            var block;
            i = nodeList.length;
            while (i--) {
                node = nodeList[i];
                block = blocks[i];
                rect = TimedTextHtmlPresenter$node2rect(node, block, containerWidth, containerHeight);
                if (rect.width > containerWidth) {
                    node.innerHTML = entry2html$getBlockInnerHTML(block, containerSize, fontFamilyMap, _fontSizeInfo, containerWidth / rect.width);
                    rect = TimedTextHtmlPresenter$node2rect(node, block, containerWidth, containerHeight);
                }
                rectList[i] = rect;
            }

            var containerSizeWithBounds = containerSize;
            if(_bounds){    
                containerSizeWithBounds = TimedTextHtmlPresenter$accommodateBounds(containerSize, _bounds, parentHeight, hMargin); 
            } 
            rectList = uncollide(rectList, containerSizeWithBounds);
            
            var firstTextNodeStyle = blocks && blocks[0] && blocks[0]['textNodes'] && blocks[0]['textNodes'][0] && blocks[0]['textNodes'][0]['style'];
            if (firstTextNodeStyle) {
                var windowColor = firstTextNodeStyle['windowColor'];
                var windowOpacity = firstTextNodeStyle['windowOpacity'];

                if (windowColor && windowOpacity > 0) {
                    // TODO: what should the size of the window be???
                    var windowSizeInPixels = Math$round(containerHeight / 50);
                    var windowHTML = entry2html$getWindowInnerHTML(blocks, rectList, windowSizeInPixels, windowColor, containerSize),
                        windowDiv = createElement('div', 'position:absolute;left:0;top:0;right:0;bottom:0;opacity:' + windowOpacity, windowHTML, TimedTextHtmlPresenter$DESCENDANT_ATTRIBTUES);
                    _element.insertBefore(windowDiv, _element.firstChild);
                }
            }

            // hide it, so we don't keep reflowing
            _element['style']['display'] = 'none';

            // properly position the nodes
            i = rectList.length;
            while (i--) {
                rect = rectList[i];

                var nodeStyle = nodeList[i]['style'],
                    region = blocks[i]['region'],
                    positionStyle = entry2html$getPositionStyle(region, rect, containerWidth, containerHeight, 0);

                mixIn(nodeStyle, positionStyle);
            }

            // show the element
            _element['style']['cssText'] = cssText;
        }

    };

    function _measureFontSize(text, fontFamily, fontSizeInPixels) {
        var textStyle = 'display:block;position:fixed;z-index:-1;visibility:hidden;font-size:' + fontSizeInPixels + 'px;' + fontFamily + ';';
        var divElement = createElement('DIV', textStyle, text, TimedTextHtmlPresenter$DESCENDANT_ATTRIBTUES);
        document.body.appendChild(divElement);

        var fontSizeInfo = {
            fontSize: fontSizeInPixels,
            height: divElement.clientHeight,
            width: divElement.clientWidth / text.length,
            lineHeight: divElement.clientHeight / fontSizeInPixels
        };

        document.body.removeChild(divElement);

        return fontSizeInfo;
    };
}

function TimedTextHtmlPresenter$node2rect(node, block, containerWidth, containerHeight) {
    var region = block['region'];

    var marginTop = (region['marginTop'] || 0) * containerHeight,
        marginBottom = (region['marginBottom'] || 0) * containerHeight,
        marginLeft = (region['marginLeft'] || 0) * containerWidth,
        marginRight = (region['marginRight'] || 0) * containerWidth;

    var top,
        left,
        width = node.clientWidth || 1,
        height = node.clientHeight || 1;

    switch (region['verticalAlignment']) {
        case 'top':
            top = marginTop;
            break;
        case 'center':
            top = (marginTop + containerHeight - marginBottom - height) / 2;
            break;
        case 'bottom':
        default:
            top = containerHeight - marginBottom - height;
            break;
    }

    switch (region['horizontalAlignment']) {
        case 'left':
            left = marginLeft;
            break;
        case 'right':
            left = containerWidth - marginRight - width;
            break;
        case 'center':
        default:
            left = (marginLeft + containerWidth - marginRight - width) / 2;
            break;
    }

    return {
        top: top,
        left: left,
        width: width,
        height: height
    };
}

var TimedTextHtmlPresenter$DESCENDANT_ATTRIBTUES = { 'class': 'player-timedtext-text-container' };

function TimedTextHtmlPresenter$accommodateBounds(containerSize, bounds, parentHeight, hMargin) {
    return {
        height: parentHeight - Math$max(hMargin, bounds.bottom | 0) - Math$max(hMargin, bounds.top | 0),
        width: containerSize.width
    }
}



// -- dfxp/uncollide.js
/**
* given a list of rectangles, moves them so they don't overlap
* returns list of rectangles with modified top and left
*/
function uncollide(rectList, containerSize) {
    var adjustedRectList = rectList.map(function (rect) {
        return {
            top: rect.top,
            left: rect.left,
            width: rect.width,
            height: rect.height
        };
    });

    _pushInBounds(adjustedRectList, containerSize);

    //if overlap detected, move each caption half the distance of the overlap away from each other in minimum direction
    for (var i = 0; i < 50; i++) {
        if (!_deoverlap(adjustedRectList, true, containerSize)) {
            break;
        }
    }

    for (var i = 0; i < 50; i++) {
        if (!_deoverlap(adjustedRectList, false, containerSize)) {
            break;
        }
    }

    return adjustedRectList;

    function _pushInBounds(rectList, containerSize) {
        rectList.forEach(function (rect) {
            if (rect.left < 0 && (rect.left + rect.width) < containerSize.width) //if the caption is off the left edge and there's space to move it right, then move it
                rect.left += Math$min(-rect.left, containerSize.width - (rect.left + rect.width));
            else if ((rect.left + rect.width) > containerSize.width && rect.left > 0) //if the caption is off the right edge and there's space to move it left, then move it
                rect.left -= Math$min((rect.left + rect.width) - containerSize.width, rect.left);

            if (rect.top < 0 && (rect.top + rect.height) < containerSize.height) //if the caption is off the top edge and there's space to move it down, then move it
                rect.top += Math$min(-rect.top, containerSize.height - (rect.top + rect.height));
            else if ((rect.top + rect.height) > containerSize.height && rect.top > 0) //if the caption if off the bottom edge and there's space to move it up, then move it
                rect.top -= Math$min((rect.top + rect.height) - containerSize.height, rect.top);
        });
    };

    function _deoverlap(rectList, inShorterDirection, containerSize) {
        if (rectList && rectList.length > 1) {
            var topDelta = [];
            var leftDelta = [];

            for (var i = 0; i < rectList.length; i++) {
                topDelta[i] = 0;
                leftDelta[i] = 0;
            }

            var wasMoved = false;

            var MinDelta = 0.25;
            var MinTolerance = 1;

            for (var i = 0; i < rectList.length; i++) {
                for (var j = i + 1; j < rectList.length; j++) {
                    var overlap = _getOverlap(rectList[i], rectList[j]);
                    if (overlap && overlap.width > MinTolerance && overlap.height > MinTolerance) {
                        //move each caption half the distance of the overlap away from each other in the specified direction
                        var isHorizontalShorter = overlap.width <= overlap.height;
                        var iCenter = _getCenter(rectList[i]);
                        var jCenter = _getCenter(rectList[j]);

                        if ((isHorizontalShorter && inShorterDirection) || (!isHorizontalShorter && !inShorterDirection)) {
                            //move in horizontal direction
                            var xDelta = Math$max(overlap.width / 2, MinDelta); //leave a little overlap to avoid breaks in between neighboring caption backgrounds
                            if (iCenter.x <= jCenter.x) {
                                leftDelta[i] -= xDelta;
                                leftDelta[j] += xDelta;
                            } else {
                                leftDelta[j] -= xDelta;
                                leftDelta[i] += xDelta;
                            }
                        } else if ((isHorizontalShorter && !inShorterDirection) || (!isHorizontalShorter && inShorterDirection)) {
                            //move in vertical direction and maintain order
                            var yDelta = Math$max(overlap.height / 2, MinDelta); //leave a little overlap to avoid breaks in between neighboring caption backgrounds
                            topDelta[i] -= yDelta;
                            topDelta[j] += yDelta;
                        }
                    }
                }
            }

            for (var i = 0; i < rectList.length; i++) {
                //if the proposed movement is some non-negligible amount and it doesn't move the caption off the screen, then move it

                if ((leftDelta[i] < -MinDelta && rectList[i].left + leftDelta[i] >= 0) ||
                    (leftDelta[i] > MinDelta && rectList[i].left + rectList[i].width + leftDelta[i] <= containerSize.width)) {
                    rectList[i].left += leftDelta[i];
                    wasMoved = true;
                }

                if ((topDelta[i] < -MinDelta && rectList[i].top + topDelta[i] >= 0) ||
                    (topDelta[i] > MinDelta && rectList[i].top + rectList[i].height + topDelta[i] <= containerSize.height)) {
                    rectList[i].top += topDelta[i];
                    wasMoved = true;
                }
            }

            return wasMoved;
        }
    };

    function _getCenter(rect) {
        return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
    };

    function _hasOverlap(rectA, rectB) {
        if (rectA.width < 0.0 || rectB.width < 0.0 || (rectB.left > rectA.left + rectA.width || rectB.left + rectB.width < rectA.left) || rectB.top > rectA.top + rectA.height)
            return false;
        else
            return rectB.top + rectB.height >= rectA.top;
    };

    function _getOverlap(rectA, rectB) {
        if (_hasOverlap(rectA, rectB)) {
            var num1 = Math$max(rectA.left, rectB.left);
            var num2 = Math$max(rectA.top, rectB.top);

            return {
                width: Math$max(Math$min(rectA.left + rectA.width, rectB.left + rectB.width) - num1, 0),
                height: Math$max(Math$min(rectA.top + rectA.height, rectB.top + rectB.height) - num2, 0),
                x: num1,
                y: num2
            };
        }
    };
};


// -- player/InitTrackingLog.js
var trackingLog = (function() {
    var _url,
        _enabled,
        _common = 'cat=cadplayback&dev=' + encodeURIComponent(DEVICE_MODEL) + '&ep=' + encodeURIComponent(ESN_PREFIX) + '&ver=' + encodeURIComponent(VERSION) + '&jssid=' + JSSID,
        _log = new log.CategoryLog('TrackingLog');


    _common += "&browserua=" + userAgent;

    loadAsync$register(ErrorCodes.INIT_COMPONENT_TRACKING_LOG, function asyncLoadTrackingLog(callback) {
        _url = config.trackingLogUrl;
        _enabled = config.trackingLogEnabled && config.trackingLogUrl;
        if (_enabled) {
            _common += '&groupName=' + encodeURIComponent(config.groupName) + getPlatformInfo();
            loadAsync(sendStartupLog);
        }
        callback(SUCCESS);
        return;
    });

    function getPlatformInfo() {
        var data = '';
        if (PLATFORM_EXTRA_INFO) {
            var o = mixIn({}, PLATFORM_EXTRA_INFO, {
                prefix: 'pi_'
            });;
            data = '&' + objectToQueryString(o);
        }
        return data;
    }

    function sendStartupLog(result) {
        var sev = 'info',
            str = '';
        if (!result.success) {
            sev = 'error';
            str += '&errorcode=' + (result.errorCode || '');
            str += '&errorsubcode=' + (result.errorSubCode || '');
        }
        str = 'type=startup&sev=' + sev + str;
        _trackingLog(str, _url);
    }

    function _trackingLog(data, url) {

        if (!url) {
            return;
        }
        var body = _common +
            '&jsoffms=' + clock$getTime() +
            '&do=' + navigator['onLine'] +
            '&' + data +
            '&' + objectToQueryString(mixIn({}, loadAsync$milestones, {
                prefix: 'im_'
            }));

        DEBUG && createDebugLog(body);

        http.download({
            url: url,
            postBody: body,
            withCredentials: true,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            diagCaption: 'track'
        }, NOOP);
    }

    function createDebugLog(body) {
        try {
            var logData = body.split('&').reduce(function(acc, tuple) {
                var tokens = tuple.split('=');
                acc[tokens[0]] = tokens[1];
                return acc;
            }, {})
            _log.debug('entry', JSON.stringify(logData, null, '\t'));
        } catch (e) {}
    }

    return _trackingLog;
})();


// -- storage/requestQuota.js
var persistentQuotaSize;

// must be executed before fileSystem
loadAsync$register(ErrorCodes.INIT_COMPONENT_REQUESTQUOTA, function asyncLoadRequestQuota(callback) {
    var _log = new log.CategoryLog('RequestQuota'),
        _minimumSize = config.storageMinimumSize,
        _rerequested;

    if (!(_minimumSize > 0)) {
        // do not need quota if config.storageMinimumSize == 0
        persistentQuotaSize = 0;
        callback(SUCCESS);
        return;
    }

    debug$assert(persistentStorage || storageInfo);

    function doRequestQuota() {
        if (persistentStorage) {
            // Chrome R28+
            persistentStorage['requestQuota'](_minimumSize, onRequestQuotaSuccess, onRequestQuotaError);
        } else {
            // Chrome R27-
            storageInfo['requestQuota'](PERSISTENT, _minimumSize, onRequestQuotaSuccess, onRequestQuotaError);
        }
    };
    doRequestQuota();

    function onRequestQuotaSuccess(grantedQuotaInBytes) {
        DEBUG && _log.debug("Request quota success", { "Requested": _minimumSize, "Granted": grantedQuotaInBytes });
        if (grantedQuotaInBytes >= _minimumSize) {
            persistentQuotaSize = grantedQuotaInBytes;
            callback(SUCCESS);
        } else {
            // try it one more time
            if (!_rerequested) {
                _rerequested = true;
                doRequestQuota();
            } else {
                _log.error('Quota request granted insufficent bytes');
                callback({ errorSubCode: ErrorSubCodes.STORAGE_QUOTA_TO_SMALL });
            }
        }
    };

    function onRequestQuotaError() {
        _log.error('Request quota error');
        callback({ errorSubCode: ErrorSubCodes.STORAGE_QUOTA_NOT_GRANTED });
    };
});


// -- storage/fileSystem.js
var fileSystem;

// must be executed before storage
loadAsync$register(ErrorCodes.INIT_COMPONENT_FILESYSTEM, function asyncLoadFileSystem(callback) {
    var _log = new log.CategoryLog('FileSystem');

    if (config.storageType != 'fs') {
        // don't load file system
        callback(SUCCESS);
        return;
    }

    debug$assert(persistentQuotaSize > 0);

    requestFileSystem(
        PERSISTENT,
        persistentQuotaSize,
        function (fs) {
            fileSystem = fs;
            callback(SUCCESS);
        },
        function () {
            _log.error('Error calling requestFileSystem');
            callback({ errorSubCode: ErrorSubCodes.STORAGE_FS_REQUESTFILESYSTEM });
        }
    );
});

var fileSystem$FLAGS_NONE = {},
    fileSystem$FLAGS_CREATE = { 'create': true },
    fileSystem$FLAGS_CREATE_EXCLUSIVE = { 'create': true, 'exclusive': true };

/**
* Gets the directory entry for give directory name
*/
function fileSystem$getDirectory(directoryName, callback) {
    fileSystem['root']['getDirectory'](
        directoryName,
        fileSystem$FLAGS_CREATE,
        function (dirEntry) {
            callback({
                success: true,
                directory: dirEntry
            });
        },
        function () {
            callback({ errorSubCode: ErrorSubCodes.STORAGE_FS_GETDIRECTORY });
        }
    );
};

/**
* Gets the list of files in given directory.
*/
function fileSystem$getFileNameList(directory, callback) {
    function onError() {
        callback({ errorSubCode: ErrorSubCodes.STORAGE_FS_READENTRIES });
    };

    var reader = directory['createReader']();
    reader['readEntries'](
        function (entries) {
            var fileNameList = [];

            var i = entries.length;
            while (i--) {
                var entry = entries[i];
                if (entry['isFile']) {
                    fileNameList.push(entry['name']);
                }
            }

            callback({
                success: true,
                fileNameList: fileNameList
            });
        },
        onError
    );
};

/**
* Reads and returns entire conten of of the file as text.
*/
function fileSystem$readAllText(directory, fileName, callback) {

    function onError() {
        callback({ errorSubCode: ErrorSubCodes.STORAGE_FS_FILEREAD });
    };

    directory['getFile'](
        fileName,
        fileSystem$FLAGS_NONE,
        function (fileEntry) {
            fileEntry['file'](
                function (file) {
                    var reader = new FileReader();
                    reader['onloadend'] = function () {
                        callback({
                            success: true,
                            text: reader['result'],
                            fileEntry: fileEntry
                        });
                    };
                    reader['onerror'] = onError;
                    reader['readAsText'](file);
                },
                onError
            );
        },
        onError
    );

};

/**
* Reads and returns entire conten of of the file as text.
* @param {boolean=} exclusive
* @param {function(Object)=} callback
*/
function fileSystem$writeAllText(directory, fileNameOrEntry, text, exclusive, callback) {

    function onError() {
        callback && callback({ errorSubCode: ErrorSubCodes.STORAGE_FS_FILEWRITE });
    };

    if (fileNameOrEntry['createWriter']) {
        doWrite(fileNameOrEntry);
    } else {
        directory['getFile'](
            fileNameOrEntry,
            exclusive ? fileSystem$FLAGS_CREATE_EXCLUSIVE : fileSystem$FLAGS_CREATE,
            doWrite,
            onError
        );
    }

    function doWrite(fileEntry) {
        fileEntry['createWriter'](
            function (writer) {
                try {
                    writer['onwriteend'] = function () {
                        writer['onwriteend'] = null;
                        writer['onerror'] = null;
                        writer['truncate'](writer['position']);
                        callback && callback({
                            success: true,
                            fileEntry: fileEntry
                        });
                    };
                    writer['onerror'] = onError;
                    writer['write'](new Blob([text]));
                }
                catch (e) {
                    onError();
                }
            },
            onError
        );
    };
};

/**
* @param {function(Object)=} callback
*/
function fileSystem$remove(directory, fileNameOrEntry, callback) {
    function onError() {
        callback && callback({ errorSubCode: ErrorSubCodes.STORAGE_FS_FILEREMOVE });
    };

    if (fileNameOrEntry['remove']) {
        doRemove(fileNameOrEntry);
    } else {
        directory['getFile'](
            fileNameOrEntry,
            fileSystem$FLAGS_NONE,
            doRemove,
            onError
        );
    }

    function doRemove(fileEntry) {
        fileEntry['remove'](
            function () {
                callback && callback(SUCCESS);
            },
            onError
        );
    };
};


// -- storage/storage-memory.js
function storage$loadMemory(callback) {

    var _log = new log.CategoryLog('Storage'),
        _nameDataPairs = {};

    var storage = {
        load: function (name, callback) {
            if (_nameDataPairs.hasOwnProperty(name)) {
                var data = _nameDataPairs[name];
                DEBUG && _log.debug("Storage entry loaded", { "Name": name }, stringifyJsonPretty(data));
                callback({
                    success: true,
                    data: data,
                    storageToken: name
                });
            } else {
                DEBUG && _log.debug('Storage entry not found', { 'Name': name });
                callback({ errorSubCode: ErrorSubCodes.STORAGE_NODATA });
            }
        },

        save: function (name, data, exclusive, callback) {
            if (exclusive && _nameDataPairs.hasOwnProperty(name)) {
                callback({ success: false });
            } else {
                _nameDataPairs[name] = data;
                DEBUG && _log.debug("Storage entry saved", { "Name": name }, stringifyJsonPretty(data))
                callback && callback({
                    success: true,
                    storageToken: name
                });
            }
        },

        remove: function (nameOrToken, callback) {
            delete _nameDataPairs[nameOrToken];
            DEBUG && _log.debug("Storage entry deleted", { "Name": nameOrToken })
            callback && callback(SUCCESS);
        }
    };

    callback({
        success: true,
        storage: storage
    });

};


// -- storage/storage-fileSystem.js
function storage$loadFileSystem(callback) {
    debug$assert(fileSystem);

    var NAMEDATAPAIRS_DIRNAME = 'netflix.player.namedatapair';

    var _log = new log.CategoryLog('Storage'),
        _nameDataPairsDir,
        _locks = {};

    fileSystem$getDirectory(NAMEDATAPAIRS_DIRNAME, function (result) {
        if (result.success) {
            _nameDataPairsDir = result.directory;
            wrapup();
        } else {
            callback(result);
        }
    });

    function wrapup() {
        wrapup = NOOP;

        var storage = {
            load: function (name, callback) {
                _acquireLock(name, function (lockResult) {
                    fileSystem$readAllText(_nameDataPairsDir, name, function (result) {
                        dispatch(lockResult.releaseLock);
                        if (result.success) {
                            var text = result.text;
                            var data;
                            try {
                                if (text) {
                                    data = JSON.parse(text);
                                }
                            } catch (e) {
                                callback({ errorSubCode: ErrorSubCodes.STORAGE_FS_PARSEJSON });
                                return;
                            }

                            if (data) {
                                DEBUG && _log.debug('Storage entry loaded', { 'Name': name }, stringifyJsonPretty(data))
                                callback({
                                    success: true,
                                    data: data,
                                    storageToken: result.fileEntry
                                });
                            } else {
                                DEBUG && _log.debug('Storage entry not found', { 'Name': name });
                                callback({ errorSubCode: ErrorSubCodes.STORAGE_NODATA });
                            }
                        } else {
                            callback(result);
                        }
                    });
                });
            },

            save: function (nameOrToken, data, exclusive, callback) {
                var name = nameOrToken['name'] || nameOrToken;
                var text = JSON.stringify(data);
                _acquireLock(name, function (lockResult) {
                    fileSystem$writeAllText(_nameDataPairsDir, nameOrToken, text, exclusive, function (result) {
                        dispatch(lockResult.releaseLock);
                        if (result.success) {
                            DEBUG && _log.debug('Storage entry saved', { 'Name': name }, stringifyJsonPretty(data))
                            callback && callback({
                                success: true,
                                storageToken: result.fileEntry
                            });
                        } else {
                            callback && callback(result);
                        }
                    });
                });
            },

            remove: function (nameOrToken, callback) {
                var name = nameOrToken['name'] || nameOrToken;
                _acquireLock(name, function (lockResult) {
                    fileSystem$remove(_nameDataPairsDir, nameOrToken, function (result) {
                        dispatch(lockResult.releaseLock);
                        if (result.success) {
                            DEBUG && _log.debug('Storage entry deleted', { 'Name': name })
                        }
                        callback && callback(result);
                    });
                });
            }
        };

        callback({
            success: true,
            storage: storage
        });
    };

    function _acquireLock(name, callback) {
        var lock = _locks[name] || (_locks[name] = new ReaderWriterLock(name));
        // threat even read locks as write locks, we just want a single lock
        lock.acquireLock(true, callback);
    };
};


// -- storage/storage-indexDB.js
function storage$loadIndexDB(callback) {
    debug$assert(indexedDB);

    var DBNAME = 'netflix.player',
        OBJECTSTORENAME = 'namedatapairs';

    var _log = new log.CategoryLog('Storage'),
        _db;

    debug$assert(config);

    if (config.environmentIsTest) {
        DBNAME += "Test";
    }

    if (!indexedDB) {
        if (indexedDBAccessException) {
            wrapup(ErrorSubCodes.INDEXDB_ACCESS_EXCEPTION, exceptionToString(indexedDBAccessException));
        } else {
            wrapup(ErrorSubCodes.INDEXDB_NOT_SUPPORTED);
        }
        return;
    }

    var openTimeoutMonitor = new TimeoutMonitor(config.storageTimeout, function () {
        wrapup(ErrorSubCodes.INDEXDB_OPEN_TIMEOUT);
    });
    openTimeoutMonitor.ensureTimer();

    loadAsync$notifyMilestone('idbo');
    var openOperation = indexedDB['open'](DBNAME, 1);
    if (!openOperation) {
        wrapup(ErrorSubCodes.INDEXDB_OPEN_NULL);
        return;
    }
    openOperation['onblocked'] = function () {
        wrapup(ErrorSubCodes.INDEXDB_OPEN_BLOCKED);
    };
    openOperation['onupgradeneeded'] = function () {
        loadAsync$notifyMilestone('idbun');
        _db = openOperation['result'];
        _db['createObjectStore'](OBJECTSTORENAME, { 'keyPath': 'name' });
    };
    openOperation['onsuccess'] = function () {
        loadAsync$notifyMilestone('idbs');
        _db = openOperation['result'];
        wrapup();
    };
    openOperation['onerror'] = function () {
        loadAsync$notifyMilestone('idbe');
        var errorDetails = _getOperationErrorDetails(openOperation);
        _log.error('IndexedDB open error', errorDetails);
        wrapup(ErrorSubCodes.INDEXDB_OPEN_ERROR, errorDetails);
    };
    
    /**
     * Test created for Chromecast to count the number of devices in the field
     * that have a corrupted IndexDB Database.
     */
    function _testIndexDB(storage) {
        var testKey = 'indexdb-test';
        var testValue = 'true';
        
        storage.save(testKey, testValue, true, function (event) {
            if (event.success) {
                
                storage.load(testKey, function (result) {
                    if (result.errorSubCode) {
                        _log.error('failed save/load test: error on load', result.errorSubCode)
                    } else if (result.data === testValue) {
                        _log.debug('save/load test passed')
                        storage.remove(testKey);
                    } else {
                        _log.error('failed save/load test: incorrect result')
                    }
                })

            } else {
                _log.error('failed save/load test: error on save', event.errorSubCode)
            }
        });
    }

    /**
    * @param {number=} errorSubCode
    * @param {string=} errorDetails
    */
    function wrapup(errorSubCode, errorDetails) {
        wrapup = NOOP;
        openTimeoutMonitor && openTimeoutMonitor.stopTimer();

        if (errorSubCode) {

            var errorResult = { errorSubCode: errorSubCode };
            if (errorDetails) {
                errorResult.errorDetails = errorDetails;
            }
            callback(errorResult);

        } else {

            var storage = {
                load: function (name, callback) {
                    _executeTransaction('get', false, name,
                        function onsuccess(e) {
                            var result;
                            try {
                                var opResult = e['target']['result'];
                                if (opResult) {
                                    var data = opResult['data'];
                                    DEBUG && _log.debug('Storage entry loaded', { 'Name': name }, stringifyJsonPretty(data));
                                    result = {
                                        success: true,
                                        data: data,
                                        storageToken: name
                                    };
                                } else {
                                    DEBUG && _log.debug('Storage entry not found', { 'Name': name });
                                    result = { 
                                        errorSubCode: ErrorSubCodes.STORAGE_NODATA 
                                    };
                                }
                            }
                            catch (ex) {
                                result = {
                                    errorSubCode: ErrorSubCodes.STORAGE_LOAD_ERROR,
                                    errorDetails: exceptionToString(ex)
                                };
                            }
                            callback(result);
                        },
                        function onerror(errorDetails) {
                            callback({ errorSubCode: ErrorSubCodes.STORAGE_LOAD_ERROR, errorDetails: errorDetails });
                        },
                        function ontimeout() {
                            callback({ errorSubCode: ErrorSubCodes.STORAGE_LOAD_TIMEOUT });
                        }
                    );
                },

                save: function (name, data, exclusive, callback) {
                    _executeTransaction(exclusive ? 'add' : 'put', true, { 'name': name, 'data': data },
                        function onsuccess() {
                            DEBUG && _log.debug('Storage entry saved', { 'Name': name }, stringifyJsonPretty(data));
                            callback && callback({
                                success: true,
                                storageToken: name
                            });
                        },
                        function onerror(errorDetails) {
                            callback && callback({ errorSubCode: ErrorSubCodes.STORAGE_SAVE_ERROR, errorDetails: errorDetails });
                        },
                        function ontimeout() {
                            callback && callback({ errorSubCode: ErrorSubCodes.STORAGE_SAVE_TIMEOUT });
                        }
                    );
                },

                remove: function (nameOrToken, callback) {
                    _executeTransaction('delete', true, nameOrToken,
                        function onsuccess() {
                            DEBUG && _log.debug('Storage entry deleted', { 'Name': nameOrToken })
                            callback && callback(SUCCESS);
                        },
                        function onerror(errorDetails) {
                            callback && callback({ errorSubCode: ErrorSubCodes.STORAGE_DELETE_ERROR, errorDetails: errorDetails });
                        },
                        function ontimeout() {
                            callback && callback({ errorSubCode: ErrorSubCodes.STORAGE_DELETE_TIMEOUT });
                        }
                    );
                }
            };
            
            if (config.testIndexDBForCorruptedDatabase) {
                _testIndexDB(storage);
            }

            callback({
                success: true,
                storage: storage
            });
        }
    };

    /**
    * @param {string} operationName
    * @param {string|Object} arg
    * @param {boolean} isWrite
    * @param {function(Object)} successHandler
    * @param {function(string=)} errorHandler
    * @param {function()} timeoutHandler
    */
    function _executeTransaction(operationName, isWrite, arg, successHandler, errorHandler, timeoutHandler) {
        try {
            var transaction = _db['transaction'](OBJECTSTORENAME, isWrite ? 'readwrite' : 'readonly');
            var objectStore = transaction['objectStore'](OBJECTSTORENAME);
            var operation = objectStore[operationName](arg);
            operation['onsuccess'] = function (e) {
                cleanup();
                successHandler(e);
            };
            operation['onerror'] = function () {
                cleanup();
                errorHandler(_getOperationErrorDetails(operation));
            };
            var timeoutMonitor = new TimeoutMonitor(config.storageTimeout, function () {
                cleanup();
                timeoutHandler();
            });
            timeoutMonitor.ensureTimer();
        }
        catch (e) {
            cleanup();
            errorHandler(exceptionToString(e));
        }

        function cleanup() {
            timeoutMonitor && timeoutMonitor.stopTimer();
            if (operation) {
                operation['onsuccess'] = null;
                operation['onerror'] = null;
            }
        };
    }

    function _getOperationErrorDetails(operation) {
        var error = operation && operation['error'];
        return 'onerror: ' + (error && (error['name'] || ('' + error)));
    }

};


// -- storage/storage-localStorage.js
function storage$loadLocalStorage(callback) {
    callback({
        success: true,
        storage: new LocalStorage(window["localStorage"])
    });
};


// -- storage/storage.js
var storage;

// load storage asynchronously
loadAsync$register(ErrorCodes.INIT_COMPONENT_STORAGE, function asyncLoadStorage(callback) {

    var loadFunction;

    // pick the storage we want to use
    switch (config.storageType) {
        case 'fs':
            loadFunction = storage$loadFileSystem;;
            break;
        case 'idb':
            loadFunction = storage$loadIndexDB;
            break;
        case 'none':
            loadFunction = storage$loadMemory;
            break;
        case 'ls':
            loadFunction = storage$loadLocalStorage;
            break;
    }

    loadFunction(function (result) {
        if (result.success) {
            storage = result.storage;
            callback(SUCCESS);
        } else {
            callback(result);
        }
    });
});


// -- storage/storageLock.js
var storageLock;

// load storage asynchronously
loadAsync$register(ErrorCodes.INIT_COMPONENT_STORAGELOCK, function asyncLoadStorageLock(callback) {
    debug$assert(storage);

    var PREFIX = 'lock-',
        SESSION_LOCK_NAME = 'session';

    var _log = new log.CategoryLog('StorageLock'),
        _locks = {};

    // pick the storage we want to use
    storageLock = {

        acquire: function storageLock_acquire(name, callback) {

            if (!localStorage) {
                if (localStorageAccessException) {
                    callback({
                        errorSubCode: ErrorSubCodes.STORAGE_LOCALSTORAGE_ACCESS_EXCEPTION,
                        errorDetails: exceptionToString(localStorageAccessException)
                    });
                } else {
                    callback({
                        errorSubCode: ErrorSubCodes.STORAGE_NO_LOCALSTORAGE
                    });
                }
                return;
            }

            initLockWorkers();

            var epoch = clock$getEpoch();
            var lockName = PREFIX + name;

            try {
                if (!(lockName in localStorage)) {
                    setLockAndCallbackWithSuccess();
                    return;
                }

                var data = parseInt10(localStorage['getItem'](lockName)),
                    lockEpoch;

                if (isUInt(data)) {
                    lockEpoch = data;
                }

                if (Math$abs(epoch - lockEpoch) * MILLISECONDS_PER_SECOND < config.lockExpiration) {
                    // lock is active
                    callback({ success: false });
                } else {
                    // lock is expired or invalid
                    _log.error('Lock was expired or invalid, ignoring', { 'Epoch': epoch, 'LockEpoch': lockEpoch });
                    setLockAndCallbackWithSuccess();
                }
            } 
            catch (e) {
                _log.error('Error acquiring Lock', e);
                callback({
                    errorSubCode: ErrorSubCodes.EXCEPTION,
                    errorDetails: exceptionToString(e)
                });
            }

            function setLockAndCallbackWithSuccess() {
                localStorage['setItem'](lockName, epoch);
                var lockToken = { lockName: lockName };
                _locks[lockName] = lockToken;
                _log.trace('Lock acquired', { 'Name': lockToken.lockName });
                callback({
                    success: true,
                    lockToken: lockToken
                });
            };
        },

        release: function storageLock_release(lockToken, callback) {
            debug$assert(_locks[lockToken.lockName] == lockToken);
            if (!localStorage) return;

            try {
                localStorage['removeItem'](lockToken.lockName);
                delete _locks[lockToken.lockName];
                _log.trace('Lock released', { 'Name': lockToken.lockName });
            }
            catch (e) {
                _log.error('Unable to release Lock', { 'Name': lockToken.lockName }, e);
            }

            callback && callback(SUCCESS);
        }

        // sessionLockResult: set later

    };

    if (config.enforceSingleSession) {
        storageLock.acquire(SESSION_LOCK_NAME, function (result) {
            // Note: no need to release, all locks will be released automatically (see globalEvents$beforeunload handler)
            storageLock.sessionLockResult = result;
            callback(SUCCESS);
        });
    } else {
        callback(SUCCESS);
    }


    function initLockWorkers() {
        initLockWorkers = NOOP;

        // refresh locks in timer
        var intervalId = setInterval(refreshLocks, config.lockRefresh);

        // when window closes, release all locks
        globalEvents.addListener(globalEvents$beforeunload, function (args) {
            var isPopStateEvent = args && args['isPopStateEvent'];
            if(isPopStateEvent){
                _log.trace('popstate event, Lock timers can stay');
                return;
            }
            enumerateOwnProperties(_locks, function (name, lockToken) {
                localStorage['removeItem'](lockToken.lockName);
            });
            clearInterval(intervalId);
        }, ORDERPROPERTY$early);
    };

    function refreshLocks() {
        var epoch = clock$getEpoch();
        enumerateOwnProperties(_locks, function (name, lockToken) {
            DEBUG && _log.debug('Refreshing Lock', { 'Name': name, 'Epoch': epoch });
            localStorage['setItem'](lockToken.lockName, epoch);
        });
    };

});


// -- storage/logPersist.js
if (DEBUG) {
    (function () {
        var LOGS_DIRNAME = 'netflix.player.logs',
            FLAGS_CREATE = { 'create': true },
            LOG_LEVEL = LogLevel['TRACE'];

        var _writer,
            _memoryEntries = [],
            _pendingWrite = '',
            _writeThrottle = new Throttle(10);

        function _writeHeader() {
            _writeText(log$buildHeader());
        }

        function _writeText(s) {
            _pendingWrite += s;
            _writeThrottle.schedule(_flushPendingWrite);
        };

        function _flushPendingWrite() {
            try{
                _writer['write'](new Blob([_pendingWrite]));
                _pendingWrite = '';
            }
            catch (e) {
                _writeThrottle.schedule(_flushPendingWrite);
            }
        };

        function _formatEntry(entry) {
            return log$entryToString(entry, true, false) + '\n';
        };

        function _memorySink(entry) {
            // "config" not available
            _memoryEntries.push(entry);
        };

        function _writerSink(entry) {
            if (entry['level'] <= LOG_LEVEL) {
                _writeText(_formatEntry(entry));
            }
        };

        log['addSink'](_memorySink);

        loadAsync$register(ErrorCodes.INIT_COMPONENT_LOGPERSIST, function asyncLoadLogPersist(callback) {
            debug$assert(config);
            
            if (!fileSystem) {
                // no filesystem = no log persisting
                log['removeSink'](_memorySink);
                _memoryEntries = undefined;
                callback(SUCCESS);
                return;
            }

            var fileName = JSSID + '.log';

            var createFileSuccess = function (writer) {
                _writer = writer;
                wrapup();
            };

            var failure = function () {
                debug$assert(false);
                wrapup();
            };

            var getFileSuccess = function (fileEntry) {
                fileEntry['createWriter'](createFileSuccess, failure);
            };

            var getDirSuccess = function (dir) {
                if (config.persistLogs) {
                    // get the new log file
                    dir['getFile'](fileName, FLAGS_CREATE, getFileSuccess, failure);
                } else {
                    // delete old logs
                    dir['removeRecursively'](NOOP);
                    wrapup();
                }
            };

            var rootDir = fileSystem['root'];
            rootDir['getDirectory'](LOGS_DIRNAME, FLAGS_CREATE, getDirSuccess, failure);

            function wrapup() {
                log['removeSink'](_memorySink);
                if (_writer) {
                    _writer['seek'](_writer['length']);
                    _writeHeader();
                    for (var i = 0; i < _memoryEntries.length; i++) {
                        _writerSink(_memoryEntries[i]);
                    }
                    _memoryEntries = undefined;
                    log['addSink'](_writerSink);
                }
            };

            // callback immidiately, don't wait for init to complete
            callback(SUCCESS);
        });
    })();
}



// -- crypto/webCrypto.js
MSL && loadAsync$register(ErrorCodes.INIT_COMPONENT_WEBCRYPTO, function asyncLoadWebCrypto(callback) {

    // check if we have WebCrypto
    if (!cryptoSubtle || !cryptoSubtle['generateKey'] || !cryptoSubtle['importKey'] || !cryptoSubtle['unwrapKey']) {
        callback({ errorSubCode: ErrorSubCodes.WEBCRYPTO_MISSING });
        return;
    }

    // if we need key discovery, check for that as well
    if (DEVICEID_VIA_WEBCRYPTO_GETKEYBYNAME || config.authenticationType == AuthenticationType$PSK || config.authenticationType == AuthenticationType$MGK) {
        if (!cryptokeys) {
            callback({ errorSubCode: ErrorSubCodes.WEBCRYPTOKEYS_MISSING });
            return;
        }
    }

    loadAsync$notifyMilestone('wcs');

    // for Chrome, the webCrypto API will be there but might fail to load the IFRAME... we need async call to determine whethere WebCrypto is available
    // use a cheap WebCrypto call to verify that
    op2promise(cryptoSubtle['generateKey']({ 'name': 'AES-CBC', 'length': 128 }, true, ['encrypt', 'decrypt']))['then'](
        function (result) {
            loadAsync$notifyMilestone('wcdone');
            callback(SUCCESS);
        },
        function (e) {
            var errorDetails = '' + e;
            var errorSubCode;
            if (errorDetails.indexOf('missing crypto.subtle') >= 0) {
                // special case when iframe tells us there is no WebCrypto
                errorSubCode = ErrorSubCodes.WEBCRYPTO_MISSING;
            } else if (errorDetails.indexOf('timeout waiting for iframe to load') >= 0) {
                errorSubCode = ErrorSubCodes.WEBCRYPTO_IFRAME_LOAD_ERROR;
            }
            callback({
                errorSubCode: errorSubCode,
                errorDetails: errorDetails
            })
        }
    );
});


// -- config.js
/**
* 1. If property x is dependant on property y, then define x before y in setters. e.g. enableImageSubs is defined before the timedTextProfile.
* 2. If config$apply is called more than once, if we intend to set 'y', which is dependant on property 'x' then both needs to be passed in the argument object.
* 3. apply$config assumes that the properties are being set in the same order as they are defined.
*/

var config;

var config$apply;

/**
* @param {Array|Arguments=} videoSessionArguments
*/
function config$load(videoSessionArguments) {
    var BITRATE_FILTER_REGEX = /^[0-9-+]+$/,
        BOOKMARK_IGNORE_REGEX = /^[0-9]+[%]?$/,
        UNSIGNED_NUMBER_REGEX = /^[0-9]*$/,
        IS_URL_REGEX = /^\S+$/;

    var initParams,
        queryStringInitParams,
        environmentIsTest,
        env,
        enableDDPlus20 = true,
        enableDDPlus = true,
        enableHEVC = false,
        overrideEnableHEVC = false,
        enableHDR = false,
        overrideEnableHDR = false,
        enablePRK = false,
        enableHWDRM = false,
        enableLSSDH = true,
        disableHD = false,
        enableImageSubs = true,
        audioChunkSizeMilliseconds = 16000,
        videoChunkSizeMilliseconds = 4004,
        maxChunkInProgress = 3;

    parseInitParams();

    env = (readString(qsok('env')) || readString(qsok('environment')) || 'prod').toLowerCase();
    // read the player specific "environment" or the "env" that tenfootui uses (env can be test/int for NCCP test, or stg/none for PROD)
    environmentIsTest = (/^test|int$/i).test(env);

    // note: using only "env" moving forward and ignoring legacy "environment"
    if (['prod', 'stg', 'int', 'test'].indexOf(env) == -1) {
        env = 'prod';
    }

    var getEdgeEndpoint = function () {
        switch (env) {
            case 'stg' : return 'https://api-staging.netflix.com/msl/';
            case 'test': return 'https://api.test.netflix.com/msl/';
            case 'int' : return 'https://api-int.test.netflix.com/msl/';
            default    :
            case 'prod': return 'https://api-global.netflix.com/msl/';
        }
    };

    /**
    *
    * @param {...*} arg
    *
    * Returns a function that takes in an optional default value as input param
    */
    var generateSetter = function (fn, arg) {
        var args = slice.call(arguments, 1);
        return function (v) {
            if (isDefined(v)) {
                args[1] = v;
            }
            debug$assert(isFunction(fn));
            return fn.apply(undefined, args);
        };
    };

    config = {};
    var setters =
    /** @lends {config} */
    {
        // --------------------------------------------------------------------------------
        // -- Plastform specific configuration

        // should we used DD plus, if supported?
        enableDDPlus20: function(v) {
            return enableDDPlus = readBool(qsok('enableDDPlus20'), coalesce(v, true));
        },
        enableDDPlus: function(v) {
            return enableDDPlus = readBool(qsok('enableDDPlus'), coalesce(v, true));
        },
        enableLSSDH: function(v) {
            return enableLSSDH = readBool(qsok('enableLSSDH'), coalesce(v, true));
        },
        enableHEVC: function(v) {
            return enableHEVC = readBool(qsok('enableHEVC'), coalesce(v, false));
        },
        overrideEnableHEVC: function(v) {
            return overrideEnableHEVC = readBool(qsok('overrideEnableHEVC'), coalesce(v, false));
        },
        enableHDR: function(v) {
            return enableHDR = readBool(qsok('enableHDR'), coalesce(v, false));
        },
        overrideEnableHDR: function(v) {
            return overrideEnableHDR = readBool(qsok('overrideEnableHDR'), coalesce(v, false));
        },
        enablePRK: function(v) {
            return enablePRK = readBool(qsok('enablePRK'), coalesce(v, false));
        },
        enableHWDRM: function(v) {
            return enableHWDRM = readBool(qsok('enableHWDRM'), coalesce(v, false));
        },

        enableImageSubs: function(v) {
            return enableImageSubs = readBool(qsok('enableImageSubs'), coalesce(v, true));
        },
        audioProfiles: function(v) {
            var profiles = readStringArray('audioProfiles', coalesce(v, PLATFORM_CONFIG_DEFAULT$audioProfiles));
            return profiles.filter(function(p) {
                if (p === audioProfile$DDPLUS_20) {
                    return MediaElement$ddplusSupported && enableDDPlus20;
                }
                if (p === audioProfile$DDPLUS) {
                    return MediaElement$ddplusSupported && enableDDPlus;
                }
                return true;
            });
        },

        // will disable HD profiles if true
        disableHD: function(v) {
            return disableHD = readBool('disableHD', coalesce(v, false));
        },

        videoProfiles: function(v) {
            var profiles = readStringArray('videoProfiles', coalesce(v, PLATFORM_CONFIG_DEFAULT$videoProfiles));

            var platformEnableHEVC = PLATFORM_ENABLE_HEVC && PLATFORM_ENABLE_HEVC(enableHEVC, overrideEnableHEVC);
            var platformEnableHDR = PLATFORM_ENABLE_HDR && PLATFORM_ENABLE_HDR(enableHDR, overrideEnableHDR);

            var filteredProfiles =  profiles.filter(function(p) {
                var value = true;

                if (p === videoProfile$H264_MPL31) {
                    value = value && !disableHD;
                }
                if (p === videoProfile$H264_MPL40) {
                    value = value && (!disableHD && MediaElement$superhdSupported);
                }
                if (/^hevc-/.test(p)) {
                    value = value && platformEnableHEVC;
                }
                if (/^hevc-hdr-/.test(p)) {
                    value = value && platformEnableHDR;
                }
                if (/-prk$/.test(p)) {
                    value = value && enablePRK;
                }

                return value;
            });

            // Now take the resulting list and filter it by device capability.
            return PLATFORM_CONFIG_DEFAULT$VideoCapabilitiesFunction(filteredProfiles, 'video');
        },

        videoCodecs:  generateSetter(
            readString,
            qsok('videoCodecs'),
            DeviceCapabilities$SelectSourceBufferType("video")
        ),

        timedTextProfiles: function(v) {
            var profiles = readStringArray('timedTextProfiles', coalesce(v, PLATFORM_CONFIG_DEFAULT$timedTextProfiles));
            return profiles.filter(function(p) {
                if (p === timedTextProfile$DFXP_LS_SDH) {
                    return enableLSSDH;
                }
                if (p === timedTextProfile$NFLX_CMISC) {
                    return enableImageSubs;
                }
                return true;
            });
        },

        // CadmiumCoreConfig will always set to true, so we know we got config
        endpoint: generateSetter(readBool, qsok('endpoint'), false),

        // Get DRM header from media and not Bladerunner. Used to work around big in Big Endian KIDs on Chromecast
        getDrmHeaderFromMedia: generateSetter(readBool, qsok('getDrmHeaderFromMedia'), false),

        // Checks if save/load works. Used to count Chromecast devices in the field with corrupted IndexDBs
        testIndexDBForCorruptedDatabase: generateSetter(readBool, qsok('testIndexDBForCorruptedDatabase'), false),

        // Set MediaKeys as soon as session is created. Hack for Chromecast to fix CAD-3114
        setMediaKeysEarly: generateSetter(readBool, qsok('setMediaKeysEarly'), false),

        ignoreKeyStatusOutputNotAllowed: generateSetter(readBool, qsok('ignoreKeyStatusOutputNotAllowed'), false),

        // will explicitly call set certificate Eme api. Currently we set it indirectly via key message.
        useSetServerCertificateApi: generateSetter(readBool, qsok('useSetServerCertificateApi'), false),
        serverCertificate: generateSetter(readString, 'serverCertificate', PLATFORM_CONFIG_DEFAULT$serverCertificateForEme),

        dummyEmeCount: generateSetter(readUInt, qsok('dummyEmeCount'), 0),
        dummyEmePerformLicense: generateSetter(readBool, qsok('dummyEmePerformLicense'), true),
        createDummySessionOnInit: generateSetter(readBool, qsok('createDummySessionOnInit'), false),
        useDummySessionManagerForPrepare: generateSetter(readBool, qsok('useDummySessionManagerForPrepare'), false),
        // do not perform a pending LDL task if another movie playback has been created and either loading or playing
        doNotPerformLdlOnPlaybackCreate: generateSetter(readBool, qsok('doNotPerformLdlOnPlaybackCreate'), false),
        // do not perform a pending LDL task if another movie playback has been started and playing
        doNotPerformLdlOnPlaybackStart: generateSetter(readBool, qsok('doNotPerformLdlOnPlaybackStart'), false),

        preCacheMediaKeys: generateSetter(readUInt, qsok('preCacheMediaKeys'), 0),
        // For pre-fetching manifest and ldl.
        prepareCadmium: generateSetter(readBool, qsok('prepareCadmium'), false),

        // explicit flag required, because there's no feature detection for Windows 10
        supportsLimitedDurationLicense: generateSetter(readBool, qsok('supportsLimitedDurationLicense'), false),
        // enableLdlPrefetch in prepare if this is true
        enableLdlPrefetch: generateSetter(readBool, qsok('enableLdlPrefetch'), false),
        // delete the cache entries on playback. will be false for trailer titles (should we make it title specific?)
        deleteCacheOnPlayback: generateSetter(readBool, qsok('deleteCacheOnPlayback'), true),
        // queue up every 5 minutes

        //deletes manifest cache of other playbacks that is not being played
        deleteOtherManifestCacheOnCreate: generateSetter(readBool, qsok('deleteOtherManifestCacheOnCreate'), false),
        //deletes ldl cache of other playbacks that is not being played
        deleteOtherLdlCacheOnCreate: generateSetter(readBool, qsok('deleteOtherLdlCacheOnCreate'), false),


        periodicPrepareLogsIntervalMilliseconds: generateSetter(readUInt, qsok('periodicPrepareLogsIntervalMilliseconds'), 10 * 60 * 1000),
        // set max cache size for manifest
        prepareManifestCacheMaxCount: generateSetter(readUInt, qsok('prepareManifestCacheMaxCount'), 50),
        // set max cache size for ldl
        prepareLdlCacheMaxCount: generateSetter(readUInt, qsok('prepareLdlCacheMaxCount'), 30),

        prepareManifestExpiryMilliseconds: generateSetter(readUInt, qsok('prepareManifestExpiryMilliseconds'), 20 * 60 * 1000),
        prepareLdlExpiryMilliseconds: generateSetter(readUInt, qsok('prepareLdlExpiryMilliseconds'), 13 * 60 * 1000),

        // storage key. will be appended with test if env is test.
        prepItemsStorePrefix: generateSetter(readString, 'prepItemsStorePrefix', 'prepitems'),
        //set this to consume pre-cached indexedDb streams.
        consumePreCachedStreams: generateSetter(readBool, qsok('consumePreCachedStreams'), false),

        waitForSecureStopToTeardownMediaElement: generateSetter(readBool, 'waitForSecureStopToTeardownMediaElement', true),

        imageSubsResolution: generateSetter(readUInt, qsok('imageSubsResolution'), 0),
        imageSubsMaxBuffer: generateSetter(readUInt, qsok('imageSubsMaxBuffer'), PLATFORM_CONFIG_DEFAULT$maxImageSubsBufferSizeBytes, 0),

        keySystemId: function(v) {
            return readString(qsok('keySystemId'), PLATFORM_CONFIG_DEFAULT$getKeySystemId(enableHWDRM), undefined);
        },

        // can this platform play HDCP content?
        //   "constrict": will downscale, so it can always play HDCP required content
        //   "ifpresent": only if HDCP engages
        //   "never": never, can't even attempt
        canHDCP: generateSetter(readString, qsok('canHDCP'), PLATFORM_CONFIG_DEFAULT$canHDCP || 'constrict', /^(constrict|ifpresent|never)$/),

        // --
        // --------------------------------------------------------------------------------

        logMediaPipelineStatus: generateSetter(readBool, 'logMediaPipelineStatus', false),

        logDisplayAutoshowLevel: function () {
            return -1;
        },

        logDisplayMaxEntryCount: generateSetter(readInt, qsok('logDisplayMaxEntryCount'), PLATFORM_CONFIG_DEFAULT$logDisplayMaxEntryCount, -1),

        logToConsoleLevel: generateSetter(readInt, qsok('logToConsoleLevel'), -1),

        environmentIsTest: function () {
            return environmentIsTest;
        },
        requireNetflixId: generateSetter(readBool, 'requireNetflixId', PLATFORM_CONFIG_DEFAULT$requireNetflixId),
        requireSecureNetflixId: generateSetter(readBool, 'requireSecureNetflixId', PLATFORM_CONFIG_DEFAULT$requireSecureNetflixId),
        // Should netflix id be upraded to double bound? This only makes sense for "browser" accounts
        upgradeNetflixId: generateSetter(readBool, 'upgradeNetflixId', true),
        // ESN prefix of the NetflixId in dev or dbl bound NetflixId
        netflixIdEsnPrefix: generateSetter(readString, 'netflixIdEsnPrefix'),

        // capture in log.error
        logErrorIfEsnNotProvided: generateSetter(readBool, 'logErrorIfEsnNotProvided', true),

        // don't let a playback start in any browser tab, if there is an open playback already (take the lock when playback is open, and release when closed)
        enforceSinglePlayback: generateSetter(readBool, 'enforceSinglePlayback', PLATFORM_CONFIG_DEFAULT$enforceSinglePlayback),
        // take the lock when page is loaded, and release on unload
        // Note: ideally we want to enforce single playback, but while that doesn't work properly cross-tab (for MSL store) , use the enforceSingleSession instead
        enforceSingleSession: generateSetter(readBool, 'enforceSingleSession', PLATFORM_CONFIG_DEFAULT$enforceSingleSession),
        // when loading a new playback, close the currently open ones
        closeOtherPlaybacks: generateSetter(readBool, 'closeOtherPlaybacks', true),

        // use the new common adaptive streaming engine
        useASE: generateSetter(readBool, qsok('useASE'), ASE),

        asyncLoadTimeout: generateSetter(readUInt, 'asyncLoadTimeout', 15000, 1),

        // 0 - disabled, otherwise polls per second
        mainThreadMonitorPollRate: generateSetter(readUInt, 'mainThreadMonitorPollRate', DEBUG ? 60 : 0),

        // For Ten foot devices controls whether the UI Overlay is displayed. Useful for development internally and with partners.
        nrdpAlwaysShowUIOverlay: generateSetter(readBool, 'nrdpAlwaysShowUIOverlay', false),

		// Hostname for API.Next. Used by nrdp config service
		nrdpConfigServiceApiHostname: generateSetter(readString, 'nrdpConfigServiceApiHostname', 'api-global.netflix.com'),

        // Endpoint for API.Next. Used by Congestion config service. Can be set by UI to send request through Zuul.
		congestionServiceApiEndpoint: generateSetter(readString, 'congestionServiceApiEndpoint', environmentIsTest ? 'https://api.test.netflix.com/cbp/html5player/congestion' : 'https://api-global.netflix.com/cbp/html5player/congestion'),

		// Enable fetching of congetion information. API always returns congestion false when disabled.
		enableCongestionService: generateSetter(readBool, 'enableCongestionService', false),

        // A/B test group name
        groupName: generateSetter(readString, 'groupName', ''),
        // One in how many playbacks should log verbose info? (such as DLREQ-s)
        verbosePlaybackInfoDenominator: generateSetter(readUInt, qsok('verbosePlaybackInfoDenominator'), 100),
        // Can we show please call message?
        allowPleaseCallMessage: generateSetter(readBool, qsok('allowPleaseCallMessage'), false),
        // Should we use built-in timed text rendering? We will need this for positional subtitles
        renderTimedText: generateSetter(readBool, 'renderTimedText', PLATFORM_CONFIG_DEFAULT$renderTimedText),
        // Timed text default styles, these typically vary by region.
        timedTextStyleDefaults: generateSetter(readStringDictionary, 'timedTextStyleDefaults', {}),
        // Timed text settings overwritten by user account or device settings
        timedTextStyleOverrides: generateSetter(readStringDictionary, 'timedTextStyleOverrides', {}),
        // Timed text font family mapping to CSS styles for HTML rendering
        timedTextFontFamilyMapping: generateSetter(readStringDictionary, 'timedTextFontFamilyMapping', PLATFORM_CONFIG_DEFAULT$timedTextFontFamilyMapping || { 'default': 'font-family:Arial,Helvetica;font-weight:bolder' }),
        // overrides the start and end time of timed text entries for testing
        timedTextTimeOverride: generateSetter(readUInt, qsok('timedTextTimeOverride'), 0),
        // fallback to simplesdh if the .dfxp is larged than this number for LS-SDH files
        timedTextSimpleFallbackThreshold: generateSetter(readUInt, 'timedTextSimpleFallbackThreshold', PLATFORM_CONFIG_DEFAULT$timedTextSimpleFallbackThreshold),
        // support using custom dfxp (it must be named customDfxpUrl, to match Silverlight, and this is used by some customers)
        customDfxpUrl: generateSetter(readString, qsok('customDfxpUrl')),

        enableSubtitleTrackerLogging: generateSetter(readBool, qsok('enableSubtitleTrackerLogging'), DEBUG),
        // CDN filtering
        cdnIdWhiteList: generateSetter(readStringArray, 'cdnIdWhiteList', []),
        cdnIdBlackList: generateSetter(readStringArray, 'cdnIdBlackList', []),

        // Provide option to CDN selection in a more or less synchronous manner.
        asynchronousCDNSelection: generateSetter(readBool, qsok('asynchronousCDNSelection'), true),

        // Audio and TimedText Tracks
        forceAudioTrack: generateSetter(readString, qsok('forceAudioTrack')),

        muteVolumeOnPlaybackClose: generateSetter(readBool, 'muteVolumeOnPlaybackClose', true),

        nrdpVolumeControlType: generateSetter(readString, 'nrdpVolumeControlType', 'VOLUME_STREAM'),

        // Use the receiver platform for volume control instead of the media element.
        nrdpUsePlatformVolumeControl: generateSetter(readBool, 'nrdpUsePlatformVolumeControl', false),

        forceTimedTextTrack: generateSetter(readString, qsok('forceTimedTextTrack')),
        // download timed text again n number of times
        maxRetriesTimedTextDownload: generateSetter(readUInt, qsok('maxRetriesTimedTextDownload'), 2),
        // gap between each retry for timed text track downloads
        timedTextRetryInterval: generateSetter(readUInt, qsok('timedTextRetryInterval'), 8000),

        storageMinimumSize: generateSetter(readUInt, 'storageMinimumSize', PLATFORM_CONFIG_DEFAULT$storageMinimumSize, 0),
        storageType: generateSetter(readString, 'storageType', PLATFORM_CONFIG_DEFAULT$storageType, /^(none|fs|idb|ls)$/),
        // timeout for async storage read/write operations
        storageTimeout: generateSetter(readUInt, 'storageTimeout', 8000, 1),

        // lock older than this is considered expired
        lockExpiration: generateSetter(readUInt, 'lockExpiration', 10000),

        lockRefresh: generateSetter(readUInt, 'lockRefresh', 3000),

        //captures error logs before startplay and flushes it
        captureUnhandledExceptions: generateSetter(readBool, 'captureUnhandledExceptions', true),
        uncaughtExceptionFlushInterval: generateSetter(readUInt, 'uncaughtExceptionFlushInterval', 6000),

        // when playback ends, this will not show the error message, instead the last frame.
        preserveLastFrame: generateSetter(readBool, 'preserveLastFrame', false),

        // a constrain to prebuffering/rebuffering progress in milliseconds
        // busy.progress won't increment faster than rate = 1/reasonableBufferTime
        minBufferingTimeInMilliseconds: generateSetter(readUInt, 'minBufferingTimeInMilliseconds', 4000),

        // The maximum we will buffer before playing back.
        maxBufferingTimeInMilliseconds: generateSetter(readUInt, 'maxBufferingTimeInMilliseconds', 0),

        // if buffering progress movies backwards, wait this many milliseconds before reflecting it in UI
        progressBackwardsGraceTimeMilliseconds: generateSetter(readUInt, 'progressBackwardsGraceTimeMilliseconds', 4000),
        // if buffering progress movies backwards, make sure it's bigger than this many percent
        progressBackwardsMinPercent: generateSetter(readUInt, 'progressBackwardsMinPercent', 10),

        // if bookmark is in these ranges, then it's ignored and movie starts from beginning
        // this can either be milliecond or percent ('xx%') of duration
        bookmarkIgnoreBeginning: generateSetter(readString, qsok('bookmarkIgnoreBeginning'), '30000', BOOKMARK_IGNORE_REGEX),
        // note that Akira is currently set to 0% via the groovy scripts, so the 5% default only applies in Merchweb.
        bookmarkIgnoreEnd: generateSetter(readString, qsok('bookmarkIgnoreEnd'), '5%', BOOKMARK_IGNORE_REGEX),

        // Downloading configuration
        connectionStrategy: generateSetter(readString, 'connectionStrategy', 'parallel', /^(parallel|single)$/),

        // use 'default', 'historical', 'sliding_window'
        bandwidthMeterType: generateSetter(readString, qsok('bandwidthMeterType'), 'sliding_window', /^(historical|sliding_window)$/),

        // how many connections to start with
        initParallelConnections: generateSetter(readUInt, 'initParallelConnections', 3),

        // maximum number to switch to after reaching parallelSafeBufferThreshhold
        maxParallelConnections: generateSetter(readUInt, 'maxParallelConnections', 3),

        // Report throughput in midplay and endplay logblogs
        reportThroughputInLogblobs: generateSetter(readBool, 'reportThroughputInLogblobs', true),

        parallelDownloadManagerType: generateSetter(readString, 'parallelDownloadManagerType', 'chunk', /^(subchunk|chunk)$/),

        // The frequency of the parallel downloader update heartbeat. In practice this can be called more often when various
        // events fire such as download completion.  The true frequency is throttled by parallelDownloaderUpdateThrottleFrequencyMs
        parallelDownloaderUpdateFrequencyMs: generateSetter(readUInt, 'parallelDownloaderUpdateFrequencyMs', 500),

        // See comment for parallelDownloaderUpdateFrequencyMs.
        parallelDownloaderUpdateThrottleFrequencyMs: generateSetter(readUInt, 'parallelDownloaderUpdateThrottleFrequencyMs', 200),

        maxChunksInProgressForSubchunking: generateSetter(readUInt, 'maxChunksInProgressForSubchunking', 3),

        subchunkLength: generateSetter(readUInt, 'subchunkLength', Math$pow(2,17)), // 128k.

        // The normalized buffer threshold for switch from single connection to multiple connections.
        parallelSafeBufferThreshhold: generateSetter(readFloat, 'parallelSafeBufferThreshhold', 40.0 / 240.0),

        // The normalized buffer threshold for below which heuristics will check for the need to abort downloads
        // to avoid a rebuffer due to a severe drop in bandwidth.
        abortDownloadBufferThreshhold: generateSetter(readFloat, 'abortDownloadBufferThreshhold', 40.0 / 240.0),

        // The width of the window for the SlidingWindowBandwidthMeter
        slidingWindowWidthMilliseconds: generateSetter(readUInt, 'slidingWindowWidthMilliseconds', 30000),

        // Should we do a ping test when there are connect timeouts during media downloads to see if we should continue waiting?
        // This counter measure handles the case when a firewall or antivirus programs intercepts the media bytes and passes them through all at once
        // after scanning them.
        pingOnConnectTimeout: generateSetter(readBool, 'pingOnConnectTimeout', false),

        // When there is a connect timeout and pingOnConnectTimeout is true, then we will ping the current cdn
        // and wait this long before declaring the a true failed connection.
        pingCDNTimeoutMilliseconds: generateSetter(readUInt, 'pingCDNTimeoutMilliseconds', 8000),

        maxBufferSizeMilliseconds: generateSetter(readUInt, 'maxBufferSizeMilliseconds', PLATFORM_CONFIG_DEFAULT$maxBufferSizeMilliseconds, 10000, MAX_MEDIA_TIME),
        maxBufferSizeBytes: generateSetter(readUInt, 'maxBufferSizeBytes', PLATFORM_CONFIG_DEFAULT$maxBufferSizeBytes),
        // if using ASE, look at the new config parameter, called 'reserveForSkipbackBufferMs'
        backBufferSizeMilliseconds: generateSetter(readUInt, 'backBufferSizeMilliseconds', 10000, 0, MAX_MEDIA_TIME),
        // when we hit maxBufferSizeBytes, what fraction (in %) of front buffer we should keep back buffer at. 25 = if we have 40 sec of front buffer, keep 10 sec (25% of it) of back buffer
        backToFrontBufferRatioPercent: generateSetter(readUInt, 'backToFrontBufferRatioPercent', 25, 0, 1000),

        // Expected (and desired) chunk sizes.
        // If actual chunk sizes don't match these, several fragments will be combined to
        // try to match these numbers as close as possible.
        audioChunkSizeMilliseconds: generateSetter(readUInt, 'audioChunkSizeMilliseconds', audioChunkSizeMilliseconds),
        videoChunkSizeMilliseconds: generateSetter(readUInt, 'videoChunkSizeMilliseconds', videoChunkSizeMilliseconds),

        // dropped frame based stream filter
        droppedFrameRateFilterEnabled: generateSetter(readBool, 'droppedFrameRateFilterEnabled', false),
        // how many obserations to keep track of (observation is done every second)
        droppedFrameRateFilterMaxObservation: generateSetter(readUInt, 'droppedFrameRateFilterMaxObservation', 60, 10, 1000),
        // If there are [0] observations of more than [1] dropped frames, switch down the resolution
        droppedFrameRateFilterPolicy: generateSetter(readUIntArrayOfArrays, 'droppedFrameRateFilterPolicy', [
            [3, 15], // more than 4 observations of 15+ dropped frames
            [6, 9], // more than 8 observations of 9+ dropped frames
            [9, 2],  // more than 12 observations of 2+ dropped frames
            [15, 1]  // more than 20 observations of 1+ dropped frames
        ], undefined, undefined, 2, 0),
        droppedFrameRateFilterWithoutRebufferEnabled: generateSetter(readBool, 'droppedFrameRateFilterWithoutRebufferEnabled', true),
        // this is the dissallowed screen resolution restriction from the previous session (e.g. 480, 720, 1080, etc.)
        droppedFrameRateFilterBasedOnPreviousSession: generateSetter(readUInt, 'droppedFrameRateFilterBasedOnPreviousSession'),
        // this policy enables the previous dropped frame bitrate restriction for subsequent session based on number of cores and cpu speed
        // the index into the array is the number of cores, and the value is the cpu speed threshold (zero index is in case number of cores can't be detected)
        droppedFrameRateFilterBasedOnPreviousSessionPolicy: generateSetter(readUIntArray, 'droppedFrameRateFilterBasedOnPreviousSessionPolicy'),
        // never disallow streams lower or equal than this height (384 matches 560 bitrate)
        droppedFrameRateFilterMinHeight: generateSetter(readUInt, 'droppedFrameRateFilterMinHeight', 384),
        // the maximum number of dropped frame histogram to store
        droppedFramesStorageSessionLimit: generateSetter(readUInt, 'droppedFramesStorageSessionLimit', 10),
        // this sets how often the dropped frames histogram is save to isolated storage
        droppedFramesStorageInterval: generateSetter(readUInt, 'droppedFramesStorageInterval', 60000),
        // list of dropped frame occurences to log percentiles for, zero means what percent of observations had no dropped frames
        droppedFramesPercentilesList: generateSetter(readUIntArray, 'droppedFramesPercentilesList', []),

        // Disables streams that don't have the same number of chunks as the mediaBuffer
        incorrectChunkCountEnabled: generateSetter(readBool, 'incorrectChunkCountEnabled', true),

        // Presenting configuration
        defaultVolume: generateSetter(readUInt, qsok('defaultVolume'), 100, 0, 100),
        disableVideoRightClickMenu: generateSetter(readBool, 'disableVideoRightClickMenu', true),

        // if decoder has less than this, it's a rebuffer
        minDecoderBufferMilliseconds: generateSetter(readUInt, 'minDecoderBufferMilliseconds', 1000, 0, MAX_MEDIA_TIME),
        // wait for decoder to have this much before starting playback,
        // this number should always be lower than prebufferMinAudioMilliseconds and prebufferMinVideoMilliseconds
        optimalDecoderBufferMilliseconds: generateSetter(readUInt, 'optimalDecoderBufferMilliseconds', 5000, 0, MAX_MEDIA_TIME),
        // don't feed decoder if it has more than this
        maxDecoderBufferMilliseconds: generateSetter(readUInt, 'maxDecoderBufferMilliseconds', PLATFORM_CONFIG_DEFAULT$maxDecoderBufferMilliseconds, 0, MAX_MEDIA_TIME),
        // how long do we give the decoder to start showing frames?
        // if we wait for it this long... then it's a fatal timeout error
        decoderTimeoutMilliseconds: generateSetter(readUInt, 'decoderTimeoutMilliseconds', 10000, 1),
        // This causes the JS memory to be freed as soon as media is appended to MSE
        // This is a very hacky implementation and should be used with care. This will disable in-buffer-seek and back-buffer as side-effect
        disgardMediaOnAppend: generateSetter(readBool, 'disgardMediaOnAppend', false),
        // Should we append media before initialization is complete?
        // This way we can append media without waiting for the license. This should improve performance, but might cuase issues for some MSE implementations.
        appendMediaBeforeInit: generateSetter(readBool, 'appendMediaBeforeInit', false),

        // if player is paused for this long, it's a timeout error
        pauseTimeoutLimitMilliseconds: generateSetter(readUInt, 'pauseTimeoutLimitMilliseconds', 1800000),

        //  monitors the suspended execution
        inactivityMonitorInterval: generateSetter(readUInt, 'inactivityMonitorInterval', 30000, 0),

        // Seconds of watched video from start of playback at which the average bitrate delivered is logged
        abrdelLogPointsSeconds: generateSetter(readUIntArray, 'abrdelLogPointsSeconds', [15, 30, 60, 120], 0, undefined, 4),

        // -- heuristics
        heuristicsAlgorithm: generateSetter(readString, qsok('heuristicsAlgorithm'), ''),
        // array of [milliseconds, bitrate] used by "fixed" heuristicsAlgorithm
        // typically used for debugging issues that surface when using bitrates in specific order
        fixedVideoBitrates: generateSetter(readUIntArrayOfArrays, qsok('fixedVideoBitrates'), [], undefined, undefined, 2, 0),
        // if true, it will not pick the first available bitrate by default for initial headers download.
        useFilteredInitialBitratesOnly: generateSetter(readBool, qsok('useFilteredInitialBitratesOnly'), false),

        // what video headers should we download at start to pick from?
        initialVideoBitrates: generateSetter(readStringArray, qsok('initialVideoBitrates'), ['0+', '400+', '900+'], BITRATE_FILTER_REGEX, 1),
        // maximim initial video bitrate if carrera is enabled but not used,
        initialVideoBitratesForCarreraFallback: generateSetter(readStringArray, qsok('initialVideoBitratesForCarreraFallback'), ['0+', '400+', '900+'], BITRATE_FILTER_REGEX, 1),
        // what audio bitrate we should play?
        initialAudioBitrates: generateSetter(readStringArray, qsok('initialAudioBitrates'), ['0+', '90+', '150+'], BITRATE_FILTER_REGEX, 1),
        // we want to spend [1/audioBandwidthDenominator] of bandwidth for getting audio
        // this is used for picking audio bitrate from initialAudioBitrates
        // 15 ~= 96 for 1750 and above
        audioBandwidthDenominator: generateSetter(readUInt, 'audioBandwidthDenominator', 15, 1),
        // how far in future should we simulate buffer levels?
        simulationLimitMilliseconds: generateSetter(readUInt, 'simulationLimitMilliseconds', 1200000, 10000),
        // stream is considered feasable if we can download this much content, and then switch to lower stream
        highStreamSimulationMilliseconds: generateSetter(readUInt, 'highStreamSimulationMilliseconds', 120000, 1),
        // prebuffer bitrate will be selected based on sustainable bitrate
        // by interpolating these values [sustainable, preferredPrebufferBitrate]
        prebufferBitrate: generateSetter(readUIntArrayOfArrays, 'prebufferBitrate', [
            [500, 235],
            [1000, 560],
            [5000, 1050],
            [10000, 1050],
            [30000, 3000]
        ], undefined, undefined, 2, 1),
        // when swiching up, the "next up" bitrate
        // is determined by this table,
        // if there is no exact match, result will be interpolated
        switchUpToBitrate: generateSetter(readUIntArrayOfArrays, 'switchUpToBitrate', [
            [235, 560],
            [375, 750],
            [560, 1050],
            [750, 1400],
            [1050, 1750],
            [1750, 3000],
            [2350, 100000]
        ], undefined, undefined, 2, 1),
        prebufferMinAudioMilliseconds: generateSetter(readUInt, 'prebufferMinAudioMilliseconds', 6000),
        prebufferMinVideoMilliseconds: generateSetter(readUInt, 'prebufferMinVideoMilliseconds', 6000),
        // never prebuffer more than this
        prebufferMaxMilliseconds: generateSetter(readUInt, 'prebufferMaxMilliseconds', 30000),
        // separate parameter for rebuffer situations, max should be max of buffer size in milliseconds
        rebufferMaxMilliseconds: generateSetter(readUInt, 'rebufferMaxMilliseconds', 232000),
        // enable trick play download
        enableTrickPlay: generateSetter(readBool, 'enableTrickPlay', false),
        // simulation parameters for downloading trickplay, or other download not included in buffer simulations
        additionalDownloadSimulationParams: generateSetter(readUIntArray, 'additionalDownloadSimulationParams', [2000, 2000, 100], 0, undefined, 3),
        // bitrate threshold for switching to low resolution trick play
        trickPlayHighResolutionBitrateThreshold: generateSetter(readUInt, 'trickPlayHighResolutionBitrateThreshold', 1000),
        // playback.duration threshold for switching to low resolution trick play
        trickPlayHighResolutionThresholdMilliseconds: generateSetter(readUInt, 'trickPlayHighResolutionThresholdMilliseconds', 10000),
        // tweak the threshold for enough buffer before trickplay is downloaded
        trickplayBufferFactor: generateSetter(readFloat, 'trickplayBufferFactor', 0.5),
        // number of retries before switching to next url
        trickPlayDownloadRetryCount: generateSetter(readUInt, 'trickPlayDownloadRetryCount', 1),
        // simulation parameters for prebuffering (extra audio, extra video, bandwidth reduction %)
        prebufferSimulationParams: generateSetter(readUIntArray, 'prebufferSimulationParams', [2000, 2000, 60], 0, undefined, 3),
        // simulation parameters for buffer, based on buffer level (buffer level, extra audio, extra video, bandwidth reduction %)
        // non-specified buffer levels are interpolated
        bufferingSimulationParams: generateSetter(readUIntArrayOfArrays, 'bufferingSimulationParams', [
            [60000, 1000, 1000, 100],
            [120000, 1000, 1000, 20],
            [180000, 0, 0, 0]
        ], undefined, undefined, 4, 1),
        bufferingSwitchUpSimulationParams: generateSetter(readUIntArrayOfArrays, 'bufferingSwitchUpSimulationParams', [
            [60000, 3000, 3000, 140],
            [120000, 3000, 3000, 60],
            [180000, 0, 0, 0]
        ], undefined, undefined, 4, 1),
        doNotSwitchDownIfBufferIsAboveMilliseconds: generateSetter(readUInt, 'doNotSwitchDownIfBufferIsAboveMilliseconds', 180000),

        // DEPRECATED
        // Historical Bandwidth configuration
        // aggregate and log data every 5 minutes
        enableHistorical: generateSetter(readBool, 'enableHistorical', false),
        histAggregationTimeSpanInSeconds: generateSetter(readUInt, 'histAggregationTimeSpanInSeconds', 5 * 60),
        histCompareBitsIPv4: generateSetter(readUInt, 'histCompareBitsIPv4', 24),
        histCompareBitsIPv6: generateSetter(readUInt, 'histCompareBitsIPv6', 32),
        histFilterType: generateSetter(readString, 'histFilterType', 'none', /^(none|timeofDay|dayOfWeekAndTimeOfDay)$/),
        histSizeLimit: generateSetter(readUInt, 'histSizeLimit', 1000),
        histMinSampleSize: generateSetter(readUInt, 'histMinSampleSize', 1),
        histMaxSampleSize: generateSetter(readUInt, 'histMaxSampleSize', 1000),
        histTimeOfDayRangeInSeconds: generateSetter(readUInt, 'histTimeOfDayRangeInSeconds', 3600), // one hour

        /*
         Carrera config parameters
         */
        carreraParameters: generateSetter(readStringDictionary, 'carreraParameters', {
            '1750': 7,
            '1050': 5,
            '750': 4.5,
            '560': 4.5,
            '375': 4.5
        }),
        carreraMediaMillisecondsToDownload: generateSetter(readInt, 'carreraMediaSecondsToDownload', 8000),
        carreraChunksToAverage: generateSetter(readInt, 'carreraChunksToAverage', 10),
        carreraConfidenceThreshold: generateSetter(readFloat, 'carreraConfidenceThreshold',0.7),
        carreraHistoricalPercentileToUse: generateSetter(readInt, 'carreraHistoricalPercentileToUse', 50),

        initialBitrateSelectionAlgorithm: generateSetter(readString, 'initialBitrateSelectionAlgorithm', 'default', /^(default|carrera)$/),

        logChunkLevelTput: generateSetter(readBool, 'logChunkLevelTput', true),

        // ASE-28: Only quickly react to throughput drop, not to throughput increase
        logOverallTputAsRef: generateSetter(readBool, 'logOverallTputAsRef', false),

        overallTputInterval: generateSetter(readInt, 'overallTputInterval', Infinity),

        maxIQRSamples: generateSetter(readInt, 'maxIQRSamples', Infinity),

        //Buffer-based QoE knob
        bufferBased: {
            //
            //Tunable values:
            //
            //The maximum size of reservoir (see SIGCOMM submission section 5.1)
            maxReservoirSizeMilliseconds: generateSetter(readUInt, 'maxReservoirSizeMilliseconds', 120000),
            //The maximum size of reservoir (see SIGCOMM submission section 5.1)
            minReservoirSizeMilliseconds: generateSetter(readUInt, 'minReservoirSizeMilliseconds', 8000),
            //The maximum size of outage protection (see SIGCOMM submission section 6)
            maxOutageProtectionMilliseconds: generateSetter(readUInt, 'maxOutageProtectionMilliseconds', 60000),
            //The maximum cushion size (see SIGCOMM submission section 5, figure 13)
            maxCushionSizeInBufferPercentage: generateSetter(readUInt, 'maxCushionSizeInBufferPercentage', 90),
            //How many chunks ahead that the reservoir should be calculated from (SIGCOMM submission section 5.1)
            reservoirLookAheadChunks: generateSetter(readUInt, 'reservoirLookAheadChunks', 60),
            //The maximum number of chunks that we stay in startup phase (SIGCOMM submission section 6)
            startupPhaseInChunks: generateSetter(readUInt, 'startupPhaseInChunks', 30),

            //Copying the cadmium config here
            //maxChunkInProgress is 3 (the same value as maxChunksInProgressForSubchunking)
            maxBufferSizeMilliseconds: generateSetter(readUInt, 'maxBufferSizeMilliseconds', (PLATFORM_CONFIG_DEFAULT$maxBufferSizeMilliseconds - maxChunkInProgress * videoChunkSizeMilliseconds), 10000, MAX_MEDIA_TIME),
            //
            //Following is the current knob setting
            //
            //The switch for startup optimization
            startupQualityOptimization: generateSetter(readBool, 'startupQualityOptimization', true),
            //The switch for reservoir calculation (when false, we need to manually set the value of reservoir)
            dynamicReservoir: generateSetter(readBool, 'dynamicReservoir', true),
            //The switch for safe rate map (when false, we are allowed to use "risky" rate map during the steady state)
            //Note: This should be set to 'true' when we cannot cancel a chunk download
            //Note: We should consider update the definition of 'safe' when we are able to cancel a chunk download
            isUsingStrictMaxChunkSize: generateSetter(readBool, 'isUsingStrictMaxChunkSize', true),
            //The switch for continuing to use the rate selection during the pre-buffer phase
            transitFromInitialPhase: generateSetter(readBool, 'transitFromInitialPhase', true),
            //The switch for taking encoding coefficient into consideration
            startupSafeRateCalculationEnabled: generateSetter(readBool, 'startupSafeRateCalculationEnabled', true),
            //The switch for gradually lower the threshold when buffer grows
            startupThresholdFunctionOfBufferEnabled: generateSetter(readBool, 'startupThresholdFunctionOfBufferEnabled', true),
            //During the startup phase, how do we calculate the encoding coefficient?
            //(1) False: calculated from the entire stream, (2) True: calculated from the X number of chunks ahead
            startupLookAheadCalculationEnabled: generateSetter(readBool, 'startupLookAheadCalculationEnabled', false),
            //This is used with 'startupLookAheadCalculationEnabled'
            startupLookAheadChunks: generateSetter(readUInt, 'startupLookAheadChunks', 120),
            //
            //Following is the settings not currently in use, but I am keeping it there just in case
            //
            //The switch for manually set the reservoir
            isReservoirManualSet: generateSetter(readBool, 'isReservoirManualSet', false),
            //If the value of reservoir is manually set, what is the value
            manualReservoirMilliseconds: generateSetter(readUInt, 'manualReservoirMilliseconds', 90000),
            //The switch for manually set the cushion
            isCushionManualSet: generateSetter(readBool, 'isCushionManualSet', false),
            //If the value of cushion is manually set, what is the value
            manualCushionMilliseconds: generateSetter(readUInt, 'manualCushionMilliseconds', 126000),
            //When picking a rate from the chunk map, how many chunks we look ahead to calculate the chunk size
            isLookingAhead: generateSetter(readBool, 'isLookingAhead', false),
            //Whether we are using the rate map or chunk map. When false, using the chunk map
            isUsingRateMap: generateSetter(readBool, 'isUsingRateMap', false)
        },

        // MediaDownloader configuration

        // if a task fails (download task or cdn selection task), next attempt will wait this much
        // after each failure, the index is increased untill it reaches last value,
        // index will reset after a successfull download
        failedDownloadRetryWaits: generateSetter(readUIntArray, 'failedDownloadRetryWaits', [10, 200, 500, 1000, 2000, 4000, 8000, 16000]),
        // ASE version, since the Streaming Manager relies on retry to succeed to drive the pipeline, we should keep the retry timeout below other timeouts in the system
        failedDownloadRetryWaitsASE: generateSetter(readUIntArray, 'failedDownloadRetryWaitsASE', [10, 200, 500, 1000, 2000, 4000]),

        // When there are download failures during CDN selection use the exponential backoff values in failedDownloadRetryWaits
        useCDNExponentialBackoff: generateSetter(readBool, 'useCDNExponentialBackoff', true),

        // after how many failures should we start pinging all CDN-s, instead of trying to get the same chunk from selected CDN
        selectCdnDownloadRetryCountBeforeCdnSwitch: generateSetter(readUInt, 'selectCdnDownloadRetryCountBeforeCdnSwitch', 2),

        // for cdn selection, after this much time after making requests stop waiting for all requests to finish (just evaluate what you have)
        selectCdnTimeoutMilliseconds: generateSetter(readUInt, 'selectCdnTimeoutMilliseconds', 1000),

        // if latency difference for two CDN-s is less than this, they both are considered equal
        selectCdnSignificantLatency: generateSetter(readUInt, 'selectCdnSignificantLatency', 300),

        // minimum bandwidth to choose cdn, w/o testing more locations
        selectCdnBandwidthThresholdKbps: generateSetter(readUInt, 'selectCdnBandwidthThresholdKbps', 2000),

        // cdn selection algorithm
        selectCdnType: generateSetter(readString, 'selectCdnType', 'bandwidth', /^(latency|bandwidth)$/),

        // minimum number of bytes used for bandwidth test
        bandwidthTestBytesPerCdn: generateSetter(readUInt, 'bandwidthTestBytesPerCdn', 200 * 1024), /* 200k */

        // -- http & download
        // vary connect timeout with buffer level? (true/false)
        useVariableConnectTimeout: generateSetter(readBool, 'useVariableConnectTimeout', false),
        // minimum connect timeout for the variable timeout calculation
        minConnectTimeoutMilliseconds: generateSetter(readUInt, 'minConnectTimeoutMilliseconds', 4000),
        // default connect timeout is 8 seconds
        connectTimeoutMilliseconds: generateSetter(readUInt, 'connectTimeoutMilliseconds', 8000, 500),
        // variables for modify the connect timeout formula
        connectTimeoutBufferDiscount: generateSetter(readUInt, 'connectTimeoutBufferDiscount', 2),
        connectTimeoutoutUpperLimitMultiplier: generateSetter(readUInt, 'connectTimeoutoutUpperLimitMultiplier', 10000),
        // the equivalent, readtimeout, is 8 seconds in Silverlight
        noProgressTimeoutMilliseconds: generateSetter(readUInt, 'noProgressTimeoutMilliseconds', 8000, 500),
        // should we use navigator.onLine api? (it's know to have glitches in Chrome)
        useOnLineApi: generateSetter(readBool, 'useOnLineApi', false),
        // how many times should we retry a header download from the same CDN, before trying another one
        headerDownloadRetryCountBeforeCdnSwitch: generateSetter(readUInt, 'headerDownloadRetryCountBeforeCdnSwitch', 1),
        timedTextDownloadRetryCountBeforeCdnSwitch: generateSetter(readUInt, 'timedTextDownloadRetryCountBeforeCdnSwitch', 1),

        // Whether or not to abort download after seek and bitrate restriction in Cadmium-ASE
        abortInProgressDownload: generateSetter(readBool, 'abortInProgressDownload', true),

        // Whether or not to abort in-progress and queued downloads when rebuffer happens
        abortInProgressAtRebuffer: generateSetter(readBool, 'abortInProgressAtRebuffer', false),

        //Whether or not to abort preemptively based on ASE currentStreamInfeasible event
        abortPreemptively: generateSetter(readBool, 'abortPreemptively', false),

        // when downloading multiple headers during initialization, after this timeout is elapsed... don't want for all header downloads to complete,
        // proceed if there is enough (one audio and one video)
        initialHeaderDownloadTimeout: generateSetter(readUInt, 'initialHeaderDownloadTimeout', 2000),

        // when buffering, we donwload headers in parallel with chunks
        // and we don't start next chunk download untill header download finishes, unless it's taking longer than this much
        headerDownloadTimeout: generateSetter(readUInt, 'headerDownloadTimeout', 3000),

        // Hack to work around CastTV bug.  webkitDecodedFrameCount is not being properly reported.
        webkitDecodedFrameCountIncorrectlyReported: generateSetter(readBool, 'webkitDecodedFrameCountIncorrectlyReported', false),

        // -- media, profile, bitrates

        // when audio track is changed, we seek back this much (preferably, should be less or equal to backBufferSizeMilliseconds)
        seekBackOnAudioTrackChangeMilliseconds: generateSetter(readUInt, 'seekBackOnAudioTrackChangeMilliseconds', 8000),
        // TODO: should we only use 'primary', as Silverlight does?
        supportedAudioTrackTypes: generateSetter(readStringArray, qsok('supportedAudioTrackTypes'), [], undefined, 1),
        supportedAudioBitrates: generateSetter(readStringArray, qsok('supportedAudioBitrates'), [], BITRATE_FILTER_REGEX),
        supportedVideoBitrates: generateSetter(readStringArray, qsok('supportedVideoBitrates'), [], BITRATE_FILTER_REGEX),

        // if this is non-zero, logblobs will be flushed x milliseconds after playback start
        initialLogFlushTimeout: generateSetter(readUInt, 'initialLogFlushTimeout', 5000),
        // Storage key for saving playdata
        playdataPersistKey: generateSetter(readString, 'playdataPersistKey', environmentIsTest ? 'unsentplaydatatest' : 'unsentplaydata'),
        // Should the persisted playdata be sent at the beginning
        sendPersistedPlaydata: generateSetter(readBool, 'sendPersistedPlaydata', true),
        // PlayData will be persisted in storage every x milliseconds. To disable set the paramter to 0.
        playdataPersistIntervalMilliseconds: generateSetter(readUInt, 'playdataPersistIntervalMilliseconds', 4000),
        // if this flag is set, during persisting there will also be a pre-encoded EDGE request created, which will be "fired and forgotten" if window closes or page reloads
        playdataPrepareRequest: generateSetter(readBool, 'playdataPrepareRequest', PLATFORM_CONFIG_DEFAULT$playdataPrepareRequest),

        // heartbeats will not be sent more often than this
        heartbeatCooldown: generateSetter(readUInt, 'heartbeatCooldown', 10000, 1000),
        // which of performance.timing values should we log in startup message?
        logPerformanceTiming: generateSetter(readStringArray, 'logPerformanceTiming', [
            'navigationStart',
            'redirectStart',
            'fetchStart',
            'secureConnectionStart',
            'requestStart',
            'domLoading'
        ]),
        // send midplay events, ever? They will always be send with every logblob
        midplayEnabled: generateSetter(readBool, 'midplayEnabled', true),
        // also, send at least with this interval
        midplayIntervalMilliseconds: generateSetter(readUInt, 'midplayIntervalMilliseconds', 5 * 60 * 1000),
        // send midplay at this points after playback starts
        midplayKeyPoints: generateSetter(readUIntArray, 'midplayKeyPoints', [15000, 30000, 60000, 120000]),
        // dlprestart is a log message that logs timings for this many files that were downloaded before startplay
        dlprestartCount: generateSetter(readUInt, qsok('dlprestartCount'), 0),
        // log when denominator > 0 && (xid % denominator) === 0
        downloadReportDenominator: generateSetter(readUInt, 'downloadReportDenominator', 0),
        // how often dlreports are sent
        downloadReportInterval: generateSetter(readUInt, 'downloadReportInterval', 300000),
        // tcpinfo (from open connect servers response headers) to include
        downloadReportTcpInfo: generateSetter(readStringArray, 'downloadReportTcpInfo', []),
        // interval in milliseconds of download trace
        downloadReportTraceInterval: generateSetter(readUInt, 'downloadReportTraceInterval', 1000),

        // movieid specific bookmark overrides
        bookmarkByMovieId: generateSetter(readStringDictionary, qsok('bookmarkByMovieId'), {}),

        // gets the limited duration license
        limitedDurationLicense: generateSetter(readBool, qsok('limitedDurationLicense'), false),
        // FPS only, requests a challenge from cdm for license renewal. This is set in platform overrides for safari
        licenseRenewalRequestDelay: generateSetter(readUInt, qsok('licenseRenewalRequestDelay'), 0),
        // over writes the value of session param : limitedDuration for EDGE license Request.
        limitedDurationFlagOverride: generateSetter(readBool, qsok('limitedDurationFlagOverride'), undefined),
        // whether CDM performs the secure stop flow.
        secureStopEnabled: generateSetter(readBool, qsok('secureStopEnabled'), false),
        // whether to perform secureStop for persisted keySession
        secureStopFromPersistedKeySession: generateSetter(readBool, qsok('secureStopFromPersistedKeySession'), false),
        // timeout ms to get keymessage event after secure stop data is requested
        secureStopKeyMessageTimeoutMilliseconds: generateSetter(readUInt, 'secureStopKeyMessageTimeoutMilliseconds' , 2000, 1),
        // timeout ms to get keyadded event after keysession.update with server response
        secureStopKeyAddedTimeoutMilliseconds: generateSetter(readUInt, 'secureStopKeyAddedTimeoutMilliseconds' , 1000, 1),

        // timeout ms to get keymessage with secure stop data from persistence
        secureStopPersistedKeyMessageTimeoutMilliseconds: generateSetter(readUInt, qsok('secureStopPersistedKeyMessageTimeoutMilliseconds'), 2500, 1),
        // number of retries for asking for FPS previous key session ID
        secureStopPersistedKeySessionRetries: generateSetter(readUInt, qsok('secureStopPersistedKeySessionRetries'), 17, 1),
        // timeout ms to get key added message if plist keySession ID is not matched and we need to retry
        secureStopPersistedKeyAddedTimeoutUnmatchedSession: generateSetter(readUInt, 'secureStopPersistedKeyAddedTimeoutUnmatchedSession' , 1000, 1),

        // display the logs window on secure stop error. could be used by partners since secure stop error is non fatal.
        secureStopDisplayLogWindowOnError: generateSetter(readBool, qsok('secureStopDisplayLogWindowOnError'), false),
        // Apply this work around as safari throws a video error when we attempt secure stop. This error should not cause any playback issue since the playback has been stopped already
        secureStopIgnoreVideoError: generateSetter(readBool, qsok('secureStopIgnoreVideoError'), false),
        // enable the logic to request a license challenge with a CDM id
        // this should ONLY be used for ChromeOS R26+, this WILL cause other CDM-s to error out
        useCdmId: generateSetter(readBool, qsok('useCdmId'), false),

        // what boxes should be included in initialization segment appended to MSE SourceBuffer
        initSegmentBoxTypeList: generateSetter(readStringArray, 'initSegmentBoxTypeList', ['ftyp', 'moov']),
        // ignore the PSSH boxes with this drmSystemId (make their type "free" so CDM ignores those)
        ignorePsshList: generateSetter(readStringArray, 'ignorePsshList', PLATFORM_CONFIG_DEFAULT$ignorePsshList || []),
        // chrome does not trigger a seeked event if seekPosition is ~150ms before the end of shorter stream.
        workaroundValueForSeekIssue: generateSetter(readUInt, 'workaroundValueForSeekIssue', 0),
        // fix broken [saio] boxes
        workaroundSaio: generateSetter(readBool, 'workaroundSaio', true),
        // fix broken [tenc] boxes
        workaroundTenc: generateSetter(readBool, 'workaroundTenc', true),
        // ensure sampleIsDifferenceSample=false for [tfhd] and [trex] boxes
        workaroundAudioKeyFrame: generateSetter(readBool, qsok('workaroundAudioKeyFrame'), PLATFORM_CONFIG_DEFAULT$workaroundAudioKeyFrame),
        // should the MediaPresenter call endOfStream?
        // current ChromeOS fires "error" if we do, so only call it for GTV
        callEndOfStream: generateSetter(readBool, qsok('callEndOfStream'), PLATFORM_CONFIG_DEFAULT$callEndOfStream),
        // clip long video stream to be less than audio, this is a workaround typically needed when callEndOfStream is trouble
        clipLongVideo: generateSetter(readBool, qsok('clipLongVideo'), PLATFORM_CONFIG_DEFAULT$clipLongVideo),
        // Decide whether to explicitly set the size and position of the
        // video element, currently used for GoogleTV only as they require
        // this behavior.
        setVideoElementSize: generateSetter(readBool, qsok('setVideoElementSize'), PLATFORM_CONFIG_DEFAULT$setVideoElementSize),
        // Workaround to memory leak in chrome, this will set the video.src = undefined  and call video.load() when shutting down the video
        clearVideoSrc: generateSetter(readBool, qsok('clearVideoSrc'), PLATFORM_CONFIG_DEFAULT$clearVideoSrc),
        // workaround IE bug where it would freeze when play or pause is called within ~300 ms of adding license key
        delayPlayPause: generateSetter(readUInt, qsok('delayPlayPause'), 0),
        // do not use SourceBuffer.remove() and assume that source buffer media is automatically evicted by the platform (this is how Chrome R28 and earlier used to be)
        avoidSBRemove: generateSetter(readBool, qsok('avoidSBRemove'), false),
        // prefer using old spec EME. VIDEO.generateKeyRequest instead of new MediaKeys. Chrome implements both, so need to control which one to use.
        preferOldEme: generateSetter(readBool, qsok('preferOldEme'), PLATFORM_CONFIG_DEFAULT$preferOldEme),

        //use promise based new EME
        promiseBasedEme: generateSetter(readBool, qsok('promiseBasedEme'), false),
        captureKeyStatusData: generateSetter(readBool, 'captureKeyStatusData', false),

        // workaround for IE11 bug CAD-882 that causes [PLAY_MSE_DECODER_TIMEOUT: 7353]
        nudgeSourceBuffer: generateSetter(readBool, qsok('nudgeSourceBuffer'), false),
        // when we seek to a key frame, add this many milliseconds to that number
        seekDelta: generateSetter(readInt, qsok('seekDelta'), 1),
        // use precise seeking, by default we seek to the chunk start time.
        preciseSeeking: generateSetter(readBool, qsok('preciseSeeking'), false),
        // In some cases, we should delay handling of an error condition in favor of waiting for a more descriptive one
        // For example, for Safari, we get VIDEO.onerror  before MediaKeySession.onkeyerror, but we prefer onkeyerror because it has detailed systemCode
        // This dictionary maps ErrorCode to delay in milliseconds.
        delayErrorHandling: generateSetter(readStringDictionary, qsok('delayErrorHandling')),
        // safari workaround for error 7363-1260-00003266
        appendInitSegmentAfterLicense: generateSetter(readBool, qsok('appendInitSegmentAfterLicense'), false),

        trackingLogEnabled: generateSetter(readBool, 'trackingLogEnabled', PLATFORM_CONFIG_DEFAULT$trackingLogEnabled),
        trackingLogUrl: generateSetter(readString, 'trackingLogUrl', environmentIsTest ? 'https://customerevents.test.netflix.com/track/debug' : 'https://customerevents.netflix.com/track/debug', IS_URL_REGEX),
        // send playstall at this points
        trackingLogStallKeyPoints: generateSetter(readUIntArray, 'trackingLogStallKeyPoints', [10000, 30000, 60000, 120000]),
        // send regpair requests. Added to debug issues with Chromecast Bladerunner migration
        trackingLogRegPairRequests: generateSetter(readBool, 'trackingLogRegPairRequests', false),

        // use esn from UI if there is none in indexedDb.
        esn: generateSetter(readString, 'esn', ''),

        // Verbose logging of all EME comminication
        enableEmeVerboseLogging: generateSetter(readBool, qsok('enableEmeVerboseLogging'), false),

        // extra logging for safari mse error
        enableLastChunkLogging: generateSetter(readBool, 'enableLastChunkLogging', false),

        // Note: these can be LONG-s, and javascript is limited to 64 doubles (so can't hold more than 53 bits), use strings to represent these
        // appId passed in to edge requests (not part of edge config object, because this is only used by NccpPlayback)
        appId: generateSetter(readString, 'appId', '', UNSIGNED_NUMBER_REGEX),
        // sessionId passed in to edge requests (not part of edge config object, because this is only used by NccpPlayback)
        sessionId: generateSetter(readString, 'sessionId', '', UNSIGNED_NUMBER_REGEX),

        // when supplied, all requests to CDN will be routed through this URL
        // primary purpose is for Quality Control team to redirect the media downloads through their own proxy
        // Example: https://localhost/originalUrl={EURL}, {EURL} will be replaced by esca[ed version of original URL.
        cdnProxyUrl: generateSetter(readString, 'cdnProxyUrl'),


        edge: {
            mslEndpoint: generateSetter(readString, 'mslEndpoint', getEdgeEndpoint(), IS_URL_REGEX),
            edgePath: generateSetter(readString, qsok('edgePath'), '/cbp/cadmium-7'),
            proxyPath: generateSetter(readString, 'proxyPath', ''),
            uiVersion: generateSetter(readString, 'uiVersion'),
            certificationversion: function() {
                return '0';
            },
            preferredlanguages: generateSetter(readStringArray, 'preferredLanguages', DEFAULT_LANGUAGES, /^[a-zA-Z-]{2,5}$/, 1),
            retryOnNetworkFailures: generateSetter(readBool, 'retryOnNetworkFailures', true),
            forceDebugLogLevel: generateSetter(readString, qsok('forceDebugLogLevel'), undefined, /^(ERROR|WARN|INFO|TRACE)$/),
            alwaysIncludeIdsInPlaydata: generateSetter(readBool, 'alwaysIncludeIdsInPlaydata', true),
            secureUrls: generateSetter(readBool, 'secureUrls', PLATFORM_CONFIG_DEFAULT$secureUrls),
            supportPreviewContent: generateSetter(readBool, 'supportPreviewContent', false),
            forceClearStreams: generateSetter(readBool, 'forceClearStreams', false),
            // CAD-3165 When enabled manifest throws a P16 exception if sessionParams.pinCapableClient == 'false'
            // indicating the requested title is PIN protected
            validatePinProtection: generateSetter(readBool, 'validatePinProtection', PLATFORM_CONFIG_DEFAULT$validatePinProtection)
        },

        qc: {
            enabled: generateSetter(readBool, 'qcEnabled', false),
            packageId: generateSetter(readString, 'qcPackageId', '')
        },

        // For NTBA is is unregister auth type (PSK or MGK or NetflixId or ESNH)
        // For MSL, this indicates EntityAuth and Key exchange mechanism. Examples: PSK, MGK, JWEJS_RSA, JWK_RSA, JWK_RSAES
        authenticationType: generateSetter(readString, 'authenticationType', environmentIsTest ? PLATFORM_CONFIG_DEFAULT$authenticationTypeTest : PLATFORM_CONFIG_DEFAULT$authenticationType),
        // Key names used for for key discovery e: encryption, h: hmac, w: wrapping, s: system for key storage.
        authenticationKeyNames: generateSetter(readStringDictionary, 'authenticationKeyNames', mixIn({ 'e': 'DKE', 'h': 'DKH', 'w': 'DKW', 's': 'DKS' }, PLATFORM_CONFIG_DEFAULT$authenticationKeyNames)),
        // What format should we use when wrapping with system key? Empty means to not to wrap, and rely on indexedDB structured clone. Other foramts are "raw" and "jwk"
        systemKeyWrapFormat: generateSetter(readString, 'systemKeyWrapFormat', PLATFORM_CONFIG_DEFAULT$systemKeyWrapFormat),
        // Forces msl headers to include NetflixId in all requests
        includeNetflixIdUserAuthData: generateSetter(readBool, 'includeNetflixIdUserAuthData', true),

        mslDeleteStore: generateSetter(readBool, 'mslDeleteStore', false),
        mslPersistStore: generateSetter(readBool, 'mslPersistStore', true),

        // CAD-3065
        correctNetworkForShortTitles: generateSetter(readBool, 'correctNetworkForShortTitles', true),

        /*
        ==============
          JS-ASE Configs defined in <NRDJS-ROOT>/node-modules/nf-ase/config/defaults.js
        ==============
        */

        // One in how many playbacks should log ASE debug info
        debugAseDenominator: generateSetter(readUInt, qsok('debugAseDenominator'), 100),

        // initialize the ASE manager with these values, set to approximate 240 seconds of buffer except for Chromecast
        aseAudioBufferSizeBytes: generateSetter(readUInt, 'aseAudioBufferSizeBytes', PLATFORM_CONFIG_DEFAULT$aseAudioBufferSizeBytes),
        aseVideoBufferSizeBytes: generateSetter(readUInt, 'aseVideoBufferSizeBytes', PLATFORM_CONFIG_DEFAULT$aseVideoBufferSizeBytes),

        // if a task fails (download task or cdn selection task), next attempt will wait this much
        // after each failure, the index is increased until it reaches last value,
        // index will reset after a successful download
        streamingFailureRetryWaits: generateSetter(readUIntArray, 'streamingFailureRetryWaits', [4000, 8000]),

        minInitVideoBitrate: generateSetter(readUInt, 'minInitVideoBitrate', 560),

        // setting to something low (560); NRDJS uses -Infinity
        minHCInitVideoBitrate: generateSetter(readUInt, 'minHCInitVideoBitrate', 560),

        // setting to something high (65535); NRDJS uses Infinity
        maxInitVideoBitrate: generateSetter(readUInt, 'maxInitVideoBitrate', 1050),

        // setting to something low (0); NRDJS uses -Infinity
        minInitAudioBitrate: generateSetter(readUInt, 'minInitAudioBitrate', 0),

        // setting to something low (0); NRDJS uses -Infinity
        minHCInitAudioBitrate: generateSetter(readUInt, 'minHCInitAudioBitrate', 0),

        // setting to something high (65535); NRDJS uses Infinity
        maxInitAudioBitrate: generateSetter(readUInt, 'maxInitAudioBitrate', 65535),

        minAcceptableVideoBitrate: generateSetter(readUInt, 'minAcceptableVideoBitrate', 235),

        minRequiredBuffer: generateSetter(readUInt, 'minRequiredBuffer', 30000),

        minPrebufSize: generateSetter(readUInt, 'minPrebufSize', 7800),

        rebufferingFactor: generateSetter(readFloat, 'rebufferingFactor', 1.0),

        // can we download the minPrebufSize amount of data for the given bitrate in maxBufferingTime milliseconds
        maxBufferingTime: generateSetter(readUInt, 'maxBufferingTime', 2600),

        useMaxPrebufSize: generateSetter(readBool, 'useMaxPrebufSize', true),

        maxPrebufSize: generateSetter(readUInt, 'maxPrebufSize', 60000),

        // Example config for carrera curve:  "[{"d" : 2000, "r" : 6000},{"d" : 5000, "r": 1050}, {"d" : 8000, "r": 560}]"
        // Example of setting this via fast properties:
        // "initialBitrateSelectionCurve":"{\"d\": 2000,\"r\": 6000} | {\"d\": 5000,\"r\": 1050}"
        initialBitrateSelectionCurve: generateSetter(readObjectArray, 'initialBitrateSelectionCurve', null),

        // setting to something low (560); NRDJS uses -Infinity
        initSelectionLowerBound: generateSetter(readUInt, 'initSelectionLowerBound', 560),

        // setting to something high (1050); NRDJS uses +Infinity
        initSelectionUpperBound: generateSetter(readUInt, 'initSelectionUpperBound', 1050),

        throughputPercentForAudio: generateSetter(readUInt, 'throughputPercentForAudio', 15),

        bandwidthMargin: generateSetter(readUInt, 'bandwidthMargin', 10),

        bandwidthMarginCurve:  generateSetter(readObjectArray, 'bandwidthMarginCurve', [
            {"m": 70, "b": 8000},
            {"m": 70, "b": 30000},
            {"m": 50, "b": 60000},
            {"m": 47, "b": 90000},
            {"m": 40, "b": 120000},
            {"m": 20, "b": 180000},
            {"m": 5, "b": 240000}]),

        /*
        ASE-22 (Switching Bandwidth Margin based on Average Throughput)
        When lower thorughput is measured,
        a more conservative discount (and curve) is applied to the predicted throughput in calculating the available throughput
        */
        conservBandwidthMargin: generateSetter(readUInt, 'conservBandwidthMargin', 20),

        conservBandwidthMarginTputThreshold: generateSetter(readUInt, 'conservBandwidthMarginTputThreshold', 2000),

        conservBandwidthMarginCurve: generateSetter(readObjectArray, 'conservBandwidthMarginCurve', [
            {"m": 80, "b": 8000},
            {"m": 80, "b": 30000},
            {"m": 70, "b": 60000},
            {"m": 60, "b": 90000},
            {"m": 50, "b": 120000},
            {"m": 30, "b": 180000},
            {"m": 10, "b": 240000}]),

        bandwidthMarginScaledRatioUpperBound: generateSetter(readFloat, 'bandwidthMarginScaledRatioUpperBound', 2.0),

        // Set it to 0 would disable the config
        maxTotalBufferLevelPerSession: generateSetter(readUInt, 'maxTotalBufferLevelPerSession', 0),

        highWatermarkLevel: generateSetter(readUInt, 'highWatermarkLevel', 30000),

        toStableThreshold: generateSetter(readUInt, 'toStableThreshold', 30000),

        toUnstableThreshold: generateSetter(readUInt, 'toUnstableThreshold', 15000),

        skipBitrateInUpswitch: generateSetter(readBool, 'skipBitrateInUpswitch', true),

        watermarkLevelForSkipStart: generateSetter(readUInt, 'watermarkLevelForSkipStart', 8000),

        highStreamRetentionWindow:  generateSetter(readUInt, 'highStreamRetentionWindow', 90000),

        highStreamTransitionWindow:  generateSetter(readUInt, 'highStreamTransitionWindow', 300000),

        lowestBufForUpswitch:  generateSetter(readUInt, 'lowestBufForUpswitch', 25000),

        lockPeriodAfterDownswitch:  generateSetter(readUInt, 'lockPeriodAfterDownswitch', 15000),

        lowWatermarkLevel:  generateSetter(readUInt, 'lowWatermarkLevel', 25000),

        maxSimuLength:  generateSetter(readUInt, 'maxSimuLength', 10 /* minutes */ * 60 * 1000),

        lowestWaterMarkLevel:  generateSetter(readUInt, 'lowestWaterMarkLevel', 6000),

        mediaRate: generateSetter(readFloat, 'mediaRate', 1),

        maxTrailingBufferLen: generateSetter(readUInt, 'maxTrailingBufferLen', 10000),

        audioBufferTargetAvailableSize: generateSetter(readUInt, 'audioBufferTargetAvailableSize', 256 * 1024),

        videoBufferTargetAvailableSize: generateSetter(readUInt, 'videoBufferTargetAvailableSize', 1024 * 1024),

        maxVideoTrailingBufferSize: generateSetter(readUInt, 'maxVideoTrailingBufferSize', 8 * 1024 * 1024),

        maxAudioTrailingBufferSize: generateSetter(readUInt, 'maxAudioTrailingBufferSize', 384 * 1024),

        fastUpswitchFactor: generateSetter(readFloat, 'fastUpswitchFactor', 3.0),

        maxMediaBufferAllowed: generateSetter(readUInt, 'maxMediaBufferAllowed', 4 * 60 * 1000),

        simulatePartialBlocks: generateSetter(readBool, 'simulatePartialBlocks', true),

        simulateBufferFull: generateSetter(readBool, 'simulateBufferFull', true),

        considerConnectTime: generateSetter(readBool, 'considerConnectTime', false),

        connectTimeMultiplier: generateSetter(readFloat, 'connectTimeMultiplier', 1.0),

        /* Location Selector Configs */

        lowGradeModeEnterThreshold: generateSetter(readUInt, 'lowGradeModeEnterThreshold', 120 * 1000),

        lowGradeModeExitThreshold: generateSetter(readUInt, 'lowGradeModeExitThreshold', 90 * 1000),

        maxDomainFailureWaitDuration: generateSetter(readUInt, 'maxDomainFailureWaitDuration', 30 * 1000),

        maxAttemptsOnFailure: generateSetter(readUInt, 'maxAttemptsOnFailure', 18),

        exhaustAllLocationsForFailure: generateSetter(readBool, 'exhaustAllLocationsForFailure', true),

        maxNetworkErrorsDuringBuffering: generateSetter(readUInt, 'maxNetworkErrorsDuringBuffering', 20),

        maxBufferingTimeAllowedWithNetworkError: generateSetter(readUInt, 'maxBufferingTimeAllowedWithNetworkError', 60 * 1000),

        fastDomainSelectionBwThreshold: generateSetter(readUInt, 'fastDomainSelectionBwThreshold', 2000),

        throughputProbingEnterThreshold: generateSetter(readUInt, 'throughputProbingEnterThreshold', 40 * 1000),

        throughputProbingExitThreshold: generateSetter(readUInt, 'throughputProbingExitThreshold', 34 * 1000),

        locationProbingTimeout: generateSetter(readUInt, 'locationProbingTimeout', 10 * 1000),

        finalLocationSelectionBwThreshold: generateSetter(readUInt, 'finalLocationSelectionBwThreshold', 10 * 1000),

        throughputHighConfidenceLevel: generateSetter(readFloat, 'throughputHighConfidenceLevel', 0.75),

        throughputLowConfidenceLevel: generateSetter(readFloat, 'throughputLowConfidenceLevel', 0.4),

        locationStatisticsUpdateInterval: generateSetter(readUInt, 'locationStatisticsUpdateInterval', 60000),

        countGapInBuffer: generateSetter(readBool, 'countGapInBuffer', false), // a temp config for testing CAD-2878

        // CAD-2882
        allowReissueMediaRequestAfterAbort: generateSetter(readBool, 'allowReissueMediaRequestAfterAbort', true),

        // When currentPts is in the middle of a chunk, NRDJS take the whole chunk into the buffer level calculation
        // However, since Cadmium's chunk can be as big as 16 seconds, this bloated calculation can be misleading when driving the pipeline
        preciseBufferCalculation: generateSetter(readBool, 'preciseBufferCalculation', true),

        // allow calls to stream selector even when there is no pipeline vacancy
        // first use is for Cadmium to get a signal on when a bitrate becomes unfeasible
        allowCallToStreamSelector: generateSetter(readBool, 'allowCallToStreamSelector', true),

        // ASE: buffer level threshold below which ASE will signal the native layer to abort
        bufferThresholdForAbort: generateSetter(readUInt, 'bufferThresholdForAbort', 10000),

        /* Streaming Manager Configs */

        //=========================================================================
        // From streaming manager
        //=========================================================================

        pipelineScheduleTimeoutMs: generateSetter(readUInt, 'pipelineScheduleTimeoutMs', 2),

        // Max number of partial requests when buffering
        maxPartialBuffersAtBufferingStart: generateSetter(readUInt, 'maxPartialBuffersAtBufferingStart', 2),

        // Min/Max partial buffer duration
        minPendingBufferLen: generateSetter(readUInt, 'minPendingBufferLen', 6000),
        maxPendingBufferLen: generateSetter(readUInt, 'maxPendingBufferLen', 12000),

        // Don't allow one pipeline to get too far ahead of the other
        maxStreamingSkew: generateSetter(readUInt, 'maxStreamingSkew', 4000),

        // Percent of partial buffers allowed
        maxPendingBufferPercentage: generateSetter(readUInt, 'maxPendingBufferPercentage', 10),

        // Max number of requests - 4 minutes with 4 seconds per buffer
        maxRequestsInBuffer: generateSetter(readUInt, 'maxRequestsInBuffer', 60),

        // size to read for header request
        headerRequestSize: generateSetter(readUInt, 'headerRequestSize', 4096),

        // minimum buffer length for opportunistic header downloading
        minBufferLenForHeaderDownloading: generateSetter(readUInt, 'minBufferLenForHeaderDownloading', 10000),

        // max time of skip back buffer to hold requests for
        reserveForSkipbackBufferMs: generateSetter(readUInt, 'reserveForSkipbackBufferMs', 10 * 1000),

        // enable / disable parallel streaming with pipelining
        pipelineEnabled: generateSetter(readBool, 'pipelineEnabled', false),

        // default socket receive buffer size
        socketReceiveBufferSize: generateSetter(readUInt, 'socketReceiveBufferSize', 0),

        // TODO: need to hook up with system capability
        // audio socket receive buffer size
        audioSocketReceiveBufferSize: generateSetter(readUInt, 'audioSocketReceiveBufferSize', 32768),

        // video socket receive buffer size
        videoSocketReceiveBufferSize: generateSetter(readUInt, 'videoSocketReceiveBufferSize', 65536),

        // header socket receive buffer size
        headersSocketReceiveBufferSize: generateSetter(readUInt, 'headersSocketReceiveBufferSize', 32768),

        // interval to check for pts changes
        // Ideally, we should make it track - Math$min(config.videoChunkSizeMilliseconds, config.audioChunkSizeMilliseconds)/2
        updatePtsIntervalMs: generateSetter(readUInt, 'updatePtsIntervalMs', Math$min(videoChunkSizeMilliseconds, audioChunkSizeMilliseconds)/2),

        // interval to notify buffer levels
        // Ideally, we should make it track - Math$min(config.videoChunkSizeMilliseconds, config.audioChunkSizeMilliseconds)/2
        bufferLevelNotifyIntervalMs: generateSetter(readUInt, 'bufferLevelNotifyIntervalMs', Math$min(videoChunkSizeMilliseconds, audioChunkSizeMilliseconds)/2),

        // enable abandon testing
        enableAbortTesting: generateSetter(readBool, 'enableAbortTesting', false),

        // abandon's every Nth request
        abortRequestFrequency: generateSetter(readUInt, 'abortRequestFrequency', 8),

        // interval to log streaming statistics
        streamingStatusIntervalMs: generateSetter(readUInt, 'streamingStatusIntervalMs', 2000),

        // After this time elapses while prebuffering, start playback
        prebufferTimeLimit:  generateSetter(readUInt, 'prebufferTimeLimit', 240 * 1000),

        // Minimum video buffer level required for an audio track switch
        minBufferLevelForTrackSwitch: generateSetter(readUInt, 'minBufferLevelForTrackSwitch', 2000),

        // Parameters to adjust buffering when encoutering long delay or network errors
        penaltyFactorForLongConnectTime:  generateSetter(readUInt, 'penaltyFactorForLongConnectTime', 2),
        longConnectTimeThreshold:  generateSetter(readUInt, 'longConnectTimeThreshold', 200),
        additionalBufferingLongConnectTime: generateSetter(readUInt, 'additionalBufferingLongConnectTime', 2000),
        additionalBufferingPerFailure:  generateSetter(readUInt, 'additionalBufferingPerFailure', 8000),

        // Buffering complete rebuffer check duration
        rebufferCheckDuration: generateSetter(readUInt, 'rebufferCheckDuration', 60000),

        // Enable lookahead hints for Open Connect
        enableLookaheadHints: generateSetter(readBool, 'enableLookaheadHints', false),

        // Number of fragments to provide as a lookahead hint to OC
        lookaheadFragments: generateSetter(readUInt, 'lookaheadFragments', 2),

        // Test: update drm header requests on network failure
        updateDrmRequestOnNetworkFailure: generateSetter(readBool, 'updateDrmRequestOnNetworkFailure', false),

        deferAseScheduling: generateSetter(readBool, 'deferAseScheduling', false),

        //CAD-2787: handling the case where Audio Stream and Video Stream has different length
        maxDiffAudioVideoEndPtsMs: generateSetter(readUInt, 'maxDiffAudioVideoEndPtsMs', Math$max(videoChunkSizeMilliseconds, audioChunkSizeMilliseconds)),

        //=========================================================================
        // Header cache
        //=========================================================================

        // default header cache size
        defaultHeaderCacheSize: generateSetter(readUInt, 'defaultHeaderCacheSize', 4),

        // default header cache data count
        defaultHeaderCacheDataCount: generateSetter(readUInt, 'defaultHeaderCacheDataCount', 3),

        // maximum number of pending streams when paused for data cache
        headerCacheMaxPendingData: generateSetter(readUInt, 'headerCacheMaxPendingData', 6),

         // Recreates the header cache's download track after adopted requests are complete
        recreateHeaderCacheDownloadTracks: generateSetter(readBool, 'recreateHeaderCacheDownloadTracks', true),

        // Limit of priority for header cache items fetched
        headerCachePriorityLimit: generateSetter(readUInt, 'headerCachePriorityLimit', 5),

        // Flush header cache data after adoption
        headerCacheFlushForCircularBuffer: generateSetter(readBool, 'headerCacheFlushForCircularBuffer', true),

        // NRDJS-4301
        enableUsingHeaderCount: generateSetter(readBool, 'enableUsingHeaderCount', false),

        //=========================================================================
        // Network failures
        //=========================================================================

        // How long to wait before resetting the network to a non-failed state
        // after a temporary failure
        networkFailureResetWaitMs: generateSetter(readUInt, 'networkFailureResetWaitMs', 2 * 1000),

        // With no progress for this long, call the temporary network failure
        // permanent
        networkFailureAbandonMs: generateSetter(readUInt, 'networkFailureAbandonMs', 60 * 1000),

        // When error directory is throttling server failures, it counts up this
        // number for each server before reporting the error to location selector
        // NRDJS-2332
        maxThrottledNetworkFailures: generateSetter(readUInt, 'maxThrottledNetworkFailures', 3),

        // Errors that are throttled by error director and happen more frequently
        // than this for each server are suppressed
        // NRDJS-2332
        throttledNetworkFailureThresholdMs: generateSetter(readUInt, 'throttledNetworkFailureThresholdMs', 200),

        // NRDJS-2498: enable the feature which aborts the blocks that have not started
        //
        abortUnsentBlocks: generateSetter(readBool, 'abortUnsentBlocks', false),

        // NRDJS-3939: limit the number of unsent blocks when abortUnsentBlocks is true
        maxUnsentBlocks: generateSetter(readUInt, 'maxUnsentBlocks', 2),

        // a threshold to classify the player's throughput to be too low
        lowThroughputThreshold: generateSetter(readUInt, 'lowThroughputThreshold', 400),

        // ----------------
        // Needed by Cadmium
        // ----------------
        mp4ParsingInNative: generateSetter(readBool, 'mp4ParsingInNative', true),

        sourceBufferInOrderAppend: generateSetter(readBool, 'sourceBufferInOrderAppend', false),

        allowAudioToStreamPastVideo: generateSetter(readBool, 'allowAudioToStreamPastVideo', true),

        pruneRequestsFromNative:  generateSetter(readBool, 'pruneRequestsFromNative', true),

        // CAD-2570:
        preciseBufferLevel: generateSetter(readBool, 'preciseBufferLevel', false),

        // NRDJS-3425: enable to collect debug messages
        enableManagerDebugTraces: generateSetter(readBool, "enableManagerDebugTraces", false),
        managerDebugMessageInterval: generateSetter(readUInt, "managerDebugMessageInterval", 1000),
        managerDebugMessageCount: generateSetter(readUInt, "managerDebugMessageCount", 20),

        // NRDJS-4273: Clean up after verifying in the field
        notifyManifestCacheEom: generateSetter(readBool, "notifyManifestCacheEom", false),

        bufferThresholdToSwitchToSingleConnMs: generateSetter(readUInt, 'bufferThresholdToSwitchToSingleConnMs', 180000),

        bufferThresholdToSwitchToParallelConnMs: generateSetter(readUInt, 'bufferThresholdToSwitchToParallelConnMs', 120000),

        //ASE-5: periodic save of network and location history
        periodicHistoryPersistMs: generateSetter(readUInt, 'periodicHistoryPersistMs', 5 * 60 * 1000),

        //=========================================================================
        // ASE Network Monitor Configs
        //=========================================================================
        expandDownloadTime: generateSetter(readBool, 'expandDownloadTime', true),
        minimumMeasurementTime: generateSetter(readUInt, 'minimumMeasurementTime', 500),
        minimumMeasurementBytes: generateSetter(readUInt, 'minimumMeasurementBytes', 128 * 1024),
        throughputMeasurementTimeout: generateSetter(readUInt, 'throughputMeasurementTimeout' , 2000),
        initThroughputMeasureDataSize:  generateSetter(readUInt, 'initThroughputMeasureDataSize' , 256 * 1024),
        throughputMeasureWindow: generateSetter(readUInt, 'throughputMeasureWindow' , 5000),
        throughputIQRMeasureWindow: generateSetter(readUInt, 'throughputIQRMeasureWindow' , 5000),
        connectTimeHalflife: generateSetter(readUInt,  'connectTimeHalflife' , 10),
        responseTimeHalflife: generateSetter(readUInt, 'responseTimeHalflife' , 10),
        historicBandwidthUpdateInterval: generateSetter(readUInt, 'historicBandwidthUpdateInterval' , 2000),
        throughputMeasurementWindowCurve: generateSetter(readObjectArray, 'throughputMeasurementWindowCurve' , null),
        throughputWarmupTime: generateSetter(readUInt, 'throughputWarmupTime' , 5000),
        throughputWarmupMode: generateSetter(readString,  'throughputWarmupMode', 'initialize'),
        minimumBufferToStopProbing: generateSetter(readUInt, 'minimumBufferToStopProbing', 10000),
        enableDecayInThroughputEstimate: generateSetter(readBool, 'enableDecayInThroughputEstimate', true),
        throughputPredictor: generateSetter(readString, 'throughputPredictor', 'ewma'),
        holtWintersDiscretizeInterval: generateSetter(readUInt, 'holtWintersDiscretizeInterval', 500), //ms
        holtWintersHalfLifeAlpha: generateSetter(readUInt, 'holtWintersHalfLifeAlpha', 6700), // halfLife in ms
        holtWintersHalfLifeGamma: generateSetter(readUInt, 'holtWintersHalfLifeGamma', 6700), // halfLife in ms
        holtWintersInitialCounts: generateSetter(readUInt, 'holtWintersInitialCounts', 3),
        holtWintersMinInitialCounts: generateSetter(readUInt, 'holtWintersMinInitialCounts', 3),
        holtWintersHalfLifeCurveEnabled: generateSetter(readBool, 'holtWintersHalfLifeCurveEnabled', false),
        holtWintersUpperBoundEnabled: generateSetter(readBool, 'holtWintersUpperBoundEnabled', false),


        //=========================================================================
        // Various debug options
        //=========================================================================

        // Choosing different stream selection algorithms
        ase_stream_selector: generateSetter(readString, 'ase_stream_selector', 'optimized'),

        // Choose a different function for the initial bitrate selection
        initBitrateSelectorAlgorithm: generateSetter(readString, 'initBitrateSelectorAlgorithm', 'default'),

        // Failure simulation for location selector
        debugLocationSelectorFailureSimulation: generateSetter(readString, 'ase_ls_failure_simulation', ''),

        // Wheter manager dumps out fragments
        debugDumpFragments: generateSetter(readBool, 'ase_dump_fragments', false),

        // Fake throughput in Kbps to use for location history
        debugLocationHistoryThroughput: generateSetter(readUInt, 'ase_location_history', 0),

        // Fake throughput in Kbps to use for network monitor
        debugNetworkMonitorThroughput: generateSetter(readUInt, 'ase_throughput', 0),

        // Whether simulation should be verbose
        debugVerboseSimulation: generateSetter(readBool, 'ase_simulate_verbose', false)
    };

    if (DEBUG || DEV) {
        setters.persistLogs = generateSetter(readBool, 'persistLogs', true);

        // see comments in logToRemote.js on how to use this
        setters.logToRemoteUrl = generateSetter(readString, 'logToRemoteUrl');
        setters.logToRemoteLevel = generateSetter(readUInt, 'logToRemoteLevel', 3);

        setters.mockPluginUrl = generateSetter(readString, 'mockPluginUrl', config$_thisScriptRoot + (NRDDPI ? 'MockNrdDpiPlugin.js' : 'MockPepperCryptoPlugin.js'));

        setters.deviceId = generateSetter(readString, 'deviceId');

        // add special config functionality for DEBUG (or DEV) builds
        setters.clearKeys = generateSetter(readStringDictionary, 'clearKeys', {
            // movieId: 70136810
            '959971662': 'h2mqp1zAJjDIC34YXEXBxA==',
            // movieId: 70177330
            '960156696': 'pNGm/kY9t9u8+A8LyB2oXA==',
            // movieId: 70204286
            '960201990': 'xUlaYur7MKT2gpqaPXo/JA==',
            // movieId: 70229094
            '960318604': '4A84I/Nuzb+XCkTlYOz0sQ==',
            // movieId: 70229098
            '960318775': 'mKrVZmTNBY82DatdHXDmGQ==',
            // movieId: 70229095
            '960318500': 'hgwWotNPt00VkC6FjKMwFw==',
            // movieId: 70229096
            '960318534': 'EFgD5peGgL8JBltpRpZKLA==',
            // movieId: 70250215 (ShowId: 70250385)
            '960388532': 'S/7rM9O/cyGJ1oFdOtktIg==',
            // movieId: 70250216 (ShowId: 70250385)
            '960388556': 'kIZgrdna8UkLaMSwkFGnPw==',
            // movieId: 70250217 (ShowId: 70250385)
            '960388544': 'KgbGkNTgrWvKGhGnmVznow==',
            // movieId: 70259776
            '960439467': 'cdXq7+vkD70r8AWRWdOUkA==',
            // movieId: 70259774
            '960439464': 'l1byPKfv6/hZEUSeILA6hw=='
        });
        // this only applies to clearkey drm, where we make a mock licnese request with hardcoded challenge. This indicates which type of hardcoded challenge to use
        setters.clearKeyMockDrmType = generateSetter(readString, 'clearKeyMockDrmType', 'playready', /^(playready|widevine)$/);


        setters.audioProfiles = function (orig, v) {
            return coalesce(readStringArray('audioProfiles', orig(v), undefined, 1));
        }.bind(setters, setters.audioProfiles);

        // HD prifles 'playready-h264mpl31-dash', add this to the list bellow to use them
        setters.videoProfiles = function (orig, v) {
            return coalesce(readStringArray('videoProfiles', orig(v), undefined, 1));
        }.bind(setters, setters.videoProfiles);

        // To enable positional, replace this with 'dfxp-ls-sdh', also see renderTimedText flag

        setters.timedTextProfiles = function (orig, v) {
            return coalesce(readStringArray('timedTextProfiles', orig(v), undefined, 0));
        }.bind(setters, setters.timedTextProfiles);

        setters.logDisplayAutoshowLevel = generateSetter(readInt, 'logDisplayAutoshowLevel', LogLevel['WARN'], -1, LogLevel['MAX']);

        setters.enforceSinglePlayback = generateSetter(readBool, 'enforceSinglePlayback', setters.enforceSinglePlayback.call());
        setters.enforceSingleSession = generateSetter(readBool, 'enforceSingleSession', setters.enforceSingleSession.call());

        setters.mockNccp = generateSetter(readBool, 'mocknccp', false);
        setters.mockPlayer = generateSetter(readBool, 'mockplayer', false);
        debug$breakOnError = readBool('breakOnError', false);
    }


    var initialConfig = true;
    // input: s: setters , target
    var _configApply = function (s, target) {
        enumerateOwnProperties(s, function (k, v) {
            if (isFunction(v)) {
                target[k] = v.call(undefined, target[k]);
            } else if (isObject(v)) {
                target[k] = target[k] || {};
                _configApply(v, target[k]);
            }
        });
    };

    config$apply = function (params) {
        debug$assert(params);
        if (!params) return;

        initParams = mixIn({}, params, { makeLowerCase: true });

        _configApply(setters, config);
        log.trace('Config applied for', formatOverridesForLog(initialConfig ? initParams : params));
        initialConfig = false;
    };

    config$apply(initParams);

    // --------------------------------------------------------------------------------
    // -- helper methods

    function parseInitParams() {
        // combine all arguments into one initParams list
        // arguments can either be a ready object, or a 'a=123,b=3,cc=1|3,d=hello'

        initParams = {};

        // start with baked-in config
        mixIn(initParams, PLATFORM_CONFIG_OVERRIDES);

        function applyConfigString(configString) {
            configString.split(',').forEach(function (kvp) {
                var i = kvp.indexOf('=');
                if (i > 0) {
                    initParams[kvp.substring(0, i).toLowerCase()] = kvp.substring(i + 1);
                }
            });
        }

        if (videoSessionArguments && videoSessionArguments.length) {
            forEach.call(videoSessionArguments, function (arg) {
                if (isString(arg)) {
                    // argument is a comma seperated name=value pairs
                    applyConfigString(arg);
                } else if (isObject(arg)) {
                    // argument is an object, use it as it is
                    mixIn(initParams, arg, { makeLowerCase: true });
                }
            });
        }

        // parse the query string into a special bucked
        queryStringInitParams = mixIn({}, getQueryString(), { makeLowerCase: true });

        // pick up cookie-based config overrides
        var overrideCookie = readCookies()['cadmiumconfig'];
        if (overrideCookie) {
            log.info('Config cookie loaded', overrideCookie);
            applyConfigString(overrideCookie);
        }

        if (DEBUG || DEV || ALLOW_QUERY_STRING_CONFIG_OVERRIDES) {
            // we allow config overrides in query string for ALL config values
            // in DEV or DEBUG or builds
            // also, if the ALLOW_QUERY_STRING_CONFIG_OVERRIDES is set

            // pick up ALL config overrides from query string
            mixIn(initParams, queryStringInitParams);
        }

        //if (DEBUG || DEV) {
            if (readString('drmType') == 'clearkey' && !initParams['keysystemid']) {
                // support legacy config: drmType==clearkey
                // this is parsed into array later
                var prefix = (window['WebKitMediaKeys'] || HTMLVideoElement.prototype['webkitGenerateKeyRequest']) ? 'webkit-' : HTMLVideoElement.prototype['msSetMediaKeys'] ? 'ms-' : '';
                initParams['keysystemid'] = prefix + 'org.w3.clearkey';
            }
        //}
    }

    /**
    * QueryString config override is ok
    * allow config overrides from query string, even for release builds
    */
    function qsok(name) {
        // copy this specific one into the init params
        name = name.toLowerCase();
        if (queryStringInitParams.hasOwnProperty(name)) {
            initParams[name] = queryStringInitParams[name];
        }
        return name;
    }

    /**
    * @param {string} name
    */
    function read(name, defaultValue, parse) {
        name = name.toLowerCase();
        if (initParams.hasOwnProperty(name)) {
            var v = initParams[name];
            try {
                v = parse ? parse(v) : v;
            }
            catch (e) {
                v = undefined;
            }
            if (v !== undefined) {
                return v;
            } else {
                debug$assert(false);
                log.error('Invalid configuration value. Name: ' + name);
            }
        }
        return defaultValue;
    }

    /**
    * @param {number=} min
    * @param {number=} max
    */
    function readInt(name, defaultValue, min, max) {
        return read(name, defaultValue, function (v) {
            if (isString(v)) {
                v = parseInt10(v);
            }
            if (isInt(v, min, max)) {
                return v;
            }
        });
    }

    /**
    * @param {number=} min
    * @param {number=} max
    */
    function readUInt(name, defaultValue, min, max) {
        return read(name, defaultValue, function (v) {
            if (isString(v)) {
                v = parseInt10(v);
            }
            if (isUInt(v, min, max)) {
                return v;
            }
        });
    }

    /**
* @param {number=} min
* @param {number=} max
*/
    function readFloat(name, defaultValue, min, max) {
        return read(name, defaultValue, function (v) {
            if (isString(v)) {
                v = parseFloat(v);
            }
            if (isNumber(v, min, max)) {
                return v;
            }
        });
    }



    /**
    * @param {string=} defaultValue
    * @param {Object=} regex
    */
    function readString(name, defaultValue, regex) {
        return read(name, defaultValue, function (v) {
            if (regex ? regex.test(v) : isString(v)) {
                return v;
            }
        });
    }

    function readBool(name, defaultValue) {
        return read(name, defaultValue, function (v) {
            if (v == 'true' || v === true) {
                return true;
            } else if (v == 'false' || v === false) {
                return false;
            }
        });
    }

    function readObject(name, defaultValue) {
        return read(name, defaultValue, function (v) {
            // object can either be escaped JSON, or an actual object
            if (isString(v)) {
                return JSON.parse(unescape(v));
            } else if (isObject(v)) {
                return v;
            }
        });
    }

    /**
    * @param {number|undefined=} min
    * @param {number|undefined=} max
    * @param {number|undefined=} minArrayLength
    */
    function parseUIntArray(v, min, max, minArrayLength) {
        v = v.split('|');
        var i = v.length;
        while (i--) {
            v[i] = parseInt10(v[i]);
            if (!isUInt(v[i], min, max)) {
                return;
            }
        }
        if (minArrayLength === undefined || v.length >= minArrayLength) {
            return v;
        }
    }

    /**
    * @param {number|undefined=} min
    * @param {number|undefined=} max
    * @param {number|undefined=} minArrayLength
    */
    function readUIntArray(name, defaultValue, min, max, minArrayLength) {
        return read(name, defaultValue, function (v) {
            return parseUIntArray(v, min, max, minArrayLength);
        });
    }

    /**
    * @param {number|undefined=} min
    * @param {number|undefined=} max
    * @param {number|undefined=} subArrayLength
    * @param {number|undefined=} minArrayLength
    */
    function readUIntArrayOfArrays(name, defaultValue, min, max, subArrayLength, minArrayLength) {
        return read(name, defaultValue, function (v) {
            v = v.split(';');
            var i = v.length;
            while (i--) {
                v[i] = parseUIntArray(v[i], min, max);
                if (v[i] === undefined || v[i].length != subArrayLength) {
                    return;
                }
            }
            if (minArrayLength === undefined || v.length >= minArrayLength) {
                return v;
            }
        });
    }

    /**
    * @param {*=} regex
    * @param {number|undefined=} minArrayLength
    */
    function readObjectArray(name, defaultValue, regex, minArrayLength) {
        name = name.toLowerCase();
        // if there is value from init params, parse it
        if (initParams.hasOwnProperty(name)) {
            var v = initParams[name];
            v = isArray(v) ? v : v.split('|');
            var i = v.length;
            while (i--) {
                if (isString(v[i])) {
                    v[i] = JSON.parse(unescape(v[i]));
                } else {
                    debug$assert(false);
                    log.error('Invalid configuration value.');
                    return defaultValue;
                }
            }
            return v;
        } else {
            return defaultValue;
        }
    };

    /**
     * @param {*=} regex
     * @param {number|undefined=} minArrayLength
     */
    function readStringArray(name, defaultValue, regex, minArrayLength) {
        return read(name, defaultValue, function (v) {
            v = isArray(v) ? v : v.split('|');
            var i = v.length;
            while (i--) {
                if (!(regex ? regex.test(v[i]) : isValidString(v[i]))) {
                    return;
                }
            }
            if (minArrayLength === undefined || v.length >= minArrayLength) {
                return v;
            }
        });
    }

    /**
     * @param {*=} regex
     */
    function readStringDictionary(name, defaultValue, regex) {
        return read(name, defaultValue, function (v) {
            var o = {};

            mixIn(o, defaultValue);

            if (isString(v)) {

                var a = v.split(';'),
                    i = a.length;

                while (i--) {
                    var kvp = a[i],
                        indexOfSeperator = kvp.indexOf(':');
                    if (indexOfSeperator <= 0) {
                        return;
                    }
                    var k = kvp.substring(0, indexOfSeperator),
                        val = kvp.substring(indexOfSeperator + 1);
                    if (val) {
                        if (regex && !regex.test(val)) {
                            return;
                        }
                        o[k] = val;
                    } else {
                        delete o[k];
                    }
                }

            } else {

                mixIn(o, v);

            }

            return o;
        });
    }

    function formatOverridesForLog(overrides) {
        var readableConfigOverrides = [];
        enumerateOwnProperties(overrides, function (k, v) {
            var s;
            try {
                s = JSON.stringify(v);
            } catch (e) {
                s = 'cantparse';
            }
            readableConfigOverrides.push(k + '=' + s);
        });
        return readableConfigOverrides.join('\n');
    }
}

function config$bookmarkToMilliseconds(value, duration) {
    if (isString(value) && value[value.length - 1] == '%') {
        return Math$round(parseFloat(value) * duration / 100);
    }
    return (value|0);
}

var config$_thisScriptRoot = '';
if ((DEBUG || DEV) && !NO_SCRIPT_TAG) {
    try {
        // script are executed in order, we should be the last one in the list
        // take the src of that and strip the file name
        config$_thisScriptRoot = (pop.call(document['getElementsByTagName']('script')))['src']['replace'](/[^\/\\]*$/, '');
    } catch (e) {
    }
}



// -- diagnostics/mainThreadMonitor.js
var mainThreadMonitor;

loadAsync$register(ErrorCodes.INIT_COMPONENT_MAINTHREADMONITOR, function asyncLoadMainThreadMonitor(callback) {
    // poll the UI thread mainThreadMonitorPollRate per second
    // and record stalls
    // stall is when we try to invoke mainThreadMonitorPollRate per second, but only end up 
    // invoking x times. Best case: [x == mainThreadMonitorPollRate], worst: [x == 0].

    var mainThreadMonitorPollRate = config.mainThreadMonitorPollRate;

    // precalculate the ration for scaling numOfCallbacks from (2, mainThreadMonitorPollRate - 2) to (7, 1)
    var scaleFrom1 = 2,
        scaleFrom2 = mainThreadMonitorPollRate - 2,
        scaleTo1 = 7, 
        scaleTo2 = 1,
        scaleRatio = (scaleTo2 - scaleTo1) / (scaleFrom2 - scaleFrom1);

    if (isPositiveInt(mainThreadMonitorPollRate)) {
        var INTERVAL = MILLISECONDS_PER_SECOND,
            MAX_HISTORY = 30;

        function _now() {
            return Math$floor(clock$getTime() / INTERVAL);
        };

        var _history = [],
            _lastEntry = _now();

        function _onInterval() {
            var now = _now();
            if (now != _lastEntry) {
                var newEntries = Math$min(now - _lastEntry, MAX_HISTORY);
                while (newEntries--) {
                    _history.push(0);
                }
                var oldEntries = Math$max(_history.length - (MAX_HISTORY + 1), 0);
                if (oldEntries) {
                    _history.splice(0, oldEntries);
                }
                _lastEntry = now;
            }
            _history[_history.length - 1]++;
        };

        setInterval(_onInterval, 1000 / mainThreadMonitorPollRate);

        mainThreadMonitor = {
            getHistory: function () {
                var a = [];
                // skip last one
                var l = _history.length - 1;
                while (l--) {
                    // map the number of times we observed the timer as follows:
                    // 0 - max or max - 1
                    // 1 - (max-2)...
                    // 2-7 - ... linearly scale ...
                    // 8 - ... 1 (once)
                    // 9 - 0 (no callbacks)
                    var numOfCallbacks = _history[l];
                    a.unshift(
                        (numOfCallbacks <= 0) ? 9 :
                        (numOfCallbacks <= 1) ? 8 :
                        (numOfCallbacks >= (mainThreadMonitorPollRate - 1)) ? 0 :
                        Math$round((numOfCallbacks - scaleFrom1) * scaleRatio + scaleTo1)
                    );
                }
                return a;
            }
        };
    }

    callback(SUCCESS);
});


// -- device/device.js
var device;

var device$DEVICEID_STORAGE_KEY = 'deviceid';
// NRD prefixes are always the first 10 characters of the ESN, with the exception of SDK- and SL devices.
// See https://nrd.netflix.com/display/CERT/ESN+Specification
var device$ESN_REGEX = /^(SDK-|SLW32-|SLW64-|SLMAC-|.{10})([A-Z0-9-=]{4,})$/;

/**
 * @constructor
 */
function Device(esn, esnPrefix, dpiversion, esnSource) {
    mixIn(this,
    /** @lends {Device.prototype} */
    {
        esnPrefix: esnPrefix,
        esn: esn,
        sdkversion: DEVICE_SDKVERSION || 'cadmium',
        dpiversion: dpiversion,
        esnSource: esnSource
    });
};

function Device$generateDeviceId() {
    var CHARS = '0123456789ACDEFGHJKLMNPQRTUVWXYZ',
        LENGTH = 30,
        deviceId = '',
        lastIndex = CHARS.length - 1,
        epoch = clock$getAppEpoch(),
        i = 6;

    // 6 characters based on current time (6 * 6 = 36 bits to fit reasonable portion of the epoch time, 34 year precision)
    while (i--) {
        deviceId = CHARS[epoch % CHARS.length] + deviceId;
        epoch = Math$floor(epoch / CHARS.length);
    }

    // fill the rest with random value
    while (deviceId.length < LENGTH) {
        deviceId += CHARS[randomInt(0, lastIndex)];
    }

    return deviceId;
};

loadAsync$register(ErrorCodes.INIT_COMPONENT_DEVICE, function asyncLoadDevice(callback) {
    debug$assert(config);
    debug$assert((crypto && crypto['getDeviceId']) || cryptokeys || GENERATE_DEVICEID);

    var esnPrefix = ESN_PREFIX,
        dpiversion,
        esnSource;

    var _log = new log.CategoryLog('Device');

    loadAsync$notifyMilestone('devs');

    if (DEBUG && config.deviceId) {

        // for debug builds, allow deviceId to be set explicitly

        // also save it if we are generating it, save it in the store
        // this is handy so once so we use debug build to set it, then use it in release build
        GENERATE_DEVICEID && storage.save(device$DEVICEID_STORAGE_KEY, config.deviceId);

        wrapup(esnPrefix + config.deviceId);

    } else if (GENERATE_DEVICEID) {

        storage.load(device$DEVICEID_STORAGE_KEY, function (result) {
            var deviceId,
                esnFromConfig = config.esn,
                deviceIdFromEsn;

            if (result.success) {
                deviceId = result.data;
            }

            if (isValidString(esnFromConfig)) {
                var prefix = extractSdkEsnPrefix(esnFromConfig);
                if (prefix != ESN_PREFIX) {
                    _log.error('esn prefix from ui is different', {
                        'ui': prefix,
                        'cad': ESN_PREFIX,
                        'ua': userAgent
                    });
                }
            } else if(config.logErrorIfEsnNotProvided) {
                _log.error('esn from ui is missing');
            }

            if (isValidString(deviceId)) {
                DEBUG && _log.debug('Loaded esn', {
                    'DeviceId': deviceId
                });

                if (isValidString(esnFromConfig)) {
                    deviceIdFromEsn = extractDeviceIdFromEsn(esnFromConfig);
                    if (deviceIdFromEsn === deviceId) {
                        esnSource = 'storage' + '_matched_esn_in_config'; // most typical case
                    } else {
                        esnSource = 'storage' + '_did_not_match_esn_in_config'; // when cookies got cleared but not indexedDB
                    }
                } else {
                    esnSource = 'storage' + '_esn_not_in_config'; // should not happen, verify from logblobs
                }
                wrapup(esnPrefix + deviceId);
            } else if (result.errorSubCode == ErrorSubCodes.STORAGE_NODATA) {
                if (isValidString(esnFromConfig)) {
                    deviceId = extractDeviceIdFromEsn(esnFromConfig);
                    if (isValidString(deviceId)) {
                        esnSource = 'config_since_not_in_storage'; // when indexedDb is cleared or first time user on this device
                        saveToStorageAndCallback();
                    } else {
                        esnSource = 'generated_since_invalid_in_config_and_not_in_storage'; //only if UI passes an invalid esn
                        _log.error('invalid esn passed from UI', esnFromConfig);
                        generateEsn();
                    }
                } else {
                    esnSource = 'generated_since_not_in_config_and_storage'; //should not happen any more
                    generateEsn();
                }
            } else {
                result.success = undefined; //fail playback since something went wrong with indexedDb reading
                callback(result);
            }

            function generateEsn() {
                deviceId = Device$generateDeviceId();
                DEBUG && _log.debug('Generated new esn', { 'DeviceId': deviceId });
                saveToStorageAndCallback();
            };

            function saveToStorageAndCallback() {
                storage.save(device$DEVICEID_STORAGE_KEY, deviceId, false, function (result) {
                    if (result.success) {
                        wrapup(esnPrefix + deviceId);
                    } else {
                        callback(result);
                    }
                });
            };
        });

    } else if (DEVICEID_VIA_WEBCRYPTO_GETKEYBYNAME && cryptokeys && cryptokeys['getKeyByName']) {

        // For Netflix, id metadata associated with a preshared key is the ESN
        // All keys will have the same data; use the encryption key here
        op2promise(cryptokeys['getKeyByName'](config.authenticationKeyNames['e']))['then'](
            function (result) {
                var esn = String.fromCharCode.apply(undefined, base64$decode(result['id']));
                debug$assert(esn != "");
                esnPrefix = extractSdkEsnPrefix(esn);
                wrapup(esn);
            },
            function (e) {
                callback({
                    errorSubCode: ErrorSubCodes.DEVICE_ERROR_GETTING_ESN,
                    errorDetails: exceptionToString(e)
                });
            }
        );

    } else if (DEVICEID_VIA_WEBCRYPTO_GETDEVICEID && crypto && crypto['getDeviceId']) {

        // use the functionality of the WebCrypto - only Neflix implemenration via plugin has this
        op2promise(crypto['getDeviceId']())['then'](
            function (result) {
                var deviceId = String.fromCharCode.apply(undefined, result),
                    esn = esnPrefix + deviceId;

                debug$assert(device$ESN_REGEX.test(deviceId));

                wrapup(esn);
            },
            function () {
                callback({ errorSubCode: ErrorSubCodes.DEVICE_ERROR_GETTING_ESN });
            }
        );

    } else {

        wrapup();

    }

    function extractDeviceIdFromEsn(esn) {
        try {
            return esn.match(device$ESN_REGEX)[2];
        } catch (e) {}
    }
    function extractSdkEsnPrefix(esn) {
        // NRD prefixes are always the first 10 characters of the ESN, with the exception of SDK- devices
        try {
            return esn.match(device$ESN_REGEX)[1];
        } catch (e) {
        }
    }

    /**
    * @param {string=} esn
    */
    function wrapup(esn) {
        if (isValidString(esn) && isValidString(esnPrefix)) {
            device = new Device(esn, esnPrefix, dpiversion, esnSource);
            DEBUG && _log.info('Esn source: ' + esnSource);
            loadAsync$notifyMilestone('devdone');
            callback(SUCCESS);
        } else {
            callback({
                errorSubCode: ErrorSubCodes.DEVICE_NO_ESN
            });
        }
    };
});



// -- ../../../tests/functional/js/mocks/http.js
var HttpMock = (function () {
    function HttpMock() {
        this.response = {
            success: true
        };
    }
    HttpMock.prototype.setResponse = function (response) {
        this.response = response;
    };
    HttpMock.prototype.setDelay = function (delayMs) {
        this.delayMs = delayMs;
    };
    HttpMock.prototype.download = function (request, callback) {
        var self = this;
        if (this.delayMs) {
            setTimeout(function () {
                callback(self.response);
            }, this.delayMs);
        }
        else {
            callback(this.response);
        }
    };
    return HttpMock;
})();



// -- ../../../tests/functional/js/mocks/clock.js
var ClockMock = (function () {
    function ClockMock() {
    }
    ClockMock.prototype.getEpoch = function () {
        if (this.epoch) {
            return this.epoch;
        }
        else {
            return Math.floor(Date.now() / 1000.0);
        }
    };
    ClockMock.prototype.setEpoch = function (epoch) {
        this.epoch = epoch;
    };
    return ClockMock;
})();



// -- ../../../tests/functional/js/mocks/log.js
var LogMock = (function () {
    function LogMock(category) {
        this.sinks = [];
        this.logIndex = 0;
        this.category = category;
    }
    LogMock.prototype.write = function (logLevel, message, fields) {
        var entry = {
            'level': logLevel,
            'message': message,
            'fields': fields || {},
            'time': Date.now(),
            'index': this.logIndex++,
            'category': this.category || 'General'
        };
        for (var i = 0; i < this.sinks.length; i++) {
            this.sinks[i](entry);
        }
    };
    LogMock.prototype.addSink = function (sink) {
        this.sinks.push(sink);
    };
    LogMock.prototype.fatal = function (message, fields) {
        this.write(LogMock.logLevel['FATAL'], message, fields);
    };
    LogMock.prototype.error = function (message, fields) {
        this.write(LogMock.logLevel['ERROR'], message, fields);
    };
    LogMock.prototype.warn = function (message, fields) {
        this.write(LogMock.logLevel['WARN'], message, fields);
    };
    LogMock.prototype.info = function (message, fields) {
        this.write(LogMock.logLevel['INFO'], message, fields);
    };
    LogMock.prototype.trace = function (message, fields) {
        this.write(LogMock.logLevel['TRACE'], message, fields);
    };
    LogMock.prototype.debug = function (message, fields) {
        this.write(LogMock.logLevel['DEBUG'], message, fields);
    };
    LogMock.prototype.log = function (message, fields) {
        this.write(LogMock.logLevel['DEBUG'], message, fields);
    };
    LogMock.logLevel = {
        'MIN': 0,
        'FATAL': 0,
        'ERROR': 1,
        'WARN': 2,
        'INFO': 3,
        'TRACE': 4,
        'DEBUG': 5,
        'MAX': 5
    };
    return LogMock;
})();



// -- ../../../tests/functional/js/test-setup.js
var tests = [];

var loadChaiAssertions = function () {
    // Add 'properties' custom assertions to ChaiJS
    //
   
    chai.use(function (_chai, utils) {
        function flatten(json) {
            var delimiter = '.';
            var output = {};

            function next(obj, previous) {
                Object.keys(obj).forEach(function (key) {
                    var value = obj[key];
                    var newKey = previous ? previous + delimiter + key : key;

                    if (isArray(value) || isValidObject(value)) {
                        return next(value, newKey);
                    }

                    output[newKey] = value;
                });
            }

            next(json, undefined);

            return output;
        }

        _chai.Assertion.addMethod('properties', function (o) {
            var json = flatten(o);

            for (var propertyKey in json) {
                var expected = json[propertyKey];
                var isDeep = propertyKey.indexOf('.') > 0;

                var assertObjectToHave = new _chai.Assertion(this._obj).to.have;
                assertObjectToHave = isDeep ? assertObjectToHave.deep : assertObjectToHave;

                if (isNumber(expected)) {
                    assertObjectToHave.property(propertyKey).that.is.closeTo(expected, 0.001);
                }
                else {
                    assertObjectToHave.property(propertyKey, expected);
                }
            }
        });
    });
};

window['runPlayerTests'] = function () {
    loadChaiAssertions();

    for (var i = 0; i < tests.length; i++) {
        if (typeof tests[i] === 'function') {
            tests[i]();
        }
    }
};

function addTest(func) {
    tests.push(func);
}

addTest(function () {
    var expect = chai.expect;

    describe('LoadAsync', function () {
        it('asynchronously load registered components', function () {
            this.timeout(60000);

            return new Promise(function (resolve) {
                config$load([{
                    'logDisplayAutoshowLevel': '-1'
                }]);

                loadAsync(resolve);
            })
            .then(function (result) {
                expect(!!result).to.equal(true);
                expect(!!result.success).to.equal(true);
                expect(!!device).to.equal(true);
                expect(isValidString(device.esn)).to.equal(true);
            });
        });
    });
});



// -- ../../../tests/functional/js/tests-imports.js
addTest(function () {
    var expect = chai.expect;

    // only basic checks, to make sure the modules were imported properly
    // modules contain their own extensive unit tests
    describe('imports', function () {

        it('nf-utf8', function () {
            return Promise.resolve().then(function () {
                expect(utf8$getString(new Uint8Array([97]))).to.equal('a');
                expect(utf8$getBytes('a')).to.deep.equal(new Uint8Array([97]));
            });
        });

        it('nf-base64', function () {
            return Promise.resolve().then(function () {
                expect(base64$decode('YQ==')).to.deep.equal(new Uint8Array([97]));
                expect(base64$decodeAsText('YQ==')).to.equal('a');
                expect(base64$encode(new Uint8Array([97]))).to.equal('YQ==');
                expect(base64$encode('a')).to.equal('YQ==');
            });
        });

    });
});


// -- ../../../tests/functional/js/tests-misc.js
addTest(function () {
    var expect = chai.expect;

    describe('Misc', function () {
        it('interpolate arrays', function () {
            return Promise.resolve().then(function () {
                var entries = [
                    [100, 10, 4000],
                    [200, 20, 5000],
                    [300, 40, 10000]
                ];

                expect(interpolateArrays(entries, 1)).to.deep.equal([10, 4000]);
                expect(interpolateArrays(entries, 93)).to.deep.equal([10, 4000]);
                expect(interpolateArrays(entries, 100)).to.deep.equal([10, 4000]);
                expect(interpolateArrays(entries, 150)).to.deep.equal([15, 4500]);
                expect(interpolateArrays(entries, 200)).to.deep.equal([20, 5000]);
                expect(interpolateArrays(entries, 250)).to.deep.equal([30, 7500]);
                expect(interpolateArrays(entries, 300)).to.deep.equal([40, 10000]);
                expect(interpolateArrays(entries, 331200)).to.deep.equal([40, 10000]);
            });
        });

        it('filter bitrates', function () {
            return Promise.resolve().then(function () {
                var bitrates = [235, 560, 1050, 1750];

                // must always have at least one
                expect(filterBitrates(bitrates, ['10000+'])).to.deep.equal([235]);
                // unless source is empty
                expect(filterBitrates([], ['0+'])).to.deep.equal([]);
                    
                expect(filterBitrates(bitrates, ['560'])).to.deep.equal([560]);
                expect(filterBitrates(bitrates, [560, 1050])).to.deep.equal([560, 1050]);
                expect(filterBitrates(bitrates, ['560', '1050'])).to.deep.equal([560, 1050]);
                expect(filterBitrates(bitrates, ['560', '700', '1050'])).to.deep.equal([560, 1050]);
                expect(filterBitrates(bitrates, ['560', '700', '1060-'])).to.deep.equal([560, 1050]);
                expect(filterBitrates(bitrates, ['1050-', '1000-'])).to.deep.equal([560]);
                expect(filterBitrates(bitrates, ['1050-'])).to.deep.equal([560]);
                expect(filterBitrates(bitrates, ['1060-'])).to.deep.equal([1050]);
                expect(filterBitrates(bitrates, ['0+'])).to.deep.equal([235]);
                expect(filterBitrates(bitrates, ['10000-'])).to.deep.equal([1750]);
                expect(filterBitrates(bitrates, ['0+', '10000-'])).to.deep.equal([235, 1750]);
                expect(filterBitrates(bitrates, ['0+', '10000-', '2000-'])).to.deep.equal([235, 1750]);
                expect(filterBitrates([1000, 10, 560, 9000, 90], ['500+'])).to.deep.equal([560]);
            });
        });

        it('convert JSON objects to CSV', function () {
            return Promise.resolve().then(function () {
                expect(makeCsv({
                    'a': 'b',
                    'c': '2'
                })).to.equal('a=b,c=2');

                expect(makeCsv({
                    'za"b': 'c d',
                    'z"z': '1',
                    'k': 5,
                    'l': 'k\n\r'
                })).to.equal('"za""b=c d","z""z=1",k=5,"l=k "');
            });
        });

        it('acquire and release ReaderWriter locks', function () {
            var l = new ReaderWriterLock('ut');
            var r1, r2, w1;
            var order = 0;

            return Promise.resolve()
                .then(function () {
                    return new Promise(function (resolve) {
                        l.acquireLock(false, resolve);
                    })
                    .then(function (result) {
                        r1 = result.lockId;
                        expect(order++).to.equal(0);
                    });
                })
                .then(function () {
                    return new Promise(function (resolve) {
                        l.acquireLock(false, resolve);
                    })
                    .then(function (result) {
                        expect(order++).to.equal(1);
                        r2 = result.lockId;
                    });
                })
                .then(function () {
                    return new Promise(function (resolve, reject) {
                        l.acquireLock(true, function (result) {
                            try { 
                                expect(order++).to.equal(3);
                                w1 = result.lockId;
                                setTimeout(function () {
                                    try {
                                        expect(order++).to.equal(4);
                                        l.releaseLock(w1);
                                    }
                                    catch (e) { reject(e); }
                                }, 10);
                            }
                            catch (e) { reject(e); }
                        });

                        setTimeout(function () {
                            expect(order++).to.equal(2);
                            l.releaseLock(r1);
                            l.releaseLock(r2);
                            l.acquireLock(false, function (result) {
                                try {
                                    expect(order++).to.equal(5);
                                    resolve();
                                }
                                catch (e) { reject(e); }
                            });
                        }, 0);
                    });
                });
        });

        it('Test containSameElements()', function () {
            return Promise.resolve().then(function () {
                var a1 = ["foo", "bar", "car"];
                var a2 = ["foo", "bar", "car"];                
                var a3 = ["bar", "foo", "car"];                            
                var a4 = ["foo", "rar", "bar"];
                var a5 = [];
                var a6 = ["may","day"];

                // happy paths
                expect(containSameElements(a1,a2)).to.equal(true);
                expect(containSameElements(a1,a3)).to.equal(true);
                expect(containSameElements(a1,a2.slice().reverse())).to.equal(true);

                // Failure paths
                expect(containSameElements(a1,a4)).to.equal(false);
                expect(containSameElements(a1,a5)).to.equal(false);
                expect(containSameElements(a1,a6)).to.equal(false);                                                

            });
                
        });

        it('Test Array$isSubsetOf()', function () {
            return Promise.resolve().then(function () {
                var largerArray1 = ["foo", "bar", "car", "dar"];
                var largerArray2 = ["foo", 3, "car", "dar", "bar"];
                var largerArray3 = ["foo", {}, "car", "dar"];
                var largerArray4 = ["foo", 3,4, null, undefined];
                var largerArray5 = ["foo", 3,"car",4];
                var smallerArray1 = ["bar", "car"];
                var smallerArray2 = ["bar", "car", "far"];
                var smallerArray3 = [];
                var smallerArray4 = [3,4];
                var smallerArray5 = [3,undefined, 4];

                // happy paths
                expect(Array$isASubsetOf(smallerArray1,largerArray1), "smallerArray1, largerArray1").to.equal(true);
                expect(Array$isASubsetOf(smallerArray3,largerArray1), "smallerArray3, largerArray1").to.equal(true);
                expect(Array$isASubsetOf(smallerArray1 ,largerArray2), "smallerArray1, largerArray2").to.equal(true);
                expect(Array$isASubsetOf(smallerArray4 ,largerArray5), "smallerArray4, largerArray5").to.equal(true);

                // Failure paths
                expect(Array$isASubsetOf(largerArray1, smallerArray1), "largerArray1, smallerArray1").to.equal(false);
                expect(Array$isASubsetOf(smallerArray2 ,largerArray1), "smallerArray2, largerArray1").to.equal(false);
                expect(Array$isASubsetOf(smallerArray1 ,largerArray3), "smallerArray1, largerArray3").to.equal(false);
                expect(Array$isASubsetOf(smallerArray4 ,largerArray4), "smallerArray4, largerArray4").to.equal(false);
                expect(Array$isASubsetOf(smallerArray5 ,largerArray4), "smallerArray4, largerArray4").to.equal(false);
                expect(Array$isASubsetOf(smallerArray5 ,largerArray5), "smallerArray4, largerArray4").to.equal(false);

            });
        });
    });
});



// -- ../../../tests/functional/js/tests-asn1.js
addTest(function () {
    var expect = chai.expect;

    describe('DataStream', function () {
        function getPropertyValues(o) {
            return Object.keys(o).map(function (k) { return o[k]; });
        }

        it('write Asn1Octet data stream', function () {
            return Promise.resolve().then(function () {
                var buffer = [], stream = new DataStream(buffer);

                stream.writeByte(2);
                expect(buffer).to.deep.equal([2]);

                stream.writeAsn1Octet([11, 12, 13, 14]);
                expect(buffer).to.deep.equal([2, 4 /* length <= 127 */, 11, 12, 13, 14]);

                stream.writeAsn1Octet([]);
                expect(buffer).to.deep.equal([2, 4 /* length <= 127 */, 11, 12, 13, 14, 0]);

                stream.writeAsn1Octet([
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46
                ]);

                expect(buffer).to.deep.equal([
                    2,
                    4 /* length <= 127 */,
                    11, 12, 13, 14,
                    0, /* length = 0 */
                    0x80, 0xA0, /* length > 160 && length <= 16,383*/
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46
                ]);
            });
        });

        it('read Asn1Octet data stream', function () {
            return Promise.resolve().then(function () {
                var stream = new DataStream([
                    2,
                    4 /* length <= 127 */,
                    11, 12, 13, 14,
                    0, /* length = 0 */
                    0x80, 0xA0, /* length > 160 && length <= 16,383*/
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46
                ]);

                var actual;

                actual = stream.readByte();
                expect(actual).to.equal(2);

                actual = getPropertyValues(stream.readAsn1Octet());
                expect(actual).to.deep.equal([11, 12, 13, 14]);

                actual = stream.readAsn1Octet();
                expect(actual).to.deep.equal({});

                actual = getPropertyValues(stream.readAsn1Octet());
                expect(actual).to.deep.equal([
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46,
                    31, 32, 33, 34, 35, 36, 37, 37, 39, 40, 41, 42, 43, 44, 45, 46
                ]);
            });
        });

        it('write and read large Asn1Octet data stream', function () {
            return Promise.resolve().then(function () {
                var array = [],
                    _64k = 0x10000,
                    _16k = 0x4000;
                var l = _64k + _16k + 100;
                var i = l;
                while (i--) {
                    array.push(91);
                }

                var buffer = [], stream = new DataStream(buffer);

                stream.writeByte(2);
                stream.writeAsn1Octet(array);

                expect(buffer.length).to.equal(1 + (1 + _64k) + (1 + _16k) + (1 + 100));
                expect(buffer[0]).to.equal(2);
                expect(buffer[1]).to.equal(0xC4);               /* 11 000100 */
                expect(buffer[1 + (1 + _64k)]).to.equal(0xC1);  /* 11 000001 */
                expect(buffer[1 + (1 + _64k) + (1 + _16k)]).to.equal(100);

                stream.writeNumber(0x12345678, 4);
                stream.seek(0);

                expect(stream.readByte()).to.equal(2);
                expect(getPropertyValues(stream.readAsn1Octet())).to.deep.equal(array);
                expect(stream.readNumber(4)).to.equal(0x12345678);
            });
        });

        it('write and read large Asn1Octet aligned data stream', function () {
            return Promise.resolve().then(function () {
                var array = [],
                    _64k = 0x10000,
                    _16k = 0x4000;

                var l = _64k + _16k;
                var i = l;
                while (i--) {
                    array.push(91);
                }

                var buffer = [],
                    stream = new DataStream(buffer);

                stream.writeByte(2);
                stream.writeAsn1Octet(array);

                expect(buffer.length).to.equal(1 + (1 + _64k) + (1 + _16k) + 1);
                expect(buffer[0]).to.equal(2);
                expect(buffer[1]).to.equal(0xC4);               /* 11 000100 */
                expect(buffer[1 + (1 + _64k)]).to.equal(0xC1);  /* 11 000001 */
                expect(buffer[1 + (1 + _64k) + (1 + _16k)]).to.equal(0);

                stream.writeNumber(0x12345678, 4);
                stream.seek(0);

                expect(stream.readByte()).to.equal(2);
                expect(getPropertyValues(stream.readAsn1Octet())).to.deep.equal(array);
                expect(stream.readNumber(4)).to.equal(0x12345678);
            });
        });
    });
});


// -- ../../../tests/functional/js/tests-xml.js
addTest(function () {
    var expect = chai.expect;

    describe('XML', function () {
        it('convert XML to JSON using xml2js() method', function () {
            return new Promise(function (resolve) {
                var xml =
                    '<tt>' +
                    '<body>' +
                        '<div>' +
                        '<p begin="1s" end="3s">Text1</p>' +
                        '<blah>foo</blah>' +
                        '<p begin="5s" end="6.6s">Text2</p>' +
                        'Div Has Text' +
                        '<p begin="9999ms" end="10s">Text3</p>' +
                        '<p begin="10000ms" end="10002ms">Text4 <i>with italic</i> end.</p>' +
                        '</div>' +
                        'Body Has Text' +
                    '</body>' +
                    '</tt>';

                xml2js(xml, resolve);
            })
            .then(function (result) {
                expect(!!result).to.equal(true);
                expect(!!result.success).to.equal(true);
                expect(result.object).to.have.properties({
                    '$name': 'tt',
                    'body': {
                        '$children': {
                            length: 2
                        },
                        '$text': 'Body Has Text',
                        'div': {
                            '$children': {
                                length: 6,
                                '0': { '$name': 'p' },
                                '1': { '$name': 'blah' },
                                '2': { '$name': 'p' },
                                '3': 'Div Has Text',
                                '5': {
                                    '$name': 'p',
                                    '$children': {
                                        length: 3,
                                        '0': 'Text4 ',
                                        '1': { '$name': 'i' },
                                        '2': ' end.'
                                    }
                                }
                            },
                            'p': {
                                '$attributes': {
                                    'begin': '1s',
                                    'end': '3s'
                                },
                                '$text': 'Text1',
                                '$sibling': {
                                    '$name': 'p',
                                    '$text': 'Text2'
                                }
                            },
                            'blah': {
                                '$name': 'blah',
                                '$text': 'foo'
                            }
                        }
                    }
                });
            });
        });

        it('convert JSON to XML using js2xml() method', function () {
            return new Promise(function (resolve) {
                var xml =
                '<blah:tt>\n' +
                '  <blah:body>\n' +
                '    <blah:div>\n' +
                '      <blah:p begin="1s" end="3s">Text1</blah:p>\n' +
                '      <blah:foo>\n' +
                '        <blah:bar>3</blah:bar>\n' +
                '      </blah:foo>\n' +
                '    </blah:div>\n' +
                '  </blah:body>\n' +
                '</blah:tt>';

                var jsObj = {
                    'body': {
                        'div': {
                            'p': {
                                '$attributes': {
                                    'begin': '1s',
                                    'end': '3s'
                                },
                                '$text': 'Text1'
                            },
                            'foo': {
                                'bar': 3
                            }
                        }
                    }
                };

                var actualXml = js2xml(jsObj, 'blah', 'tt');

                expect(actualXml).to.equal(xml);
                resolve();
            });
        });
    });
});


// -- ../../../tests/functional/js/tests-arraybuffer-slice.js
addTest(function () {
	 var expect = chai.expect;

	 describe('arraybuffer-slice', function () {
	 	it('ArrayBuffer.prototype.slice', function() {
	 		var source = new ArrayBuffer(24);
	 		var sourceBytes = new Uint8Array(source);
	 		sourceBytes.set([
				  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				  0x09, 0x0a, 0x0b, 0x0c, 0x0e, 0x0f, 0xf1, 0xf2,
				  0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa
				]);
	 		var result;
	 		result = new Uint8Array(source.slice(0, 5));
	 		expect(result).to.deep.equal(new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05]));
			result = new Uint8Array(source.slice(10, 5));
			expect(result).to.deep.equal(new Uint8Array([]));
			result = new Uint8Array(source.slice(2, 300));
			expect(result).to.deep.equal(new Uint8Array([0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				  0x09, 0x0a, 0x0b, 0x0c, 0x0e, 0x0f, 0xf1, 0xf2,
				  0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa]));
	 		result = new Uint8Array(source.slice(-2));
	 		expect(result).to.deep.equal(new Uint8Array([0xf9, 0xfa]));
	 		result = new Uint8Array(source.slice(-2, -1));
	 		expect(result).to.deep.equal(new Uint8Array([0xf9]));
	 		result = new Uint8Array(source.slice(1)); // no end with +ve start
	 		expect(result).to.deep.equal(new Uint8Array([0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				  0x09, 0x0a, 0x0b, 0x0c, 0x0e, 0x0f, 0xf1, 0xf2,
				  0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa]));
			result = new Uint8Array(source.slice(300)); // no end with start >= length
			expect(result).to.deep.equal(new Uint8Array([]));
	 	});
	 });
});



// -- ../../../tests/functional/js/tests-PlayTimeTracker.js
addTest(function () {
    var expect = chai.expect;

    describe('PlayTimeTracker', function () {
        var playback, playTimeTracker;

        before('Suite Setup', function () {
            return Promise.resolve().then(function () {
                if (!config) {
                    config$load([{
                        'logDisplayAutoshowLevel': '-1'
                    }]);
                }

                playback = createPlayback(undefined, 1, null);
                playTimeTracker = new PlayTimeTracker(playback);
            });
        });
        
        

        it('validate total play time and average bitrate and vmaf delivered', function () {
            return Promise.resolve().then(function () {
                playback.fireEvent(Playback$repositioning, { oldMediaTime: 0, newMediaTime: 0 });
                playback.mediaTime.set(0);
                playback.presentedAudio.set(null);
                playback.presentedVideo.set(null);
                playback.fireEvent(Playback$repositioned, { oldMediaTime: 0, newMediaTime: 0 });

                expect(playTimeTracker.getTotalPlayTime()).to.equal(0);

                playback.presentedAudio.set({
                    track: {
                        type: CadmiumMediaStream$AUDIO
                    },
                    chunk: {
                        startTime: 0,
                        endTime: 4000
                    },
                    stream: {
                        track: {
                            type: CadmiumMediaStream$AUDIO
                        },
                        downloadableId: 10010096,
                        bitrate: 96
                    },
                    cdn: {
                        id: 1,
                        name: 'one'
                    }
                });
                playback.presentedVideo.set({
                    track: {
                        type: CadmiumMediaStream$VIDEO
                    },
                    chunk: {
                        startTime: 0,
                        endTime: 1500
                    },
                    stream: {
                        track: {
                            type: CadmiumMediaStream$VIDEO
                        },
                        downloadableId: 20011750,
                        bitrate: 1750,
                        vmaf: 80
                    },
                    cdn: {
                        id: 1,
                        name: 'one'
                    }
                });

                expect(playTimeTracker.getTotalPlayTime()).to.equal(0);

                playback.mediaTime.set(1200);

                expect(playTimeTracker.getTotalPlayTime()).to.equal(1200);
                expect(playTimeTracker.getAverageBitrateDelivered()).to.equal(1750);
                expect(playTimeTracker.getAverageVmafDelivered()).to.equal(80);

                playback.mediaTime.set(1300);

                expect(playTimeTracker.getTotalPlayTime()).to.equal(1300);
                expect(playTimeTracker.getAverageBitrateDelivered()).to.equal(1750);
                expect(playTimeTracker.getAverageVmafDelivered()).to.equal(80);

                playback.mediaTime.set(1700);

                expect(playTimeTracker.getTotalPlayTime()).to.equal(1500);
                expect(playTimeTracker.getAverageBitrateDelivered()).to.equal(1750);
                expect(playTimeTracker.getAverageVmafDelivered()).to.equal(80);

                playback.presentedVideo.set({
                    track: {
                        type: CadmiumMediaStream$VIDEO
                    },
                    chunk: {
                        startTime: 1500,
                        endTime: 3100
                    },
                    stream: {
                        track: {
                            type: CadmiumMediaStream$VIDEO
                        },
                        downloadableId: 20013600,
                        bitrate: 3600,
                        vmaf: 90
                    },
                    cdn: {
                        id: 2,
                        name: 'two'
                    }
                });

                expect(playTimeTracker.getTotalPlayTime()).to.equal(1700);

                playback.mediaTime.set(2000);
                expect(playTimeTracker.getTotalPlayTime()).to.equal(2000);
                expect(playTimeTracker.getAverageBitrateDelivered()).to.equal(2213);
                expect(playTimeTracker.getAverageVmafDelivered()).to.equal(83);

                playback.mediaTime.set(2890);
                expect(playTimeTracker.getTotalPlayTime()).to.equal(2890);
            });
        });

        it('validate total play time, video play time by CDN & downloadableId, and play time by downloadableId', function () {
            return Promise.resolve().then(function () {
                var audioVideoPlayTimes = playTimeTracker.getAudioVideoPlayTimeByCdnAndDownloadableId();
                
                expect(audioVideoPlayTimes).to.have.properties({
                    'audio': [
                        {
                            'downloadableId': 10010096,
                            'duration': 2890
                        }
                    ],
                    'video': [
                        {
                            'downloadableId': 20011750,
                            'duration': 1500
                        },
                        {
                            'downloadableId': 20013600,
                            'duration': 2890 - 1500
                        }
                    ]
                });

                playback.activeTimedTextTrack.set({
                    type: CadmiumMediaStream$TIMEDTEXT,
                    downloadableId: 300101,
                    cdn: {
                        id: 2,
                        name: 'two'
                    }
                });

                playback.mediaTime.set(2990);
                expect(playTimeTracker.getTotalPlayTime()).to.equal(2990);

                var playTimes = playTimeTracker.getPlayTimeByDownloadableId();

                expect(playTimes).to.have.properties({
                    'audio': [
                        {
                            'downloadableId': 10010096,
                            'duration': 2990
                        }
                    ],
                    'video': [
                        {
                            'downloadableId': 20011750,
                            'duration': 1500
                        },
                        {
                            'downloadableId': 20013600,
                            'duration': 2990 - 1500
                        }
                    ],
                    'timedtext': [
                        {
                            'downloadableId': 300101,
                            'duration': 2990 - 2890
                        }
                    ]
                });

                playback.fireEvent(Playback$repositioning, { oldMediaTime: 3000, newMediaTime: 11111 });
                playback.mediaTime.set(11111);
                playback.presentedAudio.set(null);
                playback.presentedVideo.set(null);
                playback.fireEvent(Playback$repositioned, { oldMediaTime: 3000, newMediaTime: 11111 });

                expect(playTimeTracker.getTotalPlayTime()).to.equal(3000);

                playback.mediaTime.set(12111);

                expect(playTimeTracker.getTotalPlayTime()).to.equal(3000);

                playback.presentedAudio.set({
                    track: {
                        type: CadmiumMediaStream$AUDIO
                    },
                    chunk: {
                        startTime: 10000,
                        endTime: 16000
                    },
                    stream: {
                        track: {
                            type: CadmiumMediaStream$AUDIO
                        },
                        downloadableId: 10020096,
                        bitrate: 96
                    },
                    cdn: {
                        id: 4,
                        name: 'four'
                    }
                });
                playback.presentedVideo.set({
                    track: {
                        type: CadmiumMediaStream$VIDEO
                    },
                    chunk: {
                        startTime: 11000,
                        endTime: 14000
                    },
                    stream: {
                        track: {
                            type: CadmiumMediaStream$VIDEO
                        },
                        downloadableId: 20011750,
                        bitrate: 1750
                    },
                    cdn: {
                        id: 5,
                        name: 'five'
                    }
                });

                expect(playTimeTracker.getTotalPlayTime()).to.equal(4000);

                playback.mediaTime.set(12611);

                playback.activeTimedTextTrack.set(null);

                playback.mediaTime.set(13111);

                expect(playTimeTracker.getTotalPlayTime()).to.equal(5000);

                audioVideoPlayTimes = playTimeTracker.getAudioVideoPlayTimeByCdnAndDownloadableId();

                expect(audioVideoPlayTimes).to.have.properties({
                    'audio': [
                        {
                            'downloadableId': 10010096,
                            'cdnId': 1,
                            'duration': 3000
                        },
                        {
                            'downloadableId': 10020096,
                            'cdnId': 4,
                            'duration': 2000
                        },
                    ],
                    'video': [
                        {
                            'downloadableId': 20011750,
                            'cdnId': 1,
                            'duration': 1500
                        },
                        {},
                        {
                            'downloadableId': 20011750,
                            'cdnId': 5,
                            'duration': 2000
                        }
                    ]
                });

                playTimes = playTimeTracker.getPlayTimeByDownloadableId();

                expect(playTimes).to.have.properties({
                    'audio': [
                        {},
                        {
                            'downloadableId': 10020096,
                            'duration': 2000
                        }
                    ],
                    'timedtext': [
                        {
                            'downloadableId': 300101,
                            'duration': 110 + 1500
                        }
                    ]
                });
            });
        });

        describe('PlayTimeTracker$_averageTimeWeightedMetricFromSegments', function () {
            it('returns time weighted average of segments', function() {
                 return Promise.resolve().then(function() {
                     var average, segments;
                     
                     playback = createPlayback(undefined, 1, null);
                     playTimeTracker = new PlayTimeTracker(playback);

                     segments = [{
                         metric: 1500,
                         duration: 10
                     }, {
                         metric: 2250,
                         duration: 20
                     }];

                     average = PlayTimeTracker$_averageTimeWeightedMetricFromSegments(segments);
                     expect(average).to.equal(2000);
                 });
            });
            it('throws an exception when the metric does not exist', function() {
                return Promise.resolve().then(function() {
                    var average, segments;
                    
                    playback = createPlayback(undefined, 1, null);
                    playTimeTracker = new PlayTimeTracker(playback);

                    segments = [{
                        duration: 10
                    }];

                    expect(function() {
                        PlayTimeTracker$_averageTimeWeightedMetricFromSegments(segments);
                    }).to.
                    throw (Error, 'invalid arguments');
                });
            });
            
            it('throws an exception when the duration does not exist', function() {
                return Promise.resolve().then(function() {
                    var average, segments;
                    
                    playback = createPlayback(undefined, 1, null);
                    playTimeTracker = new PlayTimeTracker(playback);

                    segments = [{
                        metric: 78
                    }];

                    expect(function() {
                        PlayTimeTracker$_averageTimeWeightedMetricFromSegments(segments);
                    }).to.
                    throw (Error, 'invalid arguments');
                });
            });
        });

        describe('hasVmaf()', function () {
            it('returns true when the first track had a vmaf score', function() {
                return Promise.resolve().then(function() {
                    playback = createPlayback(undefined, 1, null);
                    playTimeTracker = new PlayTimeTracker(playback);

                    playback.fireEvent(Playback$repositioning, {
                        oldMediaTime: 0,
                        newMediaTime: 0
                    });
                    playback.mediaTime.set(0);
                    playback.presentedAudio.set(null);
                    playback.presentedVideo.set(null);
                    playback.fireEvent(Playback$repositioned, {
                        oldMediaTime: 0,
                        newMediaTime: 0
                    });

                    expect(playTimeTracker.getTotalPlayTime()).to.equal(0);

                    playback.presentedAudio.set({
                        track: {
                            type: CadmiumMediaStream$AUDIO
                        },
                        chunk: {
                            startTime: 0,
                            endTime: 4000
                        },
                        stream: {
                            track: {
                                type: CadmiumMediaStream$AUDIO
                            },
                            downloadableId: 10010096,
                            bitrate: 96
                        },
                        cdn: {
                            id: 1,
                            name: 'one'
                        }
                    });
                    playback.presentedVideo.set({
                        track: {
                            type: CadmiumMediaStream$VIDEO
                        },
                        chunk: {
                            startTime: 0,
                            endTime: 1500
                        },
                        stream: {
                            track: {
                                type: CadmiumMediaStream$VIDEO
                            },
                            downloadableId: 20011750,
                            bitrate: 1750,
                            vmaf: 80
                        },
                        cdn: {
                            id: 1,
                            name: 'one'
                        }
                    });
                    expect(playTimeTracker.getTotalPlayTime()).to.equal(0);

                    playback.mediaTime.set(1200);
                    expect(playTimeTracker.getTotalPlayTime()).to.equal(1200);

                    expect(playTimeTracker.hasVmaf()).to.equal(true);

                });
            });
            it('returns false when the first track does not have a vmaf score', function() {
                return Promise.resolve().then(function() {
                    playback = createPlayback(undefined, 1, null);
                    playTimeTracker = new PlayTimeTracker(playback);

                    playback.fireEvent(Playback$repositioning, {
                        oldMediaTime: 0,
                        newMediaTime: 0
                    });
                    playback.mediaTime.set(0);
                    playback.presentedAudio.set(null);
                    playback.presentedVideo.set(null);
                    playback.fireEvent(Playback$repositioned, {
                        oldMediaTime: 0,
                        newMediaTime: 0
                    });

                    expect(playTimeTracker.getTotalPlayTime()).to.equal(0);

                    playback.presentedAudio.set({
                        track: {
                            type: CadmiumMediaStream$AUDIO
                        },
                        chunk: {
                            startTime: 0,
                            endTime: 4000
                        },
                        stream: {
                            track: {
                                type: CadmiumMediaStream$AUDIO
                            },
                            downloadableId: 10010096,
                            bitrate: 96
                        },
                        cdn: {
                            id: 1,
                            name: 'one'
                        }
                    });
                    playback.presentedVideo.set({
                        track: {
                            type: CadmiumMediaStream$VIDEO
                        },
                        chunk: {
                            startTime: 0,
                            endTime: 1500
                        },
                        stream: {
                            track: {
                                type: CadmiumMediaStream$VIDEO
                            },
                            downloadableId: 20011750,
                            bitrate: 1750
                        },
                        cdn: {
                            id: 1,
                            name: 'one'
                        }
                    });
                    expect(playTimeTracker.getTotalPlayTime()).to.equal(0);

                    playback.mediaTime.set(1200);
                    expect(playTimeTracker.getTotalPlayTime()).to.equal(1200);

                    expect(playTimeTracker.hasVmaf()).to.equal(false);
                });
            });

        });
        
    });
});



// -- ../../../tests/functional/js/tests-constructDownloadReport.js
addTest(function () {
    var expect = chai.expect;

    describe('constructDownloadReport', function () {
        
        // [ =]
        it('create dlreport for a single download', function () {
            var downloads = [];
            downloads.push(constructDownload('A', 0, 100, 200, 400, 1, true));

            var dlreport = constructDownloadReport(downloads, 0);

            var firstUrl = dlreport['urls'][0];
            var firstDownload = firstUrl['downloads'][0];
            expect(firstDownload['tresp']).to.equal(100);
            expect(firstDownload['trace']).to.eql([[100, 400]]);
        });

        // [ -=      ]
        // [    --== ]
        it('create dlreport for two non-overlapping downloads', function () {        
            var downloads = [];
            downloads.push(constructDownload('A',   0, 100, 200, 400, 1, true));
            downloads.push(constructDownload('A', 300, 500, 700, 200, 1, true));

            var dlreport = constructDownloadReport(downloads, 0);

            var firstUrl = dlreport['urls'][0];
            var firstDownload = firstUrl['downloads'][0];
            expect(firstDownload['tresp']).to.equal(100);
            expect(firstDownload['trace']).to.eql([[100, 400], [100, -2], [200, -3], [200, 200]]);
        });

        // [ -====   ]
        // [    ---= ]
        it('create dlreport for two overlapping downloads', function () {        
            var downloads = [];
            downloads.push(constructDownload('A',   0, 100, 500, 400, 1, true));
            downloads.push(constructDownload('A', 300, 600, 700, 200, 1, true));

            var dlreport = constructDownloadReport(downloads, 0);

            var firstUrl = dlreport['urls'][0];
            var firstDownload = firstUrl['downloads'][0];
            expect(firstDownload['tresp']).to.equal(100);
            expect(firstDownload['trace']).to.eql([[400, 400], [100, -3], [100, 200]]);
        });

        // [ -====   ]
        // [    --== ]
        it('create dlreport for two overlapping downloads - pipelined', function () {        
            var downloads = [];
            downloads.push(constructDownload('A',   0, 100, 500, 400, 1, true));
            downloads.push(constructDownload('A', 300, 500, 700, 200, 1, true));

            var dlreport = constructDownloadReport(downloads, 0);

            var firstUrl = dlreport['urls'][0];
            var firstDownload = firstUrl['downloads'][0];
            expect(firstDownload['tresp']).to.equal(100);
            expect(firstDownload['trace']).to.eql([[400, 400], [200, 200]]);
        });

        function constructDownload(url, requestTime, responseStartTime, responseEndTime, bytes, port, success) {
            return {
                headers: {
                    'X-Session-Info': 'port=' + port
                },
                measurements: {
                    contentLength: bytes,
                    requestTime: requestTime,
                    responseStartTime: responseStartTime,
                    responseEndTime: responseEndTime
                },
                success: success,
                url: url
            };
        }
    });
});



// -- ../../../tests/functional/js/tests-dfxp.js
addTest(function () {
    var expect = chai.expect;
    var isSafari = DEVICE_MODEL.indexOf("safari") >= 0;

    describe('DFXP', function () {
        (isSafari?it.skip:it)('parse to DFXP format', function () {
            return new Promise(function (resolve) {
                var xml =
                    '<tt tickRate="10000000"><body><div>' +
                    '<p begin="1s" end="3s">Text1</p>' +
                    '<p begin="5s" end="6.6s">Text2</p>' +
                    '<p begin="9999ms" end="10s">Text3</p>' +
                    '<p begin="10000ms" end="10002ms">Text4</p>' +
                    '<p begin="660000000t" end="670000000t">Text5</p>' +
                    '<p begin="1:01:01" end="1:23:4.567">Text6</p>' +
                    '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {

                expect(result.entries).to.have.properties([
                    {
                        'startTime': 1000,
                        'endTime': 3000,
                        'blocks': [
                            { 'textNodes': [{ 'text': 'Text1' }] }
                        ]
                    },
                    {
                        'startTime': 5000,
                        'endTime': 6600,
                        'blocks': [
                            { 'textNodes': [{ 'text': 'Text2' }] }
                        ]
                    },
                    {
                        'startTime': 9999,
                        'endTime': 10000,
                        'blocks': [
                            { 'textNodes': [{ 'text': 'Text3' }] }
                        ]
                    },
                    {
                        'startTime': 10000,
                        'endTime': 10002,
                        'blocks': [
                            { 'textNodes': [{ 'text': 'Text4' }] }
                        ]
                    },
                    {
                        'startTime': 66000,
                        'endTime': 67000,
                        'blocks': [
                            { 'textNodes': [{ 'text': 'Text5' }] }
                        ]
                    },
                    {
                        'startTime': 3661000,
                        'endTime': 4984567,
                        'blocks': [
                            { 'textNodes': [{ 'text': 'Text6' }] }
                        ]
                    }
                ]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, video aspect ratio', function () {
            return new Promise(function (resolve) {
                var xml =
                    '<tt extent="160px 240px" pixelAspectRatio="4 2"><head>' +
                    '<layout>' +
                    '<region id="r1" origin="0% 0%" extent="100% 100%" />' +
                    '<region id="r2" />' +
                    '<region id="r3" origin="10% 10%" extent="80% 80%" />' +
                    '</layout>' +
                    '</head><body><div>' +
                    '<p begin="1s" end="2s" region="r1">Text1</p>' +
                    '<p begin="3s" end="4s" region="r2">Text2</p>' +
                    '<p begin="5s" end="6s" region="r3">Text3</p>' +
                    '<p begin="8s" end="9s" extent="10% 10%">Text4</p>' +
                    '<p begin="11s" end="12s" origin="50% 50%" extent="0% 0%">Text5</p>' +
                    '</div></body></tt>';

                parseDfxpXml(xml, 1280 / 720, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([
                    {
                        'blocks': [
                            {
                                'region': {
                                    'marginLeft': 0.125,
                                    'marginRight': 0.125,
                                    'marginTop': 0,
                                    'marginBottom': 0
                                },
                                'textNodes': [{ 'text': 'Text1' }]
                            }
                        ]
                    },
                    {
                        'blocks': [
                            {
                                'region': {
                                    'marginLeft': 0.125,
                                    'marginRight': 0.125,
                                    'marginTop': 0,
                                    'marginBottom': 0
                                },
                                'textNodes': [{ 'text': 'Text2' }]
                            }
                        ]
                    },
                    {
                        'blocks': [
                            {
                                'region': {
                                    'marginLeft': 0.20,
                                    'marginRight': 0.20,
                                    'marginTop': 0.10,
                                    'marginBottom': 0.10
                                },
                                'textNodes': [{ 'text': 'Text3' }]
                            }
                        ]
                    },
                    {
                        'blocks': [
                            {
                                'region': {
                                    'marginLeft': 0.125,
                                    'marginRight': 0.80,
                                    'marginTop': 0,
                                    'marginBottom': 0.90
                                },
                                'textNodes': [{ 'text': 'Text4' }]
                            }
                        ]
                    },
                    {
                        'blocks': [
                            {
                                'region': {
                                    'marginLeft': 0.50,
                                    'marginRight': 0.50,
                                    'marginTop': 0.50,
                                    'marginBottom': 0.50
                                },
                                'textNodes': [{ 'text': 'Text5' }]
                            }
                        ]
                    }
                ]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, overlap1', function () {
            return new Promise(function (resolve) {
                var xml =
                    '<tt><head>' +
                    '<layout>' +
                    '<region id="r1" />' +
                    '<region id="r2" />' +
                    '<region id="r3" />' +
                    '</layout>' +
                    '</head><body><div>' +
                    '<p begin="3s" end="5s" region="r2">Text2</p>' +
                    '<p begin="3s" end="5s" region="r3">Text3</p>' +
                    '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([{
                    'startTime': 3000,
                    'endTime': 5000,
                    'blocks': [
                        { 'textNodes': [{ 'text': 'Text2' }] },
                        { 'textNodes': [{ 'text': 'Text3' }] }
                    ]
                }]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, overlap2', function () {
            return new Promise(function (resolve) {
                var xml =
                    '<tt><head>' +
                    '<layout>' +
                    '<region id="r1" />' +
                    '<region id="r2" />' +
                    '<region id="r3" />' +
                    '<region id="r4" />' +
                    '<region id="r5" />' +
                    '<region id="r6" />' +
                    '<region id="r7" />' +
                    '</layout>' +
                    '</head><body><div>' +
                    '<p begin="1s" end="2s" region="r1">Text1</p>' +
                    '<p begin="3s" end="5s" region="r2">Text2</p>' +
                    '<p begin="3s" end="5s" region="r3">Text3</p>' +
                    '<p begin="6s" end="7s" region="r4">Text4</p>' +
                    '<p begin="6s" end="7s" region="r5">Text5</p>' +
                    '<p begin="9s" end="10s" region="r6">Text6</p>' +
                    '<p begin="12s" end="13s" region="r7">Text7</p>' +
                    '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([{
                    'startTime': 1000,
                    'endTime': 2000,
                    'blocks': [{ 'textNodes': [{ 'text': 'Text1' }] }]
                },
                {
                    'startTime': 3000,
                    'endTime': 5000,
                    'blocks': [
                        { 'textNodes': [{ 'text': 'Text2' }] },
                        { 'textNodes': [{ 'text': 'Text3' }] }
                    ]
                },
                {
                    'startTime': 6000,
                    'endTime': 7000,
                    'blocks': [
                        { 'textNodes': [{ 'text': 'Text4' }] },
                        { 'textNodes': [{ 'text': 'Text5' }] }
                    ]
                },
                {
                    'startTime': 9000,
                    'endTime': 10000,
                    'blocks': [{ 'textNodes': [{ 'text': 'Text6' }] }]
                },
                {
                    'startTime': 12000,
                    'endTime': 13000,
                    'blocks': [{ 'textNodes': [{ 'text': 'Text7' }] }]
                }]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, overlap3', function () {
            return new Promise(function (resolve) {
                var xml =
                    '<tt><body><div>' +
                    '<p begin="1s" end="3s">Text1</p>' +
                    '<p begin="5s" end="8s">Text2</p>' +
                    '<p begin="6s" end="10s">Text3</p>' +
                    '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([{
                    'startTime': 1000,
                    'endTime': 3000,
                    'blocks': [{ 'textNodes': [{ 'text': 'Text1' }] }]
                },
                {
                    'startTime': 5000,
                    'endTime': 6000,
                    'blocks': [{ 'textNodes': [{ 'text': 'Text2' }] }]
                },
                {
                    'startTime': 6000,
                    'endTime': 10000,
                    'blocks': [{ 'textNodes': [{ 'text': 'Text3' }] }]
                }]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, sort', function () {
            return new Promise(function (resolve) {
                var xml =
                    '<tt><body><div>' +
                    '<p begin="6s" end="10s">Text3</p>' +
                    '<p begin="1s" end="3s">Text1</p>' +
                    '<p begin="5s" end="8s">Text2</p>' +
                    '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text1' }] }] },
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text2' }] }] },
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text3' }] }] }
                ]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, overlap-complex', function () {
            var xml, entries;

            return new Promise(function (resolve) {
                // multiple regions

                xml =
                '<tt><head>' +
                '<layout>' +
                '<region id="r1" />' +
                '<region id="r2" />' +
                '<region id="r3" />' +
                '<region id="r4" />' +
                '</layout>' +
                '</head><body><div>' +
                '<p begin="20s" end="30s" region="r1">Text1</p>' +
                '<p begin="25s" end="28s" region="r2">Text2</p>' +
                '<p begin="29s" end="30s" region="r3">Text3</p>' +
                '<p begin="30s" end="35s" region="r4">Text4</p>' +
                '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([
                    {
                        'startTime': 20000,
                        'endTime': 25000,
                        'blocks': [{ 'textNodes': [{ 'text': 'Text1' }] }]
                    },
                    {
                        'startTime': 25000,
                        'endTime': 28000,
                        'blocks': [
                            { 'textNodes': [{ 'text': 'Text1' }] },
                            { 'textNodes': [{ 'text': 'Text2' }] }
                        ]
                    },
                    {
                        'startTime': 28000,
                        'endTime': 29000,
                        'blocks': [{ 'textNodes': [{ 'text': 'Text1' }] }]
                    },
                    {
                        'startTime': 29000,
                        'endTime': 30000,
                        'blocks': [
                            { 'textNodes': [{ 'text': 'Text1' }] },
                            { 'textNodes': [{ 'text': 'Text3' }] }
                        ]
                    },
                    {
                        'startTime': 30000,
                        'endTime': 35000,
                        'blocks': [{ 'textNodes': [{ 'text': 'Text4' }] }]
                    }
                ]);
            })
            .then(function () {

                return new Promise(function (resolve, reject) {
                    // same region, kick the last one out

                    xml =
                    '<tt><body><div>' +
                    '<p begin="20s" end="30s">Text1</p>' +
                    '<p begin="25s" end="28s">Text2</p>' +
                    '<p begin="29s" end="30s">Text3</p>' +
                    '<p begin="30s" end="35s">Text4</p>' +
                    '</div></body></tt>';

                    parseDfxpXml(xml, undefined, undefined, undefined, resolve);
                });
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([
                    {
                        'startTime': 20000,
                        'endTime': 25000,
                        'blocks': [{ 'textNodes': [{ 'text': 'Text1' }] }]
                    },
                    {
                        'startTime': 25000,
                        'endTime': 28000,
                        'blocks': [{ 'textNodes': [{ 'text': 'Text2' }] }]
                    },
                    {
                        'startTime': 28000,
                        'endTime': 29000,
                        'blocks': [{ 'textNodes': [{ 'text': 'Text1' }] }]
                    },
                    {
                        'startTime': 29000,
                        'endTime': 30000,
                        'blocks': [{ 'textNodes': [{ 'text': 'Text3' }] }]
                    },
                    {
                        'startTime': 30000,
                        'endTime': 35000,
                        'blocks': [{ 'textNodes': [{ 'text': 'Text4' }] }]
                    }
                ]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, styles1', function () {
            var xml, entries;

            return new Promise(function (resolve) {
                // inline styles
                xml =
                '<tt><body><div>' +
                '<p begin="1s" end="2s" color="red">Text1</p>' +
                '<p begin="4s" end="5s" color="blue" textDecoration="underline">Text2</p>' +
                '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text1', 'style': { 'characterColor': "#ff0000" } }] }] },
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text2', 'style': { 'characterColor': "#0000ff", 'characterUnderline': true } }] }] }
                ]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, styles2', function () {
            var xml, entries;

            return new Promise(function (resolve) {
                // refered styles

                xml =
                '<tt><head>' +
                '<styling>' +
                '<style id="fancy" backgroundColor="green" color="pink"/>' +
                '</styling>' +
                '</head><body><div>' +
                '<p begin="1s" end="2s" style="fancy">Text1</p>' +
                '<p begin="4s" end="5s" style="fancy" color="blue">Text2</p>' +
                '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text1', 'style': { 'characterColor': '#ffc0cb', 'backgroundColor': '#00ff00' } }] }] },
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text2', 'style': { 'characterColor': '#0000ff', 'backgroundColor': '#00ff00' } }] }] }
                ]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, styles3', function () {
            var xml, entries;

            return new Promise(function (resolve) {

                // refered styles
                xml =
                '<tt><head>' +
                '<styling>' +
                '<style id="fancy1" backgroundColor="green" color="navy"  fontFamily="monospaceSansSerif" />' +
                '<style id="fancy2" backgroundColor="yellow" color="aqua" />' +
                '</styling>' +
                '<layout>' +
                '<region id="region1" style="fancy2">' +
                '<style textDecoration="underline" />' +
                '<style color="orange" />' +
                '</region>' +
                '</layout>' +
                '</head><body><div>' +
                '<p begin="01s" end="02s" style="fancy1">Text1</p>' +
                '<p begin="03s" end="04s" style="fancy1" color="black">Text2</p>' +
                '<p begin="05s" end="06s" region="region1">Text3</p>' +
                '<p begin="07s" end="08s" region="region1" style="fancy1">Text4</p>' +
                '<p begin="09s" end="10s" region="region1" style="fancy1" color="white">Text5</p>' +
                '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text1', 'style': { 'characterColor': '#000080', 'backgroundColor': '#00ff00', 'characterStyle': 'MONOSPACED_SANS_SERIF' } }] }] },
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text2', 'style': { 'characterColor': '#000000', 'backgroundColor': '#00ff00', 'characterStyle': 'MONOSPACED_SANS_SERIF' } }] }] },
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text3', 'style': { 'characterColor': '#ffa500', 'backgroundColor': '#ffff00', 'characterUnderline': true } }] }] },
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text4', 'style': { 'characterColor': '#000080', 'backgroundColor': '#00ff00', 'characterUnderline': true, 'characterStyle': 'MONOSPACED_SANS_SERIF' } }] }] },
                    { 'blocks': [{ 'textNodes': [{ 'text': 'Text5', 'style': { 'characterColor': '#ffffff', 'backgroundColor': '#00ff00', 'characterUnderline': true, 'characterStyle': 'MONOSPACED_SANS_SERIF' } }] }] }
                ]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, styles4', function () {
            var xml, entries;

            return new Promise(function (resolve) {

                // refered styles
                xml =
                '<tt><head>' +
                '<styling>' +
                '<style id="fancy1" backgroundColor="green" color="navy"  fontFamily="monospaceSansSerif" />' +
                '<style id="fancy2" backgroundColor="yellow" color="aqua" />' +
                '<style id="fancy3" color="#666666" />' +
                '</styling>' +
                '<layout>' +
                '<region id="region1" style="fancy2">' +
                '<style textDecoration="underline" />' +
                '<style color="orange" />' +
                '</region>' +
                '</layout>' +
                '</head><body><div>' +
                '<p begin="07s" end="08s" region="region1" style="fancy1">Text4</p>' +
                '<p begin="09s" end="10s" region="region1" style="fancy1" color="white">Text5<span backgroundColor="#123456">bg</span>end</p>' +
                '<p begin="11s" end="12s" region="region1" style="fancy1" color="white">Text6<span backgroundColor="#123456" style="fancy3">bg</span>end</p>' +
                '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([
                    {
                        'blocks': [{
                            'textNodes': [
                                { 'text': 'Text4', 'style': { 'characterColor': '#000080', 'backgroundColor': '#00ff00', 'characterUnderline': true, 'characterStyle': 'MONOSPACED_SANS_SERIF' } }
                            ]
                        }]
                    },
                    {
                        'blocks': [{
                            'textNodes': [
                                { 'text': 'Text5', 'style': { 'characterColor': '#ffffff', 'backgroundColor': '#00ff00', 'characterUnderline': true, 'characterStyle': 'MONOSPACED_SANS_SERIF' } },
                                { 'text': 'bg', 'style': { 'characterColor': '#ffffff', 'backgroundColor': '#123456', 'characterUnderline': true, 'characterStyle': 'MONOSPACED_SANS_SERIF' } },
                                { 'text': 'end', 'style': { 'characterColor': '#ffffff', 'backgroundColor': '#00ff00', 'characterUnderline': true, 'characterStyle': 'MONOSPACED_SANS_SERIF' } }
                            ]
                        }]
                    },
                    {
                        'blocks': [{
                            'textNodes': [
                                { 'text': 'Text6', 'style': { 'characterColor': '#ffffff', 'backgroundColor': '#00ff00', 'characterUnderline': true, 'characterStyle': 'MONOSPACED_SANS_SERIF' } },
                                { 'text': 'bg', 'style': { 'characterColor': '#666666', 'backgroundColor': '#123456', 'characterUnderline': true, 'characterStyle': 'MONOSPACED_SANS_SERIF' } },
                                { 'text': 'end', 'style': { 'characterColor': '#ffffff', 'backgroundColor': '#00ff00', 'characterUnderline': true, 'characterStyle': 'MONOSPACED_SANS_SERIF' } }
                            ]
                        }]
                    }
                ]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, region1', function () {
            return new Promise(function (resolve) {
                var xml, entries;
                
                xml =
                '<tt><body><div>' +
                '<p begin="01s" end="02s" displayAlign="before" textAlign="start">Text1</p>' +
                '<p begin="03s" end="04s" displayAlign="center" textAlign="start">Text2</p>' +
                '<p begin="05s" end="06s" displayAlign="after" textAlign="start">Text3</p>' +
                '<p begin="07s" end="08s" displayAlign="before" textAlign="center">Text4</p>' +
                '<p begin="09s" end="10s" displayAlign="center" textAlign="center">Text5</p>' +
                '<p begin="11s" end="12s" displayAlign="after" textAlign="center">Text6</p>' +
                '<p begin="13s" end="14s" displayAlign="before" textAlign="end">Text7</p>' +
                '<p begin="15s" end="16s" displayAlign="center" textAlign="end">Text8</p>' +
                '<p begin="17s" end="18s" displayAlign="after" textAlign="end">Text9</p>' +
                '<p begin="19s" end="20s" displayAlign="before">Text10</p>' +
                '<p begin="21s" end="22s" displayAlign="center">Text11</p>' +
                '<p begin="23s" end="24s" displayAlign="after">Text12</p>' +
                '<p begin="25s" end="26s" textAlign="start">Text13</p>' +
                '<p begin="27s" end="28s" textAlign="center">Text14</p>' +
                '<p begin="29s" end="30s" textAlign="end">Text15</p>' +
                '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'top', 'horizontalAlignment': 'left' },
                            'textNodes': [{ 'text': 'Text1' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'center', 'horizontalAlignment': 'left' },
                            'textNodes': [{ 'text': 'Text2' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'bottom', 'horizontalAlignment': 'left' },
                            'textNodes': [{ 'text': 'Text3' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'top', 'horizontalAlignment': 'center' },
                            'textNodes': [{ 'text': 'Text4' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'center', 'horizontalAlignment': 'center' },
                            'textNodes': [{ 'text': 'Text5' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'bottom', 'horizontalAlignment': 'center' },
                            'textNodes': [{ 'text': 'Text6' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'top', 'horizontalAlignment': 'right' },
                            'textNodes': [{ 'text': 'Text7' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'center', 'horizontalAlignment': 'right' },
                            'textNodes': [{ 'text': 'Text8' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'bottom', 'horizontalAlignment': 'right' },
                            'textNodes': [{ 'text': 'Text9' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'top', 'horizontalAlignment': 'left' },
                            'textNodes': [{ 'text': 'Text10' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'center', 'horizontalAlignment': 'left' },
                            'textNodes': [{ 'text': 'Text11' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'bottom', 'horizontalAlignment': 'left' },
                            'textNodes': [{ 'text': 'Text12' }]
                        }]
                    },
                    // lack of displayAlign makes this default to bottom (simple sdh defaults)
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'bottom', 'horizontalAlignment': 'left' },
                            'textNodes': [{ 'text': 'Text13' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'bottom', 'horizontalAlignment': 'center' },
                            'textNodes': [{ 'text': 'Text14' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'verticalAlignment': 'bottom', 'horizontalAlignment': 'right' },
                            'textNodes': [{ 'text': 'Text15' }]
                        }]
                    }
                ]);
            });
        });

        (isSafari?it.skip:it)('parse to DFXP format, region3', function () {
            return new Promise(function (resolve) {
                var xml, entries;

                xml =
                '<tt>' +
                '<head><layout>' +
                '<region id="r1">' +
                '</region>' +
                '<region id="r2">' +
                '<style displayAlign="after" />' +
                '<style textAlign="end" />' +
                '</region>' +
                '<region id="r3">' +
                '<style displayAlign="before" />' +
                '<style textAlign="center" />' +
                '<style origin="25% 25%" />' +
                '<style extent="50% 50%" />' +
                '</region>' +
                '</layout></head><body><div>' +
                '<p begin="01s" end="02s" region="r1">Text1</p>' +
                '<p begin="03s" end="04s" region="r2">Text2</p>' +
                '<p begin="05s" end="06s" region="r3">Text3</p>' +
                '<p begin="07s" end="08s"  region="r3" textAlign="end">Text4</p>' +
                '<p begin="09s" end="10s"  region="r3" extent="25% 25%">Text4</p>' +
                '</div></body></tt>';

                parseDfxpXml(xml, undefined, undefined, undefined, resolve);
            })
            .then(function (result) {
                expect(result.entries).to.have.properties([
                    {
                        'blocks': [{
                            'region': { 'marginTop': 0, 'marginLeft': 0, 'marginRight': 0, 'marginBottom': 0, 'verticalAlignment': 'top', 'horizontalAlignment': 'left' },
                            'textNodes': [{ 'text': 'Text1' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'marginTop': 0, 'marginLeft': 0, 'marginRight': 0, 'marginBottom': 0, 'verticalAlignment': 'bottom', 'horizontalAlignment': 'right' },
                            'textNodes': [{ 'text': 'Text2' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'marginTop': 0.25, 'marginLeft': 0.25, 'marginRight': 0.25, 'marginBottom': 0.25, 'verticalAlignment': 'top', 'horizontalAlignment': 'center' },
                            'textNodes': [{ 'text': 'Text3' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'marginTop': 0.25, 'marginLeft': 0.25, 'marginRight': 0.25, 'marginBottom': 0.25, 'verticalAlignment': 'top', 'horizontalAlignment': 'right' },
                            'textNodes': [{ 'text': 'Text4' }]
                        }]
                    },
                    {
                        'blocks': [{
                            'region': { 'marginTop': 0.25, 'marginLeft': 0.25, 'marginRight': 0.75, 'marginBottom': 0.75, 'verticalAlignment': 'top', 'horizontalAlignment': 'center' },
                            'textNodes': [{ 'text': 'Text4' }]
                        }]
                    }
                ]);
            });
        });
    });
});


// -- ../../../tests/functional/js/tests-ipAddress.js
addTest(function () {
    var expect = chai.expect;

    describe('IPAddress', function () {
        it('validate IPV4 and IPV6 addresses', function () {
            return Promise.resolve().then(function () {
                var ipv4_addr =
                    ['168.192.27.54',
                    '1.1.1.1',
                    '0.0.0.0',
                    '198.45.23.244',
                    '127.0.0.1',
                    '10.10.10.10',
                    '255.255.255.255'];

                var bad_ipv4_addrs =
                    ['12345678',
                    '192.27.54',
                    '1168.192.27.54',
                    '01.192.1.54',
                    'abc.192.1.54'];

                var ipv6_addr = [
                    '2001:db8:85a3:0:0:8a2e:370:7334',
                    '2001:db8:85a3:0:0:8a2e:0.0.0.2',
                    '2001:db8:85a3::8a2e:370:7334',
                    '0:0:0:0:0:0:0:1',
                    '0:0:0:0:0:0:0:0',
                    '::1',
                    '::',
                    '2001:0db8::0001',
                    '2001:db8::1',
                    '2001:db8:0:0:0:0:2:1',
                    '2001:DB8::1',
                    '2001:db8:85a3:8d3:1319:8a2e:370:7348'];

                // this is what a valid IPv6 address will look like after expanding '::'
                var ipv6_addr_expanded = [
                    '2001:db8:85a3:0:0:8a2e:370:7334',
                    '2001:db8:85a3:0:0:8a2e:0:2',
                    '2001:db8:85a3:0:0:8a2e:370:7334',
                    '0:0:0:0:0:0:0:1',
                    '0:0:0:0:0:0:0:0',
                    '0:0:0:0:0:0:0:1',
                    '0:0:0:0:0:0:0:0',
                    '2001:0db8:0:0:0:0:0:0001',
                    '2001:db8:0:0:0:0:0:1',
                    '2001:db8:0:0:0:0:2:1',
                    '2001:DB8:0:0:0:0:0:1',
                    '2001:db8:85a3:8d3:1319:8a2e:370:7348'];


                var bad_ipv6_addr = [
                    '2001:0db8:85a3:0000:0000:8a2e:0370',
                    '2001:0db8:85a3:0000:0000:8a2e:0370:1234:1234',
                    '::0db8:85a3:0000::8a2e:0370',
                    '68.10.0.1:0:0db5',
                    'xxyy'];

                var samples;

                samples = ipv4_addr.length;
                while (samples--) {
                    expect(IPAddress$getValidIPv4(ipv4_addr[samples])).to.equal(ipv4_addr[samples]);
                    expect(IPAddress$getValidIPv6(ipv4_addr[samples])).to.equal(undefined);
                }

                samples = bad_ipv4_addrs.length;
                while (samples--) {
                    expect(IPAddress$getValidIPv4(ipv6_addr[samples])).to.equal(undefined);
                    expect(IPAddress$getValidIPv6(ipv4_addr[samples])).to.equal(undefined);
                }

                samples = ipv6_addr.length;
                while (samples--) {
                    expect(IPAddress$getValidIPv6(ipv6_addr[samples])).to.equal(ipv6_addr_expanded[samples]);
                    expect(IPAddress$getValidIPv4(ipv6_addr[samples])).to.equal(undefined);
                }

                samples = bad_ipv6_addr.length;
                while (samples--) {
                    expect(IPAddress$getValidIPv4(bad_ipv6_addr[samples])).to.equal(undefined);
                    expect(IPAddress$getValidIPv6(bad_ipv6_addr[samples])).to.equal(undefined);
                }
            });
        });

        it('validate if IPV4 and IPV6 addresses are in the same subnet', function () {
            return Promise.resolve().then(function () {
                var ipv4_addr_a = '168.192.27.54';
                var ipv4_addr_b = '168.192.27.100';

                expect(IPAddress$isInSameSubnet(ipv4_addr_a, ipv4_addr_b, 24)).to.equal(true);

                ipv4_addr_b = '171.167.27.54';
                expect(IPAddress$isInSameSubnet(ipv4_addr_a, ipv4_addr_b, 24)).to.equal(false);

                var ipv6_addr_a = '2001:0db8:85a3:0000:0000:8a2e:0db8:ab10';
                var ipv6_addr_b = '2001:0db8:85a3:0000:0000:8a2e:0000:0000';

                expect(IPAddress$isInSameSubnet(ipv6_addr_a, ipv6_addr_b, 96)).to.equal(true);
                expect(IPAddress$isInSameSubnet(ipv6_addr_a, ipv6_addr_b, 128)).to.equal(false);

                ipv6_addr_b = '2001:0db8:85a3:0000:0000:8a2e:0db8:ab11';
                expect(IPAddress$isInSameSubnet(ipv6_addr_a, ipv6_addr_b, 127)).to.equal(true);
                expect(IPAddress$isInSameSubnet(ipv6_addr_a, ipv6_addr_b, 128)).to.equal(false);

                ipv6_addr_b = '::';
                expect(IPAddress$isInSameSubnet(ipv6_addr_a, ipv6_addr_b, 96)).to.equal(false);
            });
        });
    });
});



// -- ../../../tests/functional/js/tests-subChunking.js
addTest(function () {
    var expect = chai.expect;

    var CS_32k = Math.pow(2, 15);
    var CS_64k = Math.pow(2, 16);

    describe("SubChunkPlanner Instantiations", function () {
        var sc = createSubChunkPlanner();

        before('Suite Setup', function () {
            return Promise.resolve().then(function () {        
                expect(!!sc).to.equal(true);
            });
        });

        it("expect idealSubchunkSize to equal 64k when using default SubChunkPlanner constructor", function () {
            return Promise.resolve().then(function () {
                expect(sc.idealSubchunkSize).to.be.equal(Math.pow(2, 16)); //64k
            });
        });

        it("expect idealSubchunkSize to equal the value passed into SubChunkPlanner constructor", function () {
            return Promise.resolve().then(function () {
                sc = createSubChunkPlanner(CS_32k); //32k
                expect(sc.idealSubchunkSize).to.be.equal(Math.pow(2, 15));
            });
        });
    });

    describe("SubChunkPlanner SubChunkJobs", function () {
        // For each of these test, subchunk order, offset and lengths.

        var subChunkSize = CS_64k;
        var chunkSpecsAsserts64k = getContext().chunkSpecsAsserts64k;
        var fakeChunk = { type: 'video', index: 0 };
        var numWorkers = 3;
        var sc = createSubChunkPlanner(subChunkSize);

        before('Suite Setup', function () {
            return Promise.resolve().then(function () {
                expect(!!sc).to.equal(true);
            });
        });

        it('compute sub-chunk jobs using 3 workers', function () {
            return Promise.resolve().then(function () {
                var chunkSpec = chunkSpecsAsserts64k[2].spec;
                var jobs = sc.computeSubChunkJobs(chunkSpec, fakeChunk, numWorkers);

                expect(jobs.length === 1).to.equal(true, 'expected jobs length == 1');
                expect(jobs[0].offset === 0).to.equal(true, 'expected first job offset == 0');
                expect(jobs[0].length === chunkSpec.length).to.equal(true, 'expected first job length == chunkSpec.length');

                // Test with one two and three workers
                chunkSpecsAsserts64k.forEach(function (specAssert) {
                    var jobs = sc.computeSubChunkJobs(specAssert.spec, fakeChunk, numWorkers);
                    var spec = specAssert.spec;
                    var specString = String$format("length: {0}, offset: {1}", spec.length, spec.offset);
                    var lastJob = jobs[jobs.length - 1];

                    expect(jobs.length === specAssert.expected.num).to.equal(true, String$format("Jobs length for spec: {0}, expected: {1}, was: {2}", specString, specAssert.expected.num, jobs.length));
                    expect(specAssert.expected.lastChunkLength === lastJob.length).to.equal(true,
                        String$format("Length of remainder subchunk for spec: {0}, expected: {1}, was: {2}",
                            specString,
                            specAssert.expected.lastChunkLength,
                            lastJob.length
                        ));
                });
            });
        });
    });

    function getContext() {
        var context = {};
        context.chunkSpecsAsserts64k = [
            // ZERO OFFSET
            // * Parent Chunk size < subchunk size
            { spec: { length: CS_64k - 1, offset: 0 }, expected: { num: 1, lastChunkLength: CS_64k - 1 } },

            // * Parent Chunk size == subchunk size
            { spec: { length: CS_64k, offset: 0 }, expected: { num: 1, lastChunkLength: CS_64k } },

            // * subchunkSize < Parent Chunk Size < 2 * subchunk size
            { spec: { length: 112707, offset: 0 }, expected: { num: 1, lastChunkLength: 112707 } },

            // * Parent Chunk size == 2 * subchunk size
            { spec: { length: 2 * CS_64k, offset: 0 }, expected: { num: 2, lastChunkLength: CS_64k } },

            // * 3 * subchunk size < Parent Chunk size < 4 * subchunk size 
            { spec: { length: 197608, offset: 0 }, expected: { num: 3, lastChunkLength: 66536 } }

        ];

        return context;
    }

    /**
    * create an instance of the subchunk planner optionally specifying a subchunk size.
    * @param {number=} subchunkSize size of the subchunk
    */
    function createSubChunkPlanner(subchunkSize) {
        var sc = new SubChunkPlanner(subchunkSize);
        return sc;
    }
});





// -- ../../../tests/functional/js/test-mdxhooks.js
addTest(function () {
    var expect = chai.expect;

    describe('MDX', function () {
        it('create crypto context from shared secret', function () {
            return new Promise(function (resolve) {
                VideoSession$asyncComponents['mdx']['createCryptoContextFromSharedSecret']('QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQQ==', resolve);
            })
            .then(function (result) {
                expect(!!result['success']).to.equal(true);
                var cc = result['cryptoContext'];
                expect(!!cc).to.equal(true);

                var encryptPromise = new Promise(function (resolve) {
                    cc['encrypt']('hello', resolve);
                })
                .then(function (result) {
                    return new Promise(function (resolve) {
                        var a = base64$decode(result['encryptedDataAsn1Base64']);
                        var stream = new DataStream(a);

                        expect(stream.readByte()).to.equal(2);                  // version = 2
                        expect(stream.readAsn1Octet().length).to.equal(16);     // iv
                        expect(stream.readAsn1Octet().length >= 4).to.equal(true);  // cipher text

                        cc['decrypt'](result['encryptedDataAsn1Base64'], resolve);
                    });
                })
                .then(function (result) {
                    expect(!!result['success']).to.equal(true);
                    expect(result['text']).to.equal('hello');
                });

                var decryptPromise = new Promise(function (resolve) {
                    cc['decrypt']('AhBR/1cAdPchwpY++LtmwuRfEOfLjjBOiN9SZTQBWQGiD8o=', resolve);
                })
                .then(function (result) {
                    expect(!!result['success']).to.equal(true);
                    expect(result['text']).to.equal('hello');
                });

                var hmacPromise = new Promise(function (resolve) {
                    cc['hmac']('hello', resolve);
                })
                .then(function (result) {
                    expect(!!result['success']).to.equal(true);
                    expect(result['hmacBase64']).to.equal('1zhq2jiAZcj1vJoLsT2BT2f8EEJWj5Y2ud1DNDg6wFU=');
                });

                return Promise.all([encryptPromise, decryptPromise, hmacPromise]);
            });
        });
    });
});


// -- ../../../tests/functional/js/tests-historical.js
addTest(function () {
    var expect = chai.expect;

    describe('Historical', function () {
        // local config for testing purposes
        var histMinSampleSize = 1,
            histMaxSampleSize = 5;
        var expBandwidth;
        // Date.UTC(2013,0,1,8)
        var tueMorning = 1357027200;
        // Date.UTC(2013,0,2,8)
        var wedMorning = 1357113600;
        // Date.UTC(2013,0,5,20)
        var satEvening = 1357416000;

        var fiveMinutes = 5 * 60; // in seconds

        var tuesdayMorningMeasurements = [],
            wedMorningMeasurements = [],
            satEveningMeasurements = [];

        var allMeasurements;

        before('Setup', function () {
            return Promise.resolve().then(function () {
                if (!config) {
                    config$load([{
                        'logDisplayAutoshowLevel': '-1'
                    }]);
                }

                satEveningMeasurements.push(new HistoricalBandwidthMeasurement(satEvening, 10, 2000, 1000 * 1024 * 1024));
                satEveningMeasurements.push(new HistoricalBandwidthMeasurement(satEvening + fiveMinutes, 10, 2000, 1000 * 1024 * 1024));
                satEveningMeasurements.push(new HistoricalBandwidthMeasurement(satEvening + 2 * fiveMinutes, 10, 2000, 1000 * 1024 * 1024));

                tuesdayMorningMeasurements.push(new HistoricalBandwidthMeasurement(tueMorning, 10, 2000, 1000 * 1024 * 1024));
                tuesdayMorningMeasurements.push(new HistoricalBandwidthMeasurement(tueMorning + fiveMinutes, 10, 2000, 1000 * 1024 * 1024));
                tuesdayMorningMeasurements.push(new HistoricalBandwidthMeasurement(tueMorning + 2 * fiveMinutes, 10, 2000, 1000 * 1024 * 1024));

                wedMorningMeasurements.push(new HistoricalBandwidthMeasurement(wedMorning, 10, 2000, 1000 * 1024 * 1024));
                wedMorningMeasurements.push(new HistoricalBandwidthMeasurement(wedMorning + fiveMinutes, 10, 2000, 1000 * 1024 * 1024));
                wedMorningMeasurements.push(new HistoricalBandwidthMeasurement(wedMorning + 2 * fiveMinutes, 10, 2000, 1000 * 1024 * 1024));

                allMeasurements = satEveningMeasurements.concat(tuesdayMorningMeasurements);
                allMeasurements = allMeasurements.concat(wedMorningMeasurements);
            });
        });

        describe('Test Day-of-Week Time-of-Day filtering', function () {
            /* Test Day-of-Wek Time-of-Day filtering */

            before('Suite Setup', function () {
                return Promise.resolve().then(function () {
                    expBandwidth = new ExpectedBandwidth(allMeasurements, wedMorning, ExpectedBandwidth$FilterType_DayOfWeekTimeOfDay, config.histTimeOfDayRangeInSeconds, histMinSampleSize, histMaxSampleSize * 10, false, 1, allMeasurements.length);
                });
            })

            it('Time-of-Day & Day-of-Week', function () {
                return Promise.resolve().then(function () {
                    expect(expBandwidth.orderedBandwidths.length).to.equal(3);
                });
            });

            it('Time-of-Day & Day-of-Week Filter', function () {
                return Promise.resolve().then(function () {
                    expect(ExpectedBandWidth$finalFilterType).to.equal(ExpectedBandwidth$FilterType_DayOfWeekTimeOfDay);
                });
            });
        });

        describe('Test Time-of-Day filtering', function () {
            /* Test Time-of-Day filtering */

            before('Suite Setup', function () {
                return Promise.resolve().then(function () {
                    expBandwidth = new ExpectedBandwidth(allMeasurements, wedMorning, ExpectedBandwidth$FilterType_TimeOfDay, config.histTimeOfDayRangeInSeconds, histMinSampleSize, histMaxSampleSize * 10, false, 1, allMeasurements.length);
                });
            });

            it('Time-of-Day', function () {
                return Promise.resolve().then(function () {
                    expect(expBandwidth.orderedBandwidths.length).to.equal(6);
                });
            });
            
            it('Time-of-Day & Day-of-Week', function () {
                return Promise.resolve().then(function () {
                    expect(ExpectedBandWidth$finalFilterType).to.equal(ExpectedBandwidth$FilterType_TimeOfDay);
                });
            });
        });

        describe('Test minimum sample size', function () {
            /* Test minimum sample size */

            it('Minimum sample size requirement not met', function () {
                return Promise.resolve().then(function () {
                    expBandwidth = new ExpectedBandwidth(allMeasurements, wedMorning, ExpectedBandwidth$FilterType_DayOfWeekTimeOfDay, config.histTimeOfDayRangeInSeconds, histMinSampleSize * 10, histMaxSampleSize * 10, false, 1, allMeasurements.length);
                    expect(expBandwidth.orderedBandwidths.length).to.equal(0);
                });
            });

            it('Minimum sample size requirement met', function () {
                return Promise.resolve().then(function () {
                    expBandwidth = new ExpectedBandwidth(allMeasurements, wedMorning, ExpectedBandwidth$FilterType_None, config.histTimeOfDayRangeInSeconds, histMinSampleSize * 5, histMaxSampleSize * 10, false, 1, allMeasurements.length);
                    expect(expBandwidth.orderedBandwidths.length).to.equal(expBandwidth.orderedBandwidths.length);
                });
            });
        });

        describe('Test fall-through and logging the correct filter type', function () {
            /* Test fall-through and logging the correct filter type */
    
            it('From DoW-ToD to ToD only', function () {
                return Promise.resolve().then(function () {
                    expBandwidth = new ExpectedBandwidth(allMeasurements, wedMorning, ExpectedBandwidth$FilterType_DayOfWeekTimeOfDay, config.histTimeOfDayRangeInSeconds, histMinSampleSize * 5, histMaxSampleSize * 10, false, 1, allMeasurements.length);
                    expect(ExpectedBandWidth$finalFilterType).to.equal(ExpectedBandwidth$FilterType_TimeOfDay);
                });
            });

            it('From DoW-ToD to None', function () {
                return Promise.resolve().then(function () {
                    expBandwidth = new ExpectedBandwidth(allMeasurements, wedMorning, ExpectedBandwidth$FilterType_DayOfWeekTimeOfDay, config.histTimeOfDayRangeInSeconds, histMinSampleSize * 7, histMaxSampleSize * 10, false, 1, allMeasurements.length);
                    expect(ExpectedBandWidth$finalFilterType).to.equal(ExpectedBandwidth$FilterType_None);
                });
            });

            it('From ToD to None', function () {
                return Promise.resolve().then(function () {
                    expBandwidth = new ExpectedBandwidth(allMeasurements, wedMorning, ExpectedBandwidth$FilterType_DayOfWeekTimeOfDay, config.histTimeOfDayRangeInSeconds, histMinSampleSize * 7, histMaxSampleSize * 10, false, 1, allMeasurements.length);
                    expect(ExpectedBandWidth$finalFilterType).to.equal(ExpectedBandwidth$FilterType_None);
                });
            });
        });

        describe('Test maximum sample size, dropping oldest measurements', function () {
            /* Test maximum sample size, dropping oldest measurements */

            it('Under the maximum size', function () {
                return Promise.resolve().then(function () {
                    expBandwidth = new ExpectedBandwidth(allMeasurements, wedMorning, ExpectedBandwidth$FilterType_None, config.histTimeOfDayRangeInSeconds, histMinSampleSize, histMaxSampleSize * 2, false, 1, allMeasurements.length);
                    expect(expBandwidth.orderedBandwidths.length).to.equal(allMeasurements.length);
                });
            });

            it('Over maximum size', function () {
                return Promise.resolve().then(function () {
                    expBandwidth = new ExpectedBandwidth(allMeasurements, wedMorning, ExpectedBandwidth$FilterType_None, config.histTimeOfDayRangeInSeconds, histMinSampleSize, histMaxSampleSize, false, 1, allMeasurements.length);
                    expect(expBandwidth.orderedBandwidths.length).to.equal(5);
                });
            });
        });
    });
});


// -- ../../../tests/functional/js/tests-http.js
addTest(function () {
    var expect = chai.expect;

    describe('http', function () {

        it('http$constructRequestRange', function () {
            expect(http$constructRequestRange({})).to.equal(undefined);
            expect(http$constructRequestRange({ offset: 0 })).to.equal('0-');
            expect(http$constructRequestRange({ offset: 22 })).to.equal('22-');
            expect(http$constructRequestRange({ offset: 10, length: 99 })).to.equal('10-108');
        });

        it('http$constructRequestUrl', function () {
            var response;

            response = {};
            http$constructRequestUrl({
                url: 'http://198.45.62.134/?o=AQFmIuWSyrgL2EY5v_Okmz1lM2r-nJ31bhV7BRE2vGU4R2UlPr_XMy-F2Y_aWlzDE4eKagjic8NzsDXxsNz5nsvDmQ_vrU_M9akKjHi6Xr5tIIvBWa4BJj7FKLKRS4Lo&v=3&e=1411008021&t=A5Qb1jQWD1sKvPks4-EsKYZMJjA',
                offset: 95378017,
                length: 2670285,
                cacheBuster: true
            }, response);
            expect(response.range).to.equal('95378017-98048301');
            expect(response.url).to.equal('http://198.45.62.134/range/95378017-98048301?o=AQFmIuWSyrgL2EY5v_Okmz1lM2r-nJ31bhV7BRE2vGU4R2UlPr_XMy-F2Y_aWlzDE4eKagjic8NzsDXxsNz5nsvDmQ_vrU_M9akKjHi6Xr5tIIvBWa4BJj7FKLKRS4Lo&v=3&e=1411008021&t=A5Qb1jQWD1sKvPks4-EsKYZMJjA&random=' + response.url.match(/random=([0-9]+)/)[1]);

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com' }, response);
            expect(response.url).to.equal('http://foo.com');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com/' }, response);
            expect(response.url).to.equal('http://foo.com/');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com/?a=b' }, response);
            expect(response.url).to.equal('http://foo.com/?a=b');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com', offset: 10, length: 99 }, response);
            expect(response.range).to.equal('10-108');
            expect(response.url).to.equal('http://foo.com/range/10-108');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com/', offset: 10, length: 99 }, response);
            expect(response.url).to.equal('http://foo.com/range/10-108');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com?a=b', offset: 10, length: 99 }, response);
            expect(response.url).to.equal('http://foo.com/range/10-108?a=b');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com/?a=b', offset: 10, length: 99 }, response);
            expect(response.url).to.equal('http://foo.com/range/10-108?a=b');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com/bar', offset: 10, length: 99 }, response);
            expect(response.url).to.equal('http://foo.com/bar/range/10-108');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com/bar/', offset: 10, length: 99 }, response);
            expect(response.url).to.equal('http://foo.com/bar/range/10-108');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com/bar?a=b', offset: 10, length: 99 }, response);
            expect(response.url).to.equal('http://foo.com/bar/range/10-108?a=b');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com/bar/?a=b', offset: 10, length: 99 }, response);
            expect(response.url).to.equal('http://foo.com/bar/range/10-108?a=b');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com/bar/?a=b', offset: 10 }, response);
            expect(response.range).to.equal('10-');
            expect(response.url).to.equal('http://foo.com/bar/range/10-?a=b');

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com', offset: 10, length: 99, cacheBuster: true }, response);
            expect(response.url).to.equal('http://foo.com/range/10-108?random=' + response.url.match(/random=([0-9]+)/)[1]);

            response = {};
            http$constructRequestUrl({ url: 'http://foo.com/bar?a=b', offset: 10, length: 99, cacheBuster: true }, response);
            expect(response.url).to.equal('http://foo.com/bar/range/10-108?a=b&random=' + response.url.match(/random=([0-9]+)/)[1]);

        });

    });

});


// -- ../../../tests/functional/js/tests-protobufDecoder.js
addTest(function() {
    var expect = chai.expect;
 
    describe('Protobuf Decoder', function() {
 
        describe('Chrome OS', function() {
    		var challengeWithRA = 'CAESpAsK6QoIARLxCQq0AggCEhZDaHJvbWVDRE0tQ2hyb21lT1MteDg2GKaojo4FIo4CMIIBCgKCAQEAqnQ1fDlVp6QxYLXZ23afAt70Ufr7mGk8hnfgUePb275ifL+BW4MxFTK8I7kSCNI4ZaTHVmsA/L8yANgJKm1Yq39yvuLTExyngam4jEFpPlwBv3hf1lExmWAM9K2Pivt/tIq9Ji7ZzjUG8W+ozm4m0iCoon29CBiehrfjTM6dTnd2CsqptrGE1HPLLTpj89YdMD8y0hrFBc+JQtNGEQenHX5RYu46JdZdffrWkApiir4rk3hvTXicyKYZq5GbeJA++sBaH8F7V6932iu7mKFxcB5g24qGgUnRscdNFDmPCRbkuEFwX8P6YUiLpgnUYpd8EeGbaRJj1fui3eblwC/irwIDAQABKNUgEoACeBgDpCWA8pMdRFsEtV58GsZVkRaLgV03/E7M2pafZJXi0inZRdu+l6VI+RdXJmrfDiAkGQpUMXMWzeCFCZUPy3ji0Yi3t6/IemWJuNeceDMBPUcy2GvK244wIpIgoOqWjCnCD+vKhGYDaHJKKkAl6xcKUHKPoJqRki/pX6DDfZu9uMMBwA6Mp2uW5qzDeYmrKTrkbTUMuQLKgKer9HeOLWZr7UTdw4bym/QXV0zNhBfkv5bSdpjJBS1pIx+vBKSqqSHOUL6rsda48wfkKnhVVcwZmxT0PZ/z0q3WvvWVydCK2/Otsi+fQq0uREQekgA46nlC1lkWC78M+XDu3E5lpRq0BQquAggBEhCch1qYKAc6H+BAWqbFY6gVGI6kjo4FIo4CMIIBCgKCAQEAreXn8CcRKOqk9cRK2BkoT4inxpCBZJqSWpuWhOjLza0wtUWz5iWSrIhLL9KcX6GIBRB5PYES97qvs0b1zh5R2GNrCpuZOKykimdBz4FONPI7j+KPWsa+h/bWCzQEvFLlIWEjmJ3QINaI9BZI1JZ6Rumg9bkyX5K9N0q8g3ZMM92dDG3e98vp9dpIASVOTlp+AzsIKD4/dY3AmSTxZtS/PW9RVqtrYtRtX04pk/qfxDyNPUqwSwS/ZbfcSdohmo/CaqyfnhewdEUJDPtkecCIIJMX1+nvySJxREHdUaKzU8H+fIjtajPDBr0Ahsq0Q6UFVK5bbuQbWFi02ek4Ukc0NwIDAQABKNUgEoADlKHKBThBYPDITK3H1cuMkdAtKbnuqGnZpvi+VPdgjdGMfq4SupGcNUAXRSkZZEjGfST6sH2brNqlBBPDcxDJhqhFxt6DK2oLJaGOFaXci0CgwaxgiSmByugGYJjqJSUZfi7Wn6INm9lbNV3HZ3ums/QHJWAm6mwZaVAmgoCq4RHCIRPyYx1RSzDaPW5S/mv/RBQCuvHDipPdn5+ddLJMGKCFX8wlGrr4fprcp2pwwpQw4xVefYc902ee7RkopsNee26e+JYA9AKlrmuBTZAaWAJP3ymXz4NlPaSKtSlsGroAVwHBuvZLgfnzl6gjzThT5NQBczQUXl2V2ffHHT51u+RuVwQEON6YpmldK4aCOmOM7WELZcntf2s5NhrltB/ziBSNxJKxbvsBekRCKxE6rzeh/nwIu8Nob3M0DrSkttr9+9rBLUg4lYA9Q9QDtpeZbiZ6k3Uixc3ssxT5noO0GAl5cEbbdqSkWoHbCV4wOS3ZT19zTEItFQQ27yhF+ob1GhsKEWFyY2hpdGVjdHVyZV9uYW1lEgZ4ODYtNjQaFgoMY29tcGFueV9uYW1lEgZHb29nbGUaFwoKbW9kZWxfbmFtZRIJQ2hyb21lQ0RNGhkKDXBsYXRmb3JtX25hbWUSCENocm9tZU9TMggIARABGAAgABIsCioKFAgBEhAAAAAAOTgBTgAAAAAAAAAAEAEaEJyn9+N/Bv+u1hAKtXLnk3sYASDX4sKgBTAVGoACAn/KtU0qlOBl0Y5L3E2/IepBjrbIBYn6Wiq4S7LUj1htuR/+gsio+qLG+mD44uwJIl/ofHtM22bkJ0v4clvZfFqV5aJWBeZD9E6ZV6ebjxpxIwf2isD1YzxCeAQj48zUEQlQHx2JrrJGlqknoT1P325z3qEdNLHtkQe8fITH9EKCUBmUt0tRToqILGJ6J3Y7FNTXthZSAdNrwuGJUkYK6n/on1ioCm+reqLixncEwuUCevo5iqQCA6ygpRV0MkuhQLZKKsJUX75mGd0+LnwNVDow4ZBWntjI3UeVOoYDdOFaj2kWJXUr2v9jwL6CfiM4YkSrNFpjqO4qeXCDVEfH9SqIGwrsGAoQdGVzdC5uZXRmbGl4LmNvbRIQ5US6QAvBDzfTtjb4tU/7QxqwFkUwJOfYu63ZYxqWPs+BDfFxIY+uePcy1/SFMzBdNoLkOfN6f3kBWWym4jurZd5vpc+FmbOntLLISOCLOp7sqB0fUuE2ItoeimcwOXCAa+GRdaAjVwhS+RKNFg5iO7fiGgSYn0C0KKUrtilQ01ZsLqrYeh7VA5Tuy7pjdWIKFfTOP0HfDDQqfYw7DKxrlzzCEOTZwba/buGtDF+xg0GkianJ2VQqYTqjztVE1BHtRFZ1va0XN8lMxahAy8+gyQJM0E6qbd9CmU987ht0L4olci45JCwOe2zAMgKu85tQrGjM4/OlGl/QB09YESDmDQopVHvTEXG7lkf66NyorHRevjpLzrf/s6UZqwpJf5PFVgXAsdWuWUEqGX1RrqVrhBfUCq326V4qcY59x+4OT+Tc9eDNe+h1GaEmdmBAT4S+eRQq0GDJogoEbyzNTurTCgdYqLp3evFvDrZuX2PJaAONoRffkXMskO3gur5PoOX+TPLvHIPmGmUFDSB155QkXRP3kKnwD8SMfNfa5bimCSPjdp18HkvEsY+mHZjxje+8AcQSrLrw9a10oa1/u+Bz1X5bumsr6Bu675Rg+9OigWQbc4kJpiIGHfArw3NmxeR+z9Rkm4QjKxI/6BU2tB99dzpEMCsbQ+IXjoOGgXydQbdrxo0r+DhOSQ24lhTWhqwzf9x+kPxdzaTr/ffEXNKzpHPGkcCMTTbIqtdQOZb8O79y56wBxe0ZjdP4amAip8H4m/7O29kFgdlVrXMwtwwv0f3dY+SM4wV0dRcDgzwKSytPVqkNQjZe3Ql7nWGELns06VhGXB0y1uOo9HuDyt0DBL+ROBJ0eXRmiXSZwWHc1M1M+xRFS8EQN7i97rMsbHu/vGQpGx9T8cQ8MP4I9EVXaZV7L6tmvsHrVd9KlKHM3vDK8SDhh9PkIi7Nr9qBkrNmZPgtsvYVatQwo8ZqCJ7l75oDXVM+Jp3enuC2oDLIpbzBI8/UnBQNjs+SjvT5onIKE180CilXquxBc3ZaS9OSUSCyzzjBMB+uUOvVXfcXsV4DGlhBZLtJXps1zoC42KM8RbxrazDcnifbWntR+3Z4LavJNgst2N+vhTu3LWtefHAHRKhcYjPG56r1OTnp8JtRUQBsWHrTEchnJPqPNlW5BziEO2a7wOALNoHzqU1YonYBapbPlO5TVHnrM3aoBaMYc3MP9Dku573fDXnsWrJT2zdnlS475jgX0x+QviH0FzEkj80ucJEYcBxdDE1YOXHKbcO/MkyFjTSUZ7rmWzmp4ivbB+ySPHhV9TKZON/BLqPH8r3FDxSqow3qcz/swoAK4tkWbxhN1UZ0/IBreXRiVkb8cJspQp7J6QHi7pEifiK2cVHgvSwDskDMUzIBODPU7RwWtQEpHKa33qDpW2OrNCgpmhlzuh7fmXX3DI8GHsmBA7MpZ9kSmrPZV10SR/e52yvWoGWs+JbBq1RBtGHnRGHp5o8SR/aOYMv6UVuzcSOcKGGBMA9L6244HyohqoQeXLzTlkNiUNOXHnflErtYqJqLrxB8BBBqVy4MndG908cPvL4dIQJpXRhh3riS4xes5oaHlL/bo2CUeC8Sxv76W6jQctZHoigSDWU0xcKGEv5pLxpJSMfyRObhT9hU/VCtkUPog4wGlfPoSAc8lCBDWdADUNH/FYttjX5OEmTeaRe/MW1SZUM7RJ2n05VWFwOgT7xwqsdtOn8OOuHF+6i72yzRXgp6wNZCZrxPElH2mJEHPNqKEak+TOkCdfKjELq1aL/JMHYT2y9xCD60zMsB5OMHzL0HvKRozwRVeahhKJ41undaYsOznyA1vCRqulOhXTh4ByYcr+xa08urN52gOD+6QEhDWUPwnisy7/pItLtnb5hS+UP2zKdTAIgeSRUV7C+RSmYB/SVcabn8KYLy3QTGsu7J26g0aOr82pmUmyi7nC1PRvyaczxpHAR5nLAU20ezpniEt2YOiqGaDwPNp7HCQeHPbZICWJ6IUq9n38F733BbAbUKbeQ/xrw1A4Wf8VGxhWG/ZyFBIkEaa/4Yhxuor3iEB5yVeJNgoA9kph94X4T2HtA4rNe0gVYEM1qo0Km6itHPUx9/lIVTzQ+7WTM2dMpKrCC5qEQboiNXibK1toPDl84z4m5JbphxJfa7Hk6M8FNDXrDN40ayzF+2ptkR4G1+ETo1pLVPT+HYRIS4GsgDH7ESTgEn4X8Iv/kNuq3rPnA7W/Ah7yqHxBfzyTv5PLQCRocwb2uNPc3kf4GSjItrM0GBYh0sAE6JU+6mu9RWmuuPzDG4y/tZbtz+5rtiDgzHsRNCq5SclDGaRsTaDefEO6kFDW+o0c/sV4fRWScK380NxjIXB7q8s4cnr26NFmgJ60sWa5HGgctP5kBnoKBERduM3ozwKsgHMLjG/47yNQTPdzqK9+BKZyNiWyW9lRm6xyqCdHDAO/pmXA4Rb6k+iPIMSeGegQA4YEI9nxctodRyeUo2I4Vj0iqJAa43VBbg2UvpGzkMCEUYpSHG810uOmd8OT2Svp/c2k40EFdG37SYKMlE8kmwHbnrezFYXlBvxWlyNX/hJxl1l1TQ6OCW8y1n7X6nEckK4iuQnMaFi4Xl0WnRU/IxZ4qGhEOBEvobU8cTqon3ul8o1Yran4vl/DVki9/UzdnJ3e2kjQAGWg2lI+0S3hBDr0uWYKuOafLCPEf+W6rZNRkiFK3qaP2DJ0vcoUe3hoL4JycB94ENL0/XF9aDvGHBx9dfIm9p9PY2KK5lhIs5XWbXYRNxS8cZcEi6I/sC6e6LlQvqLPWShN0Y8G/QHSwxdLmqGVTXZJ1eB5p6Rl/GMov/oY11+XEn29ld9f3cERnp/fM4hmFyYsRbfqWd3GzqaM+LHabCl5aqPaSBalc4Jk26Us3fRO6T72lpZp9dtdCvbuAmuIVN7bmTFT8tdeukxuDLeWWnwI0jrmAh5T48xTO4NX+2dGTDa109lpCqhPzmC5pkvA2CQtw+h7Yvcfyue4eI5dqZPKAXF108dHukyHxnPLke+jQ7TVk+2si4ILQ89S2HB56zMKw1OjAxL7WhcKDw49XY+7Po5eVIwqYXMJKsNFoFD1yUhe14VO+yipzfe72CDrxrBEc08eSG2WSM8vM34NTG5Wzvnyl70tpM/WlR+wts5LJ/GIZaxTdfncBPnnO8wR131mA0zBwQMrMC49eqB8iTVPASKi+82FPER7Yg/Ys6XypPsLH3xpONemPWvr+R7FL3c9DI96+ViXtYVC68/YuKLSUAIK1asA1XIj+qbzVt5lFZICj921FyOfbfmPtZLwdiyIGiEHCDzCceKpE4Z7edIcuKY2C4Sa52oLwSptpIa2sZeumRrlV2wmzgD1OGUChOuClYGxVSLk/eAW2KTK3iT8NCvEXZxxXa/XtBVKrYIRl51PLQ7hwqfva/a/K73UkiNXWxESBWl6ar8OF6kDcj3fr11EC85OeeN30s3tvbb8Z3I/7/Ajxx8TSBG3ifMIiuyD4Fw4zYj5Oj9GC2ivz1KZ5cQl6sXwK0YLqbhPsKIzPzkVD+dAY2nUT+Ru1mLSCuldXTPSNpguBz+g3EGjU8SQHX/Mqr+RKKIeqwOLwi6U4xOaZcRt9XIGepdQrIr95kIXeUvaiiWJDYLJiUJEKrYpLwM/iEy+qwCa8TxGUdKTuMZE5l73t3JuJxLIlkeoC1mI271n1UCdikqHMm4/t0IiZdN/+uas6Dr8Vyfcpq2qTX2nDn6XAQ3XJCjYAH2TuJwiSQbB/9/6PfIQYPu0vsttWmHnFfn3Pgh2dmMjyKWa55oHG9JugNNFErR/yX5162IhBNotyXpRPjeU8nb6AR7mS4KoACde4h2w+eGFOEXdCaX28VoAq4PDqLliNmKgz7p6+pBnt0Cq0s13GB5CT6NoAzQlSjOYAmzgrVJ1Lm6dhuAlPe8vnLBhfNKfIsBvtXiI1wwv2QIB633lalR1EELmoXqNfg/zfAcvf+DJ9A5CWNbnoyO+1lPHksr3t8KCzlYJA3wm0FYtnsO3KUSXMdtLkRgRknI2zgVNIQovn+2tQwDtzwi9zpBGb3Oi3IpqpeZpj4csuOp3XnvvMGPbz9P4shyqklHJhh3HRMKYZgnh8iwlrcqWOCe17Aooy6aKORxFdKcggtLvLmdbbwy8q5RtlVAvCVX7sATcTo0cKQRYAAF9E5SRIU/8RyJSr76WwDFLYeuNh1aFf0+p0agAJELTaJt44wRS1b8UpxbrhiMrhgtexWQ2WToXvv4Tee8T/RtSotU29ilkFclcNYXlIgzw0GDlmuPGL9xYWhbucV3i60Z9KL5Mxh8pUeiYUD7M/wZLy6Ptr72UPaYr7rl8fKkEHANV454iwnQT5CpKyNYU2Rhn3rJ8X87q8ZbVUknXLMeicV3z+c0+ClPqnMNIC35CwqF8ex68dxTlUBt56cm1EUbw9DMT5sxnYTzXK/aycKNYn8dywcPGIwOY9Q8/tR5WnvIvNvGDKxltHlJNE+2MpPtcf2/2JEAGJiPeuw0SQ0DwYp8dsBpr3Kc61j1bHf9nFUiQNjCdCK1CA+ng7l';
            it('Challenge With RA', function() {
                var val = isRemoteAttestationPresentInChallenge(base64$decode(challengeWithRA));
                expect(val).to.equal(true);
            });

    		var respWithRA = 'CAISqwEKMQoQmcKhB9rIaAWyTx6vm8oKjRII3cGfZ6scMWYgASgAMg81MzExNzA3MjM5MTI3MDQSEAgBEAAgwNECKMDRAjDA0QIaXAoQAAAAADk9HxkAAAAAAAAAABIQgWZ4sLfFfQn+e9oYh15SlBogOZlnR+MWjt75bCLmJgk3UjBpcXz9zaP0BQRKT+kqvdwgAigCOgQIARAqUgoIABDA3h8aAggAIJ/ex6AFKAEaIIn8ceFE/6hibXcIDBEsDBGul4n2owxWMlcVBnjqkMJJIoACAwXqPjMj8V/pxjJH+KHc4maifsd0eY7N834CDQ6nxhC9/GjUAQIWdyGpbG6WRQYr1erkpeYkfd+EkP1PiLWb4l7idaM0Y4fERFhVhCxm6zmlcilfUwodwxPh+5ruci1hFYsAAR4Pk9pZg3NWzxQRvHeVh72eBaaM5phwXOmeXTWFTiQu494sZaBRHpMljVWI9cQa8WuT+3dAHPPqWypi/EU6cRydiCSNL7ZDt9PQCJCa+Kr76vxudsB+uSEyX9BWWhEEDJZZiDSRAKWd21h3xk8O7/cbkcQGBihPTyz6fQaieLjr/einSnOXFHug9CI2OR7dc2lmGudb/aDkWeBsZA==';
            it('Response With RA', function() {
                var val = isRemoteAttestationPresentInResponse(base64$decode(respWithRA));
                expect(val).to.equal(true);
            });


            var challengeWithoutRA = 'CAESpAsK6QoIARLxCQq0AggCEhZDaHJvbWVDRE0tQ2hyb21lT1MteDg2GKaojo4FIo4CMIIBCgKCAQEAqnQ1fDlVp6QxYLXZ23afAt70Ufr7mGk8hnfgUePb275ifL+BW4MxFTK8I7kSCNI4ZaTHVmsA/L8yANgJKm1Yq39yvuLTExyngam4jEFpPlwBv3hf1lExmWAM9K2Pivt/tIq9Ji7ZzjUG8W+ozm4m0iCoon29CBiehrfjTM6dTnd2CsqptrGE1HPLLTpj89YdMD8y0hrFBc+JQtNGEQenHX5RYu46JdZdffrWkApiir4rk3hvTXicyKYZq5GbeJA++sBaH8F7V6932iu7mKFxcB5g24qGgUnRscdNFDmPCRbkuEFwX8P6YUiLpgnUYpd8EeGbaRJj1fui3eblwC/irwIDAQABKNUgEoACeBgDpCWA8pMdRFsEtV58GsZVkRaLgV03/E7M2pafZJXi0inZRdu+l6VI+RdXJmrfDiAkGQpUMXMWzeCFCZUPy3ji0Yi3t6/IemWJuNeceDMBPUcy2GvK244wIpIgoOqWjCnCD+vKhGYDaHJKKkAl6xcKUHKPoJqRki/pX6DDfZu9uMMBwA6Mp2uW5qzDeYmrKTrkbTUMuQLKgKer9HeOLWZr7UTdw4bym/QXV0zNhBfkv5bSdpjJBS1pIx+vBKSqqSHOUL6rsda48wfkKnhVVcwZmxT0PZ/z0q3WvvWVydCK2/Otsi+fQq0uREQekgA46nlC1lkWC78M+XDu3E5lpRq0BQquAggBEhCch1qYKAc6H+BAWqbFY6gVGI6kjo4FIo4CMIIBCgKCAQEAreXn8CcRKOqk9cRK2BkoT4inxpCBZJqSWpuWhOjLza0wtUWz5iWSrIhLL9KcX6GIBRB5PYES97qvs0b1zh5R2GNrCpuZOKykimdBz4FONPI7j+KPWsa+h/bWCzQEvFLlIWEjmJ3QINaI9BZI1JZ6Rumg9bkyX5K9N0q8g3ZMM92dDG3e98vp9dpIASVOTlp+AzsIKD4/dY3AmSTxZtS/PW9RVqtrYtRtX04pk/qfxDyNPUqwSwS/ZbfcSdohmo/CaqyfnhewdEUJDPtkecCIIJMX1+nvySJxREHdUaKzU8H+fIjtajPDBr0Ahsq0Q6UFVK5bbuQbWFi02ek4Ukc0NwIDAQABKNUgEoADlKHKBThBYPDITK3H1cuMkdAtKbnuqGnZpvi+VPdgjdGMfq4SupGcNUAXRSkZZEjGfST6sH2brNqlBBPDcxDJhqhFxt6DK2oLJaGOFaXci0CgwaxgiSmByugGYJjqJSUZfi7Wn6INm9lbNV3HZ3ums/QHJWAm6mwZaVAmgoCq4RHCIRPyYx1RSzDaPW5S/mv/RBQCuvHDipPdn5+ddLJMGKCFX8wlGrr4fprcp2pwwpQw4xVefYc902ee7RkopsNee26e+JYA9AKlrmuBTZAaWAJP3ymXz4NlPaSKtSlsGroAVwHBuvZLgfnzl6gjzThT5NQBczQUXl2V2ffHHT51u+RuVwQEON6YpmldK4aCOmOM7WELZcntf2s5NhrltB/ziBSNxJKxbvsBekRCKxE6rzeh/nwIu8Nob3M0DrSkttr9+9rBLUg4lYA9Q9QDtpeZbiZ6k3Uixc3ssxT5noO0GAl5cEbbdqSkWoHbCV4wOS3ZT19zTEItFQQ27yhF+ob1GhsKEWFyY2hpdGVjdHVyZV9uYW1lEgZ4ODYtNjQaFgoMY29tcGFueV9uYW1lEgZHb29nbGUaFwoKbW9kZWxfbmFtZRIJQ2hyb21lQ0RNGhkKDXBsYXRmb3JtX25hbWUSCENocm9tZU9TMggIARABGAAgABIsCioKFAgBEhAAAAAAOTgBTgAAAAAAAAAAEAEaEOxPEGwnGsCCMMwsYZ9kzTMYASCk/eGgBTAVGoACQmSR+lvfZ8/upkjmRsrevX3eICBO/xlx2WWQ8GFU0xHaICU4FrhZB08l3ErtSdcYYE/ZOVSKTWlDIv4pJosxS89NC/sq1gd/7k4AVTNNzo5+AgtcwqEvt0TFJC2IRoB+Ys+IJlWyde2ed8JP86ZgqVoW8nU8QQBqp+a4D9W7xxiQLkiIXT2fGbRlGhuBhuF8hBdwHzGx01/Oy5nxUWMJTxnPVRwAcfBiKLOqEUQAtmxMWgeYDKK/uHAST9Bppm8ilNAE8FAxCmCGftZQsoeCpPVuze1jK65lWK+P0ctDZKeMXXawslog3f9iSZnmgXLn+r1f1WQaeNhqv4xXoTkGdA==';
            it('Challenge Without RA', function() {
                var val = isRemoteAttestationPresentInChallenge(base64$decode(challengeWithoutRA));
                expect(val).to.equal(undefined);
            });

            var respWithoutRA = 'CAISqAEKIAoQ7E8QbCcawIIwzCxhn2TNMxIIAmD9SZTOXJogASgAEhAIARAAIMDRAijA0QIwwNECGmwKEAAAAAA5OAFOAAAAAAAAAAASEAtGxyICMzruxphW7EaydFcaIMlt/YdJTmkj7C+X+Nk3p91xRQaSakpuXSfF2fVjpK/lIAIoAjoECAEQKlIKCAAQwN4fGgIIAFIOCMHeHxD/////BxoCCAEgpP3hoAUaINL+29Z27jmH8XvtxqGJOn6aG6NfR/WycBOzpvq90+7ZIoACmCO1NO3Z1gMlZe90XGxGhJoiDxgKuzRaJkl0kmYg13JEmIaLvgXdVJeIf8D5nI5IHRr/GwA81RbvMT7PvQmBEsw4+TqflBe6AHewprJASXGLmmOptsdKpS0C6iEFz85o44+XOgM9U3sMUXC6lQE9X9sE/MHL3oiYJsN4+ZluY6ZKvxW2UdaGlJlhCgzguf+JkFCzvD1l+M7t0S8vXW8jjWKuX7GfkwZrFs7e+wMD6DEFtVzlXj31mzTBsSzj7fR8/9a7gb/eoMVJ8lLjaV+DB8MLmiUNUnHy8Yrv39Psik+Y/gCpjJenDof1/Gm8wM+2O+JKh1s2I4ooff0mjEMJ2Q==';
            it('Response Without RA', function() {
                var val = isRemoteAttestationPresentInResponse(base64$decode(respWithoutRA));
                expect(val).to.equal(undefined);
            });
             
        });


        describe('Mac Chrome', function() {

            var challengeWithoutRA = "CAESlw4SLAoqChQIARIQAAAAADk6zd4AAAAAAAAAABABGhAWwkluWAPxpNRzOW0VFbj5GAEgx/DdoAUwFULcDQoQdGVzdC5uZXRmbGl4LmNvbRIQ5US6QAvBDzfTtjb4tU/7QxqgCzdiT6HSKJV049lewTfK49ajqEu/9dc94qqX9u71x+k8PiZlEdpLwLsHVB0hpFrYA6lA7MeA9sGOYonVEZNHKTVITeHNyEKKwkthtzOQQfBhCUjnGIM+Y9oaaKK1/WvuCQBpU3xAUlXl7qPs5h3WxocoXlA0lIzcj4pM52lTbISA6VFqggx38n7xjcvf7O9TZAfLwVgMnroC91SvgmcvjPdRSvNLU8SGYnu5l345hmeGcpB9tl315ABBSA+ZKTJQ898wmJ3xwueXvvfnU7iZk977yS2qMQsW/VJIORiWCBb/Hs73xj2ApUcW8U3KhiaEgeKYVO7YJJvwOv5UeFaLutrXpOklVQdabF7POnFGEgiWIoQ6yCrD7GjUP5XrHpB0v2oZ1/Vl7TZyHSF9j/ytXGnD03k7sq8PQlVxftgbb5g2DHGfso0r3FaA6FqNiXdu+JRBkCgtWh7NXDNTYaTSt6deodTjJ70LKfiKgObFcYNao7s4/a3nCgiWWW39n4ULvpr1HePBAcmIiIbVrE3dy/y52QFIxX/8hzC4DGNpCa0UXxdkyJaaclMW192659DomKpa92aBQ9ssnB/PYr27AoNxgDh/0rbmu3nVw4uAi9FRFf2/lnJOMXNKOybzE5tpqp2+lCdQb/DevteyEmCdNq5Rmpz4CV6/P45jsjtOncOML2OnhdGZupHC1+R999JQ8ixNvaYQXwZhxozAR8lwDssNaXKj4mWQT21lwy5+1c2WOH+pp28lseaGrRyd2mUmi13DN27g/3keQzoiFbyT7y3vw97n3yWs5KOy+FI3GMkhiqJ0BIz8hbIXLcCM3mp/Xdw8Huu0Xx7lygYPknWnvbdqAcQaR7Tnuoq6AqleOLYiDPlyhSqNQsqSxEnsCFvN+i4UjtDozWMl+Vjqok8zGM1VdOv/LTpEPlYD36TDkkJcwe5kJEYouPb3hYtaqk6PTOdWu833qvEc2f2Bolgb29m3DlZcvBJjgIFc0pwULFuuQnhwyFlyWb30xM/arRp1ps6VHbhngS3yyb9eUOUk1IpeMUwVJO3NxuzCV+HN2qkTnPmi1xXczuJ8uKe1O7zaLs+/wWi27abXrlPDL3IeKz/8ALglgprBWEanIIir10O4C7Kq2b54fCKOkCq6vCDTZcdIB7tnH8gf8PRtqmGlTM0Xr3FgN+NFaxEnh7kTMgTMu67gJl2gKFcrfXBUj4rm9IBRlrJChylAl1rqZpoTJKDAYn8oo6msn/SlWctdjqhejxg9zvW0secouJ0IB+CqrR0doZp3pokdYaGGziytMHjSuz4FPyIhYE6vZBsbQ1EnisCOQyHpgr8QFQtJHQr8EDYDxMLfQlPMvX69c4PzhrzGRQQXfMQs8n7dxf0+U0eQkd/SEK6DUhjqrClPbr4StdhRjshSMKtrL2SZ3Nwdk5I0iFjqH1K6q/kPQC8TGO+K8oAr80iorqYCD2MWzFEQokyamGZzTdX0Zap1dlNOPDzckzjkR+1N2cR/C/La1B98/Xg+yOONKknwIeA+QyVGwk3gbgICdvObc+Es+ibVFu547CisQ2ROqqw0loiEZh2IEtDd+xSLttRoZM8JR/0wY+Rd+BBfIMqpQm3kYVfMhnno1t4XZQ7L+Q3KyLdaPDZuhSaoW+HezT/CuEOIwjWQohwRGVyknPyC/Eav/LxCs8LPETxXkGIKH8RxI29x1zheNyGRxMTI/YlqnmssvsH1R0Hb0TZNZBZTE+WMLUl5ecEHSJP42uV90+089XBuPhn7+z2ehr96i5oySXlWj3LbrB2yHZo/pSZuisfkdEA6/Nk34XaspABnLQ1zqj8X2Uqx1jOThjB33wKBu7peZyGJxD2VxVv9Of0afJjPiHe9Ws8oGQyjdk9wQbRJvEjyfwrLn6JLoXDO2w+KF7AeY3nJoyIQQBV+53Pi6g4rXfLNTk3VZCqAAiRaKjHhDI1OYDclqW/EZr8EkUkuDJiE5HWC9dj/nsEGLQchdUwyPo910/3dfXfxNH//rv8PdsLy1CU6gD35PDqCYVxAeIjiOCcgWQkRJVgb6lRfQYS3eA8zdB1R9+SqicPLCKjVN99qHIib2zCE+/XT1kFqdPI2TVglMxIyASeHAi9+7czevrY3yHxMPQmOukE4rP+7UwSdJn2no1BZtM6+1+4qHGoLJRtJ2AHSRgtSHXG5+/jfU3bkhffLhbLMRscK08Jc0gfryPxVWhN+F07UAWb4OnHlYIqGbrwVk42sfXK57okOyo1ulasYIuqeP433npKpHzwVofRmL+ccND8agAJjZ9/nuIEn6iYnlpqvorwjbSBooriUbTeI9RxWv+8K7cIaVQx5WchczpXIWnfverEhCV2Wb1RW5jvRBqOlbeqzejxbYSbSykDYsAxA9iN6tueR2fDOpM4VTjhXbSweEp2F2D9ZIwlDf/Zir+iI6rK7N+js8nIbsBcvci0j9dIXrXi9MUDqdJHqBwusrkmMPINEOGCsRWL59U/jHlqjiUwuqq1p8ve3Ngtit4+P9oJdfOyr8VmpF9MRIeoaV2ikTBADlnWM3s+lD87Eo9MZ3JUXBubYQ7zvkfsKVSHnllRzprHTYADf4YL8KO2sRPbKiHbKVK/+KsgSQXV88ruKNBij";
            it('Challenge Without RA', function() {
                var val = isRemoteAttestationPresentInChallenge(base64$decode(challengeWithoutRA));
                expect(val).to.equal(undefined);
            });

            var respWithoutRA = "CAISmAEKIAoQFsJJblgD8aTUczltFRW4+RIILP+0c9RrrFogASgAEhAIARAAIMDRAijA0QIwwNECGlwKEAAAAAA5Os3eAAAAAAAAAAASEBkujt9jPj7GbecwnHg6pCsaIADRv0h8yAUdawHx5mR0XIHZ6ccYB+Aw6QlI5zANGJ/tIAIoAjoECAAQKlIKCAAQwN4fGgIIACDH8N2gBRogykzWy4wO3luXRjXu2y9HYZZKBFIzVWFsCoNbycCc9iIigAIPGMSpyHiqWwQMEXsAhd0VCchK3WqVjzIJgGgWMvJ3ZEZ7dTbT0b1a3Ri3h5ANhHrRg9YOX6Va1zQFbSjSxga+VmueRnxse7ktzjs3VdNyhoZR2zkhpxM5keE7xCPCxz0l5ILLgWimUk7PNQzG6ohUSXYEKebeYaZEOenkKDTqhbr6dLlyRyHXP+TdzY8cB0Nh+P283Z2fQ8AjSeUrUYEG9uzv5Fa4etidmTkyEPFvYNNvPWKv12uV3e0cDYSDTMTBUwjv/jub9Z8kmy0s3zsmWKil1xk1OCckoYJqtYwq0QWB29ABvqXfempLUcw473/HT+pEJOvjafUmpH4mzIsJ";
            it('Response Without RA', function() {
                var val = isRemoteAttestationPresentInResponse(base64$decode(respWithoutRA));
                expect(val).to.equal(undefined);
            });
        });


        describe('Win Chrome', function() {

            var challengeWithoutRA = 'CAESlw4SLAoqChQIARIQAAAAAAOtICEAAAAAAAAAABABGhDMOqwV0iKQxrPyAP6baRmYGAEgy4PeoAUwFULcDQoQdGVzdC5uZXRmbGl4LmNvbRIQ5US6QAvBDzfTtjb4tU/7QxqgCzlZBeNQZ/4DT4sBtrHFUfW9IFXHFND596m17EkwrclVqhXMB6vOR5ljq5ilQAKAk6T5EpxlfWeTJK1jLoy6Fr59u0q5OdaxH5wXfD3uJZXyC8sNy0saRsWzoGlOkD2bPh4askEjq+eFM3v/woWmetArrbR2J7a5FT2aGLJvDfdPHtQFn8c1j22Y8d6+4XwCGGZt5BL/nynDCiwOpcpFJBGjRPzrTDqOz+Grfcmda5YaAlDHn7EXYoHmcNjL5pXh21HQQStGuPXsnC223CRpLnX7q/1X/xGsB/SF4Kz9FbbC4iMptMTIKcmhmuVaEYbdeTRIhUElqUMfvxA2b1Bq+3G8EudL+ith2JaVvQcUXMOaXDkMagPNLToh40mYYsfp6Gm16IDJQ/KH1F4RGVQaXoQ9oduA9xMr15KU/FKzjUSVQWL6ketvR6LcyiQ1kwH7AyH4a0iJzsvrEXdbnLFYA++VhGUUZjz3iiEIJeeZmqwqB6xLs3GsIFc8BCYgp9uT3hkw/876jEDDc5LQGWXtA0/tFuq7ikbxzEf1bXa/Y+D8qd3EPG2CSVaQgFqA7i3O1DHs8dyCmg9fOWyydcNzI5nEc0xcWarHOEvC4LBf/QDo4FQlCebghZkTHz1gEaA/q39qq0yu2j7Wv6vwOQwLegZ/uPJiOmhj/2VP4W5yyfQ/qgyw74HAu/yxOpNWuJRQshcsAVnRwbtIIgxj0qBdluj3/j4q82Vxy+FbfOYK7RcHQPOo6GMluXrvre7Q9DadC3cmqgTY2GJ08pDr6+8slo0tcJyOYQeIcCqTHdgjsmwd1oM9PtsvJh19FCqb69KqNngETA27ZNwJJaEZY1P4sabe7uKcSU1KfmpN2A+h9WK4uqoxRjd4Rk49FcP0491igAU3NHnHLZuREBVwdC5bJMfLYNSIGqSgVHg775IVQFW0S8J+nzKQ+iR37m1D4Xn4AIBq1WV8CdvcWUYyiOJOQYZE21vR3Tyu+pN1ifu2++LcVKYs5ZbfxuX2lc5byhFUagB/APBwvWmjxwRDCyQGf89wPGOwmvOKm3D5G6PFDFQld+s4AQW35vVaLJ/JM1TmB4sQLaQVOv7cKBTd9qwuNZ2YtxaiJ+YNX+3TNsNTLTrx4KW6wZYRwk1UL9atfIXro3tHanvmBm4YziyqIN1fz0aIcoVny3WWG4CN+48spTcjK6tPE/Z4CobWtQMKb4rXOtrljytbHn1nUahIkRscbu3hjobtWdGXAypt4vooZZyWoubjHIu3K5s4VLrvq+F0eMe6Juo3DHkOeHpslZwAxDCYEsakw2gyVFkH+0pCOBGo9i57wTmaET8nYr7FpS/CiMOG0t7D51oaijMvWRIo5MRxMCV97AExNfIhs/8oX7wXeVIJBMPSm7tSghb7izrB50tWBk3oy9T5ymRlYSw3MCYk/kWkofn0zsf7GUzTN4Xjn0NROybiMA0WXNgyoyNZkPK2uyjvA/qTBgAfFIpvAmKOFoGUx8ZRaKKR+qxmTEcoBuvBMox+XMqIfpibmALdAltl8FNTiolDuuvA9ePv/D/eAAvJyZzJd2BcoWChvAWD7ktfg8pi+7mJVZ4IeI2hQ2E71OIVLCWMvIMXGj8NwDQ49DyGgyIoJKgHHztUHP/OmG7A4EPdun8coFAlbaIBnE503xt3N1kuGuL3npvkCHjCtUOtSJpAplABVGXiPhBr1qGfjJHyuwEb3Mv93ZaaV1jwJRuLH88cWAw/oMqPjnfsAiCUMqVLXiEXGjS61EUXghuCr++vgiVIMbI9cfgKY7e+27EUqzxlXPcdyTNagesguhqlEhm2t13xmhdrqTYlyT2D4/uQiLlMJpT4WDhAryNWYtwQdMLGZEjsGgQpwrTvDxIaUibfjRoY2klb4Ml86o14a4Jpmr6ACfgeLcb9/iIQO7p4hwsLqWxuoreFe19T2yqAAnLWD5Q+t07qvv3rZSAg0nRj8VrayqVOo9AWkx8KzmkAuTARrZWyjJKmWfN0xOOv58ko6YF09Z1AvsLpMkWqXD6z8SUhkcV3ucC7XSeYwEAhA6YhN0HKO0Tj2EdCU11lpK8ReVslhY6t1YNVrr/tgGmB9PH8oxL7zArKtXqHPqZPdmlN33JiLBwSM84RJNc5v+BaX61UDSb7CkKb8NBqyTliia0gr+IJCDzUkx2FnJoTxlT1irn+3pS7/fDgKpVfYH5/dna59U4+EBppWtumfUqf7gSCDFoF5tQCkZe5G4MiUauTjZO6AKyfl437+cEkDDFm0DA5qwC3TscS508wO7kagAIXcXB8mXkzKfk7az4rBEbjnfxIwf5B0hemUCTji6wtx84anWaGViLhlrpBumI/FB33/IshDXkX06nEkKTOfysvSzI4hjxnS1+rE9nlvnbSYiyVOXnXxpcLAbsKw+bcPFFqlsba7x7f56uY3tIIO85R/4/f6QLqSmblAFviNhzvo70fOJSX0LsV1v8oxvOZ03BelMlIyR35H+LyuItyQoStQqW2AcCb/gtag4ShTGF1rOxq3ehy2PIG9cnEoM60D92MKFy0yfudiiUF//SKnyPTJRrO4l90QP4LVNsQvSOYx/SjoUbYjrU1AWckAM6OZjppY3iAdEewPzxPbRsrtPtQ';
            it('Challenge Without RA', function() {
                var val = isRemoteAttestationPresentInChallenge(base64$decode(challengeWithoutRA));
                expect(val).to.equal(undefined);
            });

            var respWithoutRA = 'CAISqAEKIAoQzDqsFdIikMaz8gD+m2kZmBIIutTqXEnrkSEgASgAEhAIARAAIMDRAijA0QIwwNECGmwKEAAAAAADrSAhAAAAAAAAAAASEEsjd1ezhdfizepJTpiZXewaIJhxN/6s03CoXuxe+0a0N7q0G47lOAtxJnx08pGuHMEJIAIoAjoECAEQKlIKCAAQwN4fGgIIAFIOCMHeHxD/////BxoCCAAgy4PeoAUaIM4CZ9GuyGHMtSG9jgnk+dvajohLlXUCIiR8NZojbrChIoACF6AFFhvzi+RcXpO0bVG3sp/xrjR6RwytCvjoooP8ivB7SU8ckEJst9EadRskr0m0T95Fym5tA2I/br8/kWT0WH+pvLJ98QPMdi56ZuTkm5j7fdqGwsYNTTJwxbmeGZ8tx425uSgaUEdbxg3GNBM0+EYrjupejuK62jBEne1CCiQ/0mYgQDZZl5/dMVBNWjUUqoO+qL2ztvX8L5vpxjrHw2wAL/Lx0ejykZobWxEdgNaY0NyzYDfEOKWmrbd2iMmEwva3bInakpKC7V0dq94cDOTYeIGWByT7kgMZHiUf2YRe5UI5UGI3okrVKrN/7cd6CFOuqYeEauwcma9J2PcohQ==';
            it('Response Without RA', function() {
                var val = isRemoteAttestationPresentInResponse(base64$decode(respWithoutRA));
                expect(val).to.equal(undefined);
            });
        });
    });

});


// -- ../../../tests/functional/js/tests-OneWayCounter.js
addTest(function () {
    var expect = chai.expect;

    describe('OneWayCounter', function () {

        it('typical case', function () {
            var counter = new OneWayCounter();
            counter.addObservation(5);
            expect(counter.getCount()).to.equal(5);
            counter.addObservation(9);
            expect(counter.getCount()).to.equal(9);
            counter.addObservation(9);
            expect(counter.getCount()).to.equal(9);
            counter.addObservation(100);
            expect(counter.getCount()).to.equal(100);
        });

        it('one wayness', function () {
            var counter = new OneWayCounter();
            counter.addObservation(5);
            counter.addObservation(9);
            counter.addObservation(100);
            expect(counter.getCount()).to.equal(100);
            counter.addObservation(99);
            expect(counter.getCount()).to.equal(199);
            counter.addObservation(105);
            expect(counter.getCount()).to.equal(205);
            counter.addObservation(1);
            expect(counter.getCount()).to.equal(206);
            counter.addObservation(1);
            expect(counter.getCount()).to.equal(206);
            counter.addObservation(2);
            expect(counter.getCount()).to.equal(207);
        });

        it('ignoring', function () {
            var counter = new OneWayCounter();
            counter.startIgnoring();
            expect(counter.getCount()).to.equal(undefined);
            counter.stopIgnoring();
            expect(counter.getCount()).to.equal(undefined);
            counter.addObservation(5);
            expect(counter.getCount()).to.equal(5);
            counter.addObservation(9);
            expect(counter.getCount()).to.equal(9);
            counter.startIgnoring();
            counter.addObservation(20);
            expect(counter.getCount()).to.equal(9);
            counter.addObservation(33);
            expect(counter.getCount()).to.equal(9);
            counter.stopIgnoring();
            expect(counter.getCount()).to.equal(9);
            counter.addObservation(34);
            expect(counter.getCount()).to.equal(10);
            counter.addObservation(40);
            expect(counter.getCount()).to.equal(16);

            counter.startIgnoring();
            expect(counter.getCount()).to.equal(16);
            counter.addObservation(45);
            expect(counter.getCount()).to.equal(16);
            counter.addObservation(50);
            expect(counter.getCount()).to.equal(16);
            counter.stopIgnoring();
            expect(counter.getCount()).to.equal(16);
            counter.addObservation(55);
            expect(counter.getCount()).to.equal(21);
        });

        it('ignoring and one wayness', function () {
            var counter = new OneWayCounter();
            counter.addObservation(5);
            expect(counter.getCount()).to.equal(5);
            counter.addObservation(9);
            expect(counter.getCount()).to.equal(9);
            counter.startIgnoring();
            counter.addObservation(20);
            expect(counter.getCount()).to.equal(9);
            counter.addObservation(33);
            expect(counter.getCount()).to.equal(9);
            counter.addObservation(5);
            counter.stopIgnoring();
            counter.addObservation(9);
            expect(counter.getCount()).to.equal(13);
            counter.addObservation(10);
            expect(counter.getCount()).to.equal(14);
            counter.addObservation(15);
            expect(counter.getCount()).to.equal(19);
            counter.addObservation(2);
            expect(counter.getCount()).to.equal(21);
        });

    });

});


// -- ../../../tests/functional/js/tests-browserify.js
addTest(function() {
    var expect = chai.expect;

    describe('Base 16 encoder decoder NPM module', function() {
        it('base 16 encode ', function() {
            expect(base16.encode(new Uint8Array([10, 255]))).to.equal('0AFF');
            expect(base16.encode(new Uint8Array([15, 31, 63, 127, 255]))).to.equal('0F1F3F7FFF');
        })
    });
});


// -- ../../../tests/functional/js/tests-chromeVersion.js
addTest(function() {
    var expect = chai.expect;

    describe('Chrome version from useragent', function() {
        it('less than 37', function() {
            var strArray = [
                // 781
                'Mozilla/5.0 (X11; CrOS armv7l 4920.83.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.103 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 5116.115.5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 5500.130.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.134 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 5712.88.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.155 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 5841.73.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.126 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS x86_64 5841.98.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS x86_64 9999.9999.9999) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36'
            ];

            strArray.forEach(function(s) {
                expect(getChromeVersionNumber(s)).to.be.below(37);
            });
        });

        it('equals 37', function() {
            var strArray = [
                // 1109
                'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.124 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.103 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.124 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.102 Safari/537.36',
                'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.124 YaBrowser/14.10.2062.12061 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) WhiteHat Aviator/37.0.2062.99 Chrome/37.0.2062.99 Safari/537.36',

                // 1222
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.94 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.124 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.124 YaBrowser/14.10.2062.12573 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/537.36 (KHTML, like Gecko) WhiteHat Aviator/37.0.2062.99 Chrome/37.0.2062.99 Safari/537.36',

                //781
                'Mozilla/5.0 (X11; CrOS armv7l 5978.98.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS x86_64 5978.98.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS x86_64 5978.98.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS i686 5978.98.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS x86_64 9999.9999.9999) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36',

                // 1223
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36',
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.94 Safari/537.36',
            ];

            strArray.forEach(function(s) {
                expect(getChromeVersionNumber(s)).to.equal(37);
            });
        });

        it('equals 38', function() {

            var strArray = [
                // 1109
                'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.104 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.104 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2050.0 Iron/38.0.2150.0 Safari/537.36',


                // 1222 
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36',

                // 781
                'Mozilla/5.0 (X11; CrOS x86_64 6158.70.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.110 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 6158.70.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.110 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS x86_64 6158.76.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.119 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS x86_64 6158.64.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.108 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 6158.64.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.108 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS i686 6158.70.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.110 Safari/537.36',

                // 1223
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36',
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.101 Safari/537.36',
                '"Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.101 Safari/537.36 (XHo24eA+MCbGOskVnpCE5rofX2LObH5rimOVGULnadw=)"',
                'Mozilla/5.0 (X11; Linux i686 (x86_64)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36',
                'Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/38.0.2125.111 Chrome/38.0.2125.111 Safari/537.36'
            ];

            strArray.forEach(function(s) {
                expect(getChromeVersionNumber(s)).to.equal(38);
            });
        });

        it('equals 39', function() {
            var strArray = [
                // devtype id 1109 
                'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.65 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.65 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.22 anonymized by Abelssoft 1215483134',
                'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36; campus-TU',


                // 1222
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.65 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',


                // 781
                'Mozilla/5.0 (X11; CrOS x86_64 6310.61.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.94 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 6310.61.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.94 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS x86_64 6310.48.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.85 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 6310.48.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.85 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS i686 6310.48.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.85 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS i686 6310.61.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.94 Safari/537.36',

                // 1223
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
                'Mozilla/5.0 (X11; Linux armv7l) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/39.0.2171.65 Chrome/39.0.2171.65 Safari/537.36',
                'Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/39.0.2171.65 Chrome/39.0.2171.65 Safari/537.36'


            ];

            strArray.forEach(function(s) {
                expect(getChromeVersionNumber(s)).to.equal(39);
            });
        });

        it('eqauls 40', function() {
            var strArray = [
                // 1109
                'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.28 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2194.2 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.10 Safari/537.36',

                // 1222                
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.28 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.28 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.28 Safari/537.36',

                // 781
                'Mozilla/5.0 (X11; CrOS x86_64 6457.21.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.25 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 6457.21.0) AppleWebKit/537.36 (KHTML, like Gecßko) Chrome/40.0.2214.25 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 6436.1.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2209.2 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS x86_64 6457.21.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.25 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 6457.21.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.25 Safari/537.36',

                // 1223
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.28 Safari/537.36'
            ];
            strArray.forEach(function(s) {
                expect(getChromeVersionNumber(s)).to.equal(40);
            });
        });

        it('equals 41', function() {
            var strArray = [
                // 1109
                'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2236.0 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2236.0 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2236.0 Safari/537.36',
                'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2241.0 Safari/537.36',

                // 1222
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2236.0 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2236.0 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2243.0 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2243.0 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2236.0 Safari/537.36',

                // 781
                'Mozilla/5.0 (X11; CrOS x86_64 6489.0.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2223.2 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS armv7l 6537.0.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2238.0 Safari/537.36',
                'Mozilla/5.0 (X11; CrOS x86_64 6537.0.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2238.0 Safari/537.36',

                // 1223
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2224.3 Safari/537.36',
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2236.0 Safari/537.36'
            ];
            strArray.forEach(function(s) {
                expect(getChromeVersionNumber(s)).to.equal(41);
            });
        });

    });
});


// -- ../../../tests/functional/js/tests-Promise-race.js
addTest(function () {
    var expect = chai.expect,
        NOOP = function() {},
        logError = NOOP; //console.error.bind(console, 'ASSERT ERROR ');

describe('Test Promise.race', function() {
    var a, b, c, d;

    var compareWith = function(K) {
        return function(val) {
            expect(val).to.equal(K);
        };
    };
    var compareWithA = compareWith('A'),
        compareWithB = compareWith('B'),
        compareWithC = compareWith('C'),
        compareWithD = compareWith('D'),
        compareWith4 = compareWith(4);

    beforeEach('Initialize promises', function() {
        a = new Promise(function(res, rej) {
            res('A');
        });
        b = new Promise(function(res, rej) {
            rej('B');
        }).catch(function(){});
        c = new Promise(function(res, rej) {
            setTimeout(function() {
                res('C');
            }, 100);
        });
        d = new Promise(function(res, rej) {
            setTimeout(function() {
                rej('D');
            }, 400);
        }).catch(function(){});
    });

    it('Race with pending resolve, pending reject', function(done) {
        var x = Promise.race([c, d]).then(compareWithC).catch(logError).then(NOOP);
        var y = Promise.race([d, c]).then(compareWithC).catch(logError).then(NOOP);
        Promise.all([x, y]).then(NOOP).then(done);
    });


    it('Race with pending resolve, pending reject, scalar', function(done) {
        Promise.race([c, d, 4]).then(compareWith4).catch(logError).then(done);
    });

    it('Race with pending resolve, scalar', function(done) {
        Promise.race([c, 4]).then(compareWith4).catch(logError).then(done);
    });

    it('Race with pending reject, scalar', function(done) {
        Promise.race([d, 4]).then(compareWith4).catch(logError).then(done);
    });

    it('Race with pre-resolved, scalar', function(done) {
        Promise.race([a, 4]).then(compareWithA).catch(logError).then(done);
    });

    it('Race with pre-resolved, anything', function(done) {
        var x = Promise.race([a, b]).then(compareWithA).catch(logError).then(NOOP);
        var y = Promise.race([a, b, 4]).then(compareWithA).catch(logError).then(NOOP);
        var z = Promise.race([a, d, c, 4]).then(compareWithA).catch(logError).then(NOOP);
        Promise.all([x, y, z]).then(NOOP).then(done);
    });

    it('Race with pre-rejected, scalar', function(done) {
        Promise.race([b, 4]).then(logError).catch(compareWithB).then(done);
    });

    it('Race with pre-rejected, anything', function(done) {
        var x = Promise.race([b, 4]).then(logError).catch(compareWithB).then(NOOP);
        var y = Promise.race([b, 4, a]).then(logError).catch(compareWithB).then(NOOP);
        var z = Promise.race([b, a, 4, d, c, 9]).then(logError).catch(compareWithB).then(NOOP);
        Promise.all([x, y, z]).then(NOOP).then(done);
    });

    it('Race with scalar, anything', function(done) {
        var x = Promise.race([4, a, b]).then(compareWith4).catch(logError).then(NOOP);
        var y = Promise.race([4, b, a]).then(compareWith4).catch(logError).then(NOOP);
        var z = Promise.race([4, c, b, a]).then(compareWith4).catch(logError).then(NOOP);
        Promise.all([x, y, z]).then(NOOP).then(done);
    });

    it('Race with pending resolve, resolved, scalar', function(done) {
        Promise.race([c, a, 4]).then(compareWithA).catch(logError).then(done);
    });

    it('Race with pending reject, resolved, scalar', function(done) {
        Promise.race([c, a, 4]).then(compareWithA).catch(logError).then(done);
    });

    it('Race with pending reject, rejected, scalar', function(done) {
        Promise.race([c, b, 4]).then(logError).catch(compareWithB).then(done);
    });
 
});
});


// -- ../../../tests/functional/js/tests-DeviceCapabilties.js
addTest(function () {
    var expect = chai.expect;
    var isCastTV = DEVICE_MODEL.indexOf("casttv") >= 0;
    var isEdge = DEVICE_MODEL.indexOf("edge") >= 0;
    var isSafari = DEVICE_MODEL.indexOf("safari") >= 0;
    describe('Device Capabiliites', function () {

        it('Test supportsHD', function () {
            return Promise.resolve().then(function () {
                expect(DeviceCapabilities$canDecode264()).to.equal(true);
                console.log("Device Model: "+DEVICE_MODEL);
            });
        });

       (isSafari?it.skip:it)('Test supportsUHD', function () {
           return Promise.resolve().then(function () {
           	var expected = isCastTV || isEdge;
               expect(DeviceCapabilities$canDecode265()).to.equal(expected);
               console.log("Device Model: "+DEVICE_MODEL);
           });
       });

        (isSafari?it.skip:it)('Test supportsDV', function () {
            return Promise.resolve().then(function () {
				var expected = isCastTV ? true : false;            	
                expect(DeviceCapabilities$canDecodeDV()).to.equal(expected);
            });
        });       
        
        it('Test supportsUHDA_HDR', function () {
            return Promise.resolve().then(function () {
                expect(DeviceCapabilities$canDecodeUHDA_HDR()).to.equal(false);
            });
        });            
    });
});



// -- ../../../tests/functional/js/tests-UserAgentParser.js
addTest(function () {
    var expect = chai.expect;
	
	describe('UserAgentParser', function () {
		
		describe('Constructor', function () {
		
			it('takes a string as the only param', function () {
				var userAgentParser = new UserAgentParser('useragent');
			});
			
		});
		
		describe('getProducts', function () {
			
			it('returns an object of products', function () {
				var userAgentParser = new UserAgentParser('title1/version');
				var firmware = userAgentParser.getProducts();
				expect(firmware).to.deep.equal({
					'title1': 'version'
				});
			});
			
			it('handles numeric versions', function () {
				var userAgentParser = new UserAgentParser('title1/1.0');
				var firmware = userAgentParser.getProducts();
				expect(firmware).to.deep.equal({
					'title1': '1.0'
				});
			});
			
			it('handles versions without decimal points', function () {
				var userAgentParser = new UserAgentParser('title1/1');
				var firmware = userAgentParser.getProducts();
				expect(firmware).to.deep.equal({
					'title1': '1'
				});
			});
			
			it('handles versions with many decimal points', function () {
				var userAgentParser = new UserAgentParser('title1/1.9.003.6.3');
				var firmware = userAgentParser.getProducts();
				expect(firmware).to.deep.equal({
					'title1': '1.9.003.6.3'
				});
			});
			
			it('handles multiple products', function () {
				var userAgentParser = new UserAgentParser('product1/1.0 product2/2.0 product3/3.0');
				var firmware = userAgentParser.getProducts();
				expect(firmware).to.deep.equal({
					'product1': '1.0',
					'product2': '2.0',
					'product3': '3.0'
				});
			});
			
			it('ignores comments', function () {
				var userAgentParser = new UserAgentParser('product1/1.0 (comment text)');
				var firmware = userAgentParser.getProducts();
				expect(firmware).to.deep.equal({
					'product1': '1.0'
				});
			});
			
			it('handles a real UserAgent', function () {
				var userAgentParser = new UserAgentParser('Mozilla/5.0 (X11; Linux armv7l) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.90 Safari/537.36 CrKey/1.17.46278');
				var firmware = userAgentParser.getProducts();
				expect(firmware).to.deep.equal({
					'Mozilla': '5.0',
					'AppleWebKit': '537.36',
					'Chrome': '43.0.2357.90',
					'Safari': '537.36',
					'CrKey': '1.17.46278'
				});
			});
			
			it('does not return malformed products', function () {
				var userAgentParser = new UserAgentParser('Mozilla/');
				var firmware = userAgentParser.getProducts();
				expect(firmware).to.deep.equal({});
			});
			
			it('returns an empty object when an empty string is passed', function () {
				var userAgentParser = new UserAgentParser('');
				var firmware = userAgentParser.getProducts();
				expect(firmware).to.deep.equal({});
			});
			
			it('ignores trailing spaces', function () {
				var userAgentParser = new UserAgentParser('CrKey/1.17.46278 ');
				var firmware = userAgentParser.getProducts();
				expect(firmware).to.deep.equal({
					'CrKey': '1.17.46278'
				});
			});
			
		});
		
	});
	
});


// -- ../../../tests/functional/js/tests-ConfigService.js
addTest(function () {
    var expect = chai.expect;

	describe('ConfigService', function () {
    
		describe('Constructor', function () {
		
	        it('takes a log and player info', function () {
				var playerInfo = {
					apiHost: 'test.host.com',
					esnPrefix: 'prefix',
					esn: 'fullesn',
					softwareVersion: '2.x.x',
					languages: 'en',
					castShellVersion: '1.20'
	            };
				var configLog = new log.CategoryLog('ConfigLog');
	            var configService = new ConfigService(configLog, playerInfo);
	        });
		
	        it('logs error when apiHost missing', function () {
				var logMessages = [];
				var testSink = log['addSink'](function (message) { logMessages.push(message); });
			
				var playerInfo = {
					apiHost: null,
					esnPrefix: 'prefix',
					esn: 'fullesn',
					softwareVersion: '2.x.x',
					languages: 'en',
					castShellVersion: '1.20'
	            };
				var configLog = new log.CategoryLog('ConfigLog');
	            var configService = new ConfigService(configLog, playerInfo);
			
				expect(logMessages.length).to.equal(1);
				expect(logMessages[0].message).to.equal('apiHost property is required');
	        });

		});
    

	});

});


// -- ../../../tests/functional/js/tests-CongestionService.js
/// <reference path="../../typings/chai/chai.d.ts"/>
/// <reference path="../../typings/mocha/mocha.d.ts"/>
/// <reference path="../player/congestionService.ts"/>
/// <reference path="./mocks/http.ts"/>
/// <reference path="./mocks/clock.ts"/>
/// <reference path="./mocks/log.ts"/>
addTest(function () {
    var expect = chai.expect;
    describe('CongestionService', function () {
        describe('Constructor', function () {
            it('takes a config object', function () {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
            });
        });
        describe('fetchCongestionInfo', function () {
            it('keeps downloading congestion based on TTL', function (done) {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var testCongestionInfo = {
                    'success': true,
                    'asnName': 'some-isp',
                    'asnDisplayName': 'Some ISP',
                    'isCongested': false,
                    'ttlEpoch': (Date.now() / 1000) + 1
                };
                http.setResponse({
                    success: true,
                    content: objectToArrayBuffer(testCongestionInfo)
                });
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    minTtlSeconds: 0,
                    log: log
                });
                setTimeout(function () {
                    var congestionInfo = congestionService.getCongestion();
                    expect(congestionInfo['name']).to.equal(testCongestionInfo['asnDisplayName']);
                    expect(congestionInfo['isCongested']).to.equal(testCongestionInfo['isCongested']);
                    var secondTestCongestionInfo = {
                        'success': true,
                        'asnName': 'some-isp',
                        'asnDisplayName': 'Some Other ISP',
                        'isCongested': true,
                        'ttlEpoch': (Date.now() / 1000) + 1
                    };
                    http.setResponse({
                        success: true,
                        content: objectToArrayBuffer(secondTestCongestionInfo)
                    });
                    setTimeout(function () {
                        var congestionInfo = congestionService.getCongestion();
                        expect(congestionInfo['name']).to.equal(secondTestCongestionInfo['asnDisplayName']);
                        expect(congestionInfo['isCongested']).to.equal(secondTestCongestionInfo['isCongested']);
                        done();
                    }, 10);
                }, 10);
            });
        });
        describe('getCongestion', function () {
            it('logs an error if http request fails', function (done) {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                log.addSink(function (entry) {
                    expect(entry['level']).to.equal(LogMock.logLevel['ERROR']);
                    expect(entry['message']).to.equal('HTTP Request Failed');
                    done();
                });
                http.setResponse({
                    success: false,
                    content: objectToArrayBuffer({})
                });
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
            });
            it('logs an error if response processing fails', function (done) {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                log.addSink(function (entry) {
                    expect(entry['level']).to.equal(LogMock.logLevel['ERROR']);
                    expect(entry['message']).to.equal('Response Processing Failed');
                    done();
                });
                http.setResponse({
                    success: true,
                    content: objectToArrayBuffer('garbage')
                });
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
            });
            it('returns success false if http request fails', function (done) {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                http.setResponse({
                    success: false,
                    content: objectToArrayBuffer({})
                });
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
                congestionService.getCongestion(function (congestionInfo) {
                    expect(congestionInfo['success']).to.equal(false);
                    expect(congestionInfo['isCongested']).to.equal(null);
                    done();
                });
            });
            it('returns success false if endpoint returns success false', function (done) {
                // In this case it will not retry for this session since there
                // is a problem with the endpoint
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var congestionResponse = {
                    'success': false,
                    'asnName': null,
                    'asnDisplayName': null,
                    'isCongested': null,
                    'ttlEpoch': null
                };
                http.setResponse({
                    success: true,
                    content: objectToArrayBuffer(congestionResponse)
                });
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
                congestionService.getCongestion(function (congestionInfo) {
                    expect(congestionInfo['success']).to.equal(false);
                    expect(congestionInfo['isCongested']).to.equal(null);
                    done();
                });
            });
            it('calls the callback with congestion info', function (done) {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var testCongestionInfo = {
                    success: true,
                    asnName: 'some-isp',
                    asnDisplayName: 'Comcast',
                    isCongested: true,
                    ttlEpoch: (Date.now() / 1000) + (60 * 60)
                };
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    congestionInfo: testCongestionInfo,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
                congestionService.getCongestion(function (congestionInfo) {
                    expect(congestionInfo['name']).to.equal(testCongestionInfo.asnDisplayName);
                    expect(congestionInfo['isCongested']).to.equal(testCongestionInfo.isCongested);
                    done();
                });
            });
            it('waits for an in progress request to finish', function (done) {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var testCongestionInfo = {
                    'success': true,
                    'asnName': 'some-isp',
                    'asnDisplayName': 'Comcast',
                    'isCongested': true,
                    'ttlEpoch': (Date.now() / 1000) + (60 * 60)
                };
                http.setResponse({
                    success: true,
                    content: objectToArrayBuffer(testCongestionInfo)
                });
                http.setDelay(100);
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
                congestionService.getCongestion(function (congestionInfo) {
                    expect(congestionInfo['name']).to.equal(testCongestionInfo['asnDisplayName']);
                    expect(congestionInfo['isCongested']).to.equal(testCongestionInfo['isCongested']);
                    done();
                });
            });
            it('returns success false when no info is available', function () {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var testCongestionInfo = {
                    'success': true,
                    'asnName': 'some-isp',
                    'asnDisplayName': 'Comcast',
                    'isCongested': true,
                    'ttlEpoch': (Date.now() / 1000) + (60 * 60)
                };
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
                var congestionInfo = congestionService.getCongestion();
                expect(congestionInfo['success']).to.equal(false);
                expect(congestionInfo['isCongested']).to.equal(null);
            });
            it('returns a congestion object when passed one in constructor', function () {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var testCongestionInfo = {
                    success: true,
                    asnName: 'some-isp',
                    asnDisplayName: 'Comcast',
                    isCongested: true,
                    ttlEpoch: (Date.now() / 1000) + (60 * 60)
                };
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    congestionInfo: testCongestionInfo,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
                var congestionInfo = congestionService.getCongestion();
                expect(congestionInfo['name']).to.equal(testCongestionInfo.asnDisplayName);
                expect(congestionInfo['isCongested']).to.equal(testCongestionInfo.isCongested);
            });
            it('makes a http request to fetch the congestion info', function () {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var testCongestionInfo = {
                    'success': true,
                    'asnName': 'some-isp',
                    'asnDisplayName': 'Comcast',
                    'isCongested': true,
                    'ttlEpoch': (Date.now() / 1000) + (60 * 60)
                };
                http.setResponse({
                    success: true,
                    content: objectToArrayBuffer(testCongestionInfo)
                });
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
                var congestionInfo = congestionService.getCongestion();
                expect(congestionInfo['name']).to.equal(congestionInfo['name']);
                expect(congestionInfo['isCongested']).to.equal(congestionInfo['isCongested']);
            });
            it('does not make an http request when there is fresh congestion info', function () {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var testCongestionInfo = {
                    success: true,
                    asnName: 'some-isp',
                    asnDisplayName: 'Comcast',
                    isCongested: true,
                    ttlEpoch: (Date.now() / 1000) + (60 * 60)
                };
                http.download = function () {
                    expect.fail('download should not be called again');
                };
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    congestionInfo: testCongestionInfo,
                    minTtlSeconds: 60 * 10,
                    log: log
                });
                congestionService.getCongestion();
            });
            it('makes a request when the current congestion info is not fresh', function (done) {
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var testCongestionInfo = {
                    success: true,
                    asnName: 'some-isp',
                    asnDisplayName: 'Comcast',
                    isCongested: true,
                    ttlEpoch: (Date.now() / 1000)
                };
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    congestionInfo: testCongestionInfo,
                    minTtlSeconds: 0,
                    log: log
                });
                var newTestCongestionInfo = {
                    'success': true,
                    'asnName': 'some-isp',
                    'asnDisplayName': 'Some ISP',
                    'isCongested': false,
                    'ttlEpoch': (Date.now() / 1000) + (30)
                };
                http.setResponse({
                    success: true,
                    content: objectToArrayBuffer(newTestCongestionInfo)
                });
                // var congestionInfo = congestionService.getCongestion();
                // expect(congestionInfo.isCongested).to.equal(true);
                // expect.fail('This timeout is not failing as it should be');
                setTimeout(function () {
                    var congestionInfo = congestionService.getCongestion();
                    expect(congestionInfo['isCongested']).to.equal(newTestCongestionInfo['isCongested']);
                    expect(congestionInfo['name']).to.equal(newTestCongestionInfo['asnDisplayName']);
                    done();
                }, 2000);
            });
            it('enforces a min ttl', function (done) {
                // Requests are sent 60 seconds before the TTL expires
                var http = new HttpMock();
                var clock = new ClockMock();
                var log = new LogMock();
                var testCongestionInfo = {
                    success: true,
                    asnName: 'some-isp',
                    asnDisplayName: 'Comcast',
                    isCongested: true,
                    ttlEpoch: (Date.now() / 1000)
                };
                http.download = function () {
                    expect.fail('download should not be called');
                    done();
                };
                var congestionService = new CongestionService({
                    apiEndpoint: 'http://test.netflix.com',
                    http: http,
                    clock: clock,
                    congestionInfo: testCongestionInfo,
                    minTtlSeconds: 2 * 60,
                    log: log
                });
                setTimeout(function () {
                    done();
                }, 1 * 1000);
            });
        });
    });
    function objectToArrayBuffer(object) {
        var jsonString = JSON.stringify(object);
        return stringToArrayBuffer(jsonString);
    }
    function stringToArrayBuffer(str) {
        var buffer = new ArrayBuffer(str.length);
        var bufferView = new Uint8Array(buffer);
        for (var i = 0, strLen = str.length; i < strLen; i++) {
            bufferView[i] = str.charCodeAt(i);
        }
        return bufferView;
    }
});



// -- ../../../tests/functional/js/tests-NrdpDevice.js
addTest(function () {
	var expect = chai.expect;
	var testWindow = {};
	var testNavigator = {};
	
	// HACK Test application logic by pasting the code here for testing. No other way to access the code that needs to be tested
	var window = testWindow;
	var navigator = testNavigator;
	testWindow['nrdp'] = {
		'device': {
			'firmwareVersion': function () {
				
				var firmwareVersion;
			
				var getValue = _resolveCastPlatformQueryFunction();
				
				if (getValue) {
					var castReceiverVersion = getValue('cast-receiver-version');
					var systemVersion = getValue('system-version');
				
					if (castReceiverVersion && systemVersion) {
						firmwareVersion = castReceiverVersion + ' (' + systemVersion + ')';
					}
				}
			
				if (!firmwareVersion) {
					var userAgentParser = new UserAgentParser(navigator.userAgent);
					var products = userAgentParser.getProducts();
					if (products['CrKey']) {
						firmwareVersion = products['CrKey'];
					} else {
						firmwareVersion = '';
					}
				}
			
				return firmwareVersion;
			},
			'castShellMajorVersion': function () {
				var queryFunction = _resolveCastPlatformQueryFunction();
				var unknownVersion = 'unknown_cast_shell_ver';
				var castVersion = (queryFunction && queryFunction('cast-receiver-version')) || unknownVersion
				var majorVerRegEx = /([0-9a-z]+\.[0-9a-z]+)\./g;
				var matches = majorVerRegEx.exec(castVersion);
				if (matches && matches.length > 1) {
					return matches[1];
				}

				return unknownVersion;
			}
		}
	};
	
	describe('Device', function () {
		describe('firmwareVersion', function () {
			it('returns correct format when cast-receiver-version and system-version are present', function () {
				mockCastPlatform({
					'cast-receiver-version': '1.18.51234',
					'system-version': '0.9.21.3'
				});
				
				expect(testWindow['nrdp']['device']['firmwareVersion']()).to.equal('1.18.51234 (0.9.21.3)');
			});
			
			it('gets version from user agent if cast-receiver-version not present', function () {
				testNavigator.userAgent = 'CrKey/1.17.46278';
				
				mockCastPlatform({
					'system-version': '0.9.21.3'
				});
				
				expect(testWindow['nrdp']['device']['firmwareVersion']()).to.equal('1.17.46278');
			});
			
			it('gets version from user agent if system-version not present', function () {
				testNavigator.userAgent = 'CrKey/1.17.46278';
				
				mockCastPlatform({
					'cast-receiver-version': '1.18.51234'
				});
				
				expect(testWindow['nrdp']['device']['firmwareVersion']()).to.equal('1.17.46278');
			});
			
			it('gets version from user agent when platform is null', function () {
				testNavigator.userAgent = 'CrKey/1.17.46278';
				
				mockCastPlatform({});
				testWindow['cast']['receiver']['platform'] = undefined;
				
				expect(testWindow['nrdp']['device']['firmwareVersion']()).to.equal('1.17.46278');
			});
			
			it('gets version from user agent when cast is not defined', function () {
				testNavigator.userAgent = 'CrKey/1.17.46278';
				
				mockCastPlatform({});
				testWindow['cast'] = undefined;
				
				expect(testWindow['nrdp']['device']['firmwareVersion']()).to.equal('1.17.46278');
			});
			
		});

		describe('castShellMajorVersion', function () {
			it('Doesnt blow up if cast-receiver-version is not populated', function () {

				mockCastPlatform({
					'cast-receiver-version': ''
				});

				expect(testWindow['nrdp']['device']['castShellMajorVersion']()).to.equal('unknown_cast_shell_ver');
			});
			it('Gets expected value with normal M.mm.bbbbb format', function () {

				mockCastPlatform({
					'cast-receiver-version': '1.19.23463'
				});

				expect(testWindow['nrdp']['device']['castShellMajorVersion']()).to.equal('1.19');
			});

			it('Gets expected value with  1.17a.bbbbb format', function () {

				mockCastPlatform({
					'cast-receiver-version': '1.19a.23463'
				});

				expect(testWindow['nrdp']['device']['castShellMajorVersion']()).to.equal('1.19a');
			});

			it('Gets expected value with  MM.mmm.bbbbbb format', function () {

				mockCastPlatform({
					'cast-receiver-version': '23.195.23463a'
				});

				expect(testWindow['nrdp']['device']['castShellMajorVersion']()).to.equal('23.195');
			});
		});
		
	});
	
	function mockCastPlatform(values) {
		testWindow['cast'] = {
			'receiver': {
				'platform': {
					'getValue': function (value) {
						return values[value];
					}
				}
			}
		};
	}
	
    function _resolveCastPlatformQueryFunction() {
        var queryFunction = (
                window["cast"] &&
                window["cast"]["receiver"]["platform"] &&
                window["cast"]["receiver"]["platform"]["getValue"]
            ) ||
            (
                window["cast"] &&
                window["cast"]["__platform__"] &&
                window["cast"]["__platform__"]["queryPlatformValue"]
            );

        return queryFunction;
    }
	
	
});


// -- ../../../tests/functional/js/tests-MediaStreamFilter-incorrectChunks.js
addTest(function () {
    var expect = chai.expect;
    config = {
        incorrectChunkCountEnabled: true
    }

    describe('MediaStreamFilter-incorrectChunks', function () {
        
        it ("does not filter streams with the same number of chunks as the media buffer", function () {
            var playbackMock = {
                mediaBuffer: {
                    videoChunks: new Array(2)
                }
            }
            var streamMock = {
                header: {
                    chunkInfos: new Array(2)
                }
            }
            var filter = MediaStreamFilter$incorrectChunks(playbackMock);
            var filtered = filter.shouldDisallowStream(streamMock);
            expect(filtered).to.equal(false);
        });
        
        it ("filters streams with a different number of chunks then the media buffer", function () {
            var playbackMock = {
                mediaBuffer: {
                    videoChunks: new Array(2)
                }
            }
            var streamMock = {
                header: {
                    chunkInfos: new Array(1)
                }
            }
            var filter = MediaStreamFilter$incorrectChunks(playbackMock);
            var filtered = filter.shouldDisallowStream(streamMock);
            expect(filtered).to.equal(true);
        });
        
        it ("does not filter streams without a header", function () {
            var playbackMock = {
                mediaBuffer: {
                    videoChunks: new Array(2)
                }
            }
            var streamMock = {
                header: undefined
            }
            var filter = MediaStreamFilter$incorrectChunks(playbackMock);
            var filtered = filter.shouldDisallowStream(streamMock);
            expect(filtered).to.equal(false);
        });
        
        it ("logs an error when it filters a stream", function (done) {
            var playbackMock = {
                mediaBuffer: {
                    videoChunks: new Array(2)
                }
            }
            var streamMock = {
                header: {
                    chunkInfos: new Array(1)
                },
                downloadableId: 101
            }
            var sink = function (logMessage) {
                expect(logMessage.message).to.equal("Stream disabled because chunk count does not match media buffer");
                expect(logMessage.level).to.equal(LogLevel['ERROR']);
                expect(logMessage['fields']['downloadableId']).to.equal(streamMock.downloadableId);
                done();
            }
            log['addSink'](sink);
            
            var filter = MediaStreamFilter$incorrectChunks(playbackMock);
            filter.shouldDisallowStream(streamMock);
            log['removeSink'](sink);
        });
        
        it ("only logs an error once for a stream", function () {
            var logMessages = [];
            var playbackMock = {
                mediaBuffer: {
                    videoChunks: new Array(2)
                }
            }
            var streamMock = {
                header: {
                    chunkInfos: new Array(1)
                },
                downloadableId: 101
            }
            
            var sink = function (logMessage) {
                logMessages.push(logMessage);
                expect(logMessages.length).to.equal(1);
            }
            log['addSink'](sink);
            
            var filter = MediaStreamFilter$incorrectChunks(playbackMock);
            filter.shouldDisallowStream(streamMock);
            filter.shouldDisallowStream(streamMock);
            
            log['removeSink'](sink);
        });
        
        it ("logs error for multiple streams", function (done) {
            var logMessages = [];
            var playbackMock = {
                mediaBuffer: {
                    videoChunks: new Array(2)
                }
            }
            var streamMock1 = {
                header: {
                    chunkInfos: new Array(1)
                },
                downloadableId: 101
            }
            var streamMock2 = {
                header: {
                    chunkInfos: new Array(1)
                },
                downloadableId: 102
            }
            
            var sink = function (logMessage) {
                logMessages.push(logMessage);
                if (logMessages.length === 2) {
                    expect(logMessages[0]['fields']['downloadableId']).to.equal(streamMock1.downloadableId);
                    expect(logMessages[1]['fields']['downloadableId']).to.equal(streamMock2.downloadableId);
                    done();
                }
            }
            log['addSink'](sink);
            
            var filter = MediaStreamFilter$incorrectChunks(playbackMock);
            filter.shouldDisallowStream(streamMock1);
            filter.shouldDisallowStream(streamMock2);
            
            log['removeSink'](sink);
        }); 
    });
});


// -- ../../../tests/functional/js/MockNccp.js
loadAsync$register(ErrorCodes.INIT_COMPONENT_MOCKNCCPPLAYBACK, function asyncLoadMockNccpPlayback(callback) {
    debug$assert(config);
    if (config.mockNccp) {

        NccpBrClient = function () {
            return {
                ping: function (context, callback) {
                    callback(SUCCESS);
                },

                authorize: function _authorize(authorizationRequestData, context, callback) {
                    callback(SUCCESS);
                },

                license: function (licenseRequestData, context, callback) {
                    callback(SUCCESS);
                },

                playdata: function (moviePlaybackData, context, callback) {
                    callback(SUCCESS);
                },

                createPlaydataRequest: function (moviePlaybackData, context, callback) {
                    callback({ sucess: false });
                },

                heartbeat: function (moviePlaybackData, heartbeatType, context, callback) {
                    callback(SUCCESS);
                },

                logblob: function (logMessages, context, callback) {
                    callback(SUCCESS);
                },
            };
        };

        NccpPlayback = function (playback) {
            var _self = this,
                _accountKey = playback.account.accountKey,
                _log = new playback.log.CategoryLog('NccpPlayback'),
                _httpPlayback = playback.httpPlayback,
                _nccpContext = {
                    http: playback.httpPlayback,
                    log: new playback.log.CategoryLog('Nccp'),
                    accountKey: _accountKey
                };

            debug$assert(_httpPlayback);

            function _authorize(callback) {
                var request = {
                    responseType: http$RESPONSETYPE_TEXT,
                    url: playback.movieId + '.json'
                };
                _httpPlayback.download(request, function (response) {
                    if (response.success) {
                        try {
                            var authorizationResponse = JSON.parse(response['content']);
                            parseManifest(authorizationResponse['result']['viewables'][0], playback);
                            callback(SUCCESS);
                            playback.fireEvent(Playback$authorized);
                        }
                        catch (e) {
                            log.error('Exception while parsing authorization response', e);
                            callback({ success: false });
                        }
                    }
                    else {
                        callback(response);
                    }
                });
            }

            function _license(challenge, callback) {
                dispatch(function () {
                    callback({ success: true, licenseResponse: { data: new Uint8Array([]) } });
                    playback.fireEvent(Playback$licensed);
                });
            }


            function _createMoviePlaybackData() {
                var moviePlaybackData = {
                    'xid': playback.xid,
                    'movieId': playback.movieId,
                    'trackingId': playback.trackingId,
                    'playbackContextId': playback.playbackContextId,
                    'playbackSessionId': playback.playbackSessionId,
                    'licenseId': playback.licenseId
                };

                if (isNumber(playback.mediaTime.value)) {
                    moviePlaybackData['position'] = playback.mediaTime.value;
                }

                var fatalError = playback.fatalError;
                if (fatalError && isValidString(fatalError.displayCode)) {
                    moviePlaybackData['errorDisplayCode'] = fatalError.displayCode;
                }

                if (DEBUG) {
                    _log.debug('Creating movie playback data (playdata/heartbeat)', stringifyJsonPretty(moviePlaybackData));
                }

                return moviePlaybackData;
            }

            function _callbackWithSuccess() {
                var callback = filter.call(arguments, function (arg) { return isFunction(arg); })[0];
                if (callback) {
                    dispatch(function () { callback(SUCCESS); });
                }
            }

            return {
                nccpContext: _nccpContext,

                authorize: _authorize,

                license: _license,

                heartbeat: _callbackWithSuccess,

                playdata: _callbackWithSuccess,

                logblob: _callbackWithSuccess,

                createPlaydataRequest: function (moviePlaybackData, callback) { callback(SUCCESS); },

                createMoviePlaybackData: _createMoviePlaybackData,

                getAuthorizationTime: function () { return 999; },

                getLicenseTime: function () { return 999; }
            };
        };
    }

    callback(SUCCESS);
});


// -- ../../../tests/functional/js/test-alternateMerge.js
addTest(function() {
    var expect = chai.expect,
        utils = require(4);

    describe('alternate merge arrays', function() {
        it('merge [1,3,4] and [a,b,c]', function() {
            var val = utils.alternateMerge([1, 3, 4], ['a', 'b', 'c']),
                expectedVal = [1, 'a', 3, 'b', 4, 'c'];
            expect(val).to.be.a('array');
            expect(val).to.eql(expectedVal);
        });

        it('merge [10] and [x,y,z]', function() {
            var val = utils.alternateMerge([10], ['x', 'y', 'z']),
                expectedVal = [10, 'x', 'y', 'z'];
            expect(val).to.eql(expectedVal);
        });

        it('merge [10,20,30,100,200] and [x,y]', function() {
            var val = utils.alternateMerge([10, 20, 30, 100, 200], ['x', 'y']),
                expectedVal = [10, 'x', 20, 'y', 30, 100, 200];
            expect(val.length).to.equal(7);
            expect(val).to.eql(expectedVal);
        });

        it('merge [100, 20] and []', function() {
            var val = utils.alternateMerge([100, 20], []),
                expectedVal = [100, 20];
            expect(val.length).to.equal(2);
            expect(val).to.eql(expectedVal);
        });
        it('merge [] and [9,13]', function() {
            var val = utils.alternateMerge([], [9, 13]),
                expectedVal = [9, 13];
            expect(val.length).to.equal(2);
            expect(val).to.eql(expectedVal);
        });

        it('merge [] and []', function() {
            var val = utils.alternateMerge([], []),
                expectedVal = [];
            expect(val.length).to.equal(0);
            expect(val).to.eql(expectedVal);
        });
    });

});


// -- http/http.js
var http = (function () {
    var _log = new log.CategoryLog('Http'),
        _eventSource = new EventSource(),
        _counter = 0,
        _stats = {
            'ssl': 0,
            'non-ssl': 0,
            'invalid': 0
        };

    loadAsync$register(ErrorCodes.INIT_ASYNCCOMPONENT, function asyncLoadHttp(callback) {
        // wait for async load to make sure we have access to config
        if (config.useOnLineApi) {
            window.addEventListener('online', _onlineListener);
            window.addEventListener('offline', _offlineListener);
            http$isOnLine = http$isOnLineActual;
        }
        callback(SUCCESS);
    });

    return {
        addEventListener: _eventSource.addListener,
        removeEventListener: _eventSource.removeListener,
        download: _download,
        stats: _stats
    };
    function _updateStats(request) {
        try {
            var url = request.url;
            if (!isUrl(url)) {
                _stats['invalid']++;
                return;
            }
            if (url.indexOf('https') === 0) {
                _stats['ssl']++;
            } else if (url.indexOf('http') === 0) {
                _stats['non-ssl']++;
            } else {
                _stats['invalid']++;
            }
        } catch (e) {

        }
    }
    function _onlineListener() {
        _eventSource.fire(http$online);
        _eventSource.fire(http$onlinechanged);
    }

    function _offlineListener() {
        _eventSource.fire(http$offline);
        _eventSource.fire(http$onlinechanged);
    }
    function _download(request, callback, pingJob) {
        debug$assert(callback);
        var log = (request.playback && request.playback.log && new request.playback.log.CategoryLog('Http')) || _log,
            downloadNum = _counter++,
            logFields = { 'Num': downloadNum },
            callbacks = [callback],
            measurements = { requestTime: clock$getTime() },
            url,
            connectTimeoutMilliseconds = request.connectTimeoutMilliseconds || config.connectTimeoutMilliseconds,
            noProgressTimeoutMilliseconds = request.noProgressTimeoutMilliseconds || config.noProgressTimeoutMilliseconds;

        _updateStats(request);
        DEBUG && log.debug('Download initializing', logFields, { 'RawUrl': request.url });
        var response = function () {
            var progressCallback = NOOP,
                errorCallback = NOOP;

            return {
                request: request,
                type: request.responseType,
                measurements: measurements,
                abort: abort,
                timeout: timeout,
                addCallback: function addCallback(newCallback) {
                    if (complete !== NOOP) {
                        debug$assert(callbacks, 'Callback should be added before download starts.');
                        if (callbacks) {
                            callbacks.unshift(newCallback);
                        }
                    }
                },
                onProgress: function(event) { progressCallback(event); },
                onError: function (event) { errorCallback(event); },
                setProgressCallback: function _setProgressCallback(callback) {
                    progressCallback = callback;
                },
                setErrorCallback: function _setErrorCallback(callback) {
                    errorCallback = callback;
                }
            };
        }();


        // finalize PingJob if one has been passed in
        if (pingJob) {
            pingJob.stream = request.stream;
            pingJob.chunk = request.chunks[0];
            pingJob.successCallback = extendDownloadTimeout;
            pingJob.failCallback = timeout;
        }

        var xhr,
            connected,
            timeoutId;


        function clearDownloadTimeout() {
            if (timeoutId) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
        }

        function extendDownloadTimeout() {
            clearDownloadTimeout();
            var timeoutFunction = pingJob ? timeoutWithPingCheck : timeout;
            timeoutId = setTimeout(timeoutFunction, connected ? noProgressTimeoutMilliseconds : connectTimeoutMilliseconds);
        }

        function complete() {
            complete = NOOP;
            clearDownloadTimeout();
            _eventSource.removeListener(http$offline, onOffLine);
            if (xhr) {
                xhr.onreadystatechange = null;
                xhr.onprogress = null;
                xhr.onerror = null;
                xhr.onload = null;
                xhr.onabort = null;

                // IE/Edge browsers return a copy of the internal ArrayBuffer when
                // accessing the response buffer, so we need to clear the xhr reference
                xhr = null;
            }
            if (response.success) {
                if (request.cdn) {
                    request.cdn.lastSuccess = clock$getTime();
                }
                log.trace('Download success', logFields);
            } else {
                if (request.cdn) {
                    request.cdn.lastFailure = clock$getTime();
                }
                if (response.errorSubCode != ErrorSubCodes.HTTP_ABORT) {
                    log.warn('Download failed', logFields, ErrorSubCodes$errorResultToLogFields(response));
                } else {
                    log.trace('Download aborted', logFields);
                }
            }

            // copy and clear the original
            var localCallbacks = callbacks;
            callbacks = undefined;
            // and dispatch one more time, we don't want to be processing download results on same stack
            var i = localCallbacks.length;
            while (i--) {
                (function () {
                    var callback = localCallbacks[i];
                    dispatch(function downloadCallback() { callback(response); });
                })();
            }
            _eventSource.fire(http$downloadcomplete, response, true);
        }

        /**
        * @param {Number=} errorHttpCode
        * @param {String=} errorDetails
        */
        function completeWithError(errorSubCode, errorHttpCode, errorDetails) {
            response.success = false;
            response.errorSubCode = errorSubCode;
            var currentTime = clock$getTime();
            response.measurements.responseStartTime = response.measurements.responseStartTime || currentTime;
            response.measurements.responseEndTime = response.measurements.responseEndTime || currentTime;
            if (errorHttpCode > 0) {
                response.errorHttpCode = response.errorExternalCode = errorHttpCode;
            }
            if (errorDetails) {
                response.errorDetails = errorDetails;
            }

            if (errorSubCode === ErrorSubCodes.HTTP_OFFLINE ||
                errorSubCode === ErrorSubCodes.HTTP_READTIMEOUT ||
                errorSubCode === ErrorSubCodes.HTTP_TIMEOUT) {
                    xhr.onabort = null;  // prevent call to onAbort
                    abort();
            }

            complete();
        }

        function onOffLine() {
            if (!http$isOnLine()) {
                completeWithError(ErrorSubCodes.HTTP_OFFLINE);
            }
        }

        function timeout() {
            completeWithError(connected ? ErrorSubCodes.HTTP_READTIMEOUT : ErrorSubCodes.HTTP_TIMEOUT);
        }

        function timeoutWithPingCheck() {
            if (response.success === undefined) {
                pingJob.numExtensions++;
                pingJob.pinger.ping(pingJob);
            }
        }

        function abort() {
            try {
                xhr && xhr.abort();
            }
            catch (e) { }
        }

        function onAbort(event) {
            completeWithError(ErrorSubCodes.HTTP_ABORT);
        }

        function _startDownload() {
            if (!isUrl(request.url)) {
                completeWithError(ErrorSubCodes.HTTP_BAD_URL);
                return;
            }
            try {

                http$constructRequestUrl(request, response);
                url = response.url;
                debug$assertValidString(url);
                logFields['Url'] = url;

                if (!http$isOnLine()) {
                    // dispatch it so that exception in completeWithError does not cause duplicate execution.
                    dispatch(completeWithError.bind(undefined, ErrorSubCodes.HTTP_OFFLINE));
                    return;
                }

                log.trace('Download starting', logFields);

                xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 2) { // Headers received
                        connected = true;
                        measurements.responseStartTime = clock$getTime();
                        xhr.onreadystatechange = null;
                        extendDownloadTimeout();
                        DEBUG && log.debug('Download connected', logFields);
                        _readHeaders(response, xhr);

                        if (config.useASE) {
                            //fire events for ASE manager
                            var event = {'timestamp': measurements.responseStartTime,
                                    'connect': true,
                                    'mediaRequest': request,
                                    'start': measurements.requestTime,
                                    'rt': [(measurements.responseStartTime - measurements.requestTime)]
                            };
                            response.onProgress(event);
                        }
                    }
                };
                xhr.onprogress = function (e) {
                    connected = true;
                    measurements.contentLength = e.loaded;
                    extendDownloadTimeout();

                    if (config.useASE) {
                        //fire events for ASE manager
                        var event = {'mediaRequest': request,
                                    'bytes': e.loaded,
                                    'tempstamp': clock$getTime()
                        };
                        response.onProgress(event);
                    }
                };
                xhr.onload = function (e) {
                    // Somehow we've already finalized the download,
                    // probably through abort().
                    if (complete === NOOP) {
                        return;
                    }
                    var content;
                    debug$assert(measurements.responseEndTime === undefined);
                    measurements.responseEndTime = clock$getTime();
                    measurements.responseStartTime = measurements.responseStartTime || measurements.responseEndTime;

                    if (xhr.status >= 200 && xhr.status <= 299) {
                        content = XMLHttpRequest$getContent(xhr, response);

                        if (request.parser) {
                            try {
                                response.content = request.parser(content, response);
                                response.success = true;
                                if (config.useASE) {
                                    response.parsed = true;
                                    response.raw = content;
                                }
                            }
                            catch (ex) {
                                log.warn('Exception parsing response', ex, logFields);
                                completeWithError(ErrorSubCodes.HTTP_PARSE, undefined, exceptionToString(ex));
                            }
                        } else {
                            if (config.useASE) {
                                response.parsed = false;
                            }
                            response.content = content;
                            response.success = true;
                        }
                    } else {
                        if (xhr.status == 420) {
                            completeWithError(ErrorSubCodes.HTTP_PROXY);
                        } else {
                            completeWithError(ErrorSubCodes.HTTP_PROTOCOL, xhr.status);
                        }
                    }
                    complete();
                };
                xhr.onabort = onAbort;
                xhr.onerror = function (e) {
                    if (xhr.status > 0) {
                        if (xhr.status == http$PROXY_STATUS_CODE) {
                            completeWithError(ErrorSubCodes.HTTP_PROXY);
                        } else {
                            completeWithError(ErrorSubCodes.HTTP_PROTOCOL, xhr.status, xhr.responseText);
                        }
                    } else {
                        var errorMsg = {
                            'status' : xhr['status'],
                            'internalErrorCodeB10': xhr['internalErrorCode'],
                            'internalErrorCodeB16': base16$fromInt(xhr['internalErrorCode'], 4),
                        };
                        if (config.useASE) {
                            errorMsg['url'] = xhr['responseURL'];
                        }
                        log.error('An error occurred downloading data.', errorMsg);
                        completeWithError(ErrorSubCodes.HTTP_UNKNOWN, base16$fromInt(xhr['internalErrorCode'], 4));
                    }
                };
                XMLHttpRequest$makeRequest(xhr, url, false, request);
                extendDownloadTimeout();
                _eventSource.addListener(http$offline, onOffLine);
            }
            catch (e) {
                log.error('Exception starting download', e, logFields);
                completeWithError(ErrorSubCodes.HTTP_XHR, undefined, exceptionToString(e));
            }
        }

        // fire the download started before actually starting the download
        _eventSource.fire(http$downloadstarted, response, true);

        // actually start the download on a separate dispatch, so the http$downloadstarted handlers process first
        dispatch(_startDownload);

        return response;
    }

    function _readHeaders(response, xhr) {
        var a = xhr.getAllResponseHeaders().split('\n'),
                i = a.length,
                s,
                splitAt,
                headers = {};
        while (i--) {
            s = a[i];
            if (s) {
                splitAt = s.indexOf(': ');
                // key must be 1+ charts, value might be empty string
                if (splitAt >= 1 && splitAt < s.length - 1) {
                    headers[s.substr(0, splitAt)] = s.substr(splitAt + 2);
                }
            }
        }
        response.headers = headers;
    }
})();

function http$constructRequestUrl(request, response) {
    var parts = request.url.split('?');
    var url = parts[0];

    var range = http$constructRequestRange(request);
    if (range) {
        response.range = range;
        if (url[url.length - 1] == '/') {
            url += 'range/';
        } else {
            url += '/range/';
        }
        url += range;
    }

    var random = request.cacheBuster ? 'random=' + (Math$random() * 100000000000000000).toFixed(0) : '';
    if (parts[1]) {
        url += '?' + parts[1] + (random ? '&' + random : '');
    } else {
        url += (random ? '?' + random : '');
    }

    if (request.cdn && !isUrlHttps(url)) {
        // only do this for requests from a CDN and for non-https urls
        // if there is a cnd proxy specified, re-route request through it
        var cdnProxyUrl = config && config.cdnProxyUrl;
        if (cdnProxyUrl) {
            url = cdnProxyUrl.replace('{URL}', url).replace('{EURL}', encodeURIComponent(url));
        }
    }

    response.url = url;
}

function http$constructRequestRange(request) {
    var from = request.offset;
    if (from === undefined) {
        return;
    }
    debug$assertInt(from);
    if (request.length !== undefined) {
        var to = request.offset + request.length - 1;
        debug$assertInt(to);
        debug$assert(from <= to);
        return from + '-' + to;
    } else {
        return from + '-';
    }
}

// once config is loaded, this will be replaced by http$isOnLineActual
var http$isOnLine = RETURN_TRUE;

function http$isOnLineActual() {
    // it's offline, only if there is "onLine" property and it's boolean false
    // if navigator.onLine is not supported, return true
    return navigator['onLine'] !== false;
}

function XMLHttpRequest$makeRequest(xhr, url, synchronous, request) {
    var requestPostBody = request.postBody,
        requestHeaders = request.headers;

    xhr.open(requestPostBody ? 'POST' : 'GET', url, !synchronous);

    switch (request.responseType) {
        case http$RESPONSETYPE_BINARY:
            xhr['responseType'] = 'arraybuffer';
            break;
        case http$RESPONSETYPE_XML:
            // deal with content server not returning proper mime type
            callIfPresent(xhr, 'overrideMimeType', undefined, 'text/xml');
            break;
    }

    if (requestPostBody) {
        // if there is a body for the request, make sure to pick a valid content-type for it
        var defaultContentTypeHeader = {
            'Content-Type': isString(requestPostBody) ? 'text/plain' : 'application/x-octet-stream'
        };
        // the default content-type should be overriden if one is provided in request.headers
        requestHeaders = requestHeaders ? mixIn(defaultContentTypeHeader, requestHeaders) : defaultContentTypeHeader;
    }

    if (requestHeaders) {
        enumerateOwnProperties(requestHeaders, function (k, v) {
            xhr['setRequestHeader'](k, v);
        });
    }

    if (request.withCredentials) {
        xhr['withCredentials'] = true;
    }

    if (xhr['msCaching'] !== undefined) {
        // Microsoft specific hack.
        // Event with cache-control header set to no cache, it might still be cached to disk.
        // This flag prevents XHR from ever caching to disk.
        xhr['msCaching'] = 'disabled';
    }

    if (requestPostBody) {
        xhr['send'](requestPostBody);
    } else {
        xhr['send']();
    }
}

function XMLHttpRequest$getContent(xhr, response) {
    switch (response.type) {
        case http$RESPONSETYPE_BINARY:
            // workaround the response being null for 0-length responses
            return xhr['response'] || new ArrayBuffer(0);
        case http$RESPONSETYPE_XML:
            return xhr['responseXML'];
        default:
            return xhr['responseText'];
    }
}

var http$downloadstarted = 1,
    http$downloadcomplete = 2,
    http$online = 3,
    http$offline = 4,
    http$onlinechanged = 5;

var http$RESPONSETYPE_TEXT = 1,
    http$RESPONSETYPE_XML = 2,
    http$RESPONSETYPE_BINARY = 3;

var http$PROXY_STATUS_CODE = 420;



// -- http/http-downloadSynchronously.js
function http$downloadSynchronously(request) {
    var ABSOLUTE_URL_REGEX = /^[a-z]*:\/\/.*/i;

    var url = request.url,
        xhr = new XMLHttpRequest(),
        response = {
            request: request,
            type: request.responseType
        };

    debug$assert(isString(url) && !ABSOLUTE_URL_REGEX.test(url), 'Url must be relative');

    /**
    * @param {boolean=} aborted
    */
    function complete(aborted) {
        complete = NOOP;
        xhr.onload = null;
        xhr.onabort = null;
        xhr.onerror = null;

        var status = xhr.status;

        if (!aborted && status >= 200 && status <= 299) {
            response.content = XMLHttpRequest$getContent(xhr, response);
            response.success = true;
        } else {
            response.errorSubCode = aborted ? ErrorSubCodes.HTTP_ABORT : ErrorSubCodes.HTTP_PROTOCOL;
            response.errorHttpCode = response.errorExternalCode = status;
            response.success = false;
        }
    }

    xhr.onload = function () {
        complete();
    };
    xhr.onerror = function (e) {
        complete();
    };
    xhr.onabort = function () {
        complete(true);
    };

    XMLHttpRequest$makeRequest(xhr, url, true, request);

    debug$assertBool(response.success);

    return response;
}


// -- http/HttpPlayback.js
/**
* @constructor
*/
function HttpPlayback(playback) {
    // --------------------------------------------------------------------------------
    // -- initialization & internal api

    return {
        download: _download
    };

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _download(request, callback) {
        request.playback = playback;
        var response = http.download(request, callback);
        playback.fireEvent(HttpPlayback$downloadstarted, response);
        response.addCallback(_downloadCompleteCallback);
        return response;
    }

    function _downloadCompleteCallback(response) {
        playback.fireEvent(HttpPlayback$downloadcomplete, response);
    }
}

/**
* Class for downloading media via HTTP. Supports media downloads when anti-virus
* or firewalls are scanning and holding downloads and passing the bytes on all at once. These
* can look like connect timeouts, so if we get one we ping to see if the CDN is there or not. If
* it is extend the timeout, if the CDN ping fails then the response.success is set to false.
*
* @constructor
*/
function MediaHttp(playback) {
    // --------------------------------------------------------------------------------
    // -- initialization & internal api
    return {
        download: _download
    };

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _download(request, completionCallback) {
        request.playback = playback;
        var pingJob;

        if (playback.cdn.value && config.pingOnConnectTimeout) {
            pingJob = {
                pinger: new CDNPinger(playback.httpPlayback),
                maxExtensions: config.maxParallelConnections, // scale the number of extensions by the number of connections since we are splitting the bandwidth
                numExtensions: 0,
                cdn: playback.cdn.value
            };
        }

        var response = http.download(request, completionCallback, pingJob);

        playback.fireEvent(HttpPlayback$downloadstarted, response);
        response.addCallback(_downloadCompleteCallback);

        function _downloadCompleteCallback(response) {
            playback.fireEvent(HttpPlayback$downloadcomplete, response);
        }
        return response;
    }
}


// -- http/CDNPinger.js

/**
* @constructor
*/
function CDNPinger(httpPlayback) {
    this.httpPlayback = httpPlayback;
    this.ping = _ping;

    function _ping(pingJob) {
        var _httpPlayback = this.httpPlayback,
            _stream = pingJob.stream,
            _pingForChunk = pingJob.chunk,
            _pingRequest,
            _pingResponse;

        if (pingJob.numExtensions > pingJob.maxExtensions) {
            pingJob.failCallback();
            return;
        }
        if (!_pingForChunk || _pingForChunk.media) {
            return;
        }
        _pingRequest = _constructPingRequest(pingJob.cdn, _stream, _pingForChunk);
        if (_pingRequest) {
            _pingResponse = _httpPlayback.download(_pingRequest, _onDownloadComplete);
        }

        var timeoutId = setTimeout(function () {
            _assessResults();
            _pingResponse && _pingResponse.abort();
        }, config.pingCDNTimeoutMilliseconds);

        function _onDownloadComplete(response) {
            clearTimeout(timeoutId);
            _assessResults(response);
        }

        /**
        * Assess the results of the ping test.
        * @param {Object=} response - (optional) object, if undefined, ping test fails.
        */
        function _assessResults(response) {
            var success = (response && response.success);

            success && pingJob.successCallback();
            !success && pingJob.failCallback();
        }
    }

    function _constructPingRequest(cdn, stream, chunk) {
        var url = stream.downloadUrls[cdn.id];
        if (url) {
            return {
                responseType: http$RESPONSETYPE_BINARY,
                url: stream.downloadUrls[cdn.id],
                parser: selectCdn$_verifyResponse,
                offset: stream.header.chunkInfos[chunk ? chunk.index : 0].offset,
                length: 8,
                cdn: cdn,
                track: stream.track,
                stream: stream,
                diagCaption: chunk.type + '-' + chunk.index + '-ping',
                cacheBuster: true
            };
        }
    }
}



// -- xml/xml.js
var xml$ATTRIBUTES = '$attributes',
    xml$CHILDREN = '$children',
    xml$NAME = '$name',
    xml$TEXT = '$text',
    xml$PARENT = '$parent',
    xml$SIBLING = '$sibling';

var parseXmlFragment$_xmlHeaderRegEx = /^\s*\<\?xml.*\?\>/i;

function parseXmlFragment(s, nccpVersion, callback) {
    var str = (s || '').replace(parseXmlFragment$_xmlHeaderRegEx, '');
    str = '<nccp:wrapper xmlns:nccp="http://www.netflix.com/eds/nccp/' + nccpVersion + '">' + str + '</nccp:wrapper>';
    xml2js(str, callback);
};

/**
* @param {Object} node
* @param {...string} name
*/
function getDescendantNode(node, name) {
    var i = 1;
    while ((name = arguments[i++]) && (node = node[name])) { };
    return node;
};

/**
* @param {number=} defaultValue
*/
function parseIntNode(node, defaultValue) {
    var value;
    if (node) {
        value = parseInt10(node[xml$TEXT]);
    } else if (defaultValue !== undefined) {
        value = defaultValue;
    }
    debug$assertInt(value);
    return value;
};

/**
* @param {string=} defaultValue
*/
function parseStringNode(node, defaultValue) {
    var value;
    if (node) {
        value = node[xml$TEXT];
    } else if (defaultValue !== undefined) {
        value = defaultValue;
    }
    debug$assertString(value);
    return value;
};

function makeNode(attribtues, text) {
    var node = {};
    node[xml$ATTRIBUTES] = attribtues;
    node[xml$TEXT] = text;
    return node;
};




// -- xml/xml2xmlDoc.js
function xml2xmlDoc(s) {
    if (isValidString(s)) {
        var xml = (new DOMParser()).parseFromString(s, 'text/xml');
        // parseFromString doesn't throw, but injects node named parsererror SOMEWHERE in the xml... deal with it
        var parsererrorNodes = xml.getElementsByTagName('parsererror');
        if (parsererrorNodes && parsererrorNodes[0]) {
            try {
                log.error('parser error details', {
                    'errornode': new XMLSerializer().serializeToString(parsererrorNodes[0]),
                    'xmlData': s.slice(0, 300),
                    'fileSize': s.length
                });
            } catch (e) {}
            throw new Error('xml parser error');
        }
        return xml;
    }
    throw new Error('bad xml text');
};


// -- xml/xmlDoc2js.js
function xmlDoc2js(xmlDoc) {
    var node = (xmlDoc.nodeType == xmlNode$DOCUMENT_NODE) ? xmlDoc.documentElement : xmlDoc;
    return xmlNode2js(node);
};

function xmlNode2js(node) {
    var len, i;

    var obj = {};
    obj[xml$NAME] = node.localName;

    var attributes = {};
    obj[xml$ATTRIBUTES] = attributes;
    var children = [];
    obj[xml$CHILDREN] = children;

    var nodeAttributes = node.attributes;
    len = nodeAttributes.length;
    for (i = 0; i < len; i++) {
        var attr = nodeAttributes[i];
        attributes[attr.localName] = attr.value;
    }

    var childNodes = node.childNodes;
    len = childNodes.length;
    var childListTails = {};
    for (i = 0; i < len; i++) {
        var childNode = childNodes[i];
        switch (childNode.nodeType) {
            case xmlNode$ELEMENT_NODE:
                var child = xmlNode2js(childNode);
                var childName = child[xml$NAME];
                child[xml$PARENT] = obj;
                children.push(child);
                if (obj[childName]) {
                    childListTails[childName][xml$SIBLING] = child;
                } else {
                    obj[childName] = child;
                }
                childListTails[childName] = child;
                break;
            case xmlNode$TEXT_NODE:
            case xmlNode$CDATA_SECTION_NODE:
                var text = childNode.text || childNode.nodeValue;
                children.push(text);
                if (!obj[xml$TEXT]) obj[xml$TEXT] = text;
                break;
        }
    }

    return obj;
};

var xmlNode$ELEMENT_NODE = 1,
    xmlNode$ATTRIBUTE_NODE = 2,
    xmlNode$TEXT_NODE = 3,
    xmlNode$CDATA_SECTION_NODE = 4,
    xmlNode$DOCUMENT_NODE = 9;




// -- xml/xml2js.js
function xml2js(xml, callback) {
    var xmlDoc,
        jsObj;

    try {
        xmlDoc = xml2xmlDoc(xml);
    }
    catch (e) {
        log.error('xml2xmlDoc exception', e);
    }

    // parseXml and xmlDoc2js both can be very slow, so split UI thread use
    dispatch(function () {
        if (xmlDoc && xmlDoc.documentElement) {
            try {
                jsObj = xmlDoc2js(xmlDoc);
            }
            catch (e) {
                log.error('xmlDoc2js exception', e);
            }
        }
        // dispatch the callback, there are cases when calling code won't expect it to be invoked on same stack
        // also it's nice for not hogging UI thread
        dispatch(function () {
            if (jsObj) {
                callback({
                    success: true,
                    object: jsObj
                });
            } else {
                callback({
                    success: false,
                    errorSubCode: ErrorSubCodes.FORMAT_XML
                });
            }
        });
    });
};


// -- xml/js2xml.js
/**
* @param {string=} depth
*/
function js2xml(jsObj, ns, doc, depth) {
    debug$assert(isObject(jsObj) && !isArray(jsObj));
    depth = depth || '';

    // if there is a wrapper objet, parse it along with it's attribtues
    // and wrap it around children xml
    var attribtuesString = '';
    var attribtues = jsObj.hasOwnProperty(xml$ATTRIBUTES) &&  jsObj[xml$ATTRIBUTES];
    if (attribtues) {
        enumerateOwnProperties(attribtues, function (k, v) {
            attribtuesString && (attribtuesString += ' ');
            attribtuesString += k + '="' + toXmlValue(v) + '"';
        });
    }

    var tagName = (ns ? ns + ':' : '') + doc;
    var tagOpen = depth + '<' + tagName + (attribtuesString ? (' ' + attribtuesString) : '');

    var text = jsObj.hasOwnProperty(xml$TEXT) && jsObj[xml$TEXT].trim  && jsObj[xml$TEXT].trim() !== '' && jsObj[xml$TEXT];
    if (text) {
        // if this obj has special text value, ignore the children and build a simple text node (possibly with attribtues)
        return tagOpen + '>' + toXmlValue(text) + '</' + tagName + '>';
    } else {
        // build the element along with it's children
        var childrenString = jsChildren2xml(jsObj, ns, depth + '  ');
        return tagOpen + (childrenString ? ('>\n' + childrenString + '\n' + depth + '</' + tagName + '>') : '/>');      
    }
};

/**
* @param {string=} depth
*/
function jsChildren2xml(jsObj, ns, depth) {
    debug$assert(isObject(jsObj) && !isArray(jsObj));
    depth = depth || '';

    var childrenString = '';
    enumerateOwnProperties(jsObj, function (k, v) {
        if (k[0] != '$') {
            var a = makeArray(v);
            for (var i = 0; i < a.length; i++) {
                v = a[i];
                childrenString && (childrenString += '\n');
                if (isObject(v)) {
                    childrenString += js2xml(v, ns, k, depth);
                } else {
                    var tagName = (ns ? ns + ':' : '') + k;
                    childrenString += depth + '<' + tagName + '>' + toXmlValue(v) + '</' + tagName + '>';
                }
            }
        }
    });

    return childrenString;
};

function toXmlValue(o) {
    if (isString(o)) {
        return htmlEncode(o);
    } else if (isNumber(o)) {
        debug$assertInt(o, 'Convert non-integer numbers to string for xml serialization.');
        return '' + o;
    } else if (o === null || o === undefined) {
        return '';
    }
    debug$assert(false, 'Invalid xml value.');
    return '';
};


// -- player-msl/msl.js
var msl; // loaded async

// register for async loading
MSL && loadAsync$register(ErrorCodes.INIT_COMPONENT_MSL, function asyncLoadMsl(callback) {
    debug$assert(config);

    if (!crypto || !cryptoSubtle || !cryptoSubtle['unwrapKey']) {
        callback({
            errorSubCode: ErrorSubCodes.MSL_INIT_NO_WEBCRYPTO
        });
        return;
    }

    try {
        var mslNs = window['netflix']['msl'],
            createMslClient = mslNs['createMslClient'],
            IHttpLocation = mslNs['IHttpLocation'],
            MslIoException = mslNs['MslIoException'];

    } catch (e) {
        callback({
            errorSubCode: ErrorSubCodes.MSL_INIT_NO_MSL
        });
        return;
    }

    var _log = new log.CategoryLog('Msl'),
        _shouldDeleteStore = config.mslDeleteStore,
        _shouldPersistStore = config.mslPersistStore,
        _storeStateKey = config.environmentIsTest ? 'mslstoretest' : 'mslstore',
        _sessionLockResult = storageLock.sessionLockResult,
        // force include NetflixId when we are using browser account (we managed the cookies),
        _includeNetflixIdUserAuthData = config.includeNetflixIdUserAuthData,
        // we can do key exchange or update MSL store only if we have the session lock (or session lock is not required)
        _allowTokenRefresh = !_sessionLockResult || _sessionLockResult.success;

    var identity = 'MSL_TRUSTED_NETWORK_SERVER_KEY',
        spkiKeyDataBase64 =
        'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlibeiUhffUDs6QqZiB+jXH/MNgITf7OOcMzuSv4G3JysWkc0aPbT3vkCVaxdjNtw50zo2Si8I24z' +
        '3/ggS3wZaF//lJ/jgA70siIL6J8kBt8zy3x+tup4Dc0QZH0k1oxzQxM90FB5x+UP0hORqQEUYZCGZ9RbZ/WNV70TAmFkjmckutWN9DtR6WUdAQWr0HxsxI9R' +
        '05nz5qU2530AfQ95h+WGZqnRoG0W6xO1X05scyscNQg0PNCy3nfKBG+E6uIl5JB4dpc9cgSNgkfAIeuPURhpD0jHkJ/+4ytpdsXAGmwYmoJcCSE1TJyYYoEx' +
        'uoaE8gLFeM01xXK5VINU7/eWjQIDAQAB',
        spkiKeyDataTestBase64 =
        'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAm84o+RfF7KdJgbE6lggYAdUxOArfgCsGCq33+kwAK/Jmf3VnNo1NOGlRpLQUFAqYRqG29u4wl8fH' +
        '0YCn0v8JNjrxPWP83Hf5Xdnh7dHHwHSMc0LxA2MyYlGzn3jOF5dG/3EUmUKPEjK/SKnxeKfNRKBWnm0K1rzCmMUpiZz1pxgEB/cIJow6FrDAt2Djt4L1u6sJ' +
        '/FOy/zA1Hf4mZhytgabDfapxAzsks+HF9rMr3wXW5lSP6y2lM+gjjX/bjqMLJQ6iqDi6++7ScBh0oNHmgUxsSFE3aBRBaCL1kz0HOYJe26UqJqMLQ71Swvjg' +
        'M+KnxZvKa1ZHzQ+7vFTwE7+yxwIDAQAB',
        spkiKeyData = base64$decode(config.environmentIsTest ? spkiKeyDataTestBase64 : spkiKeyDataBase64);

    if (_shouldDeleteStore) {
        // delete the store, and start fresh
        storage.remove(_storeStateKey, function(result) {
            doCreateClient();
        });
    } else if (_shouldPersistStore) {
        // load persisted store
        storage.load(_storeStateKey, function(result) {
            var loadedStoreState;
            if (result.success) {
                doCreateClient(result.data);
            } else if (result.errorSubCode == ErrorSubCodes.STORAGE_NODATA) {
                doCreateClient();
            } else {
                // HACK: In some cases IE11 throws whe trying to read persisted MSL state
                // Try to deleting the corrupt entry. And if we succeed, keep going with clean state.
                _log.error('Error loading msl store', ErrorSubCodes$errorResultToLogFields(result));
                storage.remove(_storeStateKey, function(result) {
                    if (result.success) {
                        doCreateClient();
                    } else {
                        callback(result);
                    }
                });
            }
        });
    } else {
        // ignore the stored store state
        doCreateClient();
    }

    /**
     * @param {Object=} loadedStoreState
     */
    function doCreateClient(loadedStoreState) {
        createMslClient({
            'esn': device.esn,
            'esnPrefix': device.esnPrefix,
            'authenticationType': config.authenticationType,
            'authenticationKeyNames': config.authenticationKeyNames,
            'systemKeyWrapFormat': config.systemKeyWrapFormat,
            'serverIdentityId': identity,
            'serverIdentityKeyData': spkiKeyData,
            'storeState': loadedStoreState,
            'notifyMilestone': loadAsync$notifyMilestone,
            'log': _log
        }, {
            'result': function(mslClient) {
                wrapup(mslClient);
            },
            'timeout': function() {
                callback({
                    errorSubCode: ErrorSubCodes.MSL_INIT_ERROR
                });
            },
            'error': function(e) {
                callback(_createMslErrorResult(ErrorSubCodes.MSL_INIT_ERROR, undefined, e));
            }
        });
    }

    function wrapup(mslClient) {

        var saveStoreStateThrottle = new Throttle(100),
            storeState;

        // create an implementation of IHttpLocation that works over our [http]

        var NccpHttpLocation = IHttpLocation['extend']({

            /** Create a new test MSL context for Nccp. */
            'init': function init(mslRequest) {
                this._mslRequest = mslRequest;
            },

            /** @inheritDoc */
            'getResponse': function getResponse(request, timeoutFromMsl, callback) {
                var mslRequest = this._mslRequest;
                var http = mslRequest.mslContext.http || http;
                var requestBody;

                // A change to MSL has resulted in the request.body value to
                // a byte array of the string.  So if the request.body is a
                //  byte array decode it back into a string
                if (isUint8Array(request.body)) {
                    requestBody = utf8$getString(request.body);
                } else {
                    requestBody = request.body;
                }
                debug$assertValidString(requestBody, 'Msl should not be sending empty request');

                var httpRequest = {
                    url: mslRequest.url,
                    postBody: requestBody,
                    withCredentials: true,
                    diagCaption: 'nccp-' + mslRequest.method
                };

                // use the timeout defined by NCCP and ignore the mslTimeout
                // this we we can differentiate HTTP timeout from all other MSL timeouts such as due to WebCrypto not calling back
                var timeout = this._mslRequest.timeout;
                httpRequest.connectTimeoutMilliseconds = timeout;
                httpRequest.noProgressTimeoutMilliseconds = timeout;

                var response = http.download(httpRequest, function(response) {
                    try {
                        if (response.success) {
                            callback['result']({
                                'body': response.content
                            });
                        } else {
                            throw mixIn(
                                new MslIoException("HTTP error, SubCode: " + response.errorSubCode + (response.errorHttpCode ? ", HttpCode: " + response.errorHttpCode : "")), {
                                    'cadmiumResponse': response
                                }
                            );
                        }
                    } catch (e) {
                        callback['error'](e);
                    }
                });

                return {
                    'abort': function() {
                        response.abort();
                    }
                };
            }
        });

        function saveMslStoreState() {
            if (_allowTokenRefresh) {
                storage.save(_storeStateKey, storeState, false, function(result) {
                    if (!result.success) {
                        _log.error('Error persisting msl store', ErrorSubCodes$errorResultToLogFields(result));
                    }
                });
            }
        }

        if (_shouldPersistStore) {
            mslClient['addEventHandler']('shouldpersist', function(args) {
                storeState = args['storeState'];
                saveStoreStateThrottle.schedule(saveMslStoreState);
            });
        }

        // and build a MSL interface that Nccp3Client understands

        msl = {

            send: function msl$send(mslRequest) {

                function createMslRequest() {
                    // translate the request to deal with obfuscation
                    // and augment it with [httpLocation]
                    var mslContext = mslRequest.mslContext;
                    var accountKey = mslContext.accountKey;
                    var account = accountKey && account$get(accountKey);
                    var request = {
                        'method': mslRequest.method,
                        'nonReplayable': mslRequest.nonReplayable,
                        'encrypted': mslRequest.encrypted,
                        'userId': mslRequest.userId,
                        'body': mslRequest.body,
                        // pass double the timeout to MSL, so we hit HTTP timeout before this
                        'timeout': mslRequest.timeout * 2,
                        'url': new NccpHttpLocation(mslRequest),
                        'allowTokenRefresh': _allowTokenRefresh
                    };
                    if (mslContext.email) {
                        request['email'] = mslContext.email;
                        request['password'] = mslContext.password || '';
                    } else if (mslContext.netflixId) {
                        request['netflixId'] = mslContext.netflixId;
                        request['secureNetflixId'] = mslContext.secureNetflixId;
                    } else if (mslContext.mdxControllerToken) {
                        request['mdxControllerToken'] = mslContext.mdxControllerToken;
                        request['mdxPin'] = mslContext.mdxPin;
                        request['mdxNonce'] = mslContext.mdxNonce;
                        request['mdxEncryptedPinB64'] = mslContext.mdxEncryptedPinB64;
                        request['mdxSignature'] = mslContext.mdxSignature;
                    }
                    else if (_includeNetflixIdUserAuthData || mslContext['useNetflixUserAuthData']) {
                        request['useNetflixUserAuthData'] = true;
                    }
                    return request;
                }

                return new Promise(function(resolve, reject) {
                    var request = createMslRequest();
                    mslClient['send'](request).then(function(result) {
                        if (_includeNetflixIdUserAuthData) {
                            // if we use auth data and got a successfull response,
                            // stop including them in subsequent requests. 
                            _includeNetflixIdUserAuthData = false;
                        }
                        resolve({
                            success: true,
                            body: result['body']
                        });
                    }).catch(function(e) {
                        if (e.error) {
                            var errorSubCode =
                                mslClient['isErrorReauth'](e.error) ? ErrorSubCodes.MSL_ERROR_REAUTH :
                                mslClient['isErrorHeader'](e.error) ? ErrorSubCodes.MSL_ERROR_HEADER :
                                ErrorSubCodes.MSL_ERROR;

                            var errorMslCode = mslClient['getErrorCode'](e.error);
                            reject(_createMslErrorResult(errorSubCode, errorMslCode, e.error));
                        } else {
                            _log.error('Unknown MSL error', e);
                            reject({
                                errorSubCode: e.subCode ? e.subCode : ErrorSubCodes.MSL_UNKNOWN
                            });
                        }
                    });
                });
            },

            buildPlayDataRequest: function msl$buildPlayDataRequest(mslRequest, callback) {

                // translate the request to deal with obfuscation
                var mslRequest2 = {
                    'nccpMethod': mslRequest.nccpMethod,
                    'nonReplayable': mslRequest.nonReplayable,
                    'encrypted': mslRequest.encrypted,
                    'userId': mslRequest.userId,
                    'body': mslRequest.body,
                    'serviceTokens': mslRequest.serviceTokens,
                    'timeout': mslRequest.timeout,
                    'allowTokenRefresh': false
                };

                mslClient['buildPlayDataRequest'](mslRequest2, {
                    'result': function(requestBody) {
                        callback({
                            success: true,
                            body: requestBody
                        });
                    },
                    'timeout': function() {
                        callback({
                            errorSubCode: ErrorSubCodes.MSL_REQUEST_TIMEOUT
                        });
                    },
                    'error': function(e) {
                        var errorSubCode =
                            mslClient['isErrorReauth'](e) ? ErrorSubCodes.MSL_ERROR_REAUTH :
                            mslClient['isErrorHeader'](e) ? ErrorSubCodes.MSL_ERROR_HEADER :
                            ErrorSubCodes.MSL_ERROR;

                        var errorMslCode = mslClient['getErrorCode'](e);

                        callback(_createMslErrorResult(errorSubCode, errorMslCode, e));
                    }
                });
            },

            mslClient: mslClient
        };

        callback(SUCCESS);
    }

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _createMslErrorResult(errorSubCode, errorMslCode, mslError) {
        var details;
        var stack;
        var errorExternalCode;
        var cadmiumResponse;
        var result = {
            errorSubCode: errorSubCode,
            errorMslCode: errorMslCode
        };

        if (mslError) {
            // if there is a cadmium response, just use that one
            cadmiumResponse = mslError['cadmiumResponse'];
            if (cadmiumResponse) {
                return cadmiumResponse;
            }

            details = mslError['errorMessage'] || ('' + mslError);
            stack = mslError.stack;
            if (stack) {
                stack = '' + stack;
                if (stack.indexOf(details) >= 0) {
                    // don't include message twice
                    details = stack;
                } else {
                    details += stack;
                }
            }

            errorExternalCode =
                parseInt10(mslError['internalCode']) ||
                parseInt10(mslError['error'] && mslError['error']['internalCode']);
        }

        if (details) {
            result.errorDetails = details;
        }

        if (errorExternalCode) {
            result.errorExternalCode = errorExternalCode;
        }

        return result;
    }

});



// -- nccp/decodeLicenseResponse.js
/**
* @param {string} licenseBase64
* @param {string} drmType
*/
function decodeLicenseResponse(licenseBase64, drmType, callback) {
    switch (drmType) {
        case DrmType$PLAYREADY:

            if (licenseBase64) {
                var licenseResponseXml = base64$decodeAsText(licenseBase64);

                xml2js(licenseResponseXml, function(result) {
                    if (result.success) {
                        var node = result.object;
                        if (node) {
                            
                            var xmrNode = getDescendantNode(node, 'Body', 'AcquireLicenseResponse', 'AcquireLicenseResult', 'Response', 'LicenseResponse', 'Licenses', 'License');
                            if (xmrNode) {
                                var xmrBase64 = parseStringNode(xmrNode);
                                if (xmrBase64) {
                                    var xmr = base64$decode(xmrBase64);
                                    if (xmr) {
                                        var decodedLicense = decodeLicenseResponse$readPlayReadyXmr(xmr);
                                        if (decodedLicense) {
                                            callback(decodedLicense);
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            }

            break;
    }
};

function decodeLicenseResponse$readPlayReadyXmr(xmr) {
    var xmrStream = new DataStream(xmr),
        magicNumber = xmrStream.readUInt();
    
    if (magicNumber != 0x584D5200) {
        throw new Error('Invalid header');
    }

    var obj = {
        'XMR': {
            'Version': xmrStream.readUInt(),
            'RightsID': xmrStream.readBytesAsHex(16)
        }
    };

    decodeLicenseResponse$readXmrObject(xmrStream, obj['XMR'], xmrStream.buffer.byteLength);

    return obj;
};

function decodeLicenseResponse$readXmrObject(xmrStream, obj, maxLength) {
    while (xmrStream.position < maxLength) {
        // FLAGS: 0, 1 or 2
        var flags = xmrStream.readUShort();
        var type = xmrStream.readUShort();
        var length = xmrStream.readUInt();
        var key,
            keyLength;

        // length includes the header size (flags, type, length itself)
        length -= 8;

        var name;
        switch (type) {
        case 0x0001:
            name = "OuterContainer";
            break;
        case 0x0002:
            name = "GlobalPolicy";
            break;
        case 0x0003:
            name = "MinimumEnvironment";
            break;
        case 0x0004:
            name = "PlaybackPolicy";
            break;
        case 0x0005:
            name = "OutputProtection";
            break;
        case 0x0006:
            name = "UplinkKID";
            break;
        case 0x0007:
            name = "ExplicitAnalogVideoOutputProtectionContainer";
            break;
        case 0x0008:
            name = "AnalogVideoOutputConfiguration";
            break;
        case 0x0009:
            name = "KeyMaterial";
            break;
        case 0x000A:
            name = "ContentKey";
            break;
        case 0x000B:
            name = "Signature";
            break;
        case 0x000C:
            name = "DeviceIdentification";
            break;
        case 0x000D:
            name = "Settings";
            break;
        case 0x0012:
            name = "ExpirationRestriction";
            break;
        case 0x002A:
            name = "ECCKey";
            break;
        case 0x0030:
            name = "ExpirationAfterFirstPlayRestriction";
            break;
        case 0x0032:
            name = "PlayReadyRevocationInformationVersion";
            break;
        case 0x0033:
            name = "EmbeddedLicenseSettings";
            break;
        case 0x0034:
            name = "SecurityLevel";
            break;
        case 0x0036:
            name = "PlayEnabler";
            break;
        case 0x0039:
            name = "PlayEnablerType";
            break;
        case 0x0055:
            name = "RealTimeExpirationRestriction";
            break;
        default:
            name = "Other";
            break;
        }

        var typeInHex = decodeLicenseResponse$toHexString(type);

        var newObj = {
            'Type': typeInHex
        };

        var subObj = obj[name];
        if (subObj) {
            if (isArray(subObj)) {
                // if subObj is an array, add newObj to array
                subObj.push(newObj);
            } else {
                // it's an object, convert to an array
                obj[name] = [];
                obj[name].push(subObj);
                obj[name].push(newObj);
            }
        } else {
            obj[name] = newObj;
        }

        switch (type) {
        case 1:
        case 2:
        case 4:
        case 7:
        case 9:
        case 0x0036:
            decodeLicenseResponse$readXmrObject(xmrStream, newObj, xmrStream.position + length);
            break;
        case 5:
            newObj['Reserved1'] = xmrStream.readUShort();
            newObj['MinimumUncompressedDigitalVideoOutputProtectionLevel'] = xmrStream.readUShort();
            newObj['MinimumAnalogVideoOutputProtectionLevel'] = xmrStream.readUShort();
            newObj['Reserved2'] = xmrStream.readUShort();
            newObj['MinimumUncompressedDigitalAudioOutputProtectionLevel'] = xmrStream.readUShort();
            break;
        case 0x000A:
            newObj['Reserved'] = xmrStream.readBytesAsHex(16);
            newObj['SymmetricCipherType'] = xmrStream.readUShort();
            newObj['AsymmetricCipherType'] = xmrStream.readUShort();
            keyLength = xmrStream.readUShort();
            newObj['EncryptedKeyLength'] = keyLength;
            key =xmrStream.readBytesAsHex(keyLength);
            newObj['EncryptedKeyData'] = keyLength <= 10 ? key : key.substring(0, 4) + "..." + key.substring((key.length - 4), key.length);
            break;
        case 0x000B:
            newObj['SignatureType'] = xmrStream.readBytesAsHex(2);
            keyLength = xmrStream.readUShort();
            key = xmrStream.readBytesAsHex(keyLength);
            newObj['SignatureData'] = keyLength <= 10 ? key : key.substring(0, 4) + "..." + key.substring((key.length - 4), key.length);
            break;
        case 0x000D:
            newObj['Reserved'] = xmrStream.readUShort();
            break;
        case 0x0012:
            newObj['BeginDate'] = xmrStream.readUInt();
            newObj['EndDate'] = xmrStream.readUInt();
            break;
        case 0x002A:
            newObj['CurveType'] = xmrStream.readBytesAsHex(2);
            keyLength = xmrStream.readUShort();
            key = xmrStream.readBytesAsHex(keyLength);
            newObj['Key'] = keyLength <= 10 ? key : key.substring(0, 4) + "..." + key.substring((key.length - 4), key.length);
            break;
        case 0x0030:
            newObj['ExpireAfterFirstPlay'] = xmrStream.readUInt();
            break;
        case 0x0032:
            newObj['Sequence'] = xmrStream.readUInt();
            break;
        case 0x0033:
            newObj['LicenseProcessingIndicator'] = xmrStream.readUShort();
            break;
        case 0x0034:
            newObj['MinimumSecurityLevel'] = xmrStream.readUShort();
            break;
        case 0x0039:
            newObj['PlayEnablerType'] = decodeLicenseResponse$toGuidString(xmrStream.readBytesAsHex(16));
            break;
        case 0x0055:
            break;
        default:
            newObj['OtherData'] = xmrStream.readBytesAsHex(length);
            break;
        }
    }
};

function decodeLicenseResponse$toHexString(number) {
    return '0x' + number.toString(16);
};

function decodeLicenseResponse$toGuidString(hexString) {
    var guidString = 

          hexString.substring(6,8)
        + hexString.substring(4,6)
        + hexString.substring(2,4)
        + hexString.substring(0,2)
        + '-'
        + hexString.substring(10,12)
        + hexString.substring(8,10)
        + '-'
        + hexString.substring(14,16)
        + hexString.substring(12,14)
        + '-'
        + hexString.substring(16,20)
        + '-'
        + hexString.substring(20,32);

    return guidString;
};



// -- nccp/NccpBrClient.js
/**
 * @constructor
 */
function NccpBrClient(edgeConfig, deviceParameters, msl, device, log) {
    // --------------------------------------------------------------------------------
    // -- initialization and internal API

    var _self = this,
        _nonReplayableMethods = arrayToHashSet(['license']),
        cmdHistory = [],
        serverTimeOffset = 0;

    mixIn(_self,
        /** @lends {NccpBrClient.prototype} */
        {
            getManifest: _getManifest,
            getLicense: _getLicense,
            start: _start,
            stop: _stop,
            release: _release,
            engage: _engage,
            mediaSplice: _mediaSplice,
            bindNetflixId: _bindNetflixId,
            ping: _ping,
            deviceNetflixId: _deviceNetflixId,
            netflixId: _netflixId,
            registerByNetflixId: _registerByNetflixId,
            registerByEmailPassword: _registerByEmailPassword,
            license: _license,
            playdata: _playdata,
            createPlaydataRequest: _createPlaydataRequest,
            heartbeat: _heartbeat,
            logblob: _logblob,
            mdxpair: _mdxpair,
            mdxregister: _mdxregister,
            getServerEpoch: _getServerEpoch,
            convertToServerEpoch: _convertToServerEpoch,
            getPrefetchSharedSecret: _getPrefetchSharedSecret
        });

    // Endpoint commands. NOTE: These must exactly match handler code in the groovy
    // server script Html5Endpoint.groovy.
    var MANIFEST_CMD = 'manifest',
        LICENSE_CMD = 'license',
        START_CMD = 'start',
        STOP_CMD = 'stop',
        RELEASE_CMD = 'release',
        PBLIFECYCLE_CMD = 'pblifecycle',
        LOGBLOB_CMD = 'logblob',
        BIND_CMD = 'bind',
        PAIR_CMD = 'pair',
        PING_CMD = 'ping',
        SECRET_CMD = 'secret',
        ENGAGE_CMD = 'engage';

    // Playback lifecycle types. These distiguish the various types of events that
    // go through the pblifecyle endpoint command.
    // NOTE: These must exactly match strings in handler code in the groovy server
    // script PlaybackLifecycle.groovy.
    var PBLC_TYPE_RESUME = 'resume',
        PBLC_TYPE_SUSPEND = 'suspend',
        PBLC_TYPE_INTERVAL = 'interval',
        PBLC_TYPE_STOP = 'stop',
        PBLC_TYPE_PVTRANSITION = 'previewTransition',
        PBLC_TYPE_SPLICE = 'splice';
    // Map to translate from old nccp$ heartbeat types to new playback lifecycle types
    var pblcMap = {};
    pblcMap[nccp$HEARTBEAT_TYPE_RESUME] = PBLC_TYPE_RESUME;
    pblcMap[nccp$HEARTBEAT_TYPE_SUSPEND] = PBLC_TYPE_SUSPEND;
    pblcMap[nccp$HEARTBEAT_TYPE_INTERVAL] = PBLC_TYPE_INTERVAL;

    // --------------------------------------------------------------------------------
    // -- private implementation

    /**
     * @summary Sends out a request to get the manifest for a list of movie Ids
     * @param  {{
     *         lookupType: number,
     *         viewableIds: Array.<number>,
     *         videoProfiles: Array.<string>,
     *         audioProfiles: Array.<string>,
     *         textProfiles: Array.<string>,
     *         trickplayProfiles: Array.<string>,
     *         drmSystem: string,
     *         appId: string,
     *         sessionParams: Object.<string, Object>,
     *         sessionId: string,
     *         trackingId: number,
     *         flavor: number
     *     }}                   manifestRequest the data to send to the server
     * @param  {{log: Object}}  context additional context, contains the log object for logging
     * @return {Object}         a promise that returns the requested manifests; or an error object
     *                          on failure
     * @description  The manifest command will return an array of manifest objects. Depending on
     * the lookupType 0 or more of these may have error information due to failure. 
     *
     * @example <caption>Example of single manifest with success</caption>
     * { 
     *     'success': true,
     *     'result':
     *         'viewables': [
     *         {
     *             'success': true
     *             ... manifest data ...
     *         }
     *     ]
     * }
     *
     * @example <caption>Example of mulitple manifest with some failure</caption>
     * { 
     *     'success': true,
     *     'result':
     *         'viewables': [
     *         {
     *             'success': true,
     *             'movieid': 123456,
     *             ... more manifest data ...
     *         },
     *         {
     *             'success': false,
     *             'movieid': 123456,                       // Optional
     *             'result' : {
     *                 'errorSubCode': 1234,
     *                 'errorExternalCode': 4321,
     *                 'errorEdgeCode': 5678,               // Optional
     *                 'errorDetails': ' some details',     // Optional
     *                 'errorDisplayMessage':               // Optional 
     *                 'data': 'some additional data'       // Optional
     *             }
     *         }
     *     ]
     * }
     */
    function _getManifest(manifestRequest, context) {
        var Enums = CadmiumTypescript.Enums;
        var request = {
            'method': MANIFEST_CMD,
            'lookupType': Enums.convertManifestLoadTypesEnumToString(manifestRequest.lookupType),
            'viewableIds': manifestRequest.viewableIds,
            'profiles': manifestRequest.videoProfiles
                .concat(manifestRequest.audioProfiles)
                .concat(manifestRequest.textProfiles)
                .concat(manifestRequest.trickplayProfiles)
                .filter(Boolean), // remove any empty elements
            'drmSystem': manifestRequest.drmSystem,
            'appId': manifestRequest.appId,
            'sessionParams': manifestRequest.sessionParams,
            'sessionId': manifestRequest.sessionId,
            'trackId': manifestRequest.trackingId,
            'flavor': Enums.convertPlaybackContextFlavorEnumToString(manifestRequest.flavor),
            'secureUrls': edgeConfig.secureUrls,
            'supportPreviewContent': edgeConfig.supportPreviewContent,
            'forceClearStreams': edgeConfig.forceClearStreams,
            'validatePinProtection': edgeConfig.validatePinProtection
        };

        if (DEBUG) {
            debug$assert(isDefined(request['lookupType']), 'Manifest command will fail; lookupType is undefined');
            debug$assert(isDefined(request['viewableIds']), 'Manifest command will fail; viewableIds is undefined');
            debug$assert(isDefined(request['profiles']), 'Manifest command will fail; profiles is undefined');
            debug$assert(isDefined(request['drmSystem']), 'Manifest command will fail; drmSystem is undefined');
            debug$assert(isDefined(request['sessionParams']), 'Manifest command will fail; sessionParams is undefined');
            debug$assert(isDefined(request['appId']), 'Manifest command will fail; appId is undefined');
            debug$assert(isDefined(request['sessionId']), 'Manifest command will fail; sessionId is undefined');
            debug$assert(isDefined(request['trackId']), 'Manifest command will fail; trackId is undefined');
            debug$assert(isDefined(request['flavor']), 'Manifest command will fail; flavor is undefined');
            debug$assert(isDefined(request['secureUrls']), 'Manifest command will fail; secureUrls is undefined');
            debug$assert(isDefined(request['supportPreviewContent']), 'Manifest command will fail; supportPreviewContent is undefined');
        }

        if (manifestRequest.packageId) {
            request['packageId'] = manifestRequest.packageId;
        }

        return new Promise(function(resolve, reject) {
            PLATFORM_SECURITY_DESCRIPTORS({
                config: config
            }).then(function(securityDescriptors) {
                if (securityDescriptors) {
                    request['securityDescriptors'] = securityDescriptors;
                }

                return PLATFORM_MEDIA_OUTPUT_DESCRIPTORS({
                    config: config
                });
            }).then(function(mediaOutputDescriptors) {
                if (mediaOutputDescriptors) {
                    request['mediaOutputDescriptors'] = mediaOutputDescriptors;
                }

                function processGoodResult(result) {
                    return {
                        success: true,
                        authorizationData: result
                    };
                }

                _doRequest(request, context, processGoodResult).then(function(result) {
                    resolve(result);
                }).catch(function(err) {
                    reject(err);
                });
            }).catch(function(err) {
                reject(err);
            });
        });
    }

    /**
     * Helper that returns a promise and resolves/rejects the promise based on the request results.
     * @param  {Object}    request          contains the request data
     * @param  {{log}}     context          additional context data used for generating the request, currently only log is used.
     * @param  {Function=} resolveFunction  function to call if request is successful
     * @param  {boolean=}  debug            indicates whether to have request return debug info, if turned on request cannot be parsed
     *                                      only used while debugging a script
     * @return {Promise}                    resolves on success, rejects on failure
     */
    function _doRequest(request, context, resolveFunction, debug) {
        return new Promise(function(resolve, reject) {
            _send(request, context, DEBUG, debug).then(function(result) {
                if (DEBUG) context.log.debug('Processing EDGE ' + request.method + ' response');
                if (resolveFunction) {
                    resolve(resolveFunction(result));
                } else {
                    resolve({
                        success: true,
                    });
                }
            }).catch(function(err) {
                var errorData;
                try {
                    errorData = JSON.stringify(err.errorData);
                } catch (e) {}

                context.log.error('Processing EDGE response failed', {
                    'method': request.method,
                    'success': err.success,
                    'errorSubCode': err.errorSubCode,
                    'errorExternalCode': err.errorExternalCode,
                    'errorDetails': err.errorDetails,
                    'errorDisplayMessage': err.errorDisplayMessage,
                    'errorData': errorData
                });

                if (err['__logs']) {
                    context.log.error(err['__logs']);
                }
                reject(err);
            });
        });
    }

    /**
     * Sends the license challenge to the server and if successful receives the license
     * response
     * @param  {{
     *     playbackContextId: string,
     *     clientTime: number,
     *     licenseType: string,
     *     drmContextIds: Array.<string>,
     *     challengeBase64: string
     * }} licenseRequestData the input data for the request
     * @param  {{log}} context additional context data used for generating the request, currently only log is used.
     * @return {Object} if successful a object of type
     *     <code>{
     *         success: Boolean,
     *         licenseContextId: String,
     *         licenseResponseBase64: String
     *     }</code>; otherwise an error
     */
    function _getLicense(licenseRequestData, context) {
        var request = {
            'method': LICENSE_CMD,
            'playbackContextId': licenseRequestData.playbackContextId,
            'clientTime': clock$getEpoch(),
            'licenseType': licenseRequestData.licenseType,
            'drmContextIds': licenseRequestData.drmContextIds,
            'challengeBase64': licenseRequestData.challengeBase64,
            'xid': licenseRequestData.xid
        };

        if (licenseRequestData.mdxEsn){
            request['mdxesn'] = licenseRequestData.mdxEsn;
        }

        function processGoodResult(result) {
            var licenseResponseBase64 = result['licenseResponseBase64'];
            // can get a good result but still have a bad license
            if (!isValidString(licenseResponseBase64)) {
                log.error('no license response');
                return {
                    success: false,
                    errorSubCode: ErrorSubCodes.BR_DRM_LICENSE_AQUISITION
                };
            } else {
                return {
                    success: true,
                    licenseContextId: result['licenseContextId'],
                    licenseResponseBase64: licenseResponseBase64
                };
            }
        }

        return _doRequest(request, context, processGoodResult);
    }

    /**
     * Creates the playback session and sends the start playback lifecycle event
     * @param  {{log}} context additional context data used for generating the request, currently only log is used.
     * @param  {{
     *     playbackContextId: string,
     *     mediaId: string,
     *     xid: string,
     *     appId: string,
     *     sessionId: string,
     *     sessionParams: Object.<string, Object>,
     *     trackId: string,
     *     startPosition: number,
     *     playbackType: string
     * }} startRequestData the input data for the request
     * @return {Object} if successful a object of type
     *     <code>{
     *         success: Boolean,
     *         playbackSessionId: String,
     *     }</code>; otherwise an error
     */
    function _start(context, startRequestData) {

        function _combineParams() {
            var result = {};

            if (startRequestData.authParams) {
                enumerateOwnProperties(startRequestData.authParams, function(key, value) {
                    result[key] = isString(value) ? value : JSON.stringify(value);
                });
            }
            if (startRequestData.sessionParams) {
                enumerateOwnProperties(startRequestData.sessionParams, function(key, value) {
                    result[key] = isString(value) ? value : JSON.stringify(value);
                });
            }
            return result;
        }

        var request = {
            'method': START_CMD,
            'playbackContextId': startRequestData.playbackContextId,
            'mediaId': startRequestData.mediaId,
            'xid': startRequestData.xid,
            'appId': startRequestData.appId,
            'sessionId': startRequestData.sessionId,
            'sessionParams': _combineParams(),
            'trackId': startRequestData.trackId,
            'startPosition': startRequestData.startPosition,
            'playbackType': startRequestData.playbackType
        };

        function processGoodResult(result) {
            return {
                success: true,
                playbackSessionId: result['playbackSessionId'],
            };
        }

        return _doRequest(request, context, processGoodResult);
    }

    /**
     * Stops the playback session if it hasn't expired and releases the DRM license
     * @param  {{log}} context additional context data used for generating the request, currently only log is used.
     * @param  {{
     *     playbackSessionId: string,
     *     xid: number,
     *     mediaId: string,
     *     playback: string
     * }} stopRequestData the input data for the request
     * @return {Object} if successful a object of type
     *     <code>{
     *         success: Boolean,
     *         releaseData: string,
     *     }</code>; otherwise an error
     */
    function _stop(context, stopRequestData) {
        var request = {
            'method': STOP_CMD,
            'playbackContextId': stopRequestData.playbackContextId,
            'playbackSessionId': stopRequestData.playbackSessionId,
            'xid': stopRequestData.xid,
            'mediaId': stopRequestData.mediaId,
            'type': PBLC_TYPE_STOP,
            'position': stopRequestData.position,
            'playback': stopRequestData.playback,
            'timestamp': stopRequestData.timestamp
        };

        if (DEBUG) {
            debug$assert(isDefined(request['playbackContextId']), 'Stop command will fail; playbackSessionId is undefined');
            debug$assert(isDefined(request['xid']), 'Stop command will fail; mediaId is undefined');
            debug$assert(isDefined(request['timestamp']), 'Stop command will fail; timestamp is undefined');
            debug$assert(isDefined(request['playback']), 'Stop command will fail; playback is undefined');
            debug$assert(isDefined(request['playback']['playTimes']), 'Stop command will fail; playback.playTimes is undefined');
            debug$assert(isDefined(request['playback']['playTimes']['total']), 'Stop command will fail; playTimes.total is undefined');
            if (request['playbackSessionId']) {
                debug$assert(isDefined(request['playback']['startPosition']), 'Stop command will fail; playback.startPosition is undefined');
            }
        }

        function processGoodResult(result) {
            return {
                success: true
            };
        }

        return _doRequest(request, context, processGoodResult);
    }

    /**
     * Releases a DRM license
     * @param  {{log}} context  additional context data used for generating the 
     *                          request, currently only log is used.
     * @param  {{
     *     xid: string,
     *     licenseContextId: string,
     *     secureStopData: string,
     *     stopParams: Object
     * }} releaseRequestData    the input data for the request
     * @return {Object}         if successful a object of type
     *     <code>{
     *         success: Boolean,
     *         releaseData: string,
     *     }</code>; otherwise an error
     */
    function _release(context, releaseRequestData) {
        var request = {
            'method': RELEASE_CMD,
            'xid': releaseRequestData.xid,
            'licenseContextId': releaseRequestData.licenseContextId,
        };

        if (DEBUG) {
            debug$assert(isDefined(request['xid']), 'Release command will fail; xid is undefined');
            debug$assert(isDefined(request['licenseContextId']), 'Release command will fail; licenseContextId is undefined');
        }

        if (releaseRequestData.secureStopData) {
            request['secureStopData'] = releaseRequestData.secureStopData;
        }

        if (releaseRequestData.stopParams) {
            request['stopParams'] = releaseRequestData.stopParams;
        }

        function processGoodResult(result) {
            if (result['releaseData']) {
                return {
                    success: true,
                    response: {
                        data: base64$decode(result['releaseData'])
                    }
                };
            } else {
                return {
                    success: true
                };
            }
        }

        return _doRequest(request, context, processGoodResult);
    }

    /**
     * Sends the user engagment playback lifecycle event
     * @param  {{log}}  context             additional context data used for 
     *                                      generating the request, currently only 
     *                                      log is used.
     * @param  {{
     *     playbackSessionId: string,
     *     position: number,
     *     playback: string,
     *     action: string
     * }}               engageRequestData   the input data for the request
     * 
     * @return {Promise}                    if successful a Promise that resolves
     *                                      with a value of type
     *                                      <code>{
     *                                          success: Boolean
     *                                      }</code>; otherwise rejects
     */
    function _engage(context, engageRequestData) {
        var request = {
            'method': ENGAGE_CMD,
            'type': 'engage',
            'playbackSessionId': engageRequestData.playbackSessionId,
            'mediaId': engageRequestData.mediaId,
            'position': engageRequestData.position,
            'timestamp': engageRequestData.timestamp,
            'playback': engageRequestData.playback,
            'action': engageRequestData.action
        };

        if (DEBUG) {
            debug$assert(isDefined(request['playbackSessionId']), 'Engage command will fail; playbackSessionId is undefined');
            debug$assert(isDefined(request['mediaId']), 'Engage command will fail; mediaId is undefined');
            debug$assert(isDefined(request['type']), 'Engage command will fail; type is undefined');
            debug$assert(isDefined(request['position']), 'Engage command will fail; position is undefined');
            debug$assert(isDefined(request['timestamp']), 'Engage command will fail; timestamp is undefined');
            debug$assert(isDefined(request['playback']), 'Engage command will fail; playback is undefined');
            debug$assert(isDefined(request['playback']['startPosition']), 'Engage command will fail; playback.startPosition is undefined');
            debug$assert(isDefined(request['playback']['playTimes']), 'Engage command will fail; playback.playTimes is undefined');
            debug$assert(isDefined(request['playback']['playTimes']['total']), 'Engage command will fail; playTimes.total is undefined');
            debug$assert(isDefined(request['action']), 'Engage command will fail; action is undefined');
        }

        function processGoodResult(result) {
            return {
                success: true,
            };
        }

        return _doRequest(request, context, processGoodResult);
    }

    /**
     * Sends a playback lifecycle request to the server
     * @param  {Object} data the input data for the request
     * @param  {string} pblcType the type of playback lifecycle request
     * @param  {{log}}  context  additional context data used for generating the request, currently only log is used.
     * @return {Promise}
     */
    function _sendPlaybackLifecycle(data, pblcType, context) {
        var request = {
            'method': PBLIFECYCLE_CMD,
            'type': pblcType,
            'playbackSessionId': data.playbackSessionId,
            'mediaId': data.mediaId,
            'position': data.position,
            'timestamp': data.timestamp,
            'playback': data.playback
        };

        if (DEBUG) {
            debug$assert(isDefined(request['playbackSessionId']), 'PBLifecycle command will fail; playbackSessionId is undefined');
            debug$assert(isDefined(request['mediaId']), 'mPBLifecycle command will fail; ediaId is undefined');
            debug$assert(isDefined(request['type']), 'PBLifecycle command will fail; type is undefined');
            debug$assert(isDefined(request['position']), 'PBLifecycle command will fail; position is undefined');
            debug$assert(isDefined(request['playback']), 'PBLifecycle command will fail; playback is undefined');
            debug$assert(isDefined(request['playback']['startPosition']), 'PBLifecycle command will fail; playback.startPosition is undefined');
            debug$assert(isDefined(request['playback']['playTimes']), 'PBLifecycle command will fail; playback.playTimes is undefined');
            debug$assert(isDefined(request['playback']['playTimes']['total']), 'PBLifecycle command will fail; playTimes.total is undefined');
        }

        return _doRequest(request, context);
    }
    
    /**
     * Sends a logblob request to the server
     * @param  {string} json    logblob data in a json string
     * @param  {{log}}  context additional context data used for generating the request, currently only log is used.
     * @return {Promise}
     */
    function _sendLogblob(json, context) {
        var request = {
            'method': LOGBLOB_CMD,
            'logblobs': json
        };
        return _doRequest(request, context);
    }

    /**
     * doPing's only job is to hit the server and get a successful result. Behind the
     * scenes MSL can do an authorization if it feels like it.
     * @param  {{log}}  context additional context data used for generating the request, currently only log is used.
     * @return {Object} a promise that returns an object of type:
     *     <code>{
     *         success: Boolean
     *     }</code>
     * via Promise.resolve if successful.
     * If the request fails an object of type:
     *     <code>{
     *         success: Boolean
     *     }</code>
     * is returned via Promise.reject
     */
    function _doPing(context) {
        var request = {
            'method': PING_CMD
        };
        return _doRequest(request, context);
    }

    /**
     * Device binds the Netflix ID cookie or creates a device bound cookie
     * @param  {{log}} context additional context data used for generating the request, currently only log is used.
     * @return {Object} a promise that returns an object of type:
     *     <code>{
     *         success: Boolean
     *         netflixId: String,
     *         secureNetflixId: String,
     *         netflixIdSetCookie: String,
     *         secureNetflixIdSetCookie: String
     *     }</code>
     * via Promise.resolve if successful.
     * If the request fails an object of type:
     *     <code>{
     *         success: Boolean
     *     }</code>
     * is returned via Promise.reject
     */
    function _bindNetflixId(context) {
        var request = {
            'method': BIND_CMD
        };

        function processGoodResult(result) {
            return {
                success: true
            };
        }

        return _doRequest(request, context, processGoodResult);
    }
    
    /**
     * Gets shared secret to decrypt prefetch messages sent to Cast devices.
     * Secret is composed of todays date, current account id, and a salt
     *
     * @param {string}   dateOffset  representing what keys should be fetched. To 
     *                               get yesterday, today and tomorrow use "-1,0,1"
     * @param {{log}}    context     additional context data used for generating 
     *                               the request, currently only log is used.
     * @return {Object}              a promise that returns an object of type:
     *     <code>{
     *         success: Boolean
     *         prefetchKeys: {
     *          {number}: {
     *              gcmKey: {
     *                key: string
     *              }
     *          },
     *          ...
     *      }
     *     }</code>
     * via Promise.resolve if successful.
     * If the request fails an object of type:
     *     <code>{
     *         success: Boolean
     *     }</code>
     * is returned via Promise.reject
     */
    function _getPrefetchSharedSecret(dateOffset, context) {
        var request = {
            'method': SECRET_CMD,
            'dates': dateOffset
        };

        function processGoodResult(result) {
            return {
                success: true,
                prefetchKeys: result['prefetchKeys']
            };
        }

        return _doRequest(request, context, processGoodResult);
    }

    /**
     * Sends pair request data to server to setup secure communications with a MDX compatible device
     * @param {{
     *     targetUuid: String,
     *     cticket: String,
     *     nonce: String,
     *     controllerUuid: String,
     *     pairDataHmac: String
     * }} pairRequestData the input data for the request
     * @param  {{ log: Object }} context additional context data used for generating the request.
     * @return {Object} a promise that returns an object of type:
     *                    <code>{
     *                        success: Boolean,
     *                        pairData: {
     *                            grantData: {
     *                                nonce: String|undefined,
     *                                controlleruuid: String|undefined,
     *                                controlleruserid: String|undefined,
     *                                controllersharedsecret: String|undefined,
     *                                targetuuid: String|undefined,
     *                                targetuserid: String|undefined,
     *                                targetsharedsecret: String|undefined
     *                            }|undefined,
     *                            grantDataHmac: String|undefined,
     *                        }
     *                    }</code>
     *                  via Promise.resolve if successful.
     *                  If the request fails an object of type:
     *                    <code>{
     *                        success: Boolean
     *                    }</code>
     *                  is returned via Promise.reject
     */
    function _pairMdxDevice(pairRequestData, context) {
        var request = {
            'method': PAIR_CMD,
            'targetuuid': pairRequestData.targetUuid,
            'cticket': pairRequestData.cticket,
            'nonce': pairRequestData.nonce,
            'controlleruuid': pairRequestData.controllerUuid,
            'pairdatahmac': pairRequestData.pairDataHmac
        };

        function processGoodResult(result) {
            var controllerError,
                grantData = {};

                grantData = {
                    'nonce': result['nonce'],
                    'controlleruuid': pairRequestData.controllerUuid, // NRDJS client requires that we pass this back
                    'controlleruserid': result['controllerUserId'],
                    'controllersharedsecret': result['controllerSharedSecret'],
                    'targetuuid': pairRequestData.targetUuid, // NRDJS client requires that we pass this back
                    'targetuserid': result['targetUserId'],
                    'targetsharedsecret': result['targetSharedSecret']
                }

            return {
                success: true,
                grantData: grantData,
                grantDataHmac: result['grantDataHmac']
            };
        }

        return _doRequest(request, context, processGoodResult);
    }

    /**
     * Sends a ping request to the server and asynchronously returns the response
     * @param {{
     *     log: Object,
     *     accountKey: (String|undefined)
     * }} context
     * @param {Function} callback
     */
    function _ping(context, callback) {
        _doPing(context).then(function(result) {
            callback(result);
        }).catch(function(err) {
            callback(err);
        });
    }

    /**
     * @param {{
     *     log: Object,
     *     accountKey: (String|undefined)
     * }} context
     * @param {Function} callback
     */
    function _deviceNetflixId(context, callback) {
        // explicitly make sure we don't have account key
        var context2 = mixIn({}, context);
        context2.accountKey = undefined;
        return _netflixId(context2, callback);
    }

    /**
     * @param {{
     *     log: Object,
     *     accountKey: (String|undefined)
     * }} context
     */
    function _netflixId(context, callback) {
        _bindNetflixId(context).then(function(result) {
            callback(result);
        }).catch(function(err) {
            callback(err);
        });
    }

    /**
     * @param {{
     *     log: Object,
     *     accountKey: (String|undefined)
     * }} context
     */
    function _registerByNetflixId(context, netflixId, secureNetflixId, callback) {
        // registering in MSL/NCCP 3.0 is basically refreshing NetflixId using provided NetflixId
        _netflixId(mixIn({
            netflixId: netflixId,
            secureNetflixId: secureNetflixId
        }, context), callback);
    }

    /**
     * @param {{
     *     log: Object,
     *     accountKey: (String|undefined)
     * }} context
     */
    function _registerByEmailPassword(context, email, password, callback) {
        // registering in MSL/NCCP 3.0 is basically getting NetflixId using email/password user auth
        _netflixId(mixIn({
            email: email,
            password: password
        }, context), callback);
    }

    /**
     * @param {{
     *     playbackTokens,
     *     appId: string,
     *     sessionId: string,
     *     sessionParams: Object.<string, Object>,
     *     trackingId: string,
     *     xid: string,
     *     drmType: string,
     *     challengeBase64: string,
     *     psshDataBase64: string,
     *     playbackType: string,
     *     downloadableId: string,
     *     playbackContextId: string,
     *     clientTime: number,
     *     licenseType: string,
     *     drmContextId: string
     * }} licenseRequestData
     * @param {{
     *     log,
     *     accountKey
     * }} context
     */
    function _license(licenseRequestData, context, callback) {
        var requestData = {
            playbackContextId: licenseRequestData.playbackContextId,
            clientTime: licenseRequestData.clientTime,
            licenseType: licenseRequestData.licenseType,
            drmContextIds: [licenseRequestData.drmContextId],
            challengeBase64: licenseRequestData.challengeBase64,
            xid: licenseRequestData.xid,
            appId: licenseRequestData.appId,
            sessionId: licenseRequestData.sessionId,
            sessionParams: licenseRequestData.sessionParams,
            trackingId: licenseRequestData.trackingId
        };

        if (licenseRequestData.mdxEsn) {
            requestData.mdxEsn = licenseRequestData.mdxEsn;
        }
        _getLicense(requestData, context).then(function(result) {
            callback(result);
        }).catch(function(err) {
            callback(err);
        });
    }

    function _createPlaydataRequest(moviePlaybackData, context, callback) {
        if (DEBUG) log.debug('Creating play data request');
        var requestBody = _createStop(moviePlaybackData);
        return _buildPlayDataHttpRequest(requestBody, context, moviePlaybackData, 'playdata', callback);
    }

    function _playdata(moviePlaybackData, context, callback) {
        _stop(context, moviePlaybackData).then(function(result) {
            callback(result);
        }).catch(function(err) {
            callback(err);
        });
    }

    function _mediaSplice(data, context, callback) {
        _playbackLifecycle(data, PBLC_TYPE_SPLICE, context, callback);
    }

    /**
     * Sends a playback lifecycle request to the server
     * @param  {{
     *     playbackContextId: string,
     *     xid: string,
     *     appId: string,
     *     sessionId: string,
     *     sessionParams: Object.<string, Object>,
     *     trackingId: string
     * }}               data    the input data for the request
     * @param  {string} type    the type of playback lifecycle request
     * @param  {{log}}  context additional context data used for generating the request, currently only log is used.
     * @param  {Function}       callback called when the request has completed
     */
    function _heartbeat(data, type, context, callback) {
        // Decouple old nccp heartbeat types from new playback lifecycle types
        var pblcType = pblcMap[type];
        if (!pblcType) {
            log.error('heartbeat type ' + type + ' not recognized');
            return;
        }
        _playbackLifecycle(data, pblcType, context, callback);
    }

    function _playbackLifecycle(data, type, context, callback) {
        _sendPlaybackLifecycle(data, type, context).then(function(result) {
            callback(result);
        }).catch(function(err) {
            callback(err);
        });
    }

    /**
     * @param {Array.<{data: Array.<Object>, clientEpoch: number}>} logMessages
     * Outgoing logblob data should look like this:
     * {
     *   entries [
     *     logblob,
     *     logblob,
     *     ...
     *   ]
     * }
     * Each logblob is made of the data property from an input logMessage, plus
     * the client ESN and the client time in millis since epoch.
     */
    function _logblob(logMessages, context, callback) {
        debug$assert(logMessages);
        var logblobData = logMessages.reduce(function(requestData, logMessage) {
            var logData = logMessage.data;
            mixIn(logData, {
                'esn': device.esn,
                'clienttime': logMessage.clientEpoch * 1000 // bladerunner requires millis from epoch
            });
            requestData['entries'].push(logData);
            return requestData;
        }, {
            'entries': []
        });

        var json = '';
        try {
            json = JSON.stringify(logblobData);
        } catch (e) {
            var entries = logblobData.entries;
            var count = entries && entries.length;
            for (var i = 0; i < count; i++) {
                try {
                    JSON.stringify(entries[i]);
                } catch (ex) {
                    var entry = entries[i],
                        stringifyExceptionMessage;

                    enumerateOwnProperties(entry, function(k, v) {
                        try {
                            JSON.stringify(v);
                        } catch (exception) {
                            stringifyExceptionMessage = exception.message;
                            entry[k] = stringifyExceptionMessage;
                        }
                    });

                    entry['stringifyException'] = stringifyExceptionMessage;
                    entry['originalType'] = entry['type'];
                    entry['type'] = 'debug';
                    entry['sev'] = 'error';
                }
            }

            json = JSON.stringify(logblobData);
        }

        _sendLogblob(json, context).then(function(result) {
            callback(result);
        }).catch(function(err) {
            callback(err);
        });
    }

    /**
     * @param {{
     *    targetUuid,
     *    controllerUuid,
     *    cticket,
     *    nonce,
     *    pairDataHmac
     * }} mdxPairRequestData
     * Note that consumers of this API still expect the legacy NCCP response object.
     */
    function _mdxpair(mdxPairRequestData, context, callback) {
        var requestData = {
            targetUuid: mdxPairRequestData.targetUuid,
            cticket: mdxPairRequestData.cticket,
            nonce: mdxPairRequestData.nonce,
            controllerUuid: mdxPairRequestData.controllerUuid,
            pairDataHmac: mdxPairRequestData.pairDataHmac
        };

        _pairMdxDevice(requestData, context).then(function(result) {
            callback(result);
        }).catch(function(err) {
            callback(_addNCCPPairErrorPropertities(err));
        });
    }

    // This is a hack to extract the NCCP error codes that are expected by MDX from the API exceptions
    // Long term fix is to have MDX API expose these codes directly so we can plumb them through 
    function _addNCCPPairErrorPropertities(apiErrorResponse) {
        var nccpErrorResponse = apiErrorResponse,
            errorData,
            mdxException = '';

        if (apiErrorResponse.errorData) {
            try {
                errorData = JSON.parse(apiErrorResponse.errorData);
                if (errorData['error_message']) {
                    mdxException = errorData['error_message'].replace('com.netflix.streaming.nccp.handlers.mdx.MdxException: ', '');
                } else if (errorData['implementingClass']) {
                    mdxException = errorData['implementingClass'];
                }
                
            } catch (exception) {
                log.error('Failed to parse Pairing errorData', { errorData: errorData });
            }
        }

        mixIn(nccpErrorResponse, _mapMDXExceptionToNCCPError(mdxException));
        
        return nccpErrorResponse;
    }

    // Maps strings pulled from exceptions to NCCP error propertities
    function _mapMDXExceptionToNCCPError(mdxException) {
        switch (mdxException) {
            case 'MDX_ERROR_CONTROLLER_CTICKET_EXPIRED':
                return {
                    errorActionId: 5, // Authentication Renewal required.
                    errorNccpCode: 21, // CTicket Expired
                    errorReasonCode: undefined, // Optional, not sure if we need this
                    errorDisplayMessage: undefined, // Nothing to display since this should be retried
                    errorDisplayMessageBcp47: undefined // Nothing to display since this should be retried
                }

            case 'MDX_ERROR_CONTROLLER_REQUEST_HMAC_FAILURE':
                return {
                    errorActionId: 2, // Retry, service unavailable
                    errorNccpCode: 20, // HMAC Failure
                    errorReasonCode: undefined, // Optional, not sure if we need this
                    errorDisplayMessage: undefined, // Nothing to display since this should be retried
                    errorDisplayMessageBcp47: undefined // Nothing to display since this should be retried
                }

            case 'MDX_ERROR_INVALID_CONTROLLER_REQUEST':
                return {
                    errorActionId: 2, // Retry, service unavailable
                    errorNccpCode: 10, // Invalid controller request
                    errorReasonCode: undefined, // Optional, not sure if we need this
                    errorDisplayMessage: undefined, // Nothing to display since this should be retried
                    errorDisplayMessageBcp47: undefined // Nothing to display since this should be retried
                }

            // Signals that MdxPair command failed. TODO: standardize exception handling
            case "com.netflix.api.service.mdx.MdxPairDependencyCommand":
                return {
                    errorActionId: 2, // Retry, service unavailable
                    errorNccpCode: 13, // Server unavailable or timeout
                    errorReasonCode: undefined, // Optional, not sure if we need this
                    errorDisplayMessage: undefined, // Nothing to display since this should be retried
                    errorDisplayMessageBcp47: undefined // Nothing to display since this should be retried
                }
        
            default:
                // Not sure what to do? Better regpair just in case.
                return {
                    errorActionId: 4, // NCCP Registration required. Appears to be ignored by MDX
                    errorNccpCode: 30, // TARGET NOT IN PAIRING MODE, triggers regpair. 
                    errorReasonCode: undefined,
                    errorDisplayMessage: undefined,
                    errorDisplayMessageBcp47: undefined
                }
        }
    }

    /**
     * @param {{
     *    targetUuid,
     *    controllerUuid,
     *    cticket,
     *    nonce,
     *    controllerPin,
     *    pin,
     *    registerDataHmac,
     *    pairDataHmac
     * }} mdxRegisterRequestData
     */
    function _mdxregister(mdxRegisterRequestData, context, callback) {
        var contextWithMdxRegistrationData = {
            mdxControllerToken: mdxRegisterRequestData.cticket,
            mdxPin: mdxRegisterRequestData.pin,
            mdxNonce: mdxRegisterRequestData.nonce,
            mdxEncryptedPinB64: mdxRegisterRequestData.controllerPin,
            mdxSignature: base64$decode(mdxRegisterRequestData.registerDataHmac)
        };
        mixIn(contextWithMdxRegistrationData, context);

        _bindNetflixId(contextWithMdxRegistrationData).then(function(result) {
            if (result.success) {
                 _mdxpair(mdxRegisterRequestData, context, function (pairResult) {
                     if (pairResult.success) {
                         // combine the results, and callback
                         pairResult.netflixId = result.netflixId;
                         pairResult.secureNetflixId = result.secureNetflixId;
                         pairResult.netflixIdSetCookie = result.netflixIdSetCookie;
                         pairResult.secureNetflixIdSetCookie = result.secureNetflixIdSetCookie;
                         callback(pairResult);
                     } else {
                         // TODO: what if the netflixId succeeds, but this fails... do we still want to register?
                         callback(result);
                     }
                 });
             } else {
                 callback(result);
             }
        }).catch(function(err) {
            callback(err);
        });
    }

    function _createStop(moviePlaybackData) {
        // // Note: must use quoted properties, because moviePlaybackData is serialized and must survive minification

        // var requestBody = {};
        // var data = {
        //     'movieid': moviePlaybackData['movieId'],
        //     'sessionstart': moviePlaybackData['sessionStartEpoch']
        // };

        // if (isHeartbeat) {
        //     // heartbeat

        //     debug$assertValidString(heartbeatType);
        //     data['heartbeattype'] = heartbeatType;

        //     requestBody = {
        //         'heartbeatdata': data
        //     };

        // } else {
        //     // playdata
        //     data['sessionend'] = moviePlaybackData['sessionEpoch'];

        //     requestBody = {};

        //     // we should include the ids only if the playback was not licensed (no license token)
        //     // also include them to workaround older NCCP 3.0 bug (which should be fixed at about 7/12/2013)
        //     if ((!moviePlaybackData['isLicensed']) || edgeConfig.alwaysIncludeIdsInPlaydata) {
        //         // ids may not be present, so take only ones that exist
        //         mixIn(requestBody, {
        //             'appid': moviePlaybackData['appId'],
        //             'sessionid': moviePlaybackData['sessionId'],
        //             'trackid': moviePlaybackData['trackingId'],
        //             'xid': moviePlaybackData['xid']
        //         }, { onlyIfDefined: true });
        //     }

        //     requestBody['sessiondata'] = data;

        //     if (moviePlaybackData['securestop']) {
        //         requestBody['securestop'] = moviePlaybackData['securestop'];
        //     }

        // }

        // var playback = moviePlaybackData['playback'];
        // if (playback) {
        //     // moviePlaybackData might not have [playback]
        //     // this is the case when, for example, we get a license, but the decoder errors out... or user aborts the startup
        //     var playTimes = playback['playTimes'];
        //     debug$assert(
        //         playTimes &&
        //         isUInt(playTimes['total']) &&
        //         playTimes['audio'] &&
        //         playTimes['audio'].length &&
        //         playTimes['video'] &&
        //         playTimes['video'].length
        //     );

        //     data['firstpts'] = {
        //         'pts': NccpClient$formatSeconds(playback['startPosition']),
        //         'timestamp': playback['startEpoch']
        //     };
        //     data['lastpts'] = {
        //         'pts': NccpClient$formatSeconds(moviePlaybackData['position']),
        //         'timestamp': moviePlaybackData['sessionEpoch']
        //     };
        //     var playbacktime = data['playbacktime'] = {
        //         'total': NccpClient$formatSeconds(playTimes['total'])
        //     };
        //     _addStreamPlayTimes(playbacktime, 'videostreamplaytimes', playTimes['video']);
        //     _addStreamPlayTimes(playbacktime, 'audiostreamplaytimes', playTimes['audio']);
        //     _addStreamPlayTimes(playbacktime, 'timedtextstreamplaytimes', playTimes['timedtext']);
        // } else {
        //     if (moviePlaybackData['errorDisplayCode']) {
        //         // was here an error?
        //         data['error'] = {};
        //     } else {
        //         // no error, initialization was aborted
        //         // report this as 0-second playback
        //         data['lastpts'] = data['firstpts'] = {
        //             'pts': NccpClient$formatSeconds(moviePlaybackData['position']),
        //             'timestamp': moviePlaybackData['sessionEpoch']
        //         };
        //         data['playbacktime'] = {
        //             'total': '0'
        //         }
        //     }
        // }

        return null;
    }

    function _buildPlayDataHttpRequest(request, context, moviePlaybackData, method, callback) {
        if (callback) {
            callback({
                success: true,
                method: method,
                httpRequest: null
            });
        }

        // var localLog = context.log,
        //     sentClienttime = clock$getEpoch(),
        //     controllerUrl = _getControllerUrl();

        // _buildRequest(controllerUrl, 'playdata', request, moviePlaybackData['playbackTokens'], sentClienttime, context, function (result) {
        //     if (result.success) {
        //         buildMslRequest(result.mslRequest);
        //     } else {
        //         doCallback(result);
        //     }
        // });

        // function buildMslRequest(mslRequest) {
        //     debug$assert(mslRequest);
        //     msl.buildPlayDataRequest(mslRequest, function (result) {
        //         if (result.success) {
        //             buildHttpRequest(result.body);
        //         } else {
        //             doCallback(result);
        //         }
        //     });
        // }

        // function buildHttpRequest(body) {
        //     debug$assert(body);

        //     var timeout = deviceParameters.mintimeout * MILLISECONDS_PER_SECOND,
        //         protocolVersion = edgeConfig.getProtocolVersion(method);

        //     var httpRequest = {
        //         responseType: http$RESPONSETYPE_TEXT,
        //         url: controllerUrl + '/' + protocolVersion + '/' + method,
        //         postBody: body,
        //         withCredentials: true,
        //         connectTimeoutMilliseconds: timeout,
        //         noProgressTimeoutMilliseconds: timeout,
        //         diagCaption: 'nccp-' + method
        //     };

        //     DEBUG && localLog.debug('Prepared NCCP content for playdata, http request headers and body', { 'Method': method }, stringifyJsonPretty(httpRequest.headers) + '\n' + httpRequest.postBody);

        //     doCallback({
        //         success: true,
        //         httpRequest: httpRequest
        //     });
        // }

        // function doCallback(result) {
        //     if (callback) {
        //         result.method = method;
        //         callback(result);
        //     }
        // }
    }

    function _getServerEpoch() {
        return _convertToServerEpoch(clock$getPreciseEpoch());
    }

    function _convertToServerEpoch(clientEpoch) {
        if (DEBUG) {
            log.debug('Converting client time to server time', {
                'offset': serverTimeOffset,
                'clientTime': clientEpoch,
                'serverTime': clientEpoch + serverTimeOffset,
                'clientTimeReadable': (new Date(clientEpoch)).toUTCString(),
                'serverTimeReadable': (new Date(clientEpoch + serverTimeOffset)).toUTCString()
            });
        }
        return clientEpoch + serverTimeOffset;
    }


    /**
     * Send a Bladerunner request to the server and return the response
     * @param  {Object.<string, ?>} requestParameters the parameters to send with the request
     * @param  {Object}             context           additional context, contains the log object for logging
     * @param  {boolean=}           includeLogs       true if the response should contain debug info in the __logs field
     * @param  {boolean=}           debug             true if the response should contain the debug information,
     *                                                response will not be parsable and should only be used to
     *                                                get the endpoint working correctly with the client
     * @return {Object} the response JSON parsed into an object
     */
    function _send(requestParameters, context, includeLogs, debug) {
        var sendLog = context.log,
            request,
            MAX_RETRIES = 3,
            MIN_TIMEOUT = 59,
            cmdData = {
                'method': requestParameters.method,
                'starttime': clock$getTime()
            };

        cmdHistory.push(cmdData);

        function cmdSucceeded(response) {
            var clientTime = clock$getPreciseEpoch();
            var serverTime = response['serverTime'] ? response['serverTime'] : clientTime;
            serverTimeOffset = serverTime - clientTime;
            cmdData['elapsedtime'] = clock$getTime() - cmdData['starttime'];
            cmdData['success'] = true;
            if (DEBUG || DEV) {
                sendLog.debug('BladeRunner command history', stringifyJsonPretty(cmdHistory));
            }
        }

        function cmdFailed() {
            cmdData['elapsedtime'] = clock$getTime() - cmdData['starttime'];
            cmdData['success'] = false;
            sendLog.error('BladeRunner command history', stringifyJsonPretty(cmdHistory));
            return JSON.stringify(cmdHistory);
        }

        function retryAllowed(method, type) {
            // Playback lifecycle messages are not critical and need not be retried,
            // with the exception of stop (playdata)
            if (method == PBLIFECYCLE_CMD && type && type != PBLC_TYPE_STOP) {
                return false;
                // No retries on logblobs either
            } else if (method == LOGBLOB_CMD) {
                return false;
            } else {
                return true;
            }
        }

        function buildRequest() {

            var query = '';
            if (includeLogs) {
                query += (query.length > 0 ? '&' : '') + 'logs=true';
            }
            if (debug) {
                query += (query.length > 0 ? '&' : '') + 'debug=true';
            }

            requestParameters['languages'] = edgeConfig.preferredlanguages;
            requestParameters['clientVersion'] = VERSION;
            requestParameters['uiVersion'] = edgeConfig.uiVersion;

            var payload = [{ /* global header section */ }, {
                'headers': {},
                'path': edgeConfig.edgePath,
                'payload': {
                    'data': JSON.stringify(requestParameters)
                },
                'query': query
            }];

            if (DEBUG || DEV) {
                sendLog.debug('Request payload', {
                    'Method': requestParameters.method
                }, stringifyJsonPretty(payload));
                sendLog.debug('Request parameters', {
                    'Method': requestParameters.method
                }, stringifyJsonPretty(requestParameters));
            }

            var timeout = MIN_TIMEOUT * MILLISECONDS_PER_SECOND;
            return {
                mslContext: context,
                method: requestParameters.method,
                url: edgeConfig.mslEndpoint + ESN_PREFIX + '/cadmium/' + requestParameters.method,
                body: JSON.stringify(payload),
                timeout: timeout,
                userId: context.accountKey,
                replayable: !_nonReplayableMethods[requestParameters.method],
                nonReplayable: !!_nonReplayableMethods[requestParameters.method],
                encrypted: true,
                retryAllowed: retryAllowed(requestParameters.method, requestParameters.type)
            };
        }

        function wait(ms) {
            return new Promise(function(resolve, reject) {
                setTimeout(function() {
                    resolve();
                }, ms);
            });
        }

        function calculateRetryWait(attempt, maxAttempts) {
            var maxWait = Math$pow(2, Math$min(attempt - 1, maxAttempts)) * MILLISECONDS_PER_SECOND;
            return randomInt(MILLISECONDS_PER_SECOND, maxWait);
        }

        function shouldRetry(err, attempt, maxAttempts) {
            if (attempt > maxAttempts) {
                sendLog.error('Method failed, retry limit exceeded, giving up', {
                        'Method': requestParameters.method,
                        'Attempt': attempt,
                        'MaxRetries': maxAttempts
                    },
                    ErrorSubCodes$errorResultToLogFields(err));
                return false;
            }
            return true; // FIXME: Are there any MSL errors that should NOT trigger a retry?
        }

        function retry(request, allowRetry) {
            return new Promise(function(resolve, reject) {

                function retryInner(request, attempt, maxAttempts) {
                    // note: success passes through
                    return msl.send(request).then(function(result) {
                        resolve(result);
                    }).catch(function(err) {
                        var waitTime;
                        if (shouldRetry(err, attempt, maxAttempts)) {
                            waitTime = calculateRetryWait(attempt, maxAttempts);
                            sendLog.warn('Method failed, retrying', {
                                    'Method': requestParameters.method,
                                    'Attempt': attempt,
                                    'WaitTime': waitTime,
                                    'MaxRetries': maxAttempts
                                },
                                ErrorSubCodes$errorResultToLogFields(err));
                            return wait(waitTime).then(function(result) {
                                return retryInner(request, attempt + 1, maxAttempts); // recurse
                            });
                        }
                        reject(err);
                    });
                }

                var maxRetries = allowRetry ? MAX_RETRIES : 1;
                return retryInner(request, 1, maxRetries);
            });
        }

        function sendRequest(mslRequest) {
            return new Promise(function(resolve, reject) {

                function parseMslResponse(response) {
                    /**
                     * Build the appropriate error object to return.
                     * @param  {number}  subCode Error sub code
                     * @param  {number=} extCode Error extended code
                     * @return {Object}          An object with the error information
                     */
                    function buildError(subCode, extCode) {
                        return {
                            success: false,
                            result: {
                                'errorSubCode': subCode,
                                'errorExternalCode': extCode
                            }
                        };
                    }

                    var envelope = JSON.parse(response),
                        payloadb64,
                        payload,
                        data;

                    if (DEBUG || DEV) {
                        sendLog.debug('MSL Response', {
                            'Method': requestParameters.method
                        }, stringifyJsonPretty(envelope));
                    }

                    if (envelope.length != 2) {
                        sendLog.trace('The MSL envelope did not have enough array items.');
                        return buildError(ErrorSubCodes.MSL_ERROR_ENVELOPE);
                    }

                    if (!envelope[1]['payload']) {
                        sendLog.trace('The MSL envelope did not have a payload.');
                        return buildError(ErrorSubCodes.MSL_ERROR_ENVELOPE);
                    }

                    if (!envelope[1]['status']) {
                        sendLog.trace('The MSL envelope did not have a status.');
                        return buildError(ErrorSubCodes.MSL_ERROR_ENVELOPE);
                    }

                    // On success the status field will be either an HTTP success
                    // or else 'ok'.
                    var status = envelope[1]['status'];
                    var statusInt = parseInt(status, 10);
                    if ((isNaN(statusInt) && status.toLowerCase() != 'ok') ||
                        !(statusInt >= 200 && statusInt < 300)) {
                        payloadb64 = envelope[1]['payload'].data;
                        payload = base64$decodeAsText(payloadb64);
                        sendLog.error('The MSL status indicated an error.', {
                            'status': statusInt,
                            'payload': payload
                        });

                        // If the status value is a 401 then this is the same issue as 
                        // a NCCP 4027 error - Customer must be authenticated. Return 
                        // the same error code so existing error handling continues to
                        // work.
                        if (statusInt === 401) {
                            return buildError(ErrorSubCodes.NCCP_PROTOCOL, 4027);
                        }
                        return buildError(ErrorSubCodes.MSL_ERROR, status);
                    }

                    payloadb64 = envelope[1]['payload'].data;
                    payload = base64$decodeAsText(payloadb64);
                    if (!payload) {
                        sendLog.trace('The MSL payload is missing.');
                        return buildError(ErrorSubCodes.MSL_ERROR_MISSING_PAYLOAD);
                    }

                    try {
                        return JSON.parse(payload);
                    } catch (e) {
                        sendLog.error('EDGE response JSON parse error: ', e, payload);
                        return buildError(ErrorSubCodes.MSL_ERROR_MISSING_PAYLOAD);
                    }
                }

                retry(mslRequest, mslRequest.retryAllowed).then(function(result) {
                    if (!result['body']) {
                        reject({
                            errorSubCode: ErrorSubCodes.MSL_ERROR_ENVELOPE,
                            errorDetails: cmdFailed()
                        });
                        return;
                    }
                    var response = parseMslResponse(result['body']);
                    sendLog.trace('Received EDGE response', {
                        'Method': requestParameters.method
                    });
                    if (DEBUG || DEV) {
                        sendLog.debug('EDGE content, http response headers and body', {
                            'Method': requestParameters.method
                        }, stringifyJsonPretty(response));
                    }
                    if (response['success']) {
                        cmdSucceeded(response);
                        resolve(response['result']);
                    } else {
                        // add __logs to result
                        var err = response['result'];
                        if (response['__logs']) {
                            err.__logs = response['__logs'];
                        }

                        var errorData;
                        try {
                            errorData = JSON.stringify(err['data']);
                        } catch (e) {

                        }

                        // Make sure we call this so the failure is logged
                        // we may not actually report it, if errorDetails
                        // is populated then this turns into an error that
                        // stops playback so we only populate if errorDetails
                        // is already populated
                        var history = cmdFailed();

                        // The only fields we use under bladerunner are
                        // errorSubCode, errorExternalCode, errorDetails, 
                        // errorEdgeCode, errorDisplayMessage and errorData.
                        // The other codes are legacy fields left in for NRDP.
                        // Only errorActionId actually has a value. These
                        // fields should be removed at some point.
                        reject({
                            errorSubCode: err['errorSubCode'],
                            errorExternalCode: err['errorExternalCode'],
                            errorEdgeCode: err['errorEdgeCode'],
                            errorDetails: err['errorDetails'] ? [err['errorDetails'], ' ', history].join('') : undefined,
                            errorDisplayMessage: err['errorDisplayMessage'],
                            errorData: errorData
                        });
                    }
                }).catch(function(err) {
                    // Make sure we call this so the failure is logged
                    // we may not actually report it, if errorDetails
                    // is populated then this turns into an error that
                    // stops playback so we only populate if errorDetails
                    // is already populated
                    var history = cmdFailed();
                    if (err.errorDetails) {
                        err.errorDetails = [err.errorDetails, ' ', history].join('');
                    }
                    reject(err);
                });
            });
        }

        sendLog.trace('Sending EDGE request', {
            'Method': requestParameters.method
        });

        return new Promise(function(resolve, reject) {
            var request = buildRequest();
            sendRequest(request).then(function(result) {
                resolve(result);
            }).catch(function(err) {
                var result = {
                    success: false
                };
                mixIn(result, err, {
                    onlyIfDefined: true
                });
                if (result['__logs']) {
                    result['__logs'] = err['__logs'];
                }
                reject(result);
            });
        });
    }
}



// -- device/BrowserAccount.js
/**
 * @constructor
 */
function BrowserAccount(accountKey) {
    var _log = new log.CategoryLog('BrowserAccount'),
        _account = {
            accountKey: accountKey,
            exists: true,
            registered: false,
            lastAccessTime: clock$getTime(),
            load: function(callback) {
                (callback || NOOP)(SUCCESS);
            },
            save: function() {
                _account.exists = true;
            },
            remove: function(callback) {
                _account.exists = false;
                (callback || NOOP)(SUCCESS);
            },
            UILanguages: config.edge.preferredlanguages,
            isBrowserAccount: true
        };

    return _account;
}


// -- device/account.js
loadAsync$register(ErrorCodes.INIT_COMPONENT_ACCOUNT, function asyncLoadAccount(callback) {

    debug$assert(config);

    var environmentIsTest = config.environmentIsTest;
    var accountKey;
    var account;

    if (NRDP_USES_BROWSER_ACCOUNT) {
        accountKey = environmentIsTest ? 'browsertest' : 'browser';
        account = new BrowserAccount(accountKey);
        wrapup();
    } else {
        accountKey = environmentIsTest ? 'defaultacctest' : 'defaultacc';
        account$load(accountKey, function (result) {
            if (result.success) {
                account = result.account;
                wrapup();
            } else {
                callback(result);
            }
        });
    }

    function wrapup() {
        debug$assert(account);
        account$_loaded[accountKey] = account;
        account$_latest = account;
        callback(SUCCESS);
    }

});

function account$get(accountKey) {
    var account = account$_loaded[accountKey];
    if (account) {
        account$_latest = account;
        return account;
    }
    throw new Error('invalid accountKey');
}

function account$load(accountKey, callback) {
    // make sure load function is executed only once
    var loadFunction = account$_loadFunctions[accountKey];
    if (!loadFunction) {
        account$_loadFunctions[accountKey] = loadFunction =  Function$makeMulticast(function (callback) {
            // There might be a race condition, where if 
            var account = account$_loaded[accountKey];
            if (account) {
                // handle accounts being preloaded
                // this happens for browser account
                callback({
                    success: true,
                    account: account
                });
            } else {
                account = new Account(accountKey);
                account$_loaded[accountKey] = account;
                account.load(function (result) {
                    debug$assert(result.success);
                    if (result.success) {
                        callback({
                            success: true,
                            account: account
                        });
                    } else {
                        callback(result);
                    }
                });
            }
        });
    }
    loadFunction(callback);
};

function account$getLatest() {
    return account$_latest;
};

/**
* @constructor
*/
function Account(accountKey) {
    this.accountKey = accountKey;
};

Account.prototype = {
    exists: false,
    registered: false,
    lastAccessTime: 0,
    UILanguages: DEFAULT_LANGUAGES,

    getStorageKey: function () {
        return 'acc-' + this.accountKey;
    },

    load: function (callback) {
        var self = this,
            accountKey = self.accountKey;

        storage.load(self.getStorageKey(), function (result) {
            var json;

            if (result.success) {
                json = result.data;
            }

            if (json) {
                // TODO: validate content of JSON
                self.exists = true,
                self.lastAccessTime = json['lastAccessTime'] || 0;
                self.UILanguages = json['UILanguages'] || DEFAULT_LANGUAGES;
                self.cTicket = json['cTicket'];
                self.cTicketExpiration = parseInt10(json['cTicketExpiration']) || 0;
                self.keyPairHash = json['keyPairHash'];
                self.nrdpStorage = json['nrdpStorage'];

                if (msl) {
                    self.registered = !!msl.mslClient['hasUserIdToken'](accountKey);
                    callback(SUCCESS);
                } else {
                    callback(SUCCESS);
                }
            } else {
                // otherwise, just callback
                callback(SUCCESS);
            }
        });
    },

    save: function () {
        var self = this;
        self.exists = true;
        var json = {
            'lastAccessTime': self.lastAccessTime,
            'UILanguages': self.UILanguages,
            'cTicket': self.cTicket,
            'cTicketExpiration': self.cTicketExpiration,
            'keyPairHash': self.keyPairHash,
            'nrdpStorage': self.nrdpStorage
        };
        storage.save(self.getStorageKey(), json);
    },

    remove: function (callback) {
        var self = this;
        var accountKey = self.accountKey;
        storage.remove(self.getStorageKey(), function (result) {
            var properties = [];
            enumerateOwnProperties(self, function (k) {
                properties.push(k);
            });
            var i = properties.length;
            while (i--) {
                delete self[properties[i]];
            }
            self.accountKey = accountKey;
            if (msl) {
                msl.mslClient['removeUserIdToken'](accountKey);
                callback(SUCCESS);
            } else {
                callback(SUCCESS);
            }
        });
    },
};

var account$_loaded = {},
    account$_loadFunctions = {},
    account$_latest;


// -- player-nccp/nccpDeviceParameters.js
var nccpDeviceParameters; // loaded async

var NCCP_DEVICE_PARAMETERS_PERSIST_KEY = 'deviceparameters';

// register for async loading
loadAsync$register(ErrorCodes.INIT_COMPONENT_NCCPDEVICEPARAMETERS, function asyncLoadNccpDeviceParameters(callback) {

    // NOTE: For Bladerunner NCCP device parameters are no longer sent from the server.
    // We are just going to hard-code them for now, so no need to bother with persistent
    // storage either.

    nccpDeviceParameters = {
        loginterval: 60,
        maxlogsize: 2000000,
        loglevel: 'error',

        sendheartbeats: true,
        heartbeatinterval: 60,

        notifyUpdated: undefined
    };

    callback(SUCCESS);

    // The Old Way
    /*
    debug$assert(storage);

    storage.load(NCCP_DEVICE_PARAMETERS_PERSIST_KEY, function (result) {
        var json = {};

        function _readInt(key, defaultValue, min, max) {
            var v = json[key];
            return isInt(v, min, max) ? v : defaultValue;
        };

        if (result.success) {
            json = result.data;
        }

        nccpDeviceParameters = {
            serverTimeOffset: _readInt('servertimeoffset', 0, undefined, undefined),

            retrycontrol: _readInt('retrycontrol', 3, 0, 1000),
            mintimeout: _readInt('mintimeout', 59, 0, 1000),

            loginterval: _readInt('loginterval', 60, 0, 1000),
            maxlogsize: _readInt('maxlogsize', 2000000, 100, 1000000000),
            loglevel: json['loglevel'] || 'error',
            sendheartbeats: !!json['sendheartbeats'],
            heartbeatinterval: _readInt('heartbeatinterval', 60, 1, 1000),

            notifyUpdated: function () {
                nccp$eventSource.fire(nccp$deviceParametersUpdated);

                debug$assert(storage);

                storage.save(NCCP_DEVICE_PARAMETERS_PERSIST_KEY, {
                    'servertimeoffset': nccpDeviceParameters.serverTimeOffset,
                    'retrycontrol': nccpDeviceParameters.retrycontrol,
                    'mintimeout': nccpDeviceParameters.mintimeout,
                    'loginterval': nccpDeviceParameters.loginterval,
                    'maxlogsize': nccpDeviceParameters.maxlogsize,
                    'loglevel': nccpDeviceParameters.loglevel,
                    'sendheartbeats': nccpDeviceParameters.sendheartbeats,
                    'heartbeatinterval': nccpDeviceParameters.heartbeatinterval
                });
            }
        };

        callback(SUCCESS);

    })
    */
   
});


// -- player-nccp/nccp.js
var nccp; // loaded async

// register for async loading
loadAsync$register(ErrorCodes.INIT_COMPONENT_NCCP, function asyncLoadNccp(callback) {
    debug$assert(config);
    debug$assert(device);
    debug$assert(nccpDeviceParameters);
    debug$assert(!nccp);

    var _log = new log.CategoryLog('Nccp'),
        edgeConfig = config.edge;

    debug$assert(edgeConfig);

    _log.info('Creating EDGE instance', {
        'Endpoint': edgeConfig.mslEndpoint,
        'Path': edgeConfig.edgePath
    });

    debug$assert(msl);

    nccp = new NccpBrClient(edgeConfig, nccpDeviceParameters, msl, device, _log);
    callback(SUCCESS);
});

var nccp$eventSource = new EventSource();

var nccp$HEARTBEAT_TYPE_RESUME = 'resume',
    nccp$HEARTBEAT_TYPE_SUSPEND = 'suspend',
    nccp$HEARTBEAT_TYPE_INTERVAL = 'interval';

var nccp$deviceParametersUpdated = 1,
    nccp$flushingLogs = 2,
    nccp$logMessageQueued = 3,
    nccp$aboutToSend = 4;


// -- player-nccp/nccpLogBatcher.js
var nccpLogBatcher; // loaded async

loadAsync$register(ErrorCodes.INIT_COMPONENT_NCCPLOGBATCHER, function asyncLoadNccpLogBatcher(callback) {
    var _log = new log.CategoryLog('NccpLogBatcher'),
        _logMessages = [],
        _sendTimeoutId,
        _logMessageExtraSize,
        _setTimerTimeout,
        _logInterval;

    // --------------------------------------------------------------------------------
    // -- initialization & api

    debug$assert(config);
    debug$assert(device);
    debug$assert(nccp);

    // logs generated here are not meant to be sent to NCCP, otherwise we will get in infinite loop
    _log.doNotSendToNccp = true;

    // entries look like this:
    // 1345145933 [csvData],esn=NFCDCH-01-YCUAIIUVVZO42WLYVSYT,snum=00,lnum=000\n
    // include the extra bytes for size estimation
    _logMessageExtraSize = 33 + device.esn.length;

    // listend to params updated, to start the timer then
    nccp$eventSource.addListener(nccp$deviceParametersUpdated, _nccpDeviceParametersUpdated);
    _nccpDeviceParametersUpdated();

    // wait for load to complete before sending the startup message, so we have can also time how long load took.
    // since we know loadAsync already running, just call "load" it again, this won't run the load again
    loadAsync(function () {
        dispatch(_startup);
    });

    nccpLogBatcher = {
        queueLogMessage: _queueLogMessage,
        flush: _flush
    };

    // CAD-3168 Earliest place that we can start queing log messages
    // Specifically this tells nccpLogAdapter to start sending logs to 
    // queueLogMessage, and not just keep them in a private array 
    nccp$eventSource.fire(nccp$deviceParametersUpdated);

    callback(SUCCESS);

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _startup() {
        var data = {
            // platform specific messages
            'browserua': userAgent,
            'browserhref': location['href'],
            'initstart': loadAsync$startTime,
            'initdelay': loadAsync$endTime - loadAsync$startTime
        };
        var dm = document['documentMode'];
        if (dm) {
            data['browserdm'] = '' + dm;
        }
        if (typeof nrdp !== 'undefined' && nrdp['device']) {
			data['firmware_version'] = nrdp['device']['firmwareVersion'];
		}

        NccpLogging$_addScreenSizes(data);

        var timing = performance && performance['timing'];
        if (timing) {
            config.logPerformanceTiming.map(function (k) {
                var t = timing[k];
                if (t) {
                    data['pt_' + k] = t - clock$genesis();
                }
            });
        }

        // if loadAsync is caused by playback, we should capture the playback data (xid, etc...) via Playback$mostRecentPlaybackLog
        var logMessage = new NccpLogMessage(Playback$firstPlaybackLog && Playback$firstPlaybackLog.playback, 'startup', 'info', data);
        _queueLogMessage(logMessage);
    }

    function _queueLogMessage(logMessage) {
        // don't log stuff if logMessage is a debug log message...
        DEBUG && (logMessage.type != 'debug') && _log.debug('Log message queued', { 'Type': logMessage.type }, JSON.stringify(logMessage.data, undefined, '  '));

        // Note: not delaying the timer when a new message arrives is intentional (this is a deviation from original spec)
        // Reason is that if there is a message every 30 sec (say quality message), it will delay timeout indefinitly and increase
        // probability of never sending a logblob by a lot
 
        _logMessages.push(logMessage);

        dispatch(function (){
            _fireQueuedAndSendIfFull(logMessage);
        });
    }

    function _fireQueuedAndSendIfFull(logMessage) {
        nccp$eventSource.fire(nccp$logMessageQueued, {
            logMessage: logMessage
        });

        if (_estimateSize(_logMessages) > nccpDeviceParameters.maxlogsize) {
            _sendLogMessages('size');
        } else {
            _ensureTimer();
        }
    }
    /**
    * @param {boolean=} sendEvenIfEmpty
    * @param {function(Object)=} callback
    */
    function _sendLogMessages(cause, sendEvenIfEmpty, callback) {
        callback = callback || NOOP;
        // TODO: should we include the last message, the one that put us over limit?
        // TODO: should we wait for callback and handle failure?
        // TODO: is it ok to send multiple requests at once?
        DEBUG && _log.debug('Sending log blob', { 'Cause': cause, 'Size': _estimateSize(_logMessages), 'MaxLogSize': nccpDeviceParameters.maxlogsize, 'MessageCount': _logMessages.length });
        if (_logMessages.length || sendEvenIfEmpty) {
            _stopTimer();
            nccp$eventSource.fire(nccp$aboutToSend);
            var batch = _logMessages;
            _logMessages = [];
            nccp.logblob(batch, {
                http: http,
                log: new log.CategoryLog('Nccp'),
                accountKey: account$getLatest().accountKey
            }, callback);
        } else {
            callback(SUCCESS);
        }
        _ensureTimer();
    }

    function _nccpDeviceParametersUpdated() {
        var newLogInterval = nccpDeviceParameters.loginterval;
        if (_logInterval != newLogInterval) {
            _logInterval = newLogInterval;
            _stopTimer();
            _ensureTimer();
        }
    }

    function _estimateSize(logMessages) {
        var i = logMessages.length;
        var logsize = i * _logMessageExtraSize;
        while (i--) {
            logsize += logMessages[i].getCsvData().length;
        }
        return logsize;
    }

    function _stopTimer() {
        if (_sendTimeoutId) {
            DEBUG && _log.debug('Stopping log timer');
            clearTimeout(_sendTimeoutId);
            _sendTimeoutId = null;
        }
    }

    function _ensureTimer() {
        if (!_sendTimeoutId) {
            DEBUG && _log.debug('Starting log timer', { 'Interval': _logInterval });
            _sendTimeoutId = setTimeout(_onTimeout, _logInterval * MILLISECONDS_PER_SECOND);
        }
    }

    function _onTimeout() {
        _stopTimer();
        _sendLogMessages('timer');
    }

    /**
    * @param {boolean} sendEvenIfEmpty 
    * @param {function()=} callback
    */

    function _flush(sendEvenIfEmpty, callback) {
        _log.trace('Flushing');

        // stop the timer
        _stopTimer();

        nccp$eventSource.fire(nccp$flushingLogs);

        // dispatch so we get endplay and any closing related debug log entries
        dispatch(function () {
            // send the batch
            _sendLogMessages('flush', sendEvenIfEmpty, callback);
        });
    }
});



// -- player-nccp/nccpLogAdapter.js
(function () {
    var maxLevel;

    var nccpLogLevel2logLevel = {
        'fatal': LogLevel['FATAL'],
        'error': LogLevel['ERROR'],
        'warn': LogLevel['WARN'],
        'info': LogLevel['INFO'],
        'debug': LogLevel['DEBUG']
    };

    var logLevel2nccpLogLevel = {};
    logLevel2nccpLogLevel[LogLevel['FATAL']] = 'fatal';
    logLevel2nccpLogLevel[LogLevel['ERROR']] = 'error';
    logLevel2nccpLogLevel[LogLevel['WARN']] = 'warn';
    logLevel2nccpLogLevel[LogLevel['INFO']] = 'info';
    logLevel2nccpLogLevel[LogLevel['TRACE']] = 'debug';
    logLevel2nccpLogLevel[LogLevel['DEBUG']] = 'debug';

    // before everything is loaded, record all entries
    var recordedEntries = [];
    function recordAll(entry) {
        recordedEntries.push(entry);
    };
    log['addSink'](recordAll);


    // wait for NCCP to update the deviceParameters, so we pick up the log level
    nccp$eventSource.addListener(nccp$deviceParametersUpdated, function updateMaxLevel(){
        maxLevel = config.edge.forceDebugLogLevel ? LogLevel[config.edge.forceDebugLogLevel] : nccpLogLevel2logLevel[nccpDeviceParameters.loglevel];
        debug$assertUInt(maxLevel);
    });

    nccp$eventSource.addListener(nccp$deviceParametersUpdated, nccpIsReady);
    function nccpIsReady() {
        nccp$eventSource.removeListener(nccp$deviceParametersUpdated, nccpIsReady);
        nccp$eventSource.removeListener(nccp$flushingLogs, onFlushingLogs);

        log['removeSink'](recordAll);
        log['addSink'](queueDebugLogMessage);
        sendRecordedEntries();
    };

    nccp$eventSource.addListener(nccp$flushingLogs, onFlushingLogs);
    function onFlushingLogs() {
        // if logs are flushed before nccpIsReady, still send all the error messages... assuming default maxLevel
        // this happens when we make no NCCP requests... and logblob is the first
        maxLevel = config.edge.forceDebugLogLevel ? LogLevel[config.edge.forceDebugLogLevel] : nccpLogLevel2logLevel[nccpDeviceParameters.loglevel];
        sendRecordedEntries();
    };

    function sendRecordedEntries() {
        var entries = recordedEntries;
        recordedEntries = [];
        var length = entries.length;
        for (var i = 0; i < length; i++) {
            queueDebugLogMessage(entries[i]);
        }
    };

    function queueDebugLogMessage(entry) {
        if (!entry.doNotSendToNccp && entry['level'] <= maxLevel) {
            var data = {
                'debugMessage': entry['message'],
                'debugCategory': entry['category']
            };
            mixIn(data, entry['fields'], { prefix: 'debug' })
            // attribute the log message to the playback that generated the message
            var logMessage = new NccpLogMessage(entry.playback, 'debug', logLevel2nccpLogLevel[entry['level']], data);
            nccpLogBatcher.queueLogMessage(logMessage);
        }
    };
})();



// -- player-nccp/constructDownloadReport.js
function constructDownloadReport(downloadsToLog, timeOffset) {
    var urlGroups = {};
    downloadsToLog.forEach(function (download) {
        var url = download.url;
        if (!urlGroups[url]) {
            urlGroups[url] = [];
        }

        urlGroups[url].push(download);
    });

    var urlsArray = [];
    enumerateOwnProperties(urlGroups, function(key, value) {
        urlsArray.push(constructDownloadReport$getUrlRecord(value, timeOffset));
    });

    return {
        'urls': urlsArray
    };
}

function constructDownloadReport$getUrlRecord(urlDownloads, timeOffset) {
    var firstDownload = urlDownloads[0];

    var urlRecordObject = {
        'url': firstDownload.url,
        'bitrate': firstDownload.bitrate,
        'cdnid': firstDownload.cdn && firstDownload.cdn.id,
        'dltype': firstDownload.dltype,
        'id': firstDownload.downloadableId
    };

    var downloadGroups = {};
    urlDownloads.forEach(function (download) {
        var isFailure = constructDownloadReport$isFailure(download);
        var groupKey = isFailure ? 'fail' : 'success';
        if (!downloadGroups[groupKey]) {
            downloadGroups[groupKey] = [];
        }

        downloadGroups[groupKey].push(download);
    });

    enumerateOwnProperties(downloadGroups, function(key, value) {
        if (key === 'fail') {
            urlRecordObject['failures'] = constructDownloadReport$getFailures(value, timeOffset);
        } else if (key === 'success') {
            urlRecordObject['downloads'] = constructDownloadReport$getDownloads(value, timeOffset);
        }
    });

    return urlRecordObject;
}

function constructDownloadReport$getDownloads(downloads, timeOffset) {
    var clientPortDownloadGroups = {};
    downloads.forEach(function (download) {
        var clientPort = download.clientPort;
        if (!clientPortDownloadGroups[clientPort]) {
            clientPortDownloadGroups[clientPort] = [];
        }

        clientPortDownloadGroups[clientPort].push(download);
    });

    var downloadsArray = [];
    enumerateOwnProperties(clientPortDownloadGroups, function (clientPort, clientPortDownloads) {
        var downloadSegment = [];
        clientPortDownloads.forEach(function (download) {
            downloadSegment.push(download);

            if (constructDownloadReport$isAbortOrStall(download)) {
                downloadsArray.push(constructDownloadReport$getDownload(downloadSegment, timeOffset));
                downloadSegment = [];
            }
        });

        if (downloadSegment.length > 0) {
            downloadsArray.push(constructDownloadReport$getDownload(downloadSegment, timeOffset));
        }
    });

    return downloadsArray;
}

function constructDownloadReport$getDownload(downloads, timeOffset) {
    function compareDownloadResponseStartTime(a, b) {
        if (a.measurements.responseStartTime < b.measurements.responseStartTime) {
            return -1;
        } else if (a.measurements.responseStartTime > b.measurements.responseStartTime) {
            return 1;
        } else {
            return 0;
        }
    }

    var sortedDownloads = downloads.sort(compareDownloadResponseStartTime),
        firstDownloadMeasurements = sortedDownloads[0].measurements,
        firstRequestTime = firstDownloadMeasurements.requestTime,
        firstResponseStartTime = firstDownloadMeasurements.responseStartTime,
        lastResponseEndTime = firstDownloadMeasurements.responseEndTime;

    for (var i = 1; i < downloads.length; i++) {
        var measurements = downloads[i].measurements;

        if (measurements.requestTime < firstRequestTime) {
            firstRequestTime = measurements.requestTime;
        }

        if (measurements.responseStartTime < firstResponseStartTime) {
            firstResponseStartTime = measurements.responseStartTime;
        }

        if (measurements.responseEndTime > lastResponseEndTime) {
            lastResponseEndTime = measurements.responseEndTime;
        }
    }
 
    var rangeOffset = constructDownloadReport$getRangeOffset(sortedDownloads),
        lastDownload = sortedDownloads[sortedDownloads.length - 1];

    var downloadData = {
        'time':      firstRequestTime - timeOffset,
        'tresp':     firstResponseStartTime - firstRequestTime,
        'first':     rangeOffset,
        'ranges':    constructDownloadReport$getRanges(sortedDownloads, rangeOffset),
        'dur':       lastResponseEndTime - firstResponseStartTime,
        'trace':     constructDownloadReport$getTrace(downloads),
        'status':    constructDownloadReport$getStatus(lastDownload)
    };

    if(config.downloadReportTcpInfo.length){
        downloadData['servertcp'] = constructDownloadReport$getServerTcp(downloads);
    }

    return downloadData;
}

function constructDownloadReport$getServerTcp(downloads) {
    var fields = config.downloadReportTcpInfo;
    
    return downloads.reduce(function(acc, curr) {
        var metrics = [];
        if (curr.tcpInfo) {
            var allMetricsMap = {};
            curr.tcpInfo.split(';').forEach(function(m) {
                var tokens = m.split('=');
                if (tokens.length == 2) {
                    allMetricsMap[tokens[0]] = tokens[1];
                }  
            });

            fields.forEach(function(k) {
                metrics.push(allMetricsMap[k]);
            })
        }
        acc.push(metrics);
        return acc;
    }, []);
    
}
function constructDownloadReport$getRangeOffset(sortedDownloads) {
    var rangeOffset = 0;
    sortedDownloads.forEach(function (download) {
        if (download.range) {
            rangeOffset = Math$min(rangeOffset, download.range[0]);
        }
    });

    return rangeOffset;
}

function constructDownloadReport$getRanges(downloads, rangeOffset) {
    var ranges = [];

    downloads.forEach(function (download) {
        if (download.range) {
            ranges.push([download.range[0] - rangeOffset, download.range[1] - rangeOffset]);
        } else {
            ranges.push([0, -1]);
        }
    });

    return ranges;
}

function constructDownloadReport$getTrace(sortedDownloads) {
    var trace = [];
    var previousMeasurements;
    sortedDownloads.forEach(function (download) {
        var measurements = download.measurements;

        if (previousMeasurements) {
            var timeBeforeNextRequest = measurements.requestTime - previousMeasurements.responseEndTime;
            if (timeBeforeNextRequest > 0) {
                trace.push([timeBeforeNextRequest, -2]);
            }

            var requestTime = Math$max(previousMeasurements.responseEndTime, measurements.requestTime);
            var responseTime = measurements.responseStartTime - requestTime;
            if (responseTime > 0) {
                trace.push([responseTime, -3]);
            }
        }

        trace.push([measurements.responseEndTime - measurements.responseStartTime, measurements.contentLength || 0]);

        previousMeasurements = measurements;
    });

    return trace;
}

function constructDownloadReport$isAbortOrStall(download) {
    if (download.errorSubCode === ErrorSubCodes.HTTP_ABORT)
        return true;

    if (download.errorSubCode === ErrorSubCodes.HTTP_READTIMEOUT)
        return true;
}

function constructDownloadReport$getStatus(download) {
    if (download.success) {
        return 'complete';
    }

    if (download.errorSubCode === ErrorSubCodes.HTTP_ABORT) {
        return 'abort';
    }

    if (download.errorSubCode === ErrorSubCodes.HTTP_READTIMEOUT) {
        return 'stall';
    }

    debug$assert(false, "download status should never be: other");
    return 'other';
}

function constructDownloadReport$getFailures(downloads, timeOffset) {
    var failuresObject = [];
    downloads.forEach(function (download) {
        var measurements = download.measurements;
        var reason = constructDownloadReport$getReason(download);

        var failureObject = {
            'time': measurements.responseTime - timeOffset,
            'tresp': measurements.responseStartTime - measurements.requestTime,
            'dur': measurements.responseEndTime - measurements.responseStartTime,
            'range': download.range,
            'reason': reason,
            'httpcode': download.errorHttpCode,
            'nwerr': NccpLogging$_nwerr(download.errorSubCode)
        };
        
        failuresObject.push(failureObject);
    });

    return failuresObject;
}

function constructDownloadReport$getReason(download) {
    if (download.errorHttpCode || download.errorSubCode === ErrorSubCodes.HTTP_PROTOCOL) {
        return 'http';
    }

    if (download.errorSubCode === ErrorSubCodes.HTTP_TIMEOUT) {
        return 'timeout'; // read timeout is not a failure
    }

    return 'network';
}

function constructDownloadReport$isFailure(download) {
    if (download.success) {
        return false; // complete
    }

    if (download.success === undefined) {
        return false; // still open
    }

    if (download.errorSubCode === ErrorSubCodes.HTTP_ABORT)
        return false; // abort is not a failure

    if (download.errorSubCode === ErrorSubCodes.HTTP_READTIMEOUT)
        return false; // read timeout is not a failure

    return true;
}

function constructDownloadReport$convertResponseToDownloadInfo(response) {
    var request = response.request,
        stream = request.stream,
        track = request.track,
        url = request.url;

    var dltype = constructDownloadReport$getDownloadType(track, url);

    var downloadableId = undefined;
    switch (dltype) {
        case CadmiumMediaStream$AUDIO:
        case CadmiumMediaStream$VIDEO:
            downloadableId = request.stream.downloadableId;
            break;
        case CadmiumMediaStream$TIMEDTEXT:
        case CadmiumMediaStream$TRICKPLAY:
            downloadableId = track.downloadableId;
            break;
    }

    var downloadInfo = {
        bitrate: stream && stream.bitrate,
        dltype: dltype,
        downloadableId: downloadableId,
        measurements: response.measurements,
        cdn: request.cdn,
        url: url,
        errorExternalCode: response.errorExternalCode,
        errorHttpCode: response.errorHttpCode,
        errorSubCode: response.errorSubCode,
        success: response.success,
        tcpInfo: response.headers && response.headers['X-TCP-Info'],
        clientPort: extractClientPort(response)          
    };

    if (request.offset !== undefined && request.length != undefined) {
        downloadInfo.range = [request.offset, request.offset + request.length - 1];
    }

    return downloadInfo;
}

function constructDownloadReport$getDownloadType(track, url) {
    if (track) {
        return track.type;
    }

    if (url.indexOf('netflix.com') >= 0) {
        if (url.indexOf('nccp') >= 0) {
            return 'nccp';
        }

        if (url.indexOf('api') >= 0) {
            return 'api';
        }
    }
    
    return 'other';
}

function extractClientPort(response){
    if(!response.headers){
        return;
    }
    var sessionInfo = response.headers['X-Session-Info'];
    if(!sessionInfo){
        return;
    }

    var tokens = sessionInfo ? sessionInfo.split(';') : [],
        clientPort = tokens.filter(function(t){
            return t.indexOf('port=') == 0;
        }).map(function(str){
            return str.split('=')[1];
        })[0];
    return  parseInt10(clientPort)  
}



// -- player-nccp/parseManifest.js
/**
 * Transform the manifest returned from the server a playback object
 * @param  {{
 *  movieId: Number,
 *  playbackContextId: String,
 *  runtime: Number,
 *  bookmark: {
 *      position: Number,
 *      timestamp: Number
 *  },
 *  defaultMedia: String,
 *  locations: Array.<{
 *      id: String,
 *      rank: Number,
 *      level: Number,
 *      weight: Number
 *  }>,
 *  cdns: Array.<{
 *      id: String,
 *      name: String,
 *      rank: Number,
 *      type: String,
 *      lowgrade: Boolean,
 *      exclusive: Boolean,
 *      locationId: String
 *  }>,
 *  media: Array.<{
 *      mediaId: String,
 *      score: Number,
 *      tracks: Array.<{
 *          id: String,
 *          type: String
 *      }>
 *  }>,
 *  audioTracks: Array.<{
 *      id: String,
 *      type: String,
 *      trackType: String,
 *      channels: String,
 *      bcp47: String,
 *      language: String,
 *      downloadables: Array.<{
 *          id: String,
 *          size: Number,
 *          contentProfile: String,
 *          bitrate: Number,
 *          dowloadableId: String,
 *          urls: Object
 *      }>
 *  }>,
 *  videoTracks: Array.<{
 *      id: String,
 *      type: String,
 *      trackType: String,
 *      drmContextId: String,
 *      drmHeaders: Array.<{
 *          bytes: String,
 *          checksum: String,
 *          systemType: String,
 *          keyId: String
 *      }>,
 *      downloadables: Array.<{
 *          id: String,
 *          size: Number,
 *          contentProfile: String,
 *          bitrate: Number,
 *          hdcpVersions: Array.<String>,
 *          width: Number,
 *          height: Number,
 *          dowloadableId: String,
 *          urls: Object
 *      }>
 *  }>,
 *  textTracks: Array.<{
 *      id: String,
 *      type: String,
 *      trackType: String,
 *      bcp47: String,
 *      language: String,
 *      isForced: Boolean,
 *      isNone: Boolean,
 *      downloadables: Array.<{
 *          id: String,
 *          type: String,
 *          contentProfile: String,
 *          dowloadableId: String,
 *          urls: Object
 *      }>
 *  }>,
 *  trickPlayTracks: Array.<{
 *      id: String,
 *      type: String,
 *      trackType: String,
 *      downloadables: Array.<{
 *          id: String,
 *          size: Number,
 *          interval: Number,
 *          dowloadableId: String,
 *          pixHeight: Number,
 *          pixWidth: Number,
 *          resHeight: Number,
 *          resWidth: String,
 *          urls: Object
 *      }>
 *  }>
 * }} manifest [description]
 * @param  {Playback} playback The playback object to recieve parsed manifest data
 */
function parseManifest(manifest, playback) {
    var log = new playback.log.CategoryLog('BladeRunnerParseManifest'),
        locationList,
        cdnList,
        trickPlayList,
        timedTextTrackList,
        audioTrackList,
        videoTrackList,
        preferredTrackCombinationList,
        defaultAudioTrack,
        defaultVideoTrack,
        defaultTimedTextTrack,
        preferredTrackCombination,
        urlsValidFor;

    /**
     * Gets the list of locations from the incoming manifest data
     * @return {Array.<{
     *      id: (String|null),
     *      rank: (Number|null),
     *      weight: (Number|null),
     *      level: (Number|null)
     * }>} the list of locations from the manifest
     */
    function transformLocations() {
        // Even though the object from the manifest
        // has the same shape as the object we return
        // we can't use the same object because the
        // closure compiler will rename the properties
        // for the users of the returned object.
        var locations = manifest['locations'].map(function(location) {
            return {
                id: location['id'],
                rank: location['rank'],
                level: location['level'],
                weight: location['weight']
            };
        });
        log.trace('Transformed locations', {
            'Count': locations.length
        });
        return locations;
    }

    /**
     * Gets the list CDNs from the incoming manifest data and then
     * associates each CDN with the proper location and finally
     * adds the CDN to associated locations list of CDNs
     * @param {Array.<{
     *      id: (String|null),
     *      rank: (Number|null),
     *      weight: (Number|null),
     *      level: (Number|null)
     * }>} locationList the list of locations to search for a CDNs assoicated location
     * @return {Array.<{
     *      id: string,
     *      rank: number,
     *      weight: number,
     *      level: number,
     *      location
     * }>} the array of CDNs with their associations
     * @description [description]
     */
    function transformCdns(locationList) {
        var serverList = manifest['cdns'],
            cdnIdWhiteList = config.cdnIdWhiteList,
            cdnIdBlackList = config.cdnIdBlackList,
            cdnList = [];

        /**
         * Find the location for a cdn based on the 'key'
         * value in the cdn JSON
         *
         * @param  {string} key the identifier for the location to find
         * @param  {Array}  locationList the array of locations to search
         * @return {{
         *      key: string,
         *      rank: number,
         *      weight: number,
         *      level: number
         * }} the location with the matching key value
         */
        function getLocation(key, locationList) {
            var location;
            locationList.some(function(loc) {
                if (loc.id === key) {
                    location = loc;
                    return true;
                }
            });
            return location;
        }

        serverList.forEach(function(cdn) {
            var cdnId = cdn['id'],
                location = getLocation(cdn['locationId'], locationList);

            if ((!cdnIdWhiteList.length || cdnIdWhiteList.indexOf(cdnId) >= 0) && cdnIdBlackList.indexOf(cdnId) < 0) {
                cdnList.push({
                    id: cdn['id'],
                    name: cdn['name'],
                    rank: cdn['rank'],
                    type: cdn['type'],
                    isLowgrade: cdn['isLowgrade'],
                    isExclusive: cdn['isExclusive'],
                    locationId: cdn['locationId'],
                    location: location
                });
            }
        });

        cdnList.sort(function(a, b) {
            return a.rank - b.rank;
        });

        locationList.forEach(function(location) {
            var cdnsAtLocation = cdnList.filter(function(cdn) {
                return cdn.location.id === location.id;
            });

            location.cdnList = cdnsAtLocation;
        });
        locationList.sort(function(a, b) {
            return a.rank - b.rank;
        });

        log.trace('Transformed cdns', {
            'Count': cdnList.length
        });
        if (!cdnList.length) {
            throw new Error('no valid cdns');
        }

        return cdnList;
    }

    /**
     * Transform the trick play data from the incoming manifest to
     * the TrickPlay type and sort by size
     */
    function transformTrickPlayList() {
        var downloadables,
            trickplayList = [];

        // There should only be one trick play track with both the
        // large and small stream info. So get the downloadables of
        // the first trickplay track
        if (manifest['trickPlayTracks'] && manifest['trickPlayTracks'].length) {
            downloadables = manifest['trickPlayTracks'][0]['downloadables'];
            if (downloadables) {
                trickplayList = downloadables.map(function(trickPlay) {
                    return new TrickPlay(
                        playback,
                        trickPlay['id'],
                        trickPlay['resHeight'],
                        trickPlay['resWidth'],
                        trickPlay['pixHeight'],
                        trickPlay['pixWidth'],
                        trickPlay['size'],
                        trickPlay['urls']);
                });
            } else {
                log.warn('Trickplay track has no downloadables');
            }
        } else {
            log.warn('There are no trickplay tracks');
        }

        trickplayList.sort(function(a, b) {
            return a.size - b.size;
        });

        log.trace('Transformed trick play tracks', {
            'Count': trickplayList.length
        });
        return trickplayList;
    }

    /**
     * Transform the timed text tracks from the incoming manifest to
     * the TimedTextTrack type and sort by priority
     *
     * @returns {Array.<TimedTextTrack>} the list of timed text tracks sent from the server
     */
    function transformTimedTextTracks() {
        var manifestTimedTextTracks = manifest['textTracks'],
            timedTrackList = [];

        /**
         * Transform timed text downloadable from the manifest to the
         * downloadable type used by the client
         * @param  {Object} track the timed text track containing the downloadables
         * @return  {Array.<{
         *              downloadableId: String,
         *              profile: String,
         *              size: Number,
         *              priority: Number,
         *              urls: Object,
         *              type: String
         *          }>} transformed downloadables
         */
        function transformDownloadables(track) {

            var manifestDownloadables = track['downloadables'],
                downloadables = [];

            if (!manifestDownloadables || manifestDownloadables.length === 0) {
                return downloadables;
            }

            /**
             * Determine the downloadable priority based on list position
             * and configuration options
             * @param {Object} downloadable containing the profile name, size and urls
             *                                    of the text track downloadable
             * @return {number} the priority of the downloadable
             */
            function getDownloadablePriority(downloadable) {
                var profile = downloadable['contentProfile'];
                var priority = config.timedTextProfiles.indexOf(profile);
                var size = downloadable['size'];
                var urls = downloadable['urls'];

                if (config.timedTextSimpleFallbackThreshold > 0 &&
                    profile === timedTextProfile$DFXP_LS_SDH &&
                    size > config.timedTextSimpleFallbackThreshold) {
                    // lower the priority if this is ls-sdh and is above limit
                    return config.timedTextProfiles.length + 1;
                }

                return priority >= 0 ? priority : config.timedTextProfiles.length;
            }

            manifestDownloadables.forEach(function(downloadable) {
                var d = {
                    id: downloadable['id'],
                    downloadableId: downloadable['downloadableId'],
                    profile: downloadable['contentProfile'],
                    size: downloadable['size'] | 0,
                    priority: getDownloadablePriority(downloadable),
                    offset: downloadable['offset'] | 0,
                    pixWidth: downloadable['pixWidth'],
                    pixHeight: downloadable['pixHeight'],
                    urls: downloadable['urls'],
                    type: downloadable['type']
                };
                if (downloadable['decryptionKey']) {
                    d.decryptionKey = downloadable['decryptionKey'];
                }
                downloadables.push(d);
            });

            downloadables.sort(function(a, b) {
                return a.priority - b.priority;
            });
            return downloadables;
        }

        function getMidx(downloadable) {
            var midx = {};
            if (downloadable.profile === timedTextProfile$NFLX_CMISC  || downloadable.profile === timedTextProfile$NFLX_CMISC_ENC) {
                midx.offset = downloadable.offset;
                midx.length = downloadable.size;
                midx.resolution = {
                    width: downloadable.pixWidth,
                    height: downloadable.pixHeight
                };
            }
            return midx;
        }

        function selectImageSubsResolution(downloadables){
            var resolution = config.imageSubsResolution || getPreferenceFromScreenSize();
            var pickImageSubs = function pickImageSubs(d) {
                return (d.profile === timedTextProfile$NFLX_CMISC || d.profile === timedTextProfile$NFLX_CMISC_ENC);
            };
            var matchResolution = function pickThoseMatchResolution(d) {
                return d.pixHeight === resolution;
            };

            var selectedDownloadable = downloadables.filter(pickImageSubs).filter(matchResolution)[0];
            if (selectedDownloadable) {
                return selectedDownloadable;
            } else { // should be absolutely rare
                log.warn('none of the downloadables match the intended resolution', {
                    'screenHeight': screen['height'],
                    'intendedResolution': resolution
                });
                return downloadables[0];
            }
        }

        function getPreferenceFromScreenSize(){
            var resolutionY = screen && screen['height'];
            if (isNumber(resolutionY)) {
                return resolutionY >= 1080 ? 1080 : 720;
            } else {
                log.error('screen height not available', userAgent); //should be extremely rare, log it.
            }
            return 720;
        }

        function getLogInfoFromTrack(track){
            try{
                return{
                    'isNone': track['isNone'],
                    'isForced': track['isForced'],
                    'bcp47': track['bcp47'],
                    'id': track['id']
                }
            }catch(e){}
        }

        manifestTimedTextTracks.forEach(function(track) {
            var downloadables = [],
                firstDownloadable,
                transformedTrack,
                currentProfile;

            downloadables = transformDownloadables(track); // creates internal properties and sort them based on priority
            if (track['isNone'] === false && !downloadables.length) {
                log.error('track without downloadables', getLogInfoFromTrack(track));
            }
            if (track['isForced'] === true && !downloadables.length) {
                log.error('forced track without downloadables', getLogInfoFromTrack(track));
            }
            if (downloadables.length > 0) {
                firstDownloadable = downloadables[0];
                currentProfile = firstDownloadable.profile;
                // if sorted list picked nflx-cmisc profile as the first node then pick the appropriate resolution
                if (currentProfile == timedTextProfile$NFLX_CMISC || currentProfile == timedTextProfile$NFLX_CMISC_ENC) {
                    firstDownloadable = selectImageSubsResolution(downloadables);
                    if(DEBUG){
                        log.trace('selected image subs resolution', {
                            'height': firstDownloadable.pixHeight,
                            'lang': track['bcp47']
                        });
                   }
                }

                transformedTrack = new TimedTextTrack(
                    playback,
                    track['id'],
                    firstDownloadable.downloadableId,
                    firstDownloadable.urls,
                    track['bcp47'],
                    track['language'],
                    TrackType$_map[track['trackType'].toLowerCase()] || TrackType$PRIMARY,
                    track['trackType'],
                    firstDownloadable.profile,
                    getMidx(firstDownloadable),
                    track['isNone'],
                    track['isForced'],
                    firstDownloadable.decryptionKey);
            } else {
                // This code path is taken when the 'NONE' subtitle track is selected.
                //log.warn('Unable to transform timed text track because there were no downloadables', track);
                transformedTrack = new TimedTextTrack(
                    playback,
                    track['id'],
                    undefined,
                    {},
                    track['bcp47'],
                    track['language'],
                    TrackType$PRIMARY,
                    track['trackType'],
                    undefined,
                    {},
                    track['isNone'],
                    track['isForced'],
                    undefined);
            }
            timedTrackList.push(transformedTrack);
            log.trace('Transformed timed text track', transformedTrack);
        });

        timedTrackList.sort(compareTextTracks);

        log.trace('Transformed timed text tracks', {
            'Count': timedTrackList.length
        });
        return timedTrackList;
    }

    /**
     * Transform the audio tracks from the incoming manifest to an audio record type and sort by the track display name
     * @param  {Array.<Object>}         mediaList           the list of available media, used to resolve allowed text tracks
     * @param  {Array.<TimedTextTrack>} timedTextTrackList  the list of available timed text tracks
     * @return {Array.<Object>}                             the array of transformed audio tracks
     */
    function transformAudioTracks(mediaList, timedTextTrackList) {
        var manifestAudioTracks = manifest['audioTracks'],
            audioTracks = [];

        /**
         * Gets the set of timed text tracks that are allowed to be used for the
         * audio track. Resolves the list of all timed text tracks against the
         * list of available media
         * @param  {string}                 id            the audio track Id
         * @param  {Array.<Object>}         mediaList     the list of media
         * @param  {Array.<TimedTextTrack>} allTextTracks the list of text tracks
         * @return {Array.<TimedTextTrack>}               the list of allowed text tracks
         */
        function getAllowedTextTracks(id, mediaList, allTextTracks) {
            var textTrackId,
                allowedTextTracks = [],
                mediaAudioTrack,
                mediaTextTrack,
                textTrack;

            var mediaFilter = function(media) {
                return media['tracks'].filter(function(track) {
                    return track['type'] === 'AUDIO' && track['id'] === id;
                }).length > 0;
            };

            var mediaMap = function(media) {
                var mediaTextTrack,
                    textTracks;

                mediaTextTrack = media['tracks'].filter(function(track) {
                    return track['type'] === 'TEXT';
                })[0];

                textTracks = allTextTracks.filter(function(track) {
                    return track.trackId === mediaTextTrack['id'];
                });
                return textTracks.length > 0 ? textTracks[0] : undefined;
            };

            return mediaList.filter(mediaFilter)
                            .map(mediaMap)
                            .filter(Boolean)
                            .sort(compareTextTracks);
        }

        manifestAudioTracks.forEach(function(audioTrack) {
            var trackType = audioTrack['trackType'],
                track;

            if (config.supportedAudioTrackTypes.length === 0 || config.supportedAudioTrackTypes.indexOf(trackType) >= 0) {
                track = {
                    type: CadmiumMediaStream$AUDIO,
                    trackId: audioTrack['id'],
                    trackType: TrackType$_map[trackType.toLowerCase()] || TrackType$PRIMARY,
                    nccpTrackType: trackType,
                    bcp47: audioTrack['bcp47'],
                    displayName: audioTrack['language'],
                    channels: audioTrack['channels'],
                    channelsLabel: audioTrack['channelsLabel'],
                    channelsCount: audioTrack['channelsCount'],
                    timedTextTrackList: getAllowedTextTracks(audioTrack['id'], mediaList, timedTextTrackList),
                    logField: {
                        'Bcp47': audioTrack['language'],
                        'TrackId': audioTrack['id']
                    }
                };
                track.streams = transformStreams(audioTrack['downloadables'], track);
                log.trace('Transformed audio track', track, {
                    'StreamCount': track.streams.length,
                    'AllowedTimedTextTracks': track.timedTextTrackList.length
                });

                if (track.streams.length) {
                    audioTracks.push(track);
                } else {
                    log.warn('Audio track has no streams', track);
                }
            }
        });

        if (!audioTracks.length) {
            throw new Error('no valid audio tracks');
        }
        audioTracks.sort(compareAudioTracks);
        log.trace('Transformed audio tracks', {
            'Count': audioTracks.length
        });
        return audioTracks;
    }

    /**
     * Transform the video tracks from the incoming manifest to an video record type.
     * @return {Array.<Object>} the array of transformed video tracks
     */
    function transformVideoTracks() {
        var manifestVideoTracks = manifest['videoTracks'],
            videoTracks = [];

        manifestVideoTracks.forEach(function(videoTrack) {
            var trackType = videoTrack['trackType'],
                track;

            track = {
                type: CadmiumMediaStream$VIDEO,
                trackId: videoTrack['id'],
                trackType: TrackType$_map[trackType.toLowerCase()] || TrackType$PRIMARY,
                nccpTrackType: trackType
            };
            track.streams = transformStreams(videoTrack['downloadables'], track);
            log.trace('Transformed video track', {
                'StreamCount': track.streams.length
            });
            if (track.streams.length) {
                videoTracks.push(track);
            } else {
                log.warn('Video track has no streams');
            }
        });

        if (!videoTracks.length) {
            throw new Error('No valid video tracks');
        }
        log.trace('Transformed video tracks', {
            'Count': videoTracks.length
        });
        return videoTracks;
    }

    /**
     * Map default media track in the manifest to list of audio/text track preferences
     * ordered by preference. Currently there is only one default media track so this
     * function will return an array of one item
     * @param  {Array.<Object>}         audioTracks     the list of transformed audio tracks
     * @param  {Array.<TimedTextTrack>} timedTextTracks the list of transformed text tracks
     * @return {Array.<{
     *             audioTrack: Object,
     *             timedTextTrack: Object,
     *             preferenceorder: Number
     *         }
     * >} The list (currently only one) of preferred track combinations ordered be preference
     */
    function transformPreferredCombos(audioTracks, timedTextTracks) {
        var preferredTrackCombinationList = [],
            defaultMediaId = manifest['defaultMedia'];

        /**
         * Search for a specific track in an array of track based on the ID of the track
         * @param  {Array.<Object>} trackList the array to search
         * @param  {Number}         trackId   the Id to search for
         * @return {Object}                   the first track with the matching ID if found; null otherwise
         */
        function findTrackById(trackList, trackId) {
            var i;
            for (i = 0; i < trackList.length; i++) {
                var t = trackList[i];
                if (t.trackId == trackId) {
                    return t;
                }
            }
            return null;
        }

        var reduceFxn = function(map, track) {
            map[track.type] = track.id;
            return map;
        };


        // Using the default media id, make a map of the default track id
        // for each type of track, like this:
        // {
        //      'VIDEO': <default video track id>
        //      'AUDIO': <default audio track id>
        //      'TEXT': <default timed text track id>
        // }
        var defaultTrackMap, i;
        for (i = 0; i < manifest['media'].length; i++) {
            var media = manifest['media'][i];
            if (media['mediaId'] == defaultMediaId) {
                defaultTrackMap = media['tracks'].reduce(reduceFxn, {});
                break;
            }
        }

        // Select the audio and timed text tracks by their default track id's.
        preferredTrackCombinationList.push({
            audioTrack: findTrackById(audioTracks, defaultTrackMap['AUDIO']),
            timedTextTrack: findTrackById(timedTextTracks, defaultTrackMap['TEXT']),
            preferenceorder: 0
        });

        return preferredTrackCombinationList;
    }

    /**
     * Transforms media track stream records from the incoming
     * manifest to CadmiumMediaStream objects
     * @param  {Array.<{
     *          id: string,
     *          contentProfile: string,
     *          trackType: string,
     *          bitrate: number,
     *          channels: string,
     *          bcp47: string,
     *          language: string,
     *          size: string,
     *          height: (number|undefined),
     *          width: (number|undefined),
     *          hdcpVersions: (Array.<string>|undefined),
     *          downloadableId: string,
     *          type: string,
     *          urls: Array
     * }>} streams the media track stream records from the manifest
     * @param  {{
     *          type: string,
     *          trackId: string,
     *          trackType: string,
     *          nccpTrackType: string,
     *          bcp47: (string|undefined),
     *          displayName: (string|undefined),
     *          isNative: (boolean|undefined),
     *          channels: (string|undefined),
     *          disallowedTimedTextTrackIdList: (Array.<number>|undefined),
     *          timedTextTrackList: (Array.<TimedTextTrack>|undefined),
     *          logField: ({
     *              Bcp47: string,
     *              TrackId: string
     *          }|undefined),
     *          drmContextId: ({
     *              systemType: string,
     *              bytes: (string|undefined),
     *              checksum: (string|undefined),
     *              keyId: (string|undefined)
     *          }|undefined)
     *      }} track
     * @return {Array.<CadmiumMediaStream>} an array of transformed media track streams
     */
    function transformStreams(streams, track) {
        var result = [],
            supportedBitrates;

        if (!streams) {
            log.warn('There are no media streams for ' + track.type + ' track - ' + track.trackId);
            return result;
        }
        streams.forEach(function(stream) {
            var i,
                mediaStream;

            mediaStream = new CadmiumMediaStream(
                playback,
                track,
                track.type,
                stream['downloadableId'],
                stream['bitrate'],
                stream['vmaf'],
                stream['size'],
                stream['urls'],
                stream['contentProfile']);

            var width = stream['width'],
                height = stream['height'];

            mediaStream.setWidthAndHeight(width, height);

            if (stream['decryptionKey']) {
                mediaStream.decryptionKey = stream['decryptionKey'];
            }

            if (track.drmContextId) {
                mediaStream.drmContextId = track.drmContextId;
            }

            if (track.type === CadmiumMediaStream$VIDEO || track.type === CadmiumMediaStream$AUDIO) {
                urlsValidFor = urlsValidFor ? Math$min(urlsValidFor, stream['validFor']) : stream['validFor'];
            }

            if (track.drmHeaders) {
                mediaStream.drmHeaders = track.drmHeaders.map(function(header) {
                    var transformedDrmHeader = {};
                    transformedDrmHeader.systemType = header['systemType'];
                    if (header['bytes']) {
                        transformedDrmHeader.bytes = header['bytes'];
                    }
                    if (header['checksum']) {
                        transformedDrmHeader.checksum = header['checksum'];
                    }
                    if (header['keyId']) {
                        transformedDrmHeader.keyId = header['keyId'];
                    }
                    return transformedDrmHeader;
                });
            }

            if (stream['contentProfile']) {
                mediaStream.contentProfile = stream['contentProfile'];
            }

            mediaStream.requiresHdcp = !!(stream['hdcpVersions'] && stream['hdcpVersions'][0] != 'none');

            if (!(mediaStream.requiresHdcp && config.canHDCP == 'never')) {
                // use the streams that requiresHDCP, only if we can use HDCP
                result.push(mediaStream);
            }
        });

        result.sort(function(a, b) {
            return a.bitrate - b.bitrate;
        });
        CadmiumMediaStreams$addMethodsToArray(result);

        // apply filter
        supportedBitrates = CadmiumMediaStream$switchType(track.type, config.supportedAudioBitrates, config.supportedVideoBitrates);

        result.sort(function(a, b) {
            return a.bitrate - b.bitrate;
        });
        CadmiumMediaStreams$addMethodsToArray(result);

        return result;
    }

    /**
     * Compares two audio tracks based on the languge of the track.
     *
     * Audio tracks are ordered such that the preferred language is first in
     * the list followed by the remaining tracks in alphabetical order.
     *
     * The sort order is actually dictated by a reference array that is part
     * of the incoming manifest.
     *
     * @param  {*} track1 the first track to compare
     * @param  {*} track2 the second track to compare
     * @return {number}   the value 0 if track1 and track2 are equivalent;
     *                    1 if track1 sorts after track2;
     *                    -1 if track1 sorts before track2;
     */
    function compareAudioTracks(track1, track2) {
        return compareTracks(track1, track2, manifest['orderedAudioTracks']);
    }

    /**
     * Compares two text tracks based on the languge of the track.
     *
     * Text tracks should be ordered such that the 'off' track is first, then
     * the preferred language should be second (and third if there is a CC),
     * followed by the remaining tracks in alpahbetical order.
     *
     * The sort order is actually dictated by a reference array that is part
     * of the incoming manifest.
     *
     * @param  {*} track1 the first track to compare
     * @param  {*} track2 the second track to compare
     * @return {number}   the value 0 if track1 and track2 are equivalent;
     *                    1 if track1 sorts after track2;
     *                    -1 if track1 sorts before track2;
     */
    function compareTextTracks(track1, track2) {
        return compareTracks(track1, track2, manifest['orderedTextTracks']);
    }

    /**
     * Compares two audio or text tracks based on a presorted reference array.
     *
     * @param  {*}              track1  the first track to compare
     * @param  {*}              track2  the second track to compare
     * @param  {Array<string>}  order   The reference sorted array
     * @return {number}                 the value 0 if track1 and track2 are equivalent;
     *                                  1 if track1 sorts after track2;
     *                                  -1 if track1 sorts before track2;
     */
    function compareTracks(track1, track2, order) {
        if (!order) {
            return 0;
        }
        if (!track1) {
            return -1;
        }
        if (!track2) {
            return 1;
        }

        var displayName1 = track1.displayName + (track1.nccpTrackType === 'CLOSEDCAPTIONS' ? ' [CC]' : ''),
            displayName2 = track2.displayName + (track2.nccpTrackType === 'CLOSEDCAPTIONS' ? ' [CC]' : ''),
            index1 = order.indexOf(displayName1),
            index2 = order.indexOf(displayName2);

        return index1 - index2;
    }

    /**
     * Create a manifest object for playback in the form that the JS ASE requires.
     *
     *
     */
    function addJsaseManifest() {
        var jsaseManifest = {};

        function getLocations() {
            return manifest['locations'].map(function(location) {
                return {
                    'key': location['id'],
                    'rank': location['rank'],
                    'level': location['level'],
                    'weight': location['weight']
                };
            });
        }

        function getServers() {
            var serverList = manifest['cdns'];

            return serverList.map(function(server) {
                return {
                    'name': server['name'],
                    'type': server['type'],
                    'id': server['id'],
                    'key': server['locationId'],
                    'rank': server['rank'],
                    'lowgrade': server['isLowgrade']
                };
            });
        }

        function getAudioTrackList() {
            var audioTracks = manifest['audioTracks'];

            return audioTracks.map(function(audioTrack) {
                return {
                    'id': audioTrack['id'],
                    'channels': audioTrack['channels'],
                    'language': audioTrack['bcp47'],
                    'languageDescription': audioTrack['language'],
                    'trackType': audioTrack['trackType']
                };
            });
        }

        function getUrls(urls) {
            var urlList = [];
            for (var key in urls) {
                if (urls.hasOwnProperty(key)) {
                    urlList.push({
                        'cdn_id': key,
                        'url': urls[key]
                    });
                }
            }
            return urlList;
        }

        function getAudioTracks() {
            var audioTracks = manifest['audioTracks'];

            function getStreams(streams, audioTrack) {
                return streams.map(function(stream) {
                    return {
                        'type': 0,
                        'trackType': audioTrack['trackType'],
                        'content_profile': stream['contentProfile'],
                        'downloadable_id': stream['downloadableId'],
                        'bitrate': stream['bitrate'],
                        'channels': audioTrack['channels'],
                        'language': audioTrack['bcp47'],
                        'urls': getUrls(stream['urls'])
                    };
                });
            }

            return audioTracks.map(function(audioTrack) {
                return {
                    'type': 0,
                    'track_id': audioTrack['id'],
                    'channels': audioTrack['channels'],
                    'language': audioTrack['bcp47'],
                    'languageDescription': audioTrack['language'],
                    'trackType': audioTrack['trackType'],
                    'streams': getStreams(audioTrack['downloadables'], audioTrack)
                };
            });
        }

        function getVideoTracks() {
            var videoTracks = manifest['videoTracks'];

            function getStreams(streams, trackType) {
                var streamList = streams.map(function(stream) {
                    return {
                        'type': 1,
                        'trackType': trackType,
                        'content_profile': stream['contentProfile'],
                        'downloadable_id': stream['downloadableId'],
                        'bitrate': stream['bitrate'],
                        'urls': getUrls(stream['urls'])
                    };
                });

                // sort list of tracks because ASE code assumes it
                arraySortByProperty(streamList, 'bitrate');
                return streamList;
            }

            return videoTracks.map(function(videoTrack) {
                return {
                    'type': 1,
                    'streams': getStreams(videoTrack['downloadables'], videoTrack['trackType'])
                };
            });
        }


        /**
         *
         * Get the default audio track by looking up its trackID.
         * If no trackID is given, assume this is video and return 0 by default
         * since we only have one videoTrack.
         *
         * @param {Array} trackList
         * @param {String=} trackId
         * @returns {number}
         */
        function findDefaultTrackIndex(trackList, trackId) {
            var index = 0;
            trackList.some(
                function (t, i) {
                    if (t["track_id"] == trackId) {
                        index = i;
                        return true;
                    }
                    return false;
                });
            return index;
        }

        jsaseManifest['movieId'] = manifest['movieId'];
        jsaseManifest['duration'] = manifest['runtime'];
        jsaseManifest['locations'] = getLocations();
        jsaseManifest['servers'] = getServers();
        jsaseManifest['audio_tracks'] = getAudioTracks();
        jsaseManifest['video_tracks'] = getVideoTracks();
        jsaseManifest['tracks'] = jsaseManifest['video_tracks'].concat(jsaseManifest['audio_tracks']);

        playback.defaultAudioTrackIndex = findDefaultTrackIndex(jsaseManifest['audio_tracks'], defaultAudioTrack.trackId);
        playback.defaultVideoTrackIndex = findDefaultTrackIndex(jsaseManifest['video_tracks'], defaultVideoTrack.trackId);

        return jsaseManifest;
    }

    locationList = transformLocations();
    cdnList = transformCdns(locationList);
    trickPlayList = transformTrickPlayList();
    timedTextTrackList = transformTimedTextTracks();
    audioTrackList = transformAudioTracks(manifest['media'], timedTextTrackList);
    videoTrackList = transformVideoTracks();
    preferredTrackCombinationList = transformPreferredCombos(audioTrackList, timedTextTrackList);

    preferredTrackCombination = preferredTrackCombinationList[0] || {};
    defaultVideoTrack = videoTrackList[0];
    defaultAudioTrack = preferredTrackCombination.audioTrack || audioTrackList[0];
    defaultTimedTextTrack = preferredTrackCombination.timedTextTrack || defaultAudioTrack.timedTextTrackList[0];

    // (do not touch playback until we parsed everything)
    // apply the parsed content to playback
    playback.playbackContextId = manifest['playbackContextId'];
    playback.mediaList = manifest['media'];
    playback.cert = manifest['cert'];
    playback.drmContextId = manifest['drmContextId'];
    playback.psshb64 = manifest['psshb64'];
    playback.isAudioEncrypted = manifest['audioEncrypted'];
    playback.isVideoEncrypted = manifest['videoEncrypted'];
    playback.cdnList = cdnList;
    playback.cdnLocationList = locationList;
    playback.audioTrackList = audioTrackList;
    playback.videoTrackList = videoTrackList;
    playback.bookmarkTime = manifest['bookmark']['position'];
    playback.timedTextTrackList = timedTextTrackList;
    playback.trickPlayList = trickPlayList;
    playback.estimatedRuntime = manifest['runtime'];
    playback.sessionIPAddress = manifest['clientIpAddress'];
    playback.manifest = addJsaseManifest();

    // set the default tracks
    playback.preferredTrackCombinations = preferredTrackCombinationList;
    playback.videoTrack.set(defaultVideoTrack);
    playback.audioTrack.set(defaultAudioTrack);
    playback.timedTextTrack.set(defaultTimedTextTrack);

    // sanity check, this can't be less than 10 sec
    var milliseconds = urlsValidFor * 1000;
    if (milliseconds > 10000) {
        playback.manifestWillExpireOn = clock$getTime() + milliseconds;
    } else {
        log.error('Invalid url expiration, ignoring');
    }
}

// TODO: is this the right mapping?
var TrackType$PRIMARY = 'PRIMARY',
    TrackType$ASSISTIVE = 'ASSISTIVE',
    TrackType$COMMENTARY = 'COMMENTARY';

var TrackType$_map = {
    'assistive': TrackType$ASSISTIVE,
    'closedcaptions': TrackType$ASSISTIVE,
    'directorscommentary': TrackType$COMMENTARY,
    'commentary': TrackType$COMMENTARY,
    'subtitles': TrackType$PRIMARY,
    'primary': TrackType$PRIMARY
};



// -- player-nccp/NccpPlayback.js
/**
* @constructor
*/
function NccpPlayback(playback) {
    var _log = new playback.log.CategoryLog('NccpPlayback'),
        _accountKey = playback.account.accountKey,
        _nccpContext = {
            http: playback.httpPlayback,
            log: new playback.log.CategoryLog('Nccp'),
            accountKey: _accountKey
        },
        _playbackStarted,
        _initialMediaTime,
        _initialMediaTimeEpoch,
        _authorizationTime,
        _licenseTime,
        _keySessionId, // save keySessionId after license addkey event
        _appId = config.appId || JSSID,
        _sessionId = config.sessionId || JSSID,
        _startEventSent;

    var Enums = CadmiumTypescript.Enums;
    // --------------------------------------------------------------------------------
    // -- initialization & internal api

    debug$assert(config);
    debug$assert(nccp);
    debug$assert(_nccpContext.http);

    playback.addEventListener(Playback$playbackstart, function () {
        _playbackStarted = true;
        _startEventSent = false;
        _initialMediaTime = playback.mediaTime.value;
        _initialMediaTimeEpoch = clock$getEpoch();
        debug$assertUInt(_initialMediaTime);
    });

    playback.addEventListener(Playback$licenseAdded, function(event){
        _keySessionId = event.keySessionId;
        DEBUG && _log.trace('SSManager, EME key session', {
            'keySessionId': _keySessionId
        });
    });

    playback.timedTextTrack.addListener(function () {
        _mediaSplice();
    });

    playback.audioTrack.addListener(function () {
        _mediaSplice();
    });

    /** @lends {NccpPlayback.prototype} */
    return {
        nccpContext: _nccpContext,

        authorize: _authorize,

        getLicense: _getLicense,

        start: _start,

        stopAndRelease: _stopAndRelease,

        stop: _stop,

        release: _release,

        license: _license,

        heartbeat: _heartbeat,

        engage: _engage,

        playdata: _playdata,

        createPlaydataRequest: _createPlaydataRequest,

        createPbLifecycleData: _createPbLifecycleData,

        getAuthorizationTime: function () { return _authorizationTime; },

        getLicenseTime: function () { return _licenseTime; }
    };

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _authorize(callback) {
        debug$assertUInt(playback.movieId);
        debug$assertUInt(playback.trackingId);
        var _authorizationStartTime = clock$getTime();

        function _combineParams() {
            var result = {};

            if (playback.playbackParams.authParams) {
                enumerateOwnProperties(playback.playbackParams.authParams, function(key, value) {
                    result[key] = isString(value) ? value : JSON.stringify(value);
                });
            }
            if (playback.playbackParams.sessionParams) {
                enumerateOwnProperties(playback.playbackParams.sessionParams, function(key, value) {
                    result[key] = isString(value) ? value : JSON.stringify(value);
                });
            }
            return result;
        }

        function _processManifestResponse(response) {
            var viewable;

            _authorizationTime = clock$getTime() - _authorizationStartTime;
            _log.trace('Auth Delay: ' + _authorizationTime);
            try {
                viewable = response.authorizationData['viewables'][0];
                if (viewable['success']) {
                    playback.manifestData = viewable;
                    parseManifest(viewable, playback);
                    callback(SUCCESS);
                    _fireAuthorized();
                } else {
                    callback(viewable['result']);
                }
            } catch (e) {
                _log.error('Exception processing authorization response', e);
                callback({
                    errorSubCode: ErrorSubCodes.NCCP_PROCESS_EXCEPTION
                });
            }
        }

        function _sendManifestRequest() {
            requestData.lookupType = config.qc.enabled ? Enums.MANIFEST_LOAD_TYPE.LAZY : Enums.MANIFEST_LOAD_TYPE.STANDARD;
            nccp.getManifest(requestData, _nccpContext).then(function(result) {
                _processManifestResponse(result);
            }).catch(function(err) {
                callback(err);
            });
        }

        function _assembleManifestResponse() {
            return {
                success: true,
                authorizationData: {
                    'viewables': [
                        playback.manifestData
                    ]
                }
            };
        }

        var requestData = {
            viewableIds: [playback.movieId],
            videoProfiles: config.videoProfiles,
            audioProfiles: config.audioProfiles,
            textProfiles: config.timedTextProfiles,
            trickplayProfiles: ['BIF240', 'BIF320'],
            drmSystem: MediaElement$getDrmType(),
            appId: _appId,
            sessionId: _sessionId,
            trackingId: playback.trackingId,
            sessionParams: _combineParams(),
            flavor: config.qc.enabled ? Enums.PLAYBACKCONTEXT_FLAVORS.QC : Enums.PLAYBACKCONTEXT_FLAVORS.STANDARD
        };

        if (config.edge.supportPreviewContent) {
            if (PLATFORM_CONFIG_DEFAULT$audioProfilesEncrypted) {
                PLATFORM_CONFIG_DEFAULT$audioProfilesEncrypted.forEach(function(profile){
                    requestData.audioProfiles.push(profile);
                });
            }
            if (PLATFORM_CONFIG_DEFAULT$timedTextProfilesEncrypted) {
                PLATFORM_CONFIG_DEFAULT$timedTextProfilesEncrypted.forEach(function(profile){
                    requestData.textProfiles.push(profile);
                });
            }
        }

        if (config.qc.enabled && isValidString(config.qc.packageId)) {
            requestData.packageId = config.qc.packageId;
        }

        if (playback.manifestData) {
            dispatch(function() {
                _processManifestResponse(_assembleManifestResponse());
            });
        } else if (config.prepareCadmium && videoPreparer) {
            var manifestRequest = videoPreparer.getCachedData(playback.movieId, 'manifest');

            if (manifestRequest) {
                manifestRequest.
                    then(function(data) { //either the data is ready or the request is in flight
                        playback.manifestData = data;
                        _processManifestResponse(_assembleManifestResponse());
                    }).
                    catch(function(err) { // either data does not exist or expired or the earlier request failed. Try again now
                        _log.warn('manifest not in cache', err);
                        _sendManifestRequest();
                    });
            }
        } else {
            _sendManifestRequest();
        }
    }

    function _getLicense(challenge) {
        return new Promise(function(resolve, reject) {
            var licenseStartTime = clock$getTime(),
                challengeBase64 = base64$encode(challenge.data),
                licenseType = Enums.convertLicenseEnumToString(challenge.licenseType);

            var licenseRequestData = {
                playbackContextId: playback.playbackContextId,
                licenseType: isValidString(challenge.licenseType) ? challenge.licenseType : licenseType,
                drmContextIds: [playback.drmContextId],
                challengeBase64: challengeBase64,
                xid: playback.xid,
                appId: _appId,
                sessionId: _sessionId,
                sessionParams: playback.playbackParams.sessionParams,
                trackingId: playback.trackingId,
                drmType: challenge.drmType
            };

            if (challenge.initdata) {
                licenseRequestData.initdata = base64.encode(challenge.initdata);
            }

            if (playback.controllerESN) {
                licenseRequestData.mdxEsn = playback.controllerESN;
            }

            if (DEBUG || DEV) {
                _log.debug('License challenge data', challengeBase64);
            }

            nccp.getLicense(licenseRequestData, _nccpContext).then(function(result) {
                _licenseTime = clock$getTime() - licenseStartTime;
                try {
                    if (DEBUG || DEV) {
                        _log.debug('License response data', result.licenseResponseBase64);
                        decodeLicenseResponse(result.licenseResponseBase64, licenseRequestData.drmType, function(result) {
                            _log.debug('License response', JSON.stringify(result));
                        });
                    }
                    playback.licenseContextId = result.licenseContextId;
                    resolve({
                        success: true,
                        response: {
                            data: base64$decode(result.licenseResponseBase64)
                        }
                    });
                    _fireLicensed();
                } catch (e) {
                    _log.error('Exception processing license response', e);
                    reject({
                        success: false,
                        errorSubCode: ErrorSubCodes.NCCP_PROCESS_EXCEPTION
                    });
                }
            }).catch(function(err) {
                reject(err);
            });
        });
    }

    function _start() {
        return new Promise(function(resolve, reject) {
            var requestData = {
                playbackContextId: playback.playbackContextId,
                mediaId: _getCurrentMediaId(),
                xid: playback.xid,
                appId: _appId,
                sessionId: _sessionId,
                sessionParams: playback.playbackParams.sessionParams,
                authParams: playback.playbackParams.authParams,
                trackId: playback.trackingId,
                startPosition: _initialMediaTime,
                playbackType: 'standard'
            };

            nccp.start(_nccpContext, requestData).then(function(result) {
                if (result.success) {
                    playback.playbackSessionId = result.playbackSessionId;
                    resolve(SUCCESS);
                } else {
                    reject(result);
                }
            }).catch(function (err) {
                reject(err);
            });
        });
    }

    function _stopAndRelease(requestData) {
        return NccpPlayback$stopAndRelease(_playbackStarted, playback, _nccpContext, requestData);
    }

    function _stop(requestData) {
        return NccpPlayback$stop(_playbackStarted, playback, _nccpContext, requestData);
    }

    function _release(requestData) {
        return NccpPlayback$release(_playbackStarted, playback, _nccpContext, requestData);
    }


    // --------------------------------------------------------------------------------
    // -- Legacy methods

    function _license(challenge, callback) {
        _getLicense(challenge).then(function(result) {
            callback(result);
        }).catch(function(err) {
            callback(err);
        });
    }

    /**
    * @param {function(Object=)=} callback
    */
    function _heartbeat(heartbeatType, callback) {
        var moviePlaybackData = _createPbLifecycleData();
        if (!moviePlaybackData.mediaId || !moviePlaybackData.playbackSessionId) {
            return;
        }

        nccp.heartbeat(moviePlaybackData, heartbeatType, _nccpContext, function (result) {
            if (result.success) {
                _startEventSent = true;
            }
            if (callback) {
                callback(result);
            }
        });
    }

    /**
     * Sends the engage command to the server. This is used for playback initiation
     * and is sent when a user decides to continue to play a title that the UX 
     * started on its own accord.
     * 
     * @param {string}      action      The input paramters to the server 
     *                                  command. The value for action can be
     *                                  'MDP_Timer'
     * @returns {Promise}               Called on completion, 'success' 
     *                                  will be true on success, on failure
     *                                  'success' will be false and 'error' 
     *                                  will have failure information
    */
    function _engage(action) {
        var request = _createPbLifecycleData();
        if (!request.mediaId || !request.playbackSessionId) {
            return Promise.resolve({ success: true });
        }

        request.action = action;
        return nccp.engage(_nccpContext, request);
    }
    // --------------------------------------------------------------------------------

    /**
    * @param {function(Object=)=} callback
    */
    function _playdata(moviePlaybackData, callback) {
        nccp.playdata(moviePlaybackData, _nccpContext, function (result) {
            if (callback) {
                callback(result);
            }
        });
    }

    /**
    * @param {function(Object=)=} callback
    */
    function _createPlaydataRequest(moviePlaybackData, callback) {
        nccp.createPlaydataRequest(moviePlaybackData, _nccpContext, callback);
    }

    // --------------------------------------------------------------------------------

    function _createPbLifecycleData() {
        var requestData = {
            accountKey: _accountKey,
            playbackContextId: playback.playbackContextId,
            playbackSessionId: playback.playbackSessionId,
            licenseContextId: playback.licenseContextId,
            xid: playback.xid,
            movieId: playback.movieId,
            mediaId: _getCurrentMediaId(),
            playback: _getPlayTimes(),
            timestamp: nccp.getServerEpoch()
        };

        // We only want to send position if the playbck session has been
        // created and we have a valid position.
        if (playback.playbackSessionId && isNumber(playback.mediaTime.value)) {
            requestData.position = playback.mediaTime.value;
        }

        // We are only interested in storing the EME key session id
        // if we have a session and secure stop is enabled.
        if (_keySessionId && config.secureStopEnabled) {
            requestData.keySessionId = _keySessionId;
        }

        var fatalError = playback.fatalError;
        if (fatalError && isValidString(fatalError.displayCode)) {
            requestData.success = false;
            requestData.errorDisplayCode = fatalError.displayCode;
        }

        if (DEBUG) {
            _log.debug('Creating stop request data', stringifyJsonPretty(requestData));
        }

        return requestData;
    }

    // --------------------------------------------------------------------------------
    // -- Helper methods

    function _getPlayTimes() {

        // If playback has started return all the pertinent data, however
        // if playback has not started but we do have an xid and playback 
        // context then we need to send a play duration of 0 seconds

        if (_playbackStarted) {
            return {
                'startPosition': _initialMediaTime,
                'startEpoch': _initialMediaTimeEpoch,
                'playTimes': playback.playTimeTracker.getPlayTimeByDownloadableId()
            };
        } else if (playback.playbackContextId && playback.xid) {
            return {
                'playTimes': {'total': 0 }
            };
        }
    }

    // -- Search through the mediaList to get the mediaId that corresponds to the currently
    // -- selected audio, video, and timed text tracks.
    function _getCurrentMediaId() {
        var selectedTrackId = {},
            mediaId,
            i,
            atv = playback.audioTrack.value,
            vtv = playback.videoTrack.value,
            ttv = playback.timedTextTrack.value;

        if (!(atv && vtv && ttv)) {
            return;
        }

        // Make a structure and function to identify when all three currently
        // selected audio, video, and text tracks match the set provided.
        selectedTrackId[NccpPlayback$AUDIOTYPE] = atv.trackId;
        selectedTrackId[NccpPlayback$VIDEOTYPE] = vtv.trackId;
        selectedTrackId[NccpPlayback$TIMEDTEXTTYPE] = ttv.trackId;
        function reduceFxn(acc, track) {
            if (track.type == NccpPlayback$TRICKPLAYTYPE) {  // skip TRICKPLAY tracks; same for all media
                return acc;
            }
            return acc && (track.id == selectedTrackId[track.type]);
        };

        // Find the media id that corresponds to the tuple of the currently selected video, audio,
        // and timed text track ids.
        for (i = 0; i < playback.mediaList.length; i++) {
            var found = playback.mediaList[i]['tracks'].reduce(reduceFxn, true);
            if (found) {
                mediaId = playback.mediaList[i]['mediaId'];
                break;
            }
        }
        return mediaId;
    }

    function _mediaSplice() {
        var moviePlaybackData = _createPbLifecycleData();
        if (!moviePlaybackData.mediaId || !moviePlaybackData.playbackSessionId) {
            return;
        }
        nccp.mediaSplice(moviePlaybackData, _nccpContext, function (result) {
            if (result.success) {
                _log.trace('Spliced new mediaId ' + moviePlaybackData.mediaId);
            } else {
                _log.error('Media splice failed', ErrorSubCodes$errorResultToLogFields(result));
            }
        });
    }

    function _fireLicensed() {
        // this should fire only once
        _fireLicensed = NOOP;
        NccpPlayback$upgradeNetflixIdCookie(playback, _nccpContext, _log);
        playback.fireEvent(Playback$licensed);
    }

    function _fireAuthorized() {
        // this should fire only once
        _fireAuthorized = NOOP;
        playback.fireEvent(Playback$authorized);
    }

    // --------------------------------------------------------------------------------
}

// 'AUDIO', 'VIDEO', 'TEXT', and 'TRICKPLAY' text labels are used in the manifest
// object returned from the server, to define the track type for each track in a
// media object from the mediaList in the manifest.
var NccpPlayback$AUDIOTYPE = 'AUDIO';
var NccpPlayback$VIDEOTYPE = 'VIDEO';
var NccpPlayback$TIMEDTEXTTYPE = 'TEXT';
var NccpPlayback$TRICKPLAYTYPE = 'TRICKPLAY';

function NccpPlayback$upgradeNetflixIdCookie(playback, nccpContext, log) {
    NccpPlayback$upgradeNetflixIdCookie = NOOP;

    if (!NRDP_USES_BROWSER_ACCOUNT) {
        return;
    }

    if (!config.upgradeNetflixId) {
        return;
    }

    // Always update the netflix ID cookie, with the HTTPOnly flag set we will never
    // know if we have a cookie that is not device bound.
    nccp.bindNetflixId(nccpContext).then(function(result) {
        log.trace('Updated NetflixId');
    }).catch(function(err) {
        log.error('NetflixId upgrade failed', ErrorSubCodes$errorResultToLogFields(err));
    });
}


function NccpPlayback$stopAndRelease(playbackStarted, playbackContext, edgeContext, requestData) {
    return new Promise(function (resolve, reject) {
        var stopPromise = NccpPlayback$stop(playbackStarted, playbackContext, edgeContext, requestData),
            releasePromise = NccpPlayback$release(playbackStarted, playbackContext, edgeContext, requestData);

        Promise.all([stopPromise, releasePromise])
            .then(function (values) {
                // We are only interested in the results from the release
                // promise so only resolve with that result.
                // The secure stop data comes back in a result object, the
                // emeSessions would like it in the releaseData property so
                // return it in that format.
                if (values.length > 1 && values[1].response && values[1].response.data) {
                    resolve({ releaseData: values[1].response.data });
                } else {
                    resolve({ releaseData: undefined });
                }
            })
            .catch(function (err) {
                reject(err);
            });
    });
}

function NccpPlayback$stop(playbackStarted, playbackContext, edgeContext, requestData) {
    if (playbackStarted || (playbackContext.playbackContextId && playbackContext.xid)) {
        return nccp.stop(edgeContext, mixIn(requestData, {
            playbackContextId: playbackContext.playbackContextId,
            xid: playbackContext.xid
        }));
    } else if (requestData.playbackContextId && requestData.xid) {
        return nccp.stop(edgeContext, requestData);
    } else {
        return Promise.resolve({
            success: true
        });
    }
}

function NccpPlayback$release(playbackStarted, playbackContext, edgeContext, requestData) {
    if (playbackStarted || (playbackContext.xid && playbackContext.licenseContextId)) {
        return nccp.release(edgeContext, mixIn(requestData, {
            xid: playbackContext.xid,
            licenseContextId: playbackContext.licenseContextId
        }));
    } else if (requestData.xid && requestData.licenseContextId) {
        return nccp.release(edgeContext, requestData);
    } else {
        return Promise.resolve({
            success: true
        });
    }
}



// -- player-nccp/NccpLogMessage.js
/**
* @constructor
* @param {Object=} data
*/
function NccpLogMessage(playback, type, sev, data) {
    data = data || {};

    debug$assert(
        data['jssid'] === undefined &&
        data['client_utc'] === undefined &&
        data['type'] === undefined &&
        data['sev'] === undefined &&
        data['lver'] === undefined &&
        data['xid'] === undefined &&
        data['mid'] === undefined &&
        data['esn'] === undefined &&
        data['snum'] === undefined &&
        data['lnum'] === undefined);

    if (config.groupName) {
        data['groupname'] = config.groupName;
    }

    var clientEpoch = clock$getEpoch();
    var logData = {
        'type': type,
        'sev': sev,
        'devmod': DEVICE_MODEL
    };

    if (NCCP_NETTYPE) {
        logData['nettype'] = NCCP_NETTYPE;
    }

    mixIn(logData, data);

    mixIn(logData, {
        'jssid': JSSID,
        'jsoffms': clock$getTime(),
        'client_utc': clientEpoch,
        'lver': NCCP_LOG_VERSION || '2012.2-CAD'
    });
    var xidFieldName = (type === 'startup') ? 'playbackxid' : 'xid';
    
    // Log playback specific fields only if we have a current playback.
    // For prepare/startup logblob, when there is no playback,
    if (playback) {
        mixIn(logData, {
            'soffms': playback.getRelativeTime(),
            'mid': playback.movieId,
            'lvpi': playback.logVerbosePlaybackInfo,
            'uiLabel': playback.uiLabel || ''
        });
        logData[xidFieldName] = playback.xid;
    }

    this.data = logData;
    this.type = type;
    this.clientEpoch = clientEpoch;
}


NccpLogMessage.prototype.getCsvData = function () {
    if (!this._csvData) {
        this._csvData = makeCsv(this.data);
    }
    return this._csvData;
};


// -- player-nccp/NccpLogging.js
/// <reference path="./typings/logblob/endplay.d.ts"/>

/**
* @constructor
*/
function NccpLogging(playback) {
    var _log = new playback.log.CategoryLog('NccpLogging'),
        _xid = playback.xid,
        _mid = playback.movieId,
        _nccpPlayback = playback.nccpPlayback,
        _playbackStarted,
        _lastPaused = playback.paused.value,
        _waitingForResumeSince,
        _lastAudioTrack,
        _lastAudioTrackChangedOn,
        _lastCdn,
        _resumingFrom,
        _lastPresentingStateStateChangeOn,
        _timeSpentInPresentingState = [],
        _reposSeq = 0,
        _intrplaySeq = 0,
        _midplaySeq = 0,
        _downloadReportIntervalId = 0,
        _downloadReportDownloads = [],
        _initialLogFlushTimerId,
        _maxBitrate,
        _maxResolutionHeight,
        _secureStopManager,
        _secureStopInitiated,
        _throughputTracker = new DefaultThroughputTracker(new DefaultThroughputConfig()),
        _cdnThroughputTracker = new CDNThroughputTrackerImpl(new DefaultThroughputConfig(), IsType, DefaultThroughputTracker);

    var utils = require(4);

    debug$assert(_nccpPlayback);
    debug$assert(nccpLogBatcher);

    _startMonitoringPlayback();

    this.secureStopMessage = _secureStop;
    // --------------------------------------------------------------------------------
    // -- Log Messages

    function _startplay(isError) {
        var data = {
            'browserua': userAgent,
            'browserhref': location['href'],
            'playdelaysdk': NccpClient$formatMillisecond(playback.getRelativeTime()),
            'playdelay': NccpClient$formatMillisecond(playback.calculatePlayDelay()),
            'trackid': playback.trackingId,
            'connection_type': config.connectionStrategy === 'parallel' ? 'multi' : 'single',
            'bookmark': NccpClient$formatMillisecond(playback.bookmarkTime || 0),
            'pbnum': playback.index,
            'endianness': getEndianness()
        };

        if (!config.endpoint) {
            data['configendpoint'] = 'error';
        }

        if (playback.playbackContextId) {
            data['playbackcontextid'] = playback.playbackContextId;
        }

        if (playback.controllerESN) {
            data['controllerESN'] = playback.controllerESN;
        }

        if (isNumber(playback.bookmarkTimeActual)) {
            data['bookmarkact'] = NccpClient$formatMillisecond(playback.bookmarkTimeActual);
        }

        if (isNumber(playback.bookmarkTimeActual)) {
            data['bookmarkact'] = NccpClient$formatMillisecond(playback.bookmarkTimeActual);
        }

        var nccpat = _nccpPlayback.getAuthorizationTime();
        if (nccpat) {
            data['nccpat'] = nccpat;
        }

        var nccplt = _nccpPlayback.getLicenseTime();
        if (nccplt) {
            data['nccplt'] = nccplt;
        }

        var downloadables = _downloadables();
        if (downloadables) {
            data['downloadables'] = downloadables;
        }

        if (device && isDefined(device.esnSource)) {
            data['esnSource'] = device.esnSource;
        }

        if (PLATFORM_EXTRA_INFO) {
            mixIn(data, PLATFORM_EXTRA_INFO, { prefix: 'pi_' });
        }

		if (config.enableCongestionService) {
			data['congested'] = congestionService && congestionService.getCongestion() && congestionService.getCongestion()['isCongested'];
		}

		var nettype = window['navigator'] && window['navigator']['connection'] && window['navigator']['connection']['type'];
		if (nettype) {
			data['nettype'] = nettype;
		}

        // track whether we use JS-ASE
        data['usejsase'] = config.useASE;

        if (playback.initSelReason) {
            data['initSelReason'] = playback.initSelReason;
        }

        if (playback.histbw) {
            data['histbw'] = playback.histbw;
        }

        if (playback.buffCompleteReason) {
            data['bcreason'] = playback.buffCompleteReason;
        }

        // get max bitrate for this title
        if (playback.state.value >= Playback$STATE_NORMAL) {
            try {
                var streams = playback.createFilteredVideoStreamList();
                if (streams) {
                    var bitrates = CadmiumMediaStream$getAvailableBitrates(streams);
                    _maxBitrate = Array$max(bitrates);
                    _maxResolutionHeight = CadmiumMediaStream$getMaxHeight(streams);
                    data['maxbitrate'] = _maxBitrate;
                    data['maxresheight'] = _maxResolutionHeight;
                }
            } catch (e) {
                _log.error('Exception computing max bitrate', e);
            }
        }

        try {
            var pdltime = getPlayerDownloadTime();
            if (pdltime) {
                data['pdltime'] = pdltime;
            }
        } catch (e) {
        }

        try {
            // track custom milestines
            mixIn(data, playback.milestones, { prefix: 'sm_' });

            // track video diags
            mixIn(data, playback.getVideoDiagInfo(), { prefix: 'vd_' });
        }
        catch (e) {
        }

		if (typeof nrdp !== 'undefined' && nrdp['device']) {
			data['firmware_version'] = nrdp['device']['firmwareVersion'];
		}

        if(isError && playback.psshb64){
            data['pssh'] = playback.psshb64;
        }

        if (playback.emeSession && playback.emeSession.mediaKeys && playback.emeSession.mediaKeys['keySystem']) {
            data['keysys'] = playback.emeSession.mediaKeys['keySystem'];
        }
        if (config.prepareCadmium && videoPreparer) {
            try {
                var prepareData = {},
                    stats = videoPreparer.getStats(undefined, undefined, playback.movieId),
                    absoluteStartTime = playback.getAbsoluteStartTime(),
                    completedTasks = stats.tasks.completed;

                prepareData['attempts'] = stats.prepareAttempts || 0;
                prepareData['num_completed_tasks'] = completedTasks.length;

                //window['console']['table'](completedTasks);

                var epoch = clock$getPreciseAppEpoch(),
                    filterBy = utils.filterBy,
                    prepareEvents = {},
                    TASK_SUCCEEDED = Enums.PREPARE_TASK_STATUS.SUCCEEDED,
                    TASK_FAILED = Enums.PREPARE_TASK_STATUS.FAILED;
                if (stats.firstTimeAdded) {
                    prepareEvents['scheduled'] = stats.firstTimeAdded - absoluteStartTime;
                }

                var manifestData = playback.manifestData;
                if (manifestData && isDefined(manifestData.requestStartTimePrepare)) {
                    prepareEvents['preauthsent'] = manifestData.requestStartTimePrepare - playback.loadTime;
                    prepareEvents['preauthreceived'] = manifestData.requestEndTimePrepare - playback.loadTime;
                }

                var manifests = completedTasks.filter(filterBy('type', 'manifest'));
                prepareData['mf_succ'] = manifests.filter(filterBy('status', TASK_SUCCEEDED)).length;
                prepareData['mf_fail'] = manifests.filter(filterBy('status', TASK_FAILED)).length;


                var milestones = playback.milestones;
                if (isDefined(milestones['lg']) && milestones['lg'] < 0 && playback.loadTime) {
                    prepareEvents['ldlsent'] = milestones['lc'] ;
                    prepareEvents['ldlreceived'] = milestones['lr'];
                }
                var ldls = completedTasks.filter(filterBy('type', 'ldl'));
                prepareData['ldl_succ'] = ldls.filter(filterBy('status', TASK_SUCCEEDED)).length;
                prepareData['ldl_fail'] = ldls.filter(filterBy('status', TASK_FAILED)).length;

                mixIn(data, prepareData, {
                    prefix: 'pr_'
                });
                data['eventlist'] = JSON.stringify(prepareEvents);
                if (DEBUG) {
                    log.trace('prepare eventlist', data['eventlist']);
                    log.trace('prepare data', prepareData);
                }
                _includePrepareStats(data);

            } catch (e) {
                 _log.warn('error in collecting video prepare data', e);
            }
        }


        data['avtp'] = _throughputTracker.getThroughput().throughputKbps;
        if (config.useASE && playback.streamingManager){
            _includeASEThroughputStats(data);
        }
        _includeHttpStats(data);
        _includeMemoryStats(data);
        _includeKeyStatusesData(data);
        _queueLogMessage('startplay', isError, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_PRESENTEDSTREAMS | NccpLogging$COMMON_BUFFER | NccpLogging$COMMON_SCREEN | NccpLogging$COMMON_CPU | NccpLogging$COMMON_CDN | NccpLogging$COMMON_FATALERROR, data);
    }

    function _resumeplay(playdelay) {
        _queueLogMessage('resumeplay', false, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_PRESENTEDSTREAMS | NccpLogging$COMMON_BUFFER, {
            'playdelay': NccpClient$formatMillisecond(playdelay),
            'reason': _resumingFrom,
            'intrplayseq': (_intrplaySeq - 1) // get sequence number of latest intrplay event
        });

        if(_resumingFrom == 'rebuffer'){
            playback.playTimeTracker.addIntrplayWaitTimeMs(NccpClient$formatMillisecond(playdelay));
        }
        // TODO: initialbw, initialbt, actualbw, actualbt
        // TODO: how can this be an error? spec says to log error stuff...
    }

    function _chgstrm(videoStreamOld, videoStream, chunkStartTime, streamTput, networkMonitorTput) {
        var lbw;
        if (config.useASE) {
            lbw = playback.throughput;
        } else {
            lbw = playback.bandwidthMeter.calculateNormalizedBandwidth();
        }

        var data = {
            'moff': NccpClient$formatSeconds(chunkStartTime),
            'vbitrate': videoStream.bitrate,
            'vbitrateold': videoStreamOld.bitrate,
            'vdlid': videoStream.downloadableId,
            'vdlidold': videoStreamOld.downloadableId,
            'lbw': lbw
        };

        if (streamTput > 0){
            //predicted throughput (discounted throughput)
            data['stput'] = streamTput;
        }

        if (networkMonitorTput > 0){
            //average throughput in network monitor (smoothed by EWMA by default)
            data['nmtput'] = networkMonitorTput;
        }

        var video = playback.downloadedVideo.value;
        if (video) {
            // if we have a downloaded video, then use that as our short term bw
            var latencyAndThroughput = calculateLatencyAndThroughput(video.downloadMeasurements);
            data['bw'] = calculateNormalizedBandwidth(latencyAndThroughput.latency, latencyAndThroughput.throughput);
        } else {
            // otherwise, short term bw and long term bw are the same
            data['bw'] = lbw;
        }

        _queueLogMessage('chgstrm', false, NccpLogging$COMMON_BUFFER, data);
    }

    function _renderstrmswitch(videoStreamOld, videoStream, mediaTime) {
        _queueLogMessage('renderstrmswitch', false, NccpLogging$COMMON_BUFFER, {
            'moff': NccpClient$formatSeconds(mediaTime),
            'vbitrate': videoStream.bitrate,
            'vdlidold': videoStreamOld.downloadableId,
            'vdlid': videoStream.downloadableId,
            'vbitrateold': videoStreamOld.bitrate
        });
    }

    function _playbackaborted_startplay() {
        var data = {
            'waittime': NccpClient$formatMillisecond(playback.getRelativeTime()),
            'abortedevent': 'startplay'
        };

        var videoStream = playback.videoStream;
        if(videoStream && videoStream.value) {
            data['vbitrate'] = videoStream.value.bitrate;
        }

        try {
            var pdltime = getPlayerDownloadTime();
            if (pdltime) {
                data['pdltime'] = pdltime;
            }

            mixIn(data, playback.milestones, { prefix: 'sm_' });
        } catch (e) { }

        var debugASE = config.debugAseDenominator && !(_xid % config.debugAseDenominator);
        if (debugASE && playback.streamingSession && playback.streamingSession._pipelines){
            var vp = playback.streamingSession._pipelines[playback.streamingManager.MEDIA_VIDEO],
                ap = playback.streamingSession._pipelines[playback.streamingManager.MEDIA_AUDIO];
            if (vp && ap){
                data['ASEvstreamingPts'] = vp.streamingPts;
                data['ASEastreamingPts'] = ap.streamingPts;
                data['ASEvbuflevelBytes'] = vp.bufferLevelBytes;
                data['ASEabuflevelBytes'] = ap.bufferLevelBytes;
                data['ASEvbuflevelMs'] = vp.bufferLevelMs;
                data['ASEabuflevelMs'] = ap.bufferLevelMs;
                data['ASEaudioSentData'] = JSON.stringify(ap.requestManager._sentData);
                data['ASEvideoSentData'] = JSON.stringify(vp.requestManager._sentData);
                data['ASEaudioToAppend'] = JSON.stringify(ap.bufferManager._toAppend);
                data['ASEvideoToAppend'] = JSON.stringify(vp.bufferManager._toAppend);
            }
        }

        _queueLogMessage('playbackaborted', false, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_BUFFER, data);
    }

    function _playbackaborted_resumeplay(waittime, resumeplayreason) {
        var additionalLogs = {
            'waittime': NccpClient$formatMillisecond(waittime),
            'abortedevent': 'resumeplay',
            'resumeplayreason': resumeplayreason
        };

        var videoStream = playback.videoStream;
        if(videoStream && videoStream.value) {
            additionalLogs['vbitrate'] = videoStream.value.bitrate;
        }
        _queueLogMessage('playbackaborted', false, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_BUFFER, additionalLogs);
    }

    function _statechanged(oldPaused, newPaused) {
        // TODO: should this be send when media ends?
        _queueLogMessage('statechanged', false, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_BUFFER, {
            'newstate': newPaused ? 'Paused' : 'Playing',
            'oldstate': oldPaused ? 'Paused' : 'Playing'
        });
    }

    function _intrplay(timeSpentPlaying, timeSpentPaused, cause) {
		var data = {
            'vdlid': playback.videoStream.value.downloadableId,
            'cdnid': playback.cdn.value.id,
            // non-standard fields: since last rebuffer, how much time was spent playing and how much time paused
            'playingms': timeSpentPlaying,
            'pausedms': timeSpentPaused,
            'cause': cause,
            'intrplayseq': _intrplaySeq++
        };

		if (config.enableCongestionService) {
			data['congested'] = congestionService && congestionService.getCongestion() && congestionService.getCongestion()['isCongested'];
		}

        var debugASE = config.debugAseDenominator && !(_xid % config.debugAseDenominator);
        if (debugASE && playback.streamingSession && playback.streamingSession._pipelines){
            var vp = playback.streamingSession._pipelines[playback.streamingManager.MEDIA_VIDEO],
                ap = playback.streamingSession._pipelines[playback.streamingManager.MEDIA_AUDIO];
            if (vp && ap){
                data['ASEvstreamingPts'] = vp.streamingPts;
                data['ASEastreamingPts'] = ap.streamingPts;
                data['ASEvbuflevelBytes'] = vp.bufferLevelBytes;
                data['ASEabuflevelBytes'] = ap.bufferLevelBytes;
                data['ASEvbuflevelMs'] = vp.bufferLevelMs;
                data['ASEabuflevelMs'] = ap.bufferLevelMs;
                data['ASEaudioSentData'] = JSON.stringify(ap.requestManager._sentData);
                data['ASEvideoSentData'] = JSON.stringify(vp.requestManager._sentData);
                data['ASEaudioToAppend'] = JSON.stringify(ap.bufferManager._toAppend);
                data['ASEvideoToAppend'] = JSON.stringify(vp.bufferManager._toAppend);
            }
        }

        data['avtp'] = _throughputTracker.getThroughput().throughputKbps;
        if (config.useASE && playback.streamingManager){
            _includeASEThroughputStats(data);
        }
        _queueLogMessage('intrplay', false, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_BUFFER, data);
    }

    function _repos(oldMediaTime) {
        _queueLogMessage('repos', false, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_BUFFER, {
            'moffold': NccpClient$formatSeconds(oldMediaTime),
            'reposseq': _reposSeq++
        });
        // TODO: navt
    }

    function _audioswitch() {
        _queueLogMessage('audioswitch', false, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_BUFFER, {
            'switchdelay': NccpClient$formatMillisecond(clock$getTime() - _lastAudioTrackChangedOn),
            'newtrackinfo': playback.audioTrack.value.trackId,
            'oldtrackinfo': _lastAudioTrack.trackId
        });
    }

    function _bitrateRestriction(bitrateRestrictionInfo) {
        _queueLogMessage('bitraterestriction', false, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_BUFFER, bitrateRestrictionInfo);
    }

    // todo: fix _cdnsel() to use bandwidth meter for throughput.
    function _cdnsel(oldCdn, newCdn, downloadMeasurements, serverSelReason) {
        var selcdnid = newCdn.id,
            data = {
                'selcdnid': selcdnid
            };

        if (downloadMeasurements) {
            var bw = calculateLatencyAndThroughput(downloadMeasurements),
                selcdnrtt = bw.latency,
                selcdnbw = calculateNormalizedBandwidth(bw.latency, bw.throughput);

            data['selcdnrtt'] = selcdnrtt;
            data['selcdnbw'] = selcdnbw;
            data['cdnbwdata'] = JSON.stringify([
                {
                    'id': selcdnid,
                    'rtt': selcdnrtt,
                    'bw': selcdnbw
                }
            ]);
        }

        if (oldCdn) {
            data['oldcdnid'] = oldCdn.id;
        }

        if (serverSelReason) {
            data['selreason'] = serverSelReason;
        }

        mixIn(data, newCdn.cdnsel);

        _queueLogMessage('cdnsel', false, NccpLogging$COMMON_CDN, data);
    }

    function _dlreport() {
        //playback.cdnList can be undefined if the nccp authorization response hasn't arrived yet.
        if (!playback.cdnList) {
            return;
        }

        try {
            var errorOnly = false;

            if (_xid % config.downloadReportDenominator) {
                errorOnly = true;

                _downloadReportDownloads = _downloadReportDownloads.filter(function (download) {
                    return !download.success;
                });
            }

            if(_downloadReportDownloads.length > 0) {
                var data = constructDownloadReport(_downloadReportDownloads, playback.relativeLoadTime);
                _downloadReportDownloads = [];

                data['erroronly'] = errorOnly;

                // add tcpinfo fields if specified in the config
                if (config.downloadReportTcpInfo.length) {
                    data['tcpinfo'] = config.downloadReportTcpInfo.join(',')
                }

                enumerateOwnProperties(data, function(k, v) {
                    data[k] = JSON.stringify(v);
                });

                _queueLogMessage('dlreport', false, NccpLogging$COMMON_BUFFER, data);
            }
        } catch (e) {
            _log.error('Exception in dlreport.', e);
        }
    }

    function _dlreq(response) {
        var request = response.request,
            track = request.track;

        if (track) {
            // aborted download is not an error
            var isError = !response.success && (response.errorSubCode != ErrorSubCodes.HTTP_ABORT),
                dltype = track.type,
                measurements = response.measurements;

            if (isError || playback.logVerbosePlaybackInfo) {

                var data = {
                    'dltype': dltype,
                    'url1': request.url,
                    'url2': response.url || '',
                    'cdnid': request.cdn.id,
                    'tresp': NccpClient$formatMillisecond(measurements.responseStartTime - measurements.requestTime),
                    'brecv': NccpClient$formatInt(measurements.contentLength),
                    'trecv': NccpClient$formatMillisecond(measurements.responseEndTime - measurements.responseStartTime)
                };

                if (response.range) {
                    data['range'] = response.range;
                }

                switch (dltype) {
                    case CadmiumMediaStream$AUDIO:
                        data['adlid'] = request.stream.downloadableId;
                        break;
                    case CadmiumMediaStream$VIDEO:
                        data['vdlid'] = request.stream.downloadableId;
                        break;
                    case CadmiumMediaStream$TIMEDTEXT:
                        data['ttdlid'] = track.downloadableId;
                        break;
                }

                var nwerr = NccpLogging$_nwerr(response.errorSubCode);
                if (nwerr) {
                    data['nwerr'] = nwerr;
                }
                if (response.errorHttpCode) {
                    data['httperr'] = response.errorHttpCode;
                }

                _queueLogMessage('dlreq', isError, NccpLogging$COMMON_BUFFER, data);
            }
        };
    }

    function _dlprestart() {
        // cadmium only, originally added for troubleshooting Chromecast startup delays
        // we log all the performance.getEntries('resource') to log all the downloads that might
        // have delayed startup
        // This should ideally include things like:
        //   - time it took to download very this javascript file
        //   - API call to get the current episode ID, that haappens before authorization
        //   - blade image download that happens in parallel to header downloads.
        try {
            var timeOffset = performance['timing']['navigationStart'] - (clock$genesis() + (playback.loadTime || clock$getTime()));
            var timings = performance['getEntries']('resource');
            // take last dlprestartCount entries
            var d = timings.length - config.dlprestartCount;
            if (d > 0) {
                timings = timings.slice(d);
            }
            var dlinfos = timings.map(function (t) {
                return {
                    'u': t['name'],
                    's': Math$round(t['startTime'] + timeOffset),
                    'd': Math$round(t['duration'])
                }
            });
            var data = {
                'dlinfos': JSON.stringify(dlinfos)
            };
            _queueLogMessage('dlprestart', false, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_BUFFER, data);
        } catch (e) {
        }
    }

    function _midplay() {
        if (playback.state.value == Playback$STATE_NORMAL) {
            var data = _playbackQuality();

            if (config.reportThroughputInLogblobs) {
                data['avtp'] = _throughputTracker.getThroughput().throughputKbps;
                if (config.useASE && playback.streamingManager){
                    _includeASEThroughputStats(data);
                }
            }

            data['midplayseq'] = _midplaySeq++;
            var presentingState = playback.presentingState.value;
            data['prstate'] =
                (presentingState == PresentingState$PLAYING) ? 'playing' :
                (presentingState == PresentingState$PAUSED) ? 'paused' :
                (presentingState == PresentingState$ENDED) ? 'ended' :
                'waiting';

            _includeSubtitleQoeScore(data);
            if (config.prepareCadmium && videoPreparer) {
                _includePrepareStats(data);
            }
            _includeHttpStats(data);
            _includeMemoryStats(data);
            _queueLogMessage('midplay', false, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_BUFFER | NccpLogging$COMMON_CPU | NccpLogging$COMMON_SCREEN, data);
        }
    }

    function _endplay(error) {
        var data = _playbackQuality();
        var cdnThroughputs = [];

        data['browserua'] = userAgent;

        // track whether we use JS-ASE
        data['usejsase'] = config.useASE;
        // track trickplay stats
        if (playback.trickPlay && playback.trickPlay.getStatus() === 'downloaded') {
            data['trickplay_ms'] = playback.trickplayStats.offset; // offset at which trickplay was downloaded
            data['trickplay_res'] = playback.trickplayStats.res; // resolution which trickplay was downloaded
        }

        if (config.reportThroughputInLogblobs) {
            _cdnThroughputTracker.getCDNThroughputs().forEach(function (cdnThroughput) {
                cdnThroughputs.push({
                    'cdnid': cdnThroughput.cdnId,
                    'avtp': cdnThroughput.throughputKbps,
                    'tm': cdnThroughput.downloadTimeMs
                });
            });

            data['avtp'] = _throughputTracker.getThroughput().throughputKbps;
            data['cdnavtp'] = cdnThroughputs;
            if (config.useASE && playback.streamingManager) {
                _includeASEThroughputStats(data);
            }
        }

        data['endreason'] = error ? 'error' : (playback.presentingState.value == PresentingState$ENDED ? 'ended' : 'stopped');
        if (PLATFORM_EXTRA_INFO) {
            mixIn(data, PLATFORM_EXTRA_INFO, { prefix: 'pi_' });
        }
        var fatalError = playback.fatalError;
        var sev;
        if (error && fatalError && ErrorCodes$isNotSevere(fatalError.errorCode)) {
            // some error codes aren't severe, threa them as such
            sev = 'info';
        }

        try {
            mixIn(data, playback.milestones, {
                prefix: 'sm_'
            });
        } catch (e) {}

        var debugASE = config.debugAseDenominator && !(_xid % config.debugAseDenominator);
        if (debugASE && playback.streamingSession && playback.streamingSession._pipelines){
            var vp = playback.streamingSession._pipelines[playback.streamingManager.MEDIA_VIDEO],
                ap = playback.streamingSession._pipelines[playback.streamingManager.MEDIA_AUDIO];
            if (vp && ap){
                data['ASEvstreamingPts'] = vp.streamingPts;
                data['ASEastreamingPts'] = ap.streamingPts;
                data['ASEvbuflevelBytes'] = vp.bufferLevelBytes;
                data['ASEabuflevelBytes'] = ap.bufferLevelBytes;
                data['ASEvbuflevelMs'] = vp.bufferLevelMs;
                data['ASEabuflevelMs'] = ap.bufferLevelMs;
                if (sev !== 'info' && error){
                    data['ASEaudioSentData'] = JSON.stringify(ap.requestManager._sentData);
                    data['ASEvideoSentData'] = JSON.stringify(vp.requestManager._sentData);
                    data['ASEaudioToAppend'] = JSON.stringify(ap.bufferManager._toAppend);
                    data['ASEvideoToAppend'] = JSON.stringify(vp.bufferManager._toAppend);
                }
                if (vp.requestManager._shortDownloads.length > 0) {
                    data['ASEvshortDownloads'] = JSON.stringify(vp.requestManager._shortDownloads);
                }
                if (ap.requestManager._shortDownloads.length > 0) {
                    data['ASEashortDownloads'] = JSON.stringify(ap.requestManager._shortDownloads);
                }
            }

        }

        _includeSubtitleQoeScore(data);
        if (config.prepareCadmium && videoPreparer) {
            _includePrepareStats(data);
        }
        _includeHttpStats(data);
        _includeMemoryStats(data);
        _includeKeyStatusesData(data);
        _includeDecoderQuotaExceededStat(data);
        _queueLogMessage('endplay', error, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_PRESENTEDSTREAMS | NccpLogging$COMMON_BUFFER | NccpLogging$COMMON_CPU | NccpLogging$COMMON_SCREEN | NccpLogging$COMMON_FATALERROR, data, sev);
    }

    function _subtitleError(data){
        var result = shallowCopy(data);
        if(result['details']){
            result['details'] = JSON['stringify'](result['details']);
        }
        _queueLogMessage('subtitleerror', true, NccpLogging$COMMON_MOFF | NccpLogging$COMMON_PRESENTEDSTREAMS | NccpLogging$COMMON_CDN, result);
    }

    // --------------------------------------------------------------------------------
    // -- complex values

    function _downloadables() {
        if (playback.videoTrackList && playback.audioTrackList) {
            var downloadables = [];
            playback.videoTrackList.concat(playback.audioTrackList).forEach(function (t) {
                t.streams.forEach(function (stream) {
                    downloadables.push({
                        'dlid': stream.downloadableId,
                        'type': stream.type,
                        'bitrate': stream.bitrate
                    });
                });
            });
            // TODO: do we need timed text tracks here?
            return JSON.stringify(downloadables);
        }
    }

    function _cdnplayback() {
        var entries = playback.playTimeTracker.getAudioVideoPlayTimeByCdnAndDownloadableId();
        var cdnplayback = [];
        var cdnMap = {};

        entries.audio.forEach(function (entry) {
            buildCdnPlayback(entry, 'adlid') // audio download id
        });

        entries.video.forEach(function (entry) {
            buildCdnPlayback(entry, 'dlid')  // video download id
        });

        function buildCdnPlayback(entry, downloadType) {
            var cdnId = entry['cdnId'],
                cdn = cdnMap[cdnId],
                vmaf = entry['vmaf'];

            if (!cdn) {
                cdn = {
                    'cdnid': cdnId,
                    'dls': []
                };
                cdnMap[cdnId] = cdn;
                cdnplayback.push(cdn);
            }

            debug$assertUInt(entry['bitrate']);
            debug$assertUInt(entry['duration']);

            var download = {
                'bitrate': entry['bitrate'],
                'tm': NccpClient$formatMillisecond(entry['duration'])
            };

            if (vmaf) {
                debug$assertUInt(entry['vmaf']);
                download['vf'] = vmaf;
            }

            download[downloadType] = entry['downloadableId'];

            cdn['dls'].push(download);
        }

        return JSON.stringify(cdnplayback);
    }

    function _playbackQuality() {
        var playTimeTracker = playback.playTimeTracker;

        var data = {
            'totaltime': NccpClient$formatSeconds(playTimeTracker.getTotalPlayTime()),
            'cdndldist': _cdnplayback(),
            'reposcount': _reposSeq,
            'intrplaycount': _intrplaySeq
        };

        try {
            var playqualvideo = {
                // html5 never skips
                'numskip': 0,
                // html5 doesn't render at low quality
                'numlowqual': 0
            };
            var mediaPresenter = playback.mediaPresenter;
            var n;

            n = mediaPresenter.getFrameCount();
            if (isNumber(n)) {
                data['totfr'] = n;
                playqualvideo['numren'] = n;
            }

            n = mediaPresenter.getDroppedFrameCount();
            if (isNumber(n)) {
                data['totdfr'] = n;
                playqualvideo['numrendrop'] = n;
            }

            n = mediaPresenter.getCorruptedFrameCount();
            if (isNumber(n)) {
                data['totcfr'] = n;
                playqualvideo['numrenerr'] = n;
            }

            n = mediaPresenter.getFrameDelayCount();
            if (isNumber(n)) {
                data['totfdl'] = n;
            }

            data['playqualvideo'] = JSON.stringify(playqualvideo);

            data['videofr'] = playback.videoStream.value.header.framerate.toFixed(3);

            var abrdel = playTimeTracker.getAverageBitrateDelivered();
            if (abrdel) {
               data['abrdel'] = abrdel;
            }

            var tw_vmaf = playTimeTracker.hasVmaf() && playTimeTracker.getAverageVmafDelivered();
            if (tw_vmaf) {
               data['tw_vmaf'] = tw_vmaf;
            }

            var abrdels = playTimeTracker.getAverageBitrateDeliveredAtTimes();
            if (abrdels) {
                mixIn(data, abrdels);
            }

            data['rbfrs'] = _intrplaySeq;

            data['maxbitrate'] = _maxBitrate;
            data['maxresheight'] = _maxResolutionHeight;

            var videoStreamList = playback.getVideoStreamList();
            var videoStream;
            var lastVideoStream;
            var disallow;
            var i;
            for (i = 0; i < videoStreamList.length; i++) {
                videoStream = videoStreamList[i];
                disallow = playback.mediaStreamFilter.shouldDisallowStream(videoStream);
                if (disallow) {
                    debug$assert(lastVideoStream);
                    data['maxbitrate'] = lastVideoStream ? lastVideoStream.bitrate : 0;
                    data['maxresheight'] = lastVideoStream ? lastVideoStream.height: 0;
                    data['bitratefilters'] = disallow.join('|');
                    break;
                }
                lastVideoStream = videoStream;
            }

            // log Carrera statistics
            if (playback && playback.usingCarrera && playback.carreraStats && playback.bandwidthMeter) {
                var stats = playback.carreraStats;
                var expectedbw = {
                    'ab': Math$floor(stats.averageBandwidth),
                    'actual60': playback.bandwidthMeter.getThroughput60(),
                    'b20': Math$floor(stats.bandwidth20Percentile),
                    'b50': Math$floor(stats.bandwidth50Percentile),
                    'b90': Math$floor(stats.bandwidth90Percentile),
                    'std': Math$floor(stats.standardDev),
                    'ns': stats.totalSamples,
                    'ss': stats.sampleSize,
                    'filt': stats.filter
                };
                data['expectedbw'] = JSON.stringify(expectedbw);

            }

	        if (playback.trickPlay) {
               data['trickplay'] = playback.trickPlay.getStatus();
	        }

            if (playback.timedTextManager.averageSubtitleDelay !== null) {
                data['avg_subt_delay'] = playback.timedTextManager.averageSubtitleDelay;
            }
        }
        catch (e) {
            _log.error('Exception reading some of the endplay fields', e);
        }

        // track video diags
        mixIn(data, playback.getVideoDiagInfo(), { prefix: 'vd_' });

        // TODO: following fields
        // "dfdata", droppedFrameHistogram != null ? droppedFrameHistogram.ToString() : "");
        // "totdfrut", IC.ToString(totalDroppedFramesUnderThreshold));
        // "dfthresh", IC.ToString(droppedFrameThreshold));

        return data;
    }

    // --------------------------------------------------------------------------------
    // -- Monior playback and generate log messages.

    function _startMonitoringPlayback() {

        // -- dlreq
        playback.addEventListener(HttpPlayback$downloadcomplete, _dlreq, ORDERPROPERTY$late);

        if (config.downloadReportDenominator) {

            playback.addEventListener(HttpPlayback$downloadcomplete, function (response) {
                _downloadReportDownloads.push(constructDownloadReport$convertResponseToDownloadInfo(response));
            });

            _downloadReportIntervalId = setInterval(_dlreport, config.downloadReportInterval);
        }

        if (config.reportThroughputInLogblobs) {
            playback.addEventListener(HttpPlayback$downloadcomplete, function (response) {
                var startTime = response.measurements.responseStartTime,
                    endTime = response.measurements.responseEndTime,
                    bytes = response.measurements.contentLength;

                if (bytes && bytes > 0) {
                    _throughputTracker.addDownload(new DefaultDownload(
                    	new DefaultRange(startTime, endTime, CadmiumTypescript.Utils.numberComparator),
						bytes
                    ));
                    if (response && response.request && response.request.cdn && response.request.cdn.id) {
                        _cdnThroughputTracker.addDownload(new CDNDownloadImpl(
                            new DefaultRange(startTime, endTime, CadmiumTypescript.Utils.numberComparator),
                            bytes,
                            response.request.cdn.id
                        ));
                    }
                }
            });
        }

        // -- stagechanged
        playback.paused.addListener(function (args) {
            // ignore non-user initiated pauses, because those happen right before seek
            var newValue = args.newValue;
            // if it's user initiated OR it's unpause
            if (!args.notUserInitiated || !newValue) {
                if (newValue != _lastPaused) {
                    _statechanged(_lastPaused, newValue);
                    _lastPaused = newValue;
                }
            }
        });

        // -- intrplay, repos,  resumeplay, audioswitch
        playback.addEventListener(Playback$bufferUnderrun, _logRebuffer);
        // media rebuffer
        playback.addEventListener(Playback$decoderUnderrun, _logRebuffer);

        function _logRebuffer(args) {
            _resumingFrom = 'rebuffer';
            _intrplay(_timeSpentInPresentingState[PresentingState$PLAYING] || 0, _timeSpentInPresentingState[PresentingState$PAUSED] || 0, args.cause);
            _waitingForResumeSince = clock$getTime();
            dispatch(_checkForResume);
        }

        function _trackTimeSpentInPresentingState(args) {
            // Note: this relies on presentingState changing before Playback$bufferUnderrun event
            var lastState = args.oldValue;
            var now = clock$getTime();
            if (lastState == PresentingState$WAITING) {
                // if we are comming from waiting state, reset everything
                _timeSpentInPresentingState = [];
            } else {
                // otherwise track the time spent in old state
                _timeSpentInPresentingState[lastState] = (_timeSpentInPresentingState[lastState] || 0) + (now - _lastPresentingStateStateChangeOn);
            }
            _lastPresentingStateStateChangeOn = now;
        };
        playback.presentingState.addListener(_trackTimeSpentInPresentingState);

        playback.addEventListener(Playback$repositioned, function (args) {
            switch (args.cause) {
                case Playback$REPOSITION_CAUSE_SEEK:
                case Playback$REPOSITION_CAUSE_TRACK_CHANGED:
                    if (_resumingFrom && _waitingForResumeSince) {
                        // if we reposition, without starting a playback, that's essentially playback aborted
                        // TODO: check if resumeplayreason what potential "resumeplay" was aborted, instead of "why" it's aborted
                        _playbackaborted_resumeplay(clock$getTime() - _waitingForResumeSince, _resumingFrom);
                    } else if (!_playbackStarted) {
                        _playbackaborted_startplay();
                    }
                    _resumingFrom = 'repos';
                    _repos(args.oldMediaTime);
                    _waitingForResumeSince = clock$getTime();
                    dispatch(_checkForResume);
                    break;
            }
        });
        function _checkForResume() {
            if (_waitingForResumeSince && playback.presentingState.value != PresentingState$WAITING) {
                var waittime = clock$getTime() - _waitingForResumeSince;
                _resumeplay(waittime);
                if (_lastAudioTrack && _lastAudioTrack != playback.audioTrack.value) {
                    _audioswitch();
                }
                _waitingForResumeSince = undefined;
                _resumingFrom = undefined;
            }
        };
        playback.presentingState.addListener(_checkForResume);

        playback.audioTrack.addListener(function (args) {
            _lastAudioTrackChangedOn = clock$getTime();
            _lastAudioTrack = args.oldValue;
        });

        // -- startplay, playbackaborted, endplay
        playback.addEventListener(Playback$playbackstart, function () {
            debug$assert(!_playbackStarted);
            _playbackStarted = true;
            _startplay(false);
            _initMidPlay();
            if (config.initialLogFlushTimeout) {
                _initialLogFlushTimerId = setTimeout(function () {
                    if (nccpLogBatcher) {
                        nccpLogBatcher.flush(false);
                    }
                    _initialLogFlushTimerId = undefined;
                }, config.initialLogFlushTimeout);
            }
        });
        playback.addEventListener(Playback$closing, function () {
            if (_initialLogFlushTimerId) {
                clearTimeout(_initialLogFlushTimerId);
            }

            if (config.downloadReportDenominator) {
                if (_downloadReportIntervalId) {
                    clearInterval(_downloadReportIntervalId);
                }
                _dlreport();
            }

            if (_playbackStarted) {
                // TODO: is endplay error the right message?
                _endplay(!!playback.fatalError);
            }
            else {
                if (playback.fatalError) {
                    _startplay(true);
                } else {
                    _playbackaborted_startplay();
                }
            }

            // stop sending messages
            if(!_secureStopInitiated){
                _queueLogMessage = NOOP;
            }

        });

        // -- bitrateRestriction
        playback.bitrateRestriction && playback.bitrateRestriction.addListener(function (args) {
            _bitrateRestriction(args.newValue);
        });

        // -- chgstrm
        playback.videoStream.addListener(function (args) {
            // don't react to first stream change
            if (args.oldValue && args.chunkStartTime) {
                _chgstrm(args.oldValue, args.newValue, args.chunkStartTime, args.streamTput, args.networkMonitorTput);
            }
        });

        // -- renderstrmswitch
        var _lastPresentedVideoStream;
        playback.presentedVideo.addListener(function (args) {
            if (args.newValue) {
                var presentedVideoStream = args.newValue.stream;
                if (_lastPresentedVideoStream != presentedVideoStream) {
                    if (_lastPresentedVideoStream) {
                        _renderstrmswitch(_lastPresentedVideoStream, presentedVideoStream, args.newValue.chunk.startTime);
                    }
                    _lastPresentedVideoStream = presentedVideoStream;
                }
            }
        });

        // -- cdnsel
        playback.cdn.addListener(function (args) {
            var newCdn = args.newValue;
            if (newCdn) {
                if (_lastCdn != newCdn) {
                    _cdnsel(_lastCdn, newCdn, playback.downloadedVideo && playback.downloadedVideo.value && playback.downloadedVideo.value.downloadMeasurements, newCdn.serverSelReason);
                    _lastCdn = newCdn;
                }
            }
        });

        // -- dlprestart, as soon as we download 1 audio and 1 video
        function onDownloadedChunk() {
            if (playback.downloadedAudio.value && playback.downloadedVideo.value) {
                playback.downloadedAudio.removeListener(onDownloadedChunk);
                playback.downloadedVideo.removeListener(onDownloadedChunk);
                _dlprestart();
            }
        }
        if (config.dlprestartCount) {
            playback.downloadedAudio.addListener(onDownloadedChunk);
            playback.downloadedVideo.addListener(onDownloadedChunk);
        }

        if (config.secureStopEnabled) {
            _secureStopInitiated = true;
        }

        playback.addEventListener(Playback$subtitleError, _subtitleError);
    }

    /**
    * @param {Object} result
    * @param {boolean=} queueMessageUnchanged
    */
    function _secureStop(result, queueMessageUnchanged) {
        result['browserua'] = userAgent;
        _queueLogMessage('securestop', !result['success'], NccpLogging$COMMON_MOFF | NccpLogging$COMMON_CPU, result);
        if(!queueMessageUnchanged){
            _queueLogMessage = NOOP;
        }
    }

    function _initMidPlay() {
        var midplayIntervalId,
            midplayTimeoutIds = [];

        if (config.midplayEnabled) {
            // send the midplay with every logblob
            nccp$eventSource.addListener(nccp$aboutToSend, _midplay);
            config.midplayKeyPoints.forEach(function (delay) {
                midplayTimeoutIds.push(setTimeout(_midplay, delay));
            });
            if (config.midplayIntervalMilliseconds) {
                // also, send it on interval, in case there aren't any outgoing longblobs
                midplayIntervalId = setInterval(_onMidplayInterval, config.midplayIntervalMilliseconds);
            }
            playback.addEventListener(Playback$closing, function () {
                nccp$eventSource.removeListener(nccp$aboutToSend, _midplay);
                midplayTimeoutIds.forEach(function (timeoutId) {
                    clearTimeout(timeoutId);
                });
                midplayIntervalId && clearInterval(midplayIntervalId);
            });
        }
    }

    function _onMidplayInterval() {
        // just flush the logs, the midplay-tag-along-logblob logic will add a midplay to the logblob
        nccpLogBatcher.flush(true);
    }

    function _includeSubtitleQoeScore(data) {
        try {
            var pts = playback.mediaPresenter.getElementTime();
            data['subtitleqoescore'] = playback.timedTextManager.getSubtitleQoeScore(pts);
            data['subtitleqoe'] = JSON.stringify(playback.timedTextManager.getSubtitleQoe(pts));
        } catch (e) {
            _log.error('error getting subtitle score', e);
        }
    }

    function _includePrepareStats(data){
        try{
            var stats = videoPreparer.getStats();
            data['pr_cache_size'] = JSON.stringify(stats.cache);
            data['pr_stats'] = JSON.stringify(stats.general);
        }catch(e){

        }
    }

    function _includeHttpStats(data){
        _log.debug('httpstats', http.stats);
        mixIn(data, http.stats, {
            prefix: 'http_'
        });
    }

    function _includeASEThroughputStats(data){
        var aseMgr = playback.streamingManager;
        var statistics = aseMgr._networkMonitor.get();
        if (statistics.confidence && statistics.throughput){
            data['aseavtp'] = statistics.throughput.average;
            data['asevartp'] = statistics.throughput.variance;
            if (statistics.iqr){
                var percentiles = statistics.iqr.percentiles;
                data['aseniqr'] = (percentiles.p75 - percentiles.p25) / percentiles.p50;
                data['aseiqr'] = (percentiles.p75 - percentiles.p25);
                data['asemedtp'] = percentiles.p50;
            }
            if ( config.logChunkLevelTput && statistics.clThroughput){
                data['aseavcltp'] = statistics.clThroughput.average;
                data['asevarcltp'] = statistics.clThroughput.variance;
                if (statistics.clIQR){
                    var clPercentiles = statistics.clIQR.percentiles;
                    data['aseclniqr'] = (clPercentiles.p75 - clPercentiles.p25) / clPercentiles.p50;
                    data['asecliqr'] = (clPercentiles.p75 - clPercentiles.p25);
                    data['aseclmedtp'] = clPercentiles.p50;
                }
            }
        }
    }

    function _includeMemoryStats(data) {
        try {
            var memory = performance['memory'];
            if (!isValidObject(memory)) {
                return;
            }
            data['totalJSHeapSize'] = memory['totalJSHeapSize'];
            data['usedJSHeapSize'] = memory['usedJSHeapSize'];
            data['jsHeapSizeLimit'] = memory['jsHeapSizeLimit'];

        } catch (e) {}
    }

    function _includeKeyStatusesData(data) {
        var emeSession = playback.emeSession;
        if (config.captureKeyStatusData && emeSession) {
            data['keystatuses'] = playback.normalizeKeyStatuses(emeSession.getKeyStatuses());
            _log.trace('keystatuses', data['keystatuses']);
        }
    }

    function _includeDecoderQuotaExceededStat(data) {
        if (playback.decoderQuotaExceededCount) {
            data['dqec'] = playback.decoderQuotaExceededCount;
        }
    }
    /**
    * @param {string=} sev
    */
    function _queueLogMessage(type, isError, common, data, sev) {
        NccpLogging$_addCommonFields(data, playback, isError, common);
        var logMessage = new NccpLogMessage(playback, type, sev || (isError ? 'error' : 'info'), data);
        nccpLogBatcher.queueLogMessage(logMessage);
    }
}

function NccpLogging$_nwerr(errorSubCode) {
    switch (errorSubCode) {
        case ErrorSubCodes.HTTP_PROTOCOL:
            return 'http';
        case ErrorSubCodes.HTTP_TIMEOUT:
            return 'connectiontimeout';
        case ErrorSubCodes.HTTP_READTIMEOUT:
            return 'readtimeout';
        case ErrorSubCodes.HTTP_PARSE:
            return 'corruptcontent';
        case ErrorSubCodes.HTTP_ABORT:
            return 'abort';
        case ErrorSubCodes.HTTP_UNKNOWN:
        case ErrorSubCodes.HTTP_XHR:
            return 'unknown';
    }
}

function NccpLogging$_addCommonFields(data, playback, isError, common) {

    if (typeof nrdp !== 'undefined' && nrdp['device'] && nrdp['device']['deviceModel']) {
        data['devmod'] = nrdp['device']['deviceModel'];
    }

    if (common & NccpLogging$COMMON_MOFF) {
        debug$assert(!data || data['moff'] === undefined);
        if (playback.mediaTime.value >= 0) {
            data['moff'] = NccpClient$formatSeconds(playback.mediaTime.value);
        }
    }

    if (common & NccpLogging$COMMON_PRESENTEDSTREAMS) {
        var cdn = playback.cdn.value;
        var audio = (playback.presentedAudio.value || playback.downloadedAudio.value);
        var video = (playback.presentedVideo.value || playback.downloadedVideo.value);
        debug$assert(isError || playback.presentedAudio.value);
        debug$assert(isError || playback.presentedVideo.value);

        if (cdn) {
            data['cdnid'] = cdn.id;
            data['cdnname'] = cdn.name;
        }
        if (audio) {
            data['adlid'] = audio.stream.downloadableId;
            data['abitrate'] = audio.stream.bitrate;
        }
        if (video) {
            data['vdlid'] = video.stream.downloadableId;
            data['vbitrate'] = video.stream.bitrate;
        }
    }

    if (common & NccpLogging$COMMON_BUFFER) {
        var mediaBuffer = playback.mediaBuffer;
        if (mediaBuffer && playback.mediaTime.value >= 0) {
            data['abuflmsec'] = NccpClient$formatMillisecond(mediaBuffer.getAudioBufferLength());
            data['vbuflmsec'] = NccpClient$formatMillisecond(mediaBuffer.getVideoBufferLength());
            data['abuflbytes'] = NccpClient$formatInt(mediaBuffer.getAudioBufferBytes());
            data['vbuflbytes'] = NccpClient$formatInt(mediaBuffer.getVideoBufferBytes());
        }

        // currentStateName will go away with JS ASE
        var currentStateName = playback.mediaDownloader &&
                               playback.mediaDownloader.getCurrentStateName &&
                               playback.mediaDownloader.getCurrentStateName();

        if (currentStateName) {
            data['curdlstatename'] = currentStateName;
        }
    }

    if (common & NccpLogging$COMMON_SCREEN) {
        NccpLogging$_addScreenSizes(data);
        try {
            var rect = playback.rootElement['getBoundingClientRect']();
            data['rendersize'] = rect['width'] + 'x' + rect['height'];
            data['renderpos'] = rect['left'] + 'x' + rect['top'];
        } catch (e) {
        }
    }

    if (common & NccpLogging$COMMON_CPU) {
        // Only supported in Chrome as of 09/2015
        var numCores = navigator['hardwareConcurrency'];
        if (numCores >= 0) {
            data['numcores'] = numCores;
        }
        if (playback.cpuSpeed >= 0) {
            data['cpuspeed'] = playback.cpuSpeed;
        }

        var droppedFramesAverage = playback.droppedFrames && playback.droppedFrames.getAverages();
        if (droppedFramesAverage) {
            data['droppedFrames'] = JSON.stringify(droppedFramesAverage);
        }

        var droppedFramesPercentiles = playback.droppedFrames && playback.droppedFrames.getPercentiles(config.droppedFramesPercentilesList);
        enumerateOwnProperties(droppedFramesPercentiles, function(k, v) {
            var logKey = 'droppedFramesP' + k;
            data[logKey] = JSON.stringify(v);
        });
    }

    if (common & NccpLogging$COMMON_CDN) {
        try {
            data['pricdnid'] = playback.primaryCdn.id;
            data['cdninfo'] = JSON.stringify(playback.cdnList.map(function (cdn) {
                return {
                    'id': cdn.id,
                    'nm': cdn.name,
                    'rk': cdn.rank,
                    'wt': cdn.location.weight,
                    'lv': cdn.location.level
                };
            }));
        } catch (e) {
        }
    }

    if (isError && (common & NccpLogging$COMMON_FATALERROR)) {
        debug$assert(playback.fatalError);
        var fatalError = playback.fatalError;
        if (fatalError) {
            NccpLogging$_addPlayerErrorFields(data, fatalError);
        } else {
            data['errorcode'] = ErrorCodes.UNKNOWN;
        }
        // TODO: errormsg, proper errorcode, errorstring
    }
}

function NccpLogging$_addPlayerErrorFields(data, fatalError) {
    debug$assert(fatalError.errorCode);
    data['errorcode'] = ERROR_PREFIX + (fatalError.errorCode || ErrorCodes.UNKNOWN);
    if (fatalError.errorSubCode) {
        data['errorsubcode'] = fatalError.errorSubCode;
    }
    if (fatalError.errorExternalCode) {
        data['errorextcode'] = fatalError.errorExternalCode;
    }
    if (fatalError.errorEdgeCode) {
        data['erroredgecode'] = fatalError.errorEdgeCode;
    }
    if (fatalError.errorDetails) {
        data['errordetails'] = fatalError.errorDetails;
    }
    if (fatalError.errorHttpCode) {
        data['httperr'] = fatalError.errorHttpCode;
    }
    if (fatalError.errorData) {
        data['errordata'] = fatalError.errorData;
    }
    if (fatalError.errorExternalCode === ErrorExtCodes.BR_VIEWABLE_OUT_OF_AVAILABILITY_WINDOW ||
        fatalError.errorExternalCode === ErrorExtCodes.BR_ACCOUNT_ON_HOLD ||
        fatalError.errorExternalCode === ErrorExtCodes.BR_CONCURRENT_STREAM_QUOTA_EXCEEDED ||
        fatalError.errorExternalCode === ErrorExtCodes.BR_INSUFFICIENT_MATURITY_LEVEL ||
        fatalError.errorExternalCode === ErrorExtCodes.BR_BLACKLISTED_IP ||
        fatalError.errorExternalCode === ErrorExtCodes.BR_AGE_VERIFICATION_REQUIRED) {
        data['nccperr'] = fatalError.errorExternalCode;
    }
    var nwerr = NccpLogging$_nwerr(fatalError.errorSubCode);
    if (nwerr) {
        data['nwerr'] = nwerr;
    }
}

function NccpLogging$_addScreenSizes(data) {
    data['screensize'] = screen['width'] + 'x' + screen['height'];
    data['screenavailsize'] = screen['availWidth'] + 'x' + screen['availHeight'];
    data['clientsize'] = window['innerWidth'] + 'x' + window['innerHeight'];
}

var NccpLogging$COMMON_MOFF = 0x01,
    NccpLogging$COMMON_PRESENTEDSTREAMS = 0x02,
    NccpLogging$COMMON_BUFFER = 0x04,
    NccpLogging$COMMON_SCREEN = 0x08,
    NccpLogging$COMMON_CPU = 0x10,
    NccpLogging$COMMON_CDN = 0x20,
    NccpLogging$COMMON_FATALERROR = 0x40;



// -- player-nccp/PlayDataManager.js
/**
* @constructor
*/
function PlayDataManager(playback) {
    var HEARBEAT_COOLDOWN_TOLERANCE = 500,
        // wait this many milliseconds before sending heartbeat when stream ends
        HEARBEAT_MINWAIT_ON_ENDOFSTREAM = 500;

    var _log = new playback.log.CategoryLog('PlayDataManager'),
        _heartbeatPendingType = nccp$HEARTBEAT_TYPE_INTERVAL,
        _heartbeatLastSentOn = 0,
        _heartbeatLastSentType,
        _heartbeatTimeoutId,
        _heartbeatIsBeingSent,
        _persistPlaydataIntervalId,
        _playdataRequest,
        _moviePlaybackData;

    if (!EmeSession || !DrmRequests) {
        var eme = PLATFORM_EME();
        EmeSession = eme.session;
        DrmRequests = eme.request;
    }

    // --------------------------------------------------------------------------------
    // -- initialization & internal api

    playback.addEventListener(Playback$authorized, _onAuthorized);
    playback.addEventListener(Playback$licensed, _onLicensed);
    playback.addEventListener(Playback$closing, _onClosing);
    playback.addEventListener(Playback$repositioned, _createAndPersistPlaydata);
    playback.addEventListener(Playback$playbackstart, _onPlaybackStart, ORDERPROPERTY$late);
    globalEvents.addListener(globalEvents$beforeunload, _onBeforeUnload);

    /** @lends {PlayDataManager.prototype} */
    return {
        sendPersistedPlaydataEarly: _sendPersistedPlaydataEarly
    };

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _sendPersistedPlaydataEarly(callback) {
        if (PlayDataManager$waitForPersistedPlaydataToBeSent) {
            // playdata is already being sent, wait for it
            PlayDataManager$waitForPersistedPlaydataToBeSent['then'](function () {
                callback(SUCCESS);
            });
        } else if (PlayDataManager$persistedPlaydataFromLastSession && PlayDataManager$persistedPlaydataFromLastSession.movieId == playback.movieId) {
            // send it early only if it has the same movie id, so we maintain the bookmark
            _sendPersistedPlaydataFromLastPlayback(callback);
        } else {
            callback(SUCCESS);
        }
    }

    function _onAuthorized() {
        // send persisted playdata if there is any
        if (PlayDataManager$persistedPlaydataFromLastSession) {
            _sendPersistedPlaydataFromLastPlayback();
        }
    }

    function _onLicensed() {
        _createAndPersistPlaydata();
    }

    function _onPlaybackStart() {
        // If we have started playback then we need to start persisting 
        // playdata
        debug$assert(playback.nccpPlayback);
        if (config.playdataPersistIntervalMilliseconds > 0) {
            _persistPlaydataIntervalId = setInterval(_createAndPersistPlaydata, config.playdataPersistIntervalMilliseconds);
        }

        // start reacting on playback pausing only after playback starts
        playback.presentingState.addListener(function () {
            _processHeartbeat(
                playback.presentingState.value == PresentingState$PLAYING ? nccp$HEARTBEAT_TYPE_RESUME : nccp$HEARTBEAT_TYPE_SUSPEND,
                playback.presentingState.value == PresentingState$ENDED ? HEARBEAT_MINWAIT_ON_ENDOFSTREAM : 0);
        });
        // and schedule the first heartbeat with type=interval, then it will reschedule itself
        if (_shouldSendThePendingHeartbeat()) {
            _scheduleHeartbeat(_getHeartbeatCooldownForInterval());
        }

        _createAndPersistPlaydata();
    }

    // --------------------------------------------------------------------------------
    // -- heartbeat

    function _getHeartbeatCooldownForInterval() {
        return Math$max(config.heartbeatCooldown, nccpDeviceParameters.heartbeatinterval * MILLISECONDS_PER_SECOND);
    };

    function _shouldSendThePendingHeartbeat() {
        return nccpDeviceParameters.sendheartbeats &&
            playback.state.value == Playback$STATE_NORMAL &&
            !_heartbeatIsBeingSent &&
            (nccpDeviceParameters.heartbeatinterval > 0 || _heartbeatPendingType != nccp$HEARTBEAT_TYPE_INTERVAL);
    };

    /**
    * @param {string=} requestedType
    * @param {number=} minWait
    * Tries to send heartbeat, if it's unable to do so due to a cooldown... then it schedules one to be sent later on. 
    */
    function _processHeartbeat(requestedType, minWait) {
        var type = requestedType || nccp$HEARTBEAT_TYPE_INTERVAL;

        if (type != nccp$HEARTBEAT_TYPE_INTERVAL) {
            // "interval" type should not overwrite other pending types
            _heartbeatPendingType = type;
        }

        DEBUG && _log.debug('Processing heartbeat', { 'Type': _heartbeatPendingType, 'RequestedType': type });

        if (_shouldSendThePendingHeartbeat()) {
            var cooldown = _heartbeatPendingType != nccp$HEARTBEAT_TYPE_INTERVAL ?
                config.heartbeatCooldown :
                _getHeartbeatCooldownForInterval();

            var reaminingWait = Math$max(cooldown - (clock$getTime() - _heartbeatLastSentOn), minWait || 0);
            // if we have minWait specified, make sure to wait 
            // ... otehrwise if we have never sent a heartbeat, or cooldown is elapsed, or that last one we sent was "interval" and this one is not...
            if (!minWait && (!_heartbeatLastSentOn || reaminingWait <= HEARBEAT_COOLDOWN_TOLERANCE || (_heartbeatLastSentType == nccp$HEARTBEAT_TYPE_INTERVAL && _heartbeatPendingType != nccp$HEARTBEAT_TYPE_INTERVAL))) {
                // ok to send it now
                _sendHeartbeat();
            } else {
                // need to wait
                debug$assertPositiveInt(reaminingWait);
                _scheduleHeartbeat(reaminingWait);
            }
        }
    };

    function _clearScheduledHeartbeat() {
        if (_heartbeatTimeoutId) {
            clearTimeout(_heartbeatTimeoutId);
            _heartbeatTimeoutId = undefined;
        }
    };

    function _scheduleHeartbeat(delay) {
        _clearScheduledHeartbeat();
        _heartbeatTimeoutId = setTimeout(_processHeartbeat, delay);
    };

    function _sendHeartbeat() {
        if (_shouldSendThePendingHeartbeat()) {
            _clearScheduledHeartbeat();
            _heartbeatIsBeingSent = true;
            var heartbeatType = _heartbeatPendingType;
            // reset the type, so incoming suspend/resume can overwrite it
            _heartbeatPendingType = nccp$HEARTBEAT_TYPE_INTERVAL;
            DEBUG && _log.debug('Sending heartbeat', { 'Type': heartbeatType });
            playback.nccpPlayback.heartbeat(heartbeatType, function (result) {
                if (result.success) {
                    DEBUG && _log.debug('Heartbeat sent', { 'Type': heartbeatType });
                } else {
                    _log.error('Heartbeat failed', { 'Type': heartbeatType }, ErrorSubCodes$errorResultToLogFields(result));
                    // If there is an errorDisplayMessage it is a fatal error. This can happen in the case of a
                    // concurrent stream check failure, account on hold failure, etc. This logic is the equivalent
                    // of the old actionID=11 and actionID=3 handling.
                    if (result.errorDisplayMessage) {
                        playback.closeWithError(new PlayerError(ErrorCodes.NCCP_HEARTBEAT, result));
                    }
                }
                _heartbeatLastSentType = heartbeatType;
                _heartbeatLastSentOn = clock$getTime();
                _heartbeatIsBeingSent = false;
                _processHeartbeat();
            });
        }
    };

    // --------------------------------------------------------------------------------
    // -- playdata

    function _createAndPersistPlaydata() {
        if(!playback.nccpPlayback){
            return; //in case this happens before init
        }
        var moviePlaybackData = playback.nccpPlayback.createPbLifecycleData();
        _persistPlaydata(moviePlaybackData);

        if (config.playdataPrepareRequest) {
            // prepare an NCCP request which we can immediately sent when browser is closed
            _moviePlaybackData = moviePlaybackData;
            playback.nccpPlayback.createPlaydataRequest(moviePlaybackData, function (result) {
                if (_moviePlaybackData == moviePlaybackData) {
                    _playdataRequest = result.success ? result.httpRequest : undefined;
                };
            });
        }
    };

    /**
    * @param {function(Object=)=} callback
    */
    function _persistPlaydata(moviePlaybackData, callback) {
        // Make sure we don't persist the data if it does not have
        // playback or playtimes data, these can be undefined if 
        // there is media element error before playback starts
        if (config.playdataPersistIntervalMilliseconds > 0 &&
            config.playdataPersistKey &&
            moviePlaybackData.playback &&
            moviePlaybackData.playback['playTimes']) {

            // The movie playback data should be minified, to maintain compatibility
            // between builds we need store an unminified version of this data.
            // TODO: Make sure the playback object is converted to use minified properties
            var unminifiedData = unminifyPlayData(moviePlaybackData);
            if (DEBUG || DEV) {
                _log.debug('Persisting playdata', stringifyJsonPretty(unminifiedData));
            }

            storage.save(config.playdataPersistKey, JSON.stringify(unminifiedData), false, callback);
        } else {
            callback && callback(SUCCESS);
        }
    };

    /**
    * @param {function(Object=)=} callback
    */
    function _sendPersistedPlaydataFromLastPlayback(callback) {
        PlayDataManager$sendPersistedPlaydataFromLastPlayback(playback, function (result) {
            if (result.success) {
                PlayDataManager$deletePersistedPlaydata();
                // overwrite playdata file with current one
                _createAndPersistPlaydata();
            }
            callback && callback(result);
        });
    };

    function _onBeforeUnload() {
        // window is closing, if we have a pre-prepared playdata, try to send it
        // also create a fresh one, and persist it
        if (_playdataRequest) {
            // if we have an nccp proxy path we can use, use it to make synch request
            _log.info('Sending last playdata synchronously', { 'Url': _playdataRequest.url });
            var response = http$downloadSynchronously(_playdataRequest);
            if (response.success) {
                // happy path, delete the stored one and we are done
                PlayDataManager$deletePersistedPlaydata();
                return;
            }

            // something went wrong, try fire and forget and also persist the playdata
            // otherwise try the fire and forget approach
            _log.info('Sending last playdata asynchronously');
            playback.httpPlayback.download(_playdataRequest, NOOP);
            _createAndPersistPlaydata();
        }
    }

    function _onClosing() {
        // stop the timers
        globalEvents.removeListener(globalEvents$beforeunload, _onBeforeUnload);
        _clearScheduledHeartbeat();
        if (_persistPlaydataIntervalId) {
            clearInterval(_persistPlaydataIntervalId);
            _persistPlaydataIntervalId = undefined;
        }

        var stopComplete,
            logblobComplete;

        playback.waitForNotifyClosed();

        if (playback && playback.nccpPlayback) {
            var moviePlaybackData = playback.nccpPlayback.createPbLifecycleData();
            // persist the playdata, in case we fail to send it
            _persistPlaydata(moviePlaybackData, function() {

                if (playback.emeSession && playback.emeSession.getSessionId()) {
                    _log.info('Sending the expedited playdata and secure stop data');   
                    playback.emeSession.expediteSecureStop(moviePlaybackData)
                        .then(function (result) {
                            _log.info('Sent the expedited playdata and secure stop data');
                            stopComplete = true;
                            PlayDataManager$deletePersistedPlaydata();
                            if (config.secureStopEnabled) {
                                playback.nccpLogging.secureStopMessage({
                                    'success': result.success,
                                    'persisted': false,
                                    'ss_km': result.messageTime,
                                    'ss_sr': result.serverTime,
                                    'ss_ka': result.completeTime
                                });
                            }
                            tryComplete();
                        })
                        .catch(function (err) {
                            _log.error('Unable to send the expedited playdata and secure stop data', err);
                            stopComplete = true;
                            if (config.secureStopEnabled) {
                                playback.nccpLogging.secureStopMessage({
                                    'success': err.success,
                                    'state': err.state,
                                    'ErrorCode': err.code,
                                    'ErrorSubCode': err.subCode,
                                    'ErrorExternalCode': err.extCode,
                                    'ErrorEdgeCode': err.edgeCode,
                                    'ErrorDetails': err.cause && err.cause.errorDetails,
                                });
                            }
                        tryComplete();
                    });
                } else {
                    _log.info('Sending the expedited playdata');
                    playback.nccpPlayback.stop(moviePlaybackData).then(function(result) {
                        _log.info('Sent the expedited playdata');
                        stopComplete = true;
                        PlayDataManager$deletePersistedPlaydata();
                        tryComplete();
                    }).catch(function(err) {
                        _log.error('Unable to send the expedited playdata', err);
                        stopComplete = true;
                        tryComplete();
                    });
                }
            });
        } else {
            stopComplete = true;
        }
        
        // send logblobs
        if (nccpLogBatcher) {
            // nccpLogBatcher might not be loaded... nothing much we can do if it's not
            nccpLogBatcher.flush(false, function(result) {
                if (!result.success) {
                    _log.error('Unable to send logblob');
                }
                logblobComplete = true;
                tryComplete();
            });
        } else {
            logblobComplete = true;
        }

        function tryComplete() {
            if (stopComplete && logblobComplete) {
                tryComplete = NOOP;
                playback.notifyClosed();
            }
        }
        dispatch(tryComplete); // since the state needs to be set to closing
    }
}

var PlayDataManager$persistedPlaydataFromLastSession;

var PlayDataManager$waitForPersistedPlaydataToBeSent;

/**
* @param {{
     *   playbackContextId: String,
     *   xid: number}}  context optional playback to assosiate SENDING with, this is different than the playback this playdata is saved for
* @param {function(Object=)=} callback
*/
function PlayDataManager$sendPersistedPlaydataFromLastPlayback(context, callback) {
    var edgeContext,
        _log = new log.CategoryLog('PlayDataManager');    
 
    function _stopAndRelease(requestData) {
        return NccpPlayback$stopAndRelease(false, context, edgeContext, requestData);
    }

    /**
     * Create the EME node module
     * @param  {string} initDataType The initialization data type 
     * @return {Object}              The newly created EME session
     */
    function _createEmeSession(initDataType) {

        var session,
            requests,
            emeLog;

        emeLog = new log.CategoryLog('Eme');

        // Create a new requests object, this will need to have a license and secure
        // stop methods that will handle sending any requests that will need to
        // be made during the licensing process.
        requests = new DrmRequests(emeLog, undefined, _stopAndRelease, {
            isDebug: DEBUG,
            isDev: DEV,
            cert: '', // cert is not required since we will not perform license before secure stop.
        });

        // Create a new instance of an EmeSession, this will do the complete
        // license flow 
        return new EmeSession(emeLog, initDataType, undefined, {
            isDebug: DEBUG,
            isDev: DEV,
            isSecureStopEnabled: config.secureStopEnabled,
            secureStopTimeouts: {
                messageTimeout: config.secureStopPersistedKeyMessageTimeoutMilliseconds,
                changedTimeout: config.secureStopKeyAddedTimeoutMilliseconds,
                unmatchTimeout: config.secureStopPersistedKeyAddedTimeoutUnmatchedSession
            },
            requests: requests,
            promiseBased: config.promiseBasedEme,
            useCdmId: config.useCdmId,
            verboseLogging: config.enableEmeVerboseLogging,
            persistentRetries: config.secureStopPersistedKeySessionRetries
        });
    }

    /**
     * sends a secure stop logblob to the server
     * @param  {Object}   result      the data to send to the server
     * @param  {Object}   playdata    the loaded playdata
     */
    function _sendSecureStopLogBlob(result, playdata) {
        var fields,
            fauxPlayback = {
                xid: playdata['xid'],
                getRelativeTime: function() {
                    return 0;
                },
                movieId: playdata['movieId'],
                logVerbosePlaybackInfo: false
            };
        if (config.secureStopEnabled) {
            _log.info('secure stop is enabled');
            if (result.success) {
                fields = {
                    'success': result.success,
                    'persisted': true,
                    'ss_km': result.messageTime,
                    'ss_sr': result.serverTime,
                    'ss_ka': result.completeTime
                };
            } else {
                fields = {
                    'success': result.success,
                    'persisted': true,
                    'state': result.state,
                    'ErrorCode': result.code,
                    'ErrorSubCode': result.subCode,
                    'ErrorExternalCode': result.extCode,
                    'ErrorEdgeCode': result.edgeCode,
                    'ErrorDetails': result.cause && result.cause.errorDetails
                };
            }

            fields['browserua'] = userAgent;
            var logMessage = new NccpLogMessage(fauxPlayback, 'securestop', (result.success ? 'info' : 'error'), fields);
            nccpLogBatcher.queueLogMessage(logMessage);
        }
    }

    callback = callback || NOOP;
    var data = PlayDataManager$persistedPlaydataFromLastSession;
    if (data) {
        var accountKey = data.accountKey;
        // delete this immediately, we never want to retry
        PlayDataManager$persistedPlaydataFromLastSession = null;
        if (accountKey) {
            var doResolve;
            PlayDataManager$waitForPersistedPlaydataToBeSent = new Promise(function(resolve, reject) {
                doResolve = resolve;
            });
            account$load(accountKey, function(result) {
                var account = result.account;
                if (result.success && account) {
                    var keySessionId = data.keySessionId;

                    edgeContext = {
                        http: http,
                        log: _log,
                        accountKey: accountKey
                    };

                    if (!keySessionId) {
                        _log.info('No key session so just send the playdata');
                        _stopAndRelease(data).then(function(result) {
                            _log.trace('Successfully sent stop command for previous session');
                            doResolve();
                            callback(SUCCESS);
                        }).catch(function(err) {
                            _log.error('Unable to send stop command for previous session', err);
                            doResolve();
                            callback(SUCCESS);
                        });                        
                    } else {
                        var emeSession = _createEmeSession('cenc');
                        _log.info('Sending the deferred playdata and secure stop data');
                        emeSession.create(config.keySystemId).then(function(result) {
                            return emeSession.deferredSecureStop(keySessionId, data);
                        }).then(function(result) {
                            _log.info('Sent the deferred playdata and secure stop data');
                            doResolve();
                            callback(SUCCESS);
                            _sendSecureStopLogBlob(result, data);
                        }).catch(function(err) {
                            _log.error('Unable to send last stop', err);
                            doResolve();
                            callback(SUCCESS);
                            _sendSecureStopLogBlob(err, data);
                        });
                    }
                } else {
                    doResolve();
                    callback(SUCCESS);
                }
            });
        } else {
            callback(SUCCESS);
        }
    } else {
        _log.info('no data to persist')
        callback(SUCCESS);
    }
}
/**
* @param {function(Object=)=} callback
*
*/
function PlayDataManager$deletePersistedPlaydata(callback) {
    if (storage && config && config.playdataPersistKey) {
        storage.remove(config.playdataPersistKey, function(result) {
            if (!result.success) {
                log.error('Error deleting playdata', result);
            }
            callback && callback(result);
        });
    }
}

function unminifyPlayData(data) {
    return {
        'accountKey': data.accountKey,
        'keySessionId': data.keySessionId,
        'licenseContextId': data.licenseContextId,
        'mediaId': data.mediaId,
        'movieId': data.movieId,
        'playback': data.playback,
        'playbackContextId': data.playbackContextId,
        'playbackSessionId': data.playbackSessionId,
        'position': data.position,
        'timestamp': data.timestamp,
        'xid': data.xid
    };
}

function minifyPlayData(data) {
    return {
        accountKey: data['accountKey'],
        keySessionId: data['keySessionId'],
        licenseContextId: data['licenseContextId'],
        mediaId: data['mediaId'],
        movieId: data['movieId'],
        playback: data['playback'],
        playbackContextId: data['playbackContextId'],
        playbackSessionId: data['playbackSessionId'],
        position: data['position'],
        timestamp: data['timestamp'],
        xid: data['xid']
    };
}

loadAsync$register(ErrorCodes.INIT_COMPONENT_PERSISTEDPLAYDATA, function asyncLoadPersistedPlaydataFromLastSession(callback) {

    var _log = new log.CategoryLog('PlayDataManager');

    if (config.sendPersistedPlaydata && config.playdataPersistKey) {

        storage.load(config.playdataPersistKey, function (result) {
            var data;
            if (result.success) {
                var dataString = result.data;
                try {
                    data = minifyPlayData(JSON.parse(dataString));
                    if (DEBUG || DEV) {
                        _log.debug('Read playdata', stringifyJsonPretty(data));
                    }
                }
                catch (e) {
                }
            }

            if (data) {
                PlayDataManager$persistedPlaydataFromLastSession = data;
            } else {
                // if we fail to get the data, due to reason OTHER than there not being persisted data, log and error and wipe it
                if (result.errorSubCode != ErrorSubCodes.STORAGE_NODATA) {
                    _log.error('Unable to parse persisted playdata');
                    PlayDataManager$deletePersistedPlaydata();
                }
            }

            callback(SUCCESS);
        });

    } else {

        callback(SUCCESS);

    }

});



// -- bandwidth/HistoricalBandwidthMeasurement.js
/**
* @constructor
*/
function HistoricalBandwidthMeasurement(requestTimestamp, latency, transferTime, transferBytes) {
    // seconds since applicaiton start-up
    this.startTimestamp = requestTimestamp;
    // duration in milliseconds
    this.responseTime = latency;
    this.transferTime = transferTime;
    // Bytes
    this.transferBytes = transferBytes;
    // duration in milliseconds
    this.totalTime = this.responseTime + this.transferTime;
}


// -- bandwidth/HistoricalBandwidth.js
var HISTORICAL_PERSIST_KEY = 'HistoricalBandwidth';

/**
 * @constructor
 */
function HistoricalBandwidth(playback) {
    var _log = new playback.log.CategoryLog('HistoricalBandwidth');
    var _self = this;
    var _sessionIPAddress,
        _bandwidthMeter,
        _aggregateCurrentMeasurementsTimer,
        _firstAggregationComplete = false,
        _numMeasurementsInHistory = 0;

    playback.addEventListener(Playback$authorized, _init);

    // measurements from the current session
    var sessionBandwidthMeasurements = {};
    // periodically updated measurements that combine history and current session
    var historicalBandwidthMeasurements = {};
    var ipAddressesInTheSameNetblock = [];
    // keep track of the last entry that has been persisted to indexedDB
    var lastAddedTimestamp = 0;

    /* Public functions */
    this.getNumMeasurementsInHistory = function () { return _numMeasurementsInHistory; };
    this.getExpectedBandwidth = _getExpectedBandwidth;

    function _init() {
        DEBUG && _log.debug('Initiating HistoricalBandwidth class');
        playback.historical = _self;
        _bandwidthMeter = playback.bandwidthMeter;
        _sessionIPAddress = playback.sessionIPAddress;
        // aggregate and persist data periodically, instead of just at the end of session
        _aggregateCurrentMeasurementsTimer = new RecurringTimer(config.histAggregationTimeSpanInSeconds * 1000, _aggregateCurrentSession);
        _aggregateCurrentMeasurementsTimer.setTimer();
        playback.addEventListener(BandwidthMeter$aggregateUpdated, _addSessionBandwidthMeasurement);
        playback.addEventListener(Playback$closing, function () {
            _saveHistoricalData();
            _aggregateCurrentMeasurementsTimer.clearTimer();
        });
        // stop logging if the playback is ended but Playback$closing has not been fired yet (CAD-1058)
        playback.presentingState.addListener(function () {
            if (playback.presentingState.value === PresentingState$ENDED) {
                _aggregateCurrentMeasurementsTimer.clearTimer();
            }
        });
        _loadHistoricalData();
    }

    // add a measurement given the current CDN choice
    function _addSessionBandwidthMeasurement() {
        var appStartTime = clock$getAppEpoch() * 1000;
        var cdnLocationId = _bandwidthMeter.getLatestCDN();
        var requestTimestamp = _bandwidthMeter.getLatestRequestTime();
        var requestLatency = _bandwidthMeter.getLatency();
        var transferLatency = _bandwidthMeter.getTransferTime();
        var totalBytes = _bandwidthMeter.getTotalBytes();

        if (!cdnLocationId) {
            return;
        }

        if (!totalBytes) {
            return;
        }

        var bandwidthMeasurement =
            new HistoricalBandwidthMeasurement(appStartTime + requestTimestamp, requestLatency, transferLatency, totalBytes);

        // check that sessionIPAddress is defined and not empty
        if (_sessionIPAddress) {
            if (!(cdnLocationId in sessionBandwidthMeasurements)) {
                sessionBandwidthMeasurements[cdnLocationId] = []; // list of historicalBandwidthMeasurements
            }
            sessionBandwidthMeasurements[cdnLocationId].push(bandwidthMeasurement);
        }
    }

    function _getExpectedBandwidth(cdnLocationId, startTime) {
        var expected;
        if (_sessionIPAddress) {
            var bandwidthMeasurements = [];

            // if we have measurements from the current session, use those
            if (cdnLocationId in sessionBandwidthMeasurements && _firstAggregationComplete) {
                bandwidthMeasurements = sessionBandwidthMeasurements[cdnLocationId];
                expected = new ExpectedBandwidth
                (
                    bandwidthMeasurements,
                    startTime,
                    config.histFilterType,
                    config.histTimeOfDayRangeInSeconds,
                    config.histMinSampleSize,
                    config.histMaxSampleSize,
                    true,
                    1.0,
                    _countTotalMeasurements()
                );
                return expected;
            }

            // use the historical measurement
            var numAddresses = ipAddressesInTheSameNetblock.length;
            var ipAddress,
                entry,
                numEntries,
                cdnData;
            while (numAddresses--) {
                ipAddress = ipAddressesInTheSameNetblock[numAddresses];
                if (cdnLocationId in historicalBandwidthMeasurements[ipAddress]) {
                    entry = historicalBandwidthMeasurements[ipAddress];
                    cdnData = entry[cdnLocationId];
                    numEntries = cdnData.length;
                    while (numEntries--) {
                        bandwidthMeasurements.push(cdnData[numEntries]);
                    }
                }
            }
            if (bandwidthMeasurements.length !== 0) {
                expected = new ExpectedBandwidth
                (
                    bandwidthMeasurements,
                    startTime,
                    config.histFilterType,
                    config.histTimeOfDayRangeInSeconds,
                    config.histMinSampleSize,
                    config.histMaxSampleSize,
                    false,
                    1.0,
                    _countTotalMeasurements()
                );
                 return expected;
            }
        }
    }

    // add the measurements from the current session to the historical record
    function  _addSessionToHistoricalBandwidthMeasurements() {
        if (!(_sessionIPAddress in historicalBandwidthMeasurements)) {
            historicalBandwidthMeasurements[_sessionIPAddress] = {}; // list of <cdn, measurement list> pairs
        }

        var currentSession = historicalBandwidthMeasurements[_sessionIPAddress];
        var latestTimestamp = 0;
        enumerateOwnProperties(sessionBandwidthMeasurements, function (cdnLocationId, measurements) {
            var cdnEntry;
            if (!(cdnLocationId in currentSession)) {
                // create a new list for this CDN
                cdnEntry = [];
            } else {
                cdnEntry = currentSession[cdnLocationId];
            }

            var aggregatedBandwidthMeasurements = _aggregateBandwidthMeasurements(measurements, config.histAggregationTimeSpanInSeconds);
            var len = aggregatedBandwidthMeasurements.length;
            while (len--) {
                // only add entry if it is new since the last time we persisted data
                if (aggregatedBandwidthMeasurements[len].startTimestamp > lastAddedTimestamp) {
                    cdnEntry.push(aggregatedBandwidthMeasurements[len]);
                }
                // keep updated the timestamp of what's the last persisted entry
                if (latestTimestamp < aggregatedBandwidthMeasurements[len].startTimestamp) {
                    latestTimestamp = aggregatedBandwidthMeasurements[len].startTimestamp;
                }
            }
            currentSession[cdnLocationId] = cdnEntry;
            lastAddedTimestamp = latestTimestamp;
        });
    }

    // aggregate measurements during the session in order to limit memory use
    function _aggregateCurrentSession() {
        if (!_firstAggregationComplete) {
            _firstAggregationComplete = true;
        }
        for (var cdnLocationId in sessionBandwidthMeasurements) {
            sessionBandwidthMeasurements[cdnLocationId] = _aggregateBandwidthMeasurements(sessionBandwidthMeasurements[cdnLocationId], config.histAggregationTimeSpanInSeconds);
        }
        _saveHistoricalData();
    }

    function _aggregateBandwidthMeasurements(bandwidthMeasurements, aggregationTimeSpan) {
        var aggregatedBandwidthMeasurements = []; //of bandwidth measurements
        var measurementsToAggregate = []; //of bandwidth measurements
        var aggregationTimeSpanInMillis = aggregationTimeSpan * 1000;
        var bandwidthMeasurement;

        if (bandwidthMeasurements.length > 0) {
            var startTimestamp = bandwidthMeasurements[0].startTimestamp;
            for (var i=0; i<bandwidthMeasurements.length; i++) {
                bandwidthMeasurement = bandwidthMeasurements[i];
                var timeSpan = Math$abs(startTimestamp - bandwidthMeasurement.startTimestamp);
                if (timeSpan <= aggregationTimeSpanInMillis) {
                    measurementsToAggregate.push(bandwidthMeasurement);
                } else {
                    // aggregate and add
                    aggregatedBandwidthMeasurements.push
                        (_sumMeasurementsByField(measurementsToAggregate));

                    // start new list
                    startTimestamp = bandwidthMeasurement.startTimestamp;
                    measurementsToAggregate = [bandwidthMeasurement];
                }
            }
            if (measurementsToAggregate.length > 0) {
                aggregatedBandwidthMeasurements.push
                    (_sumMeasurementsByField(measurementsToAggregate));
            }
        }
        return aggregatedBandwidthMeasurements;
    }

    function _sumMeasurementsByField(listToSum) {
        var responseTime = 0;
        var transferTime = 0;
        var transferBytes = 0;

        var listLength = listToSum.length;
        for (var i=0; i<listLength; i++) {
            responseTime += listToSum[i].responseTime;
            transferTime += listToSum[i].transferTime;
            transferBytes += listToSum[i].transferBytes;
        }
        var newEntry = new HistoricalBandwidthMeasurement(listToSum[0].startTimestamp, responseTime, transferTime, transferBytes);
        return newEntry;
    }

    // order all measurements over all IPs and CDNS in descending order
    // save the (SizeLimit) most recent ones
    // remove everything else
    // check if any CDN or IP is empty and remove those

    function _removeOldestBandwidthMeasurements() {
        var numberOfMeasurements = _countTotalMeasurements();

        if (numberOfMeasurements > config.histSizeLimit) {
            var allDatapoints = [];
            var measurements,
                arrayLength,
                i,
                ipKey;

            // get all measurements in the same array
            enumerateOwnProperties(historicalBandwidthMeasurements, function(ipKey, ipSession) {
                if (ipSession) {
                    enumerateOwnProperties(ipSession, function(cdnKey, measurements) {
                        arrayLength = measurements.length;
                        for (i=0; i<arrayLength; i++) {
                            allDatapoints.push(measurements[i]);
                        }
                    });
                }
            });

            // sort all existing historical bandwidth measurements, newest first
            allDatapoints.sort(function(a, b) {
                return b.startTimestamp-a.startTimestamp; });

            // find the time limit of which datapoints to keep
            var startTimeLimit = allDatapoints[config.histSizeLimit-1].startTimestamp;

            // prune array to only keep newest datapoints
            enumerateOwnProperties(historicalBandwidthMeasurements, function(ipKey, ipSession){
                if (ipSession) {
                    enumerateOwnProperties(ipSession, function(cdnKey, measurements) {
                        arrayLength = measurements.length;
                        for (i=0; i<arrayLength; i++) {
                            if (measurements[i].startTimestamp < startTimeLimit) {
                                // remove the measurement
                                measurements.splice(i, 1);
                                // adjust array index since we removed an element
                                i = i-1;
                                arrayLength = arrayLength - 1;
                            }
                        }
                        // if a CDN entry lost all its datapoints, delete it
                        if (measurements.length === 0) {
                            delete ipSession[cdnKey];
                        }
                    });

                    // the IP address has no data associated with it any more
                    if (Object.keys(ipSession).length === 0) {
                        delete historicalBandwidthMeasurements[ipKey];
                    }
                }
            });
        }
    }

    function _countTotalMeasurements() {
        var sum = 0;
        for (var ipKey in historicalBandwidthMeasurements) {
            var cdnList = historicalBandwidthMeasurements[ipKey];
            for (var cdnKey in cdnList) {
                sum += cdnList[cdnKey].length;
            }
        }
        return sum;
    }

    function _getIPAddressesInTheSameNetblock(ipAddressToMatch, ipAddresses) {
        var result = [];
        var bitmask;

        if (IPAddress$getValidIPv4(ipAddressToMatch)) {
            bitmask = config.histCompareBitsIPv4;
        } else if (IPAddress$getValidIPv6(ipAddressToMatch)) {
            bitmask = config.histCompareBitsIPv6;
        } else {
            // IP address was not formatted properly
            return result;
        }

        for (var i=0; i<ipAddresses.length; i++) {
            if (IPAddress$isInSameSubnet(ipAddressToMatch, ipAddresses[i], bitmask)) {
                result.push(ipAddresses[i]);
            }
        }
        return result;
    }

    function _loadHistoricalData() {
        debug$assert(storage);

        if (!_sessionIPAddress) {
            return;
        }

        storage.load(HISTORICAL_PERSIST_KEY, function (result) {
            var json;
            if (result.success) {
                json = result.data;

                if (json) {
                    historicalBandwidthMeasurements = _deobfuscateHistorical(json);
                    ipAddressesInTheSameNetblock = _getIPAddressesInTheSameNetblock(_sessionIPAddress, Object$keys(historicalBandwidthMeasurements));
                    _numMeasurementsInHistory = _countTotalMeasurements();
                }
            }
        });
    }

    function _saveHistoricalData() {
        debug$assert(storage);
        if (_sessionIPAddress) {
            _addSessionToHistoricalBandwidthMeasurements();
            _removeOldestBandwidthMeasurements();
            storage.save(HISTORICAL_PERSIST_KEY, _obfuscateHistorical(historicalBandwidthMeasurements));
        }
    }

    // shorten the fileds of the Historical measurements object
    // do this manually so minimization is consistent over time
    function _obfuscateHistorical(historicalBandwidthMeasurements){
            var toStore = {};
            Object.keys(historicalBandwidthMeasurements).forEach(function(ip_key){
                toStore[ip_key] = {};
                Object.keys(historicalBandwidthMeasurements[ip_key]).forEach(function(cdn_key) {
                    var measurementsForCDN = historicalBandwidthMeasurements[ip_key][cdn_key];
                    var len = measurementsForCDN.length;
                    var newList = [];

                    for (var i=0; i<len; i++) {
                        newList.push(
                            {
                                'sT': measurementsForCDN[i].startTimestamp,
                                'rT': measurementsForCDN[i].responseTime,
                                'trT': measurementsForCDN[i].transferTime,
                                'tB': measurementsForCDN[i].transferBytes,
                                'toT': measurementsForCDN[i].totalTime
                            }
                        );
                    }
                    toStore[ip_key][cdn_key] = newList;
                });


            });
            return toStore;
    }

    function _deobfuscateHistorical(historicalBandwidthMeasurements){
        var toLoad = {};
        Object.keys(historicalBandwidthMeasurements).forEach(function(ip_key){
            toLoad[ip_key] = {};
            Object.keys(historicalBandwidthMeasurements[ip_key]).forEach(function(cdn_key) {
                var measurementsForCDN = historicalBandwidthMeasurements[ip_key][cdn_key];
                var len = measurementsForCDN.length;
                var singleMeasurement;
                var newList = [];

                for (var i=0; i<len; i++) {
                    singleMeasurement = {};
                    // prune old data which might have been obfuscated differently
                    // those measurements will not have the 'sT', 'rT', 'trT', 'tB', and 'toT' fields
                    if (typeof measurementsForCDN[i]['sT'] !== 'undefined' &&
                        typeof measurementsForCDN[i]['rT'] !== 'undefined' &&
                        typeof measurementsForCDN[i]['trT'] !== 'undefined' &&
                        typeof measurementsForCDN[i]['tB'] !== 'undefined' &&
                        typeof measurementsForCDN[i]['toT'] !== 'undefined' )
                    {
                        singleMeasurement.startTimestamp = measurementsForCDN[i]['sT'];
                        singleMeasurement.responseTime = measurementsForCDN[i]['rT'];
                        singleMeasurement.transferTime = measurementsForCDN[i]['trT'];
                        singleMeasurement.transferBytes = measurementsForCDN[i]['tB'];
                        singleMeasurement.totalTime = measurementsForCDN[i]['toT'];
                        newList.push(singleMeasurement);
                    }
                }
                // if the whole list of measurements was pruned, don't add it.
                if (newList.length > 0) {
                    toLoad[ip_key][cdn_key] = newList;
                }
            });
            if (Object.keys(toLoad[ip_key]).length === 0) {
                delete toLoad[ip_key];
            }
        });
        return toLoad;
    }
}


// -- bandwidth/ExpectedBandwidth.js
/**
 * @constructor
 */

function ExpectedBandwidth(bandwidthMeasurements, startTime, filterType, timeOfDayRange, minNumberOfSamples, maxNumberOfSamples, isCurrentSessionOnly, confidence, totalSamples) {
    this.isCurrentSessionOnly = isCurrentSessionOnly;
    this.confidence = confidence;
    this.minNumberOfSamples = minNumberOfSamples;
    this.maxNumberOfSamples = maxNumberOfSamples;

    bandwidthMeasurements = ExpectedBandwidth$_calculate(bandwidthMeasurements, startTime, filterType, timeOfDayRange, this.minNumberOfSamples, this.maxNumberOfSamples, this.isCurrentSessionOnly, this.confidence);
    var bandwidths = [];
    //cap at 40,000
    for (var i=0; i<bandwidthMeasurements.length; i++) {
        bandwidths.push(Number$clamp((bandwidthMeasurements[i].transferBytes / bandwidthMeasurements[i].totalTime),  BandwidthMeter$_minThroughput, BandwidthMeter$_maxThroughput) * BPMStoKBPS);
    }

    this.orderedBandwidths = Array$sortNumbers(bandwidths);
    this.sampleSize = this.orderedBandwidths.length;
    this.averageBandwidth = Array$sum(this.orderedBandwidths)/this.orderedBandwidths.length;
    this.standardDev = computeStandardDev(this.orderedBandwidths, this.sampleSize, this.averageBandwidth);
    this.bandwidth20Percentile =  calculatePercentile(bandwidths, 0.20);
    this.bandwidth50Percentile =  calculatePercentile(bandwidths, 0.50);
    this.bandwidth90Percentile =  calculatePercentile(bandwidths, 0.90);
    this.filter = ExpectedBandWidth$finalFilterType;
    this.totalSamples = totalSamples;
}

function ExpectedBandwidth$_calculate(bandwidthMeasurements, startTime, filterType, timeOfDayRange, minNumberOfSamples, maxNumberOfSamples, isCurrentSessionOnly, confidence) {
    var filteredBandwidthMeasurements = [];
    var filter = filterType;
    var startDayOfWeek = Math$ceil((startTime % SECONDS_IN_WEEK) / SECONDS_IN_DAY); // remove week information from date, 0 is thursday, 1/1/1970
    var startTimeOfDay = startTime % SECONDS_IN_DAY; // remove date portion of the time stamp in seconds
    var elem,
        elemTimeOfDay,
        elemDayOfWeek,
        i;

    // for logging purposes
    ExpectedBandWidth$finalFilterType = filterType;

    if (filter === ExpectedBandwidth$FilterType_DayOfWeekTimeOfDay) {
        for (i=0; i<bandwidthMeasurements.length; i++) {
            elem = bandwidthMeasurements[i];
            elemTimeOfDay = elem.startTimestamp % SECONDS_IN_DAY;
            elemDayOfWeek = Math$ceil((elem.startTimestamp % SECONDS_IN_WEEK) / SECONDS_IN_DAY);

            if (startDayOfWeek === elemDayOfWeek && Math$abs(elemTimeOfDay - startTimeOfDay) <= timeOfDayRange) {
                filteredBandwidthMeasurements.push(elem);
            }
        }
        // check if after filtering on DayOfWeek and TimeOfDay, we have enough samples
        if (filteredBandwidthMeasurements.length < minNumberOfSamples) {
            filter = ExpectedBandwidth$FilterType_TimeOfDay;
            ExpectedBandWidth$finalFilterType = ExpectedBandwidth$FilterType_TimeOfDay;
            filteredBandwidthMeasurements = [];
        }
    }

    if (filter === ExpectedBandwidth$FilterType_TimeOfDay) {
        for (i=0; i<bandwidthMeasurements.length; i++) {
            elem = bandwidthMeasurements[i];
            elemTimeOfDay = elem.startTimestamp % SECONDS_IN_DAY;
            elemDayOfWeek = Math$ceil((elem.startTimestamp % SECONDS_IN_WEEK) / SECONDS_IN_DAY);

            if (Math$abs(elemTimeOfDay - startTimeOfDay) <= timeOfDayRange) {
                filteredBandwidthMeasurements.push(elem);
            }
        }

        // check if after filtering on DayOfWeek and TimeOfDay, we have enough samples
        if (filteredBandwidthMeasurements.length < minNumberOfSamples) {
            ExpectedBandWidth$finalFilterType = ExpectedBandwidth$FilterType_None;
            filteredBandwidthMeasurements = [];
        }
    }

    if (filter === ExpectedBandwidth$FilterType_None) {
        filteredBandwidthMeasurements = bandwidthMeasurements;
        if (filteredBandwidthMeasurements.length < minNumberOfSamples) {
            filteredBandwidthMeasurements = [];
        }
    }

    // if we have more than the max number of measurements
    // order by time and drop the oldest
    if (filteredBandwidthMeasurements.length > maxNumberOfSamples) {
        filteredBandwidthMeasurements = filteredBandwidthMeasurements.sort(function(o1,o2){
            if  (o1.startTimestamp < o2.startTimestamp)     { return -1; }
            else if(o1.startTimestamp > o2.startTimestamp)  { return  1; }
            else                                            { return  0; }
        }).slice(0, maxNumberOfSamples);
    }

    // ensure that total time is positive, to avoid divide by zero
    var nonzeroBandwidthMeasurements = [];
    for (var j=0; j<filteredBandwidthMeasurements.length; j++) {
        if (filteredBandwidthMeasurements[j].totalTime > 0) {
            nonzeroBandwidthMeasurements.push(filteredBandwidthMeasurements[j]);
        }
    }
    return nonzeroBandwidthMeasurements;
}

var ExpectedBandwidth$FilterType_None = 'none';
var ExpectedBandwidth$FilterType_DayOfWeekTimeOfDay = 'dayOfWeekTimeOfDay';
var ExpectedBandwidth$FilterType_TimeOfDay = 'timeofDay';
var ExpectedBandWidth$finalFilterType;



// -- cadmium-ase/PlaybackASE-BR.js
/**
 * @constructor
 * @param {?} accountKey     [description]
 * @param {number} movieId   [description]
 * @param {?} playbackParams [description]
 * @param {?} idProvider     [description]
 */
function PlaybackASE(accountKey, movieId, playbackParams, idProvider) {
    var _self = this,
        _done,
        _xid,
        _mediaTimeChangedThrottle = new Throttle(1000),
        _eventSource = new EventSource(),
        _milestones = {},
        _firstPrebufferComplete,
        _videoDiagInfo = {},
        _mediaSourceCounter = 0,
        _platformDeps = {};

    _self.createTime = clock$getTime();
    if (config.prepareCadmium && videoPreparer) {
        _xid = videoPreparer.getXid(movieId)
    }
    if (!_xid) {
        if (Playback$firstPlaybackXid) {
            _xid = Playback$firstPlaybackXid;
            Playback$firstPlaybackXid = undefined;
        } else {
            _xid = clock$createId();
        }
    }

    Playback$mostRecentPlaybackXid = _xid;

    // events
    _self.addEventListener = _eventSource.addListener;
    _self.removeEventListener = _eventSource.removeListener;
    _self.fireEvent = _eventSource.fire;

    // basic information about this playback
    _self.accountKey = accountKey;
    _self.movieId = movieId;
    _self.playbackParams = playbackParams || {};
    _self.trackingId = _self.playbackParams.trackingId || 0;
    _self.index = ++Playback$_index;
    _self.xid = _xid;
    _self.rootElement = createElement('DIV', 'position:relative;width:100%;height:100%;overflow:hidden');
    // throw a dice, and see if we should log trace info
    _self.logVerbosePlaybackInfo = config.verbosePlaybackInfoDenominator && !(_xid % config.verbosePlaybackInfoDenominator);
    _self.logFields = { 'MovieId': _self.movieId, 'TrackingId': _self.trackingId, 'Xid': _self.xid, 'AccountKey': _self.accountKey };
    _self.milestones = _milestones;
    var _playbackLog = new PlaybackLog(_self);
    _self.log = _playbackLog;
    var _log = new _self.log.CategoryLog('PlaybackASE');
    Playback$mostRecentPlaybackLog = _playbackLog;
    Playback$firstPlaybackLog || (Playback$firstPlaybackLog = _playbackLog);

    _log.info('Playback created', _self.logFields);

    if (_self.logVerbosePlaybackInfo) {
        _log.info('Playback selected for trace playback info logging');
    } else {
        _log.trace('Playback not selected for trace playback info logging');
    }

    _self.getCongestionInfo = function (callback) {
		if (config.enableCongestionService) {
			return congestionService.getCongestion(callback);
		} else {
			callback = callback || function () {};
			var congestionInfo = {
                'success': false,
				'name': null,
				'isCongested': null
			}
			callback(congestionInfo);
	        return congestionInfo;
		}
    }

    if(config.prepareCadmium && videoPreparer) {
        videoPreparer.handlePlaybackCreated(_self.movieId);

        _self.addEventListener(Playback$playbackstart, function() {
            videoPreparer.handlePlaybackStarted(_self.movieId);
        });
        _self.addEventListener(Playback$closing, function() {
            videoPreparer.handlePlaybackClosing(_self.movieId);
        });
    }

    // --------------------------------------------------------------------------------
    // -- .state, .fatalError, closing event

    _self.state = new ObservableProperty(Playback$STATE_NOTLOADED);
    _self.state.addListener(function (args) {
        _log.info('Playback state changed', { 'From': args.oldValue, 'To': args.newValue });
        debug$assert(args.newValue > args.oldValue);
    });

    _self.notifyLoading = function () {
        debug$assert(_self.state.value == Playback$STATE_NOTLOADED);
        _self.log.playback.loadTime = _self.loadTime = clock$getTime();
        _self.loadEpoch = clock$getEpoch();
        _self.relativeLoadTime = clock$getTime();
        _self.state.set(Playback$STATE_LOADING);
    };
    _self.notifyLoaded = function () {
        // handle being in in Playback$STATE_CLOSED due to a playback error
        // when .load finishes
        //only set the state after the manager is up
        if (_self.state.value == Playback$STATE_LOADING) {
            _self.state.set(Playback$STATE_NORMAL);
        }
    };
    _self.notifyMilestone = function (milestoneId) {
        // track key startup milestones for logging
        _log.trace('Milestone', { 'Id': milestoneId });
        _milestones[milestoneId] = _self.getRelativeTime();
    };

    _self.getAuthDelay = function(){
        if(isNumber(_self.milestones['ats']) && isNumber(_self.milestones['at'])){
            return _self.milestones['at'] - _self.milestones['ats'];
        }
    };
    _self.getBufferedLength = function(){
        return _self.mediaBuffer && _self.mediaBuffer.getBufferLength();
    };
    _self.getIntialHeadersDelay = function(){
        if(isNumber(_self.milestones['shs']) && isNumber(_self.milestones['sh'])){
            return _self.milestones['sh'] - _self.milestones['shs'];
        }
    };

    /**
     * @param {Function=} callback
     */
    _self.close = function (callback) {
        if (callback) {
            if (_self.state.value == Playback$STATE_CLOSED) {
                callback();
            } else {
                // no need to remove the event, _eventSource.dispose() will do it
                _self.addEventListener(Playback$closed, function () {
                    callback();
                });
            }
        }
        _startClosing();
    };
    _self.closeWithError = function (fatalError) {
        // in some cases (erros induced by UI), we are asked to fail with error without being loaded
        // for those cases, we actually need to load so we can send the error to NCCP
        if (_self.state.value == Playback$STATE_NOTLOADED) {
            // just cache the error, and stat loading
            // the load() will call us again
            if (!_self.fatalError) {
                _self.fatalError = fatalError;
                _self.load();
            }
            return;
        }

        function _doStartClosing() {
            _startClosing(fatalError);
        }
        var handleDelay = config.delayErrorHandling && fatalError && config.delayErrorHandling[fatalError.errorCode];
        if (isValidString(handleDelay)) handleDelay = parseInt10(handleDelay);
        // for some errors we don't want to shutdown playback immidiately, rather wait for a more desriptive error
        // for example, in Safari, sourceBuffer.append might throw... but only a followup keyerror event will have the helpfull systemCode we can use to show good error message
        _log.error('Fatal playback error', { 'Error': '' + fatalError, 'HandleDelay': '' + handleDelay });
        if (handleDelay >= 0) {
            setTimeout(_doStartClosing, handleDelay);
        } else {
            _doStartClosing();
        }
    };
    _self.waitForNotifyClosed = function () {
        _shouldWaitForNotifyClosed = true;
    };
    _self.notifyClosed = function () {
        _releaseLockAndCompleteClosing();
    };

    _self.tryRecoverFromStall = function _tryRecoverFromStall() {
        _eventSource.fire(Playback$tryRecoverFromStall);
    };

    var _shouldWaitForNotifyClosed;
    /**
     * @param {Object=} fatalError
     */
    function _startClosing(fatalError) {
        if (_self.state.value == Playback$STATE_NOTLOADED || _self.state.value == Playback$STATE_LOADING || _self.state.value == Playback$STATE_NORMAL) {
            _log.info('Playback closing', _self, fatalError ? { 'ErrorCode': fatalError.displayCode } : undefined);
            globalEvents.removeListener(globalEvents$beforeunload, _onBeforeUnload);

            // update videoDiagInfo right before closing, so we don't loose information after componets are disposed
            _self.fatalError = fatalError;
            _fireShouldUpdateVideoDiagInfo();
            try {
                _eventSource.fire(Playback$closing);
            } catch (e) {
                _log.error('Unable to fire playback closing event', e);
            }
            _self.state.set(Playback$STATE_CLOSING);
            _ASEClosing();
            if (!_shouldWaitForNotifyClosed) {
                dispatch(_releaseLockAndCompleteClosing);
            }
        }
    };
    function _ASEClosing(){
        if (_self.streamingSession) {
            _self.streamingSession.close();
            _self.streamingSession.cleanup();
        }
        if (_self.streamingManager) {
            _self.streamingManager.cacheFlush();
        }
        delete _self.streamingSession;
        delete _self.streamingManager;
    };
    function _releaseLockAndCompleteClosing() {
        debug$assert(_self.state.value == Playback$STATE_CLOSING);
        var lockToken = _self.lockToken;
        _self.lockToken = undefined;
        if (lockToken) {
            storageLock.release(lockToken, function (result) {
                debug$assert(result.success);
                _completeClosing();
            });
        } else {
            _completeClosing();
        }
    };
    function _completeClosing() {
        _completeClosing = NOOP;
        debug$assert(_self.state.value == Playback$STATE_CLOSING);

        var index = Playback$openPlaybacks.indexOf(_self);
        debug$assert(index >= 0);
        Playback$openPlaybacks.splice(index, 1);

        _self.state.set(Playback$STATE_CLOSED);
        _eventSource.fire(Playback$closed, {}, true);
        // stop firing events
        _eventSource.dispose();
    };

    // close the playback (so we stop all donwnloads) when window is unloading
    // also, Playback needs to be the last to handle this... in case say PlayDataManager needs to do something synchroniously
    function _onBeforeUnload() {
        _startClosing();
    };
    globalEvents.addListener(globalEvents$beforeunload, _onBeforeUnload, ORDERPROPERTY$late);

    // --------------------------------------------------------------------------------
    // -- mediaTime

    // current media time, a.k.a. PTS
    _self.mediaTime = new ObservableProperty();
    var _lastThrottledMediaTimeValue;
    function _fireThrottledMediaTimeChanged() {
        var v = _self.mediaTime.value;
        if (_lastThrottledMediaTimeValue != v) {
            DEBUG && _log.debug('MediaTime changed', { 'MediaTime': Number$formatMillisecond(v) });
            _lastThrottledMediaTimeValue = v;
            _eventSource.fire(Playback$throttledMediaTimeChanged);
        }
    };
    _self.mediaTime.addListener(function (args) {
        _mediaTimeChangedThrottle.schedule(_fireThrottledMediaTimeChanged);
    });
    _self.flushThrottledMediaTimeChanged = function () {
        _fireThrottledMediaTimeChanged();
    };

    // --------------------------------------------------------------------------------

    // is playback paused by user?
    // TODO: debug$assertBool(value);
    _self.paused = new ObservableProperty(false);
    _self.paused.addListener(function (args) {
        _log.info('Paused changed', { 'From': args.oldValue, 'To': args.newValue, 'MediaTime': Number$formatMillisecond(_self.mediaTime.value) });
    });

    _self.muted = new ObservableProperty(false);
    _self.volume = new ObservableProperty(config.defaultVolume / 100);

    // state of the presenter
    // TODO: debug$assertBool(value);
    _self.presentingState = new ObservableProperty(PresentingState$WAITING);
    _self.presentingState.addListener(function (args) {
        _log.info('PresentingState changed', { 'From': args.oldValue, 'To': args.newValue, 'MediaTime': Number$formatMillisecond(_self.mediaTime.value) }, _self.mediaBuffer.getLogFields());
    });

    // state of the downloader
    // TODO: debug$assert(value >= 0 && value <= 4);
    _self.bufferingState = new ObservableProperty(BufferingState$BUFFERING);
    _self.bufferingState.addListener(function (args) {
        _log.info('BufferingState changed', { 'From': args.oldValue, 'To': args.newValue, 'MediaTime': Number$formatMillisecond(_self.mediaTime.value) }, _self.mediaBuffer.getLogFields());
    });

    // debug$assert(value);
    _self.audioTrack = new ObservableProperty(null);
    _self.audioTrack.addListener(function (args) {
        debug$assert(args.newValue);
        _log.info('AudioTrack changed',
            args.newValue && { 'ToBcp47': args.newValue.bcp47, 'To': args.newValue.trackId },
            args.oldValue && { 'FromBcp47': args.oldValue.bcp47, 'From': args.oldValue.trackId },
            { 'MediaTime': Number$formatMillisecond(_self.mediaTime.value) }
        );
    });

    _self.videoTrack = new ObservableProperty(null);
    _self.videoTrack.addListener(function (args) {
        var streams = _self.getVideoStreamList();
        var streamsLength = streams.length;
        CadmiumMediaStreams$addMethodsToArray(streams);
        for (var i = 0; i < streamsLength; i++) {
            streams[i].lower = streams[i - 1];
            streams[i].higher = streams[i + 1];
        }
        _self.videoStream.set(_self.getVideoStreamList()[0]);
    });

    _self.timedTextTrack = new ObservableProperty(null);
    _self.timedTextTrack.addListener(function (args) {
        _log.info('TimedTextTrack changed',
            args.newValue ? { 'ToBcp47': args.newValue.bcp47, 'To': args.newValue.trackId } : { 'To': 'none' },
            args.oldValue ? { 'FromBcp47': args.oldValue.bcp47, 'From': args.oldValue.trackId } : { 'From': 'none' },
            { 'MediaTime': Number$formatMillisecond(_self.mediaTime.value) }
        );
    });
    // unlike .timedTextTrack, this gets set only if timedTextTrack has downloaded it's data
    _self.activeTimedTextTrack = new ObservableProperty(null);
    _self.timedText = new ObservableProperty(null);

    _self.videoStream = new ObservableProperty(null);
    _self.audioStream = new ObservableProperty(null);
    _self.cdn = new ObservableProperty(null);

    // chunk and time that is being presented now {stream, chunk, cdn}
    // unlike .mediaTime, .videoStream, .audioStream, .cdn, which indicate "what we want to show"
    // these indicate what's actually on the screen
    _self.presentedAudio = new ObservableProperty(null);
    _self.presentedVideo = new ObservableProperty(null);

    // chunk that started downloading {stream, chunk, cdn}
    _self.downloadingAudio = new ObservableProperty(null);
    _self.downloadingVideo = new ObservableProperty(null);

    // chunk that was downloaded last {stream, chunk, cdn}
    _self.downloadedAudio = new ObservableProperty(null);
    _self.downloadedVideo = new ObservableProperty(null);

    // property to log why we restrict bitrate
    _self.bitrateRestriction = new ObservableProperty(null);

    // Playback$playbackstart
    // playback is considered started when PresentingState becomes something else by WAITING for the first time
    function _presentingStateChangedForPlaybackStart(e) {
        if (e.newValue != PresentingState$WAITING) {
            _self.presentingState.removeListener(_presentingStateChangedForPlaybackStart);
            _eventSource.fire(Playback$playbackstart);
        }
    };
    _self.presentingState.addListener(_presentingStateChangedForPlaybackStart);

    _self.addEventListener(Playback$playbackstart, function handlePlaybackStart(){
        _self.playDelay = NccpClient$formatMillisecond(_self.getRelativeTime());
        if (DEBUG) {
            log.info('PlayDelay: ' + _self.playDelay + ', milestones: ', _self.milestones);
        }
        _self.notifyMilestone('start');
        var video = (_self.presentedVideo.value || _self.downloadedVideo.value);
        _self.initialVideoBitrate = video.stream.bitrate;
    });

    // Busy is either empty (player is not busy) or {stalled: true|false, progress: 0..1}
    // stalled and progress can be empty
    _self.busy = new ObservableProperty();
    Playback$initBusy(_self);

    // --------------------------------------------------------------------------------
    // custom diag info filled in with different components.
    // this is displayed in diag panel, and logged in startplay/midplay/endplay
    function _fireShouldUpdateVideoDiagInfo() {
        _eventSource.fire(Playback$shouldUpdateVideoDiagInfo, { videoDiagInfo: _videoDiagInfo });
    }
    _self.getVideoDiagInfo = function getVideoDiagInfo() {
        _fireShouldUpdateVideoDiagInfo();
        return _videoDiagInfo;
    };
    _self.setVideoDiagInfo = function setVideoDiagInfo(k, v) {
        _videoDiagInfo[k] = v;
    };

    // --------------------------------------------------------------------------------
    // -- playback components that are required to be ready before starting the playback
    // -- also create components that will be required for initialization
    // --------------------------------------------------------------------------------
    Playback$openPlaybacks.push(_self);
    _self.httpPlayback = new HttpPlayback(_self);
    _self.mediaHttp = new MediaHttpASE(_self);
    _self.bandwidthMeter = new BandwidthMeterASE(_self);

    _self.diagnostics = new PlayerDiagnostics(_self);
    _self.playbackInfoPanel = new PlaybackInfoPanel(_self);
    _self.playbackStreamManager = new PlaybackStreamManager(_self);
    _self.playDataManager = new PlayDataManager(_self);
    _self.mediaStreamFilter = new MediaStreamFilter(_self);

    if (config.enableHistorical) {
        _self.historical = new HistoricalBandwidth(_self);
    }

    // network throughout will be signaled from ASE; initialize here
    _self.throughput = -1;
    _self.responseTime = -1;
    _self.streamingBitrate = -1;


    Playback$componentsWhenCreated.forEach(function (loadComponent) {
        loadComponent(_self);
    });

    function addSessionEventListeners(streamingSession) {
        _self.addEventListener(Playback$repositioned, function (args) {
            if(args.cause === Playback$REPOSITION_CAUSE_INITIAL){
                //JSASE doesn't start on seek, don't change the state up there
                //_self.streamingSession.play();
                return;
            }
            _self.streamingSession.stop();
            // stop ASE
            // check whether we should swim (outside buffer) or skip (inside buffer)
            var videoChunkToSeekTo = _self.mediaBuffer.videoChunks.getForTime(args.newMediaTime);
            var audioChunkToSeekTo = _self.mediaBuffer.audioChunks.getForTime(args.newMediaTime);
            if (videoChunkToSeekTo.media && audioChunkToSeekTo.media) {
                // we have media, we can skip
                _log.trace('Repositioned. Skipping from ' + args.oldMediaTime + ' to ' + args.newMediaTime);
                _self.streamingSession.skipped(args.newMediaTime);
                _self.streamingSession.play();
            } else {
                // we don't have media, we should swim
                _log.trace('Repositioned. Seeking from ' + args.oldMediaTime + ' to ' + args.newMediaTime);

                // reset the Cadmium buffer upon seek to mimic the current NRDJS behavior.
                if(_self.mediaBuffer){
                    _self.mediaBuffer.reset();
                }
                _self.streamingSession.seek(args.newMediaTime);
            }
        });


        //following are the events issued by JSASE
        streamingSession.addEventListener("error", function(evt)
            {
                //TODO: ASE add event handler
                //this._error(evt);

                //Reset streamingFailure after exponential backoff
                // only reset error when it's Permenant streaming error
                if ( evt['error'] === "NFErr_MC_StreamingFailure"){
                    _log.trace("receiving an unrecoverable streaming error: " + JSON.stringify(evt));
                    if(_self.streamingFailureRetryCount >= _self.streamingFailureRetryWaits.length){
                        _self.streamingFailureRetryCount = _self.streamingFailureRetryWaits.length - 1;
                    }
                    var retryWaitMs = _self.streamingFailureRetryWaits[_self.streamingFailureRetryCount];
                    _self.streamingFailureRetryCount++;
                    _log.trace('StreamingFailure, buffer status:' + JSON.stringify(_self.mediaBuffer.getLogFields()));
                    setTimeout( function () {
                        // Ready to try it again from a clean-slate
                        _self.streamingSession._errorDirector.resetFailures(true);
                    } , retryWaitMs);
                }
            }.bind(this));
        streamingSession.addEventListener("headerCacheHit", function(evt)
            {
                //TODO: ASE
                //Handler for Header Cache Hit
            }.bind(this));
        streamingSession.addEventListener("bufferingStarted", function(evt)
            {
                //TODO: ASE
                // What else is needed here?
                _self.bufferingState.set(BufferingState$BUFFERING);
            }.bind(this));
        streamingSession.addEventListener("bufferingComplete", function(evt)
            {
                _log.trace('Buffering complete', { 'Cause': "ASE Buffering complete" }, _self.mediaBuffer);
                _self.histbw = evt['histBW'];
                _self.initSelReason = evt['initSelReason'];
                _self.buffCompleteReason = evt['buffCompleteReason'];
                DEBUG && _log.trace('Historical throughput used (after discounts): ' + _self.histbw);
                DEBUG && _log.trace('Reason for initial bitrate selection: ' + _self.initSelReason);
                DEBUG && _log.trace('Reason for ending pre-buffering: ' + _self.buffCompleteReason);
                _self.bufferingState.set(BufferingState$NORMAL);

                if (!_firstPrebufferComplete) {
                    _firstPrebufferComplete = true;
                    _self.notifyMilestone('pb');
                }
                _self.streamingSession.play();
            }.bind(this));
        streamingSession.addEventListener("audioTrackSwitchStarted", function(evt)
            {
                _self.streamingSession.onAudioTrackSwitchStarted();
            }.bind(this));
        streamingSession.addEventListener("audioTrackSwitchRejected", function(evt)
            {
                _self.streamingSession.onAudioTrackSwitchRejected();
            }.bind(this));
        /*streamingSession.addEventListener("audioTrackSwitchComplete", function(evt)
            {
                //TODO: ASE
            }.bind(this));*/
        streamingSession.addEventListener("streamingstat", function(evt)
            {
                //TODO: ASE
                // log as a streaming stat message
                _self.throughput = evt['location']['bandwidth'];
                _self.responseTime = evt['location']['httpResponseTime'];
                _self.streamingBitrate = evt['stat']['streamingBitrate'];

                if (_self.mediaBuffer && _self.mediaBuffer.isBufferFull()) {
                    _self.mediaBuffer.compact();
                }
            }.bind(this));
        if (config.abortPreemptively) {
            streamingSession.addEventListener("currentStreamInfeasible", function(evt)
            {

                    DEBUG && _log.trace('Current stream not feasible. Old: ' + evt['oldBitrate'] + ' New: ' + evt['newBitrate']);
                    // abort anything above the new bitrate that ASE is selecting
                    _self.mediaDownloader.abortAndClearDownloads(evt['newBitrate']);
            });
        }
    }

    addLoadMethodsToPlayback(this);
    //----- Load Steps Overrides
    // Override the template steps in the load method as defined in
    // addLoadMethodsToPlayback()
    mixIn(this,
        /** @lends {PlaybackASE.prototype} */
        {   getMediaElement: function() {return _self.mediaElement;},
            getMediaDownloader: function() {return _self.mediaDownloader;},
            getMediaSourceCounter: function() {return _mediaSourceCounter;},
            incrementMediaSourceCounter: function() { _mediaSourceCounter++; },
            // Step 7: Download some stream headers
            downloadInitialStreamHeaders: function downloadInitialStreamHeaders() {

                if (_self.state.value != Playback$STATE_LOADING)
                    return;

                _self.notifyMilestone('shs');

                // process force Track Selection if applicible
                var matches;
                if (config.forceAudioTrack) {
                    matches = this.audioTrackList.filter(function(track) {
                        return track.bcp47 == config.forceAudioTrack || track.trackId == config.forceAudioTrack;
                    });
                    if (matches && matches.length) {
                        _self.audioTrack.set(matches[0]);
                    }
                }

                if (config.forceTimedTextTrack) {
                    matches = this.timedTextTrackList.filter(function(track) {
                        return track ? (track.bcp47 == config.forceTimedTextTrack || track.trackId == config.forceTimedTextTrack) : config.forceTimedTextTrack.toLowerCase() == 'none';
                    });
                    if (matches && matches.length) {
                        _self.timedTextTrack.set(matches[0]);
                    }
                }

                // Download multiple stream headers,
                // Wait for all headers download to complete...
                // ... or, if timeout elapses, a single audio and a single video should suffice
                var audioStreamList = _self.getAudioStreamList(),
                    videoStreamList = _self.getVideoStreamList(),
                    headerDownloadTimeoutEllapsed = false,
                    lastDownloadFailureResult;

                function assessHeaderDownloadState() {
                    // pick lowest streams with header
                    var audioStream = audioStreamList.firstAbove(0, true);
                    var videoStream = videoStreamList.firstAbove(0, true);
                    var streamCdnList;

                    if (audioStream && videoStream) {
                        // we have at least one of each header, we are done!
                        assessHeaderDownloadState = NOOP;
                        _self.audioStream.set(_self.primaryAudioStream = audioStream);
                        _self.videoStream.set(_self.primaryVideoStream = videoStream);

                        streamCdnList = _self.streamCdnList;
                        if ( !_self.primaryCdn || !_self.streamCdnList ) {
                            // stream CDN-s are the CDN-s that have urls for audio and video streams
                            streamCdnList = [];
                            function addCdnToStreamCdnList(stream) {
                                enumerateOwnProperties(stream.downloadUrls, function(cdnId, url) {
                                    if (isUrl(url)) {
                                        _self.cdnList.forEach(function (cdn) {
                                            if (cdn.id === cdnId) {
                                                Array$pushIfDoesntContain(streamCdnList, cdn);
                                            }
                                        });
                                    }
                                });
                            };
                            map.call(_self.getAudioStreamList(), addCdnToStreamCdnList);
                            map.call(_self.getVideoStreamList(), addCdnToStreamCdnList);
                            sort.call(streamCdnList, function (a, b) {
                                return a.rank - b.rank;
                            });

                            // primary cdn is always the first on the list (one with lowest rank)
                            _self.primaryCdn = streamCdnList[0];
                            _self.streamCdnList = streamCdnList;
                        }


                        var streamLocationGroups = {};
                        streamCdnList.forEach(function(cdn) {
                            var locationId = cdn.location.id;
                            if (!streamLocationGroups[locationId]) {
                                streamLocationGroups[locationId] = [];
                            }

                            streamLocationGroups[locationId].push(cdn);
                        });
                        var streamLocationList = [];
                        enumerateOwnProperties(streamLocationGroups, function(locationId, cdnList) {
                            var location = cdnList[0].location;
                            location.cdnList = cdnList;
                            streamLocationList.push(location);
                        });
                        _self.streamLocationList = streamLocationList.sort(function(a, b) { return a.rank - b.rank; });

                        if (_self.primaryCdn != _self.cdnList[0]) {
                            log.error('Primary CDN does not have downloadUrls for a/v streams', { 'CdnId': _self.cdnList[0].id });
                        }
                        // Make sure we have a valid primary CDN to start the playback with
                        if (streamCdnList.length) {
                            _self.populatePlayback();
                        } else {
                            processFatalError(ErrorCodes.NCCP_AUTHORIZE_VERIFY);
                        }
                    } else {
                        // we don't have any usable header combination,
                        // and if there are no more downloads in progress this is a fatal error
                        if (_self.headerDownloadsInProgress <= 0) {
                            assessHeaderDownloadState = NOOP;
                            processFatalError(ErrorCodes.INIT_HEADER_MEDIA, _self.mediaDownloader.getLastHeaderDownloadFailureResult());
                        }
                    }
                };

                //initialize ASE
                _platformDeps.playbackLog = _self.log;
                _platformDeps.createFilteredVideoStreamList = function(){ return _self.createFilteredVideoStreamList(); };
                _platformDeps.storage = storage;
                _platformDeps.getNow = Date$now;
                _platformDeps.getTime = clock$getTime;
                _platformDeps.getMediaDownloader = _self.getMediaDownloader;
                _platformDeps.getMediaElement = _self.getMediaElement;
                _platformDeps.getMediaSourceCounter = _self.getMediaSourceCounter;
                _platformDeps.incrementMediaSourceCounter = _self.incrementMediaSourceCounter;
                _platformDeps.lhcache = {};
                _platformDeps.MediaRequest = MediaRequest;
                _platformDeps.DownloadTrack = DownloadTrack;
                _platformDeps.MediaSource = MediaSourceASE;
                _platformDeps.SourceBuffer = MediaElementSourceBuffer;
                _platformDeps.getCurrentPts = function(){ return _self.mediaTime.value; };
                _platformDeps.ipAddress = this.sessionIPAddress;

                //This is needed to mimic async storage API as a sync API
                //ASE Manager assume storage API is synchronous

                var loadNetworkHistory = new Promise(function(resolve, reject) {
                    storage.load("nh", function(result) {
                        if (result.success) {
                            _platformDeps.lhcache["nh"] = result.data;
                        } else {
                            _platformDeps.lhcache["nh"] = undefined;
                        }
                        resolve();
                    });
                });

                var loadLocationHistory = new Promise(function(resolve, reject) {
                    storage.load("lh", function(result) {
                        if (result.success) {
                            _platformDeps.lhcache["lh"] = result.data;
                        } else {
                            _platformDeps.lhcache["lh"] = undefined;
                        }
                        resolve();
                    });
                });

                var loadBitrateHistory = new Promise(function(resolve, reject) {
                    storage.load("vb", function(result) {
                        if (result.success) {
                            _platformDeps.lhcache["vb"] = result.data;
                        } else {
                            _platformDeps.lhcache["vb"] = undefined;
                        }
                        resolve();
                    });
                });

                Promise.all([loadLocationHistory, loadBitrateHistory, loadNetworkHistory]).then(function() {
                    var platform = require(7)(_platformDeps);
                    _self.streamingManager = require(52)(platform);

                    // Override ASE defaults
                    platform.events.emit('configChanged', require(6)(config));

                    // Vary ASE network monitor behavior depending on whether title is short
                    if (config.correctNetworkForShortTitles && _self.manifest['duration'] < 300000) {
                        platform.events.emit('configChanged', {'expandDownloadTime': false});
                    }

                    // downloader to fetch the media (CDN Selection happens here.)...
                    _self.mediaDownloader = new MediaDownloaderASE(_self);

                    _self.streamingManager.init(config.aseAudioBufferSizeBytes, config.aseVideoBufferSizeBytes,
                                                {
                                                    playbackLog: _self.log,
                                                    mediaDownloader: _self.mediaDownloader
                                                });

                    //download the initial header
                    // the number of headers in progress will be imcremented in MediaDownloaderASE when the request is issues.
                    // the number will be decremented when the download completes, regardless of success or fail
                    _self.headerDownloadsInProgress = 0;
                    var getManifestInfo = function()
                    {
                        return {
                            manifest: _self.manifest,
                            fastplay: false,
                            audioTrackId: audioStreamList[0].track.trackId
                        };
                    }.bind(this);

                    var args = {
                        movieId: _self.movieId,
                        priority: 0,
                        pts: _self.mediaTime.value,
                        getManifestInfo: getManifestInfo
                    };
                    _self.streamingManager.cachePrepare(args, assessHeaderDownloadState);

                    setTimeout(function () {
                        headerDownloadTimeoutEllapsed = true;
                        assessHeaderDownloadState();
                    }, config.initialHeaderDownloadTimeout);
                });

                // listen to rebuffering event and abort/clear video chunks that are not at the lowest bitrate
                // TODO: use AB test to determine whether we need a flag or we always abort
                if (config.abortInProgressAtRebuffer) {
                    _self.addEventListener(Playback$bufferUnderrun, function () {
                        DEBUG && _log.trace('Aborting and clearing jobs due to a rebuffer event.');
                        _self.mediaDownloader.abortAndClearDownloads();
                    });
                }
            },
            //step 9
            createWorkedObjects: function _createWorkedObjects() {
                try {
                    _self.mediaElement = new MediaElement(_self);
                    // this creates the MSE MediaSource
                    var sourceOpenPromise = new Promise(
                            function(resolve, reject){
                                _self.mediaElement.addEventListener(MediaElement$sourceopen, function () {
                                    resolve();
                                });
                                _self.mediaElement.open();
                            }
                        );
                    // presenter to play the media...
                    // Note: downloader and time tracker should be created after presenter, because presenter will change the playback.mediaTime

                    _self.mediaPresenter = new MediaPresenter(_self);


                    //TODO: Allow ASE pass in the trackIndexes
                    //These are the default audio/video track decided by Cadmium
                    this.trackIndexes = [this.defaultAudioTrackIndex, this.defaultVideoTrackIndex];

                    //TODO: ASE pass in the right audo/video buffer size
                    _self.streamingManager.updatePlatformImplementation(
                        {
                            mediaBuffer: _self.mediaBuffer
                        });

                    // context for session
                    var ctxt = {
                        playbackLog: _self.log,
                    };

                    var flags = {
                        fastplay: false,
                        useHeaderCache: true,
                        useHeaderCacheData: false,
                        loopVideo: false
                    };

                    _self.streamingFailureRetryCount = 0;
                    _self.streamingFailureRetryWaits = config.streamingFailureRetryWaits;
                    sourceOpenPromise.then(function(){
                        _self.streamingSession = _self.streamingManager.createSession(
                            _self.manifest,
                            _self.trackIndexes,
                            _self.bookmarkTime || 0,
                            flags,
                            ctxt);
                        addSessionEventListeners(_self.streamingSession);
                        _self.streamingSession.open();
                    });

                    //this is here to give mediatime a value,
                    //otherwise MediaBuffer will throw a bunch of errors
                    _self.mediaTime.set(_self.bookmarkTime || 0);
                    // timed text...
                    _self.timedTextManager = new TimedTextManager(_self);

                    // render the timed text
                    if (config.renderTimedText) {
                        _self.timedTextPresenter = new TimedTextPresenter(_self);
                    }

                    // play time tracker for reporting and diagnostics
                    _self.playTimeTracker = new PlayTimeTracker(_self);

                    // monitor for long pauses OR suspended execution, and induce playback error
                    _self.inactivityMonitor = new InactivityMonitor(_self);

                    Playback$componentsWhenLoaded.forEach(function(loadComponent) {
                        loadComponent(_self);
                    });

                    // and finally tell the playback that we are done
                    _self.notifyLoaded();
                } catch (e) {
                    processFatalError(ErrorCodes.INIT_CORE_OBJECTS3, {
                        errorSubCode: ErrorSubCodes.EXCEPTION,
                        errorDetails: exceptionToString(e)
                    });
                }
            }
            // ...etc
        }//end of mixin
    );

    /**
    * @param {number} errorCode
    * @param {Object|string|number=} errorResult
    */
    function processFatalError(errorCode, errorResult) {
        if (_done) return; _done = true;
        _self.closeWithError(new PlayerError(errorCode, errorResult));
    }
}

PlaybackASE.prototype = {
    getAudioStreamList: function () {
        return this.audioTrack.value.streams;
    },

    getVideoStreamList: function () {
        return this.videoTrack.value.streams;
    },

    createFilteredVideoStreamList: function () {
        var playback = this;
        var filteredVideoStreamList = playback.getVideoStreamList().filter(function (stream) {
            return !playback.mediaStreamFilter.shouldDisallowStream(stream);
        });
        CadmiumMediaStreams$addMethodsToArray(filteredVideoStreamList);
        for (var i = 0; i < filteredVideoStreamList.length; i++) {
            filteredVideoStreamList[i].lower = filteredVideoStreamList[i - 1];
            filteredVideoStreamList[i].higher = filteredVideoStreamList[i + 1];
        }

        if ( playback && playback.streamingSession ){
            // If the session is already opened, we will need to update the bitrate range
            var profileList = [];
            playback.getVideoStreamList().forEach(function(stream){
                if (profileList.indexOf(stream.contentProfile) == -1){
                    profileList.push(stream.contentProfile);
                }
            });
            var minBitRate = null,
                maxBitRate = null;
            filteredVideoStreamList.forEach(function(stream){
                if ( minBitRate === null ) {
                    minBitRate = stream.bitrate;
                    maxBitRate = stream.bitrate;
                } else if ( maxBitRate < stream.bitrate ) {
                    maxBitRate = stream.bitrate;
                } else if ( minBitRate > stream.bitrate ) {
                    minBitRate = stream.bitrate;
                }
            });
            var filters = [];
            profileList.forEach(function(profile){
                var filter = {};
                filter["ranges"] = [];
                if (!filter["profile"]) {
                    filter["profile"] = profile;
                }
                if ( minBitRate && maxBitRate ){
                    filter["ranges"].push( {"min": minBitRate, "max": maxBitRate} );
                    filters.push(filter);
                }
            });

            playback.streamingSession.setVideoBitrateRanges(filters);
        }

        return filteredVideoStreamList;
    },

    getRelativeTime: function () {
        var loadTime = this.loadTime;
        if(!isNumber(loadTime)){
            loadTime = this.createTime;
        }
        // we might go from STATE_NOTLOADED -> CLOSING -> CLOSED and never have load time
        debug$assert(isUInt(loadTime) || !this.state || (this.state.value != Playback$STATE_LOADING && this.state.value != Playback$STATE_NORMAL));
        return clock$getTime() - loadTime;
    },

    importMilestones: function(milestones){
        var loadTime = this.loadTime,
            self = this;
            log.trace('importing milestones', milestones);
        enumerateOwnProperties(milestones, function(k,v){
            self.milestones[k] = v - loadTime;
        });
    },
    normalizeKeyStatuses: function(list){
         var loadTime = this.loadTime,
            updatedList = {};
        enumerateOwnProperties(list, function(k, entries) {
            updatedList[k] = entries.map(function(v){
                return (v - loadTime);
            });
        });
        return updatedList;
    },

    getAbsoluteStartTime: function() {
        var startTime,
            uiPlayStartTime = this.playbackParams['uiPlayStartTime'];

        if (isNumber(uiPlayStartTime)) {
            startTime = uiPlayStartTime;
        } else if (this.loadTime) {
            startTime = this.loadTime + clock$getPreciseAppEpoch();
        } else {
            startTime = this.createTime + clock$getPreciseAppEpoch(); //if load is not called or an exception occurs before.
        }
        debug$assert(isUInt(startTime));
        return startTime;
    },
    // calculates the delta from absolute time when user initiated the playback.
    // if uiPlayStartTime was not passed by UI, use the player.loadTime
    calculatePlayDelay: function calculatePlayDelay() {
        return Date$now() - this.getAbsoluteStartTime();
    },
    isTrailer: function(){
        return this.uiLabel === 'trailer';
    },
    isBillboard: function(){
        return (this.uiLabel) && (this.uiLabel.indexOf('billboard') >= 0);
    }
};



// -- cadmium-ase/DownloadJobManagerASE.js
/**
 * @constructor
 */
function DownloadJobManagerASE(numWorkers, numActiveWorkers, playback) {
    var _workers = [],
        _self = this;
    var _log = new playback.log.CategoryLog('DownloadJobManagerASE');

    var _innerQueue = new buckets.Queue();
    var _eventSource = new EventSource();
    this.addEventListener = _eventSource.addListener;
    this.removeEventListener = _eventSource.removeListener;

        //--- Event Handlers
    playback.addEventListener(Playback$repositioned, function (args) {
        var resetJobQueue = true;
        if(playback.mediaBuffer){
            var videoChunkToSeekTo = playback.mediaBuffer.videoChunks.getForTime(args.newMediaTime);
            var audioChunkToSeekTo = playback.mediaBuffer.audioChunks.getForTime(args.newMediaTime);
            if (videoChunkToSeekTo.media && audioChunkToSeekTo.media) {
                //it's a skip, do nothing
                resetJobQueue = false;
            }
        }
        if(resetJobQueue){
            DEBUG && _log.trace('Aborting and clearing jobs due to a reposition event.');
            if (config.abortInProgressDownload){
                _self.clearJobs();
                _self.abortJobs();
            }
            if (config.pruneRequestsFromNative){
                playback.mediaBuffer.pruneASERequests();
            }
        }
    });

    playback.addEventListener(Playback$closing, function () {
        _self.clearJobs();
        _self.abortJobs();
    });

    //--- Public API
    /**
    * The second parameter is used when we re-enqueue the job to avoid head-of-line blocking
    * (in which case, Media Buffer doesn't have room for the first job from the queue;
    * but it might have room for the second job)
    * In the case of re-enqueue, we don't want to trigger the shortCircuit, since we don't need to re-examine the job immediately
    * @param {Object} elem
    * @param {boolean=} reenter
    */
    this.enqueue = function _enqueue(elem, reenter) {
        var result = _innerQueue.enqueue(elem);
        if (!reenter){
            elem.chunk.setDownloading(MediaBuffer$CHUNK_ONDECK);
            _eventSource.shortCircuitFire(DownloadJobManagerASE$JobAdded);
        }
        return result;
    };

    this.dequeue = function _dequeue() {
        return _innerQueue.dequeue();
    };

    this.peek = function _peek() {
        return _innerQueue.peek();
    };

    this.size = function _size() {
        return _innerQueue.size();
    };

    this.contains = function _contains(elem, equalsFunction) {
        return _innerQueue.contains(elem, equalsFunction);
    };

    this.forEach = function _forEach(callback) {
        return _innerQueue.forEach(callback);
    };

    this.setEnabled = function _setEnabled(isEnabled) {
        _workers.forEach(function(worker) {
            worker.setEnabled(isEnabled);
        });
    };

    // Abort jobs that are more than numActiveWorkers distant from comparison chunks.
    this.abortDistantChunkDownloads = function abortDistantChunkDownloads(comparisonChunk) {
        if (!comparisonChunk) {
            return;
        }

        _workers.forEach(function (worker) {
            var job = worker.getCurrentJob();

            if (!job) {
                return;
            }

            // We want to abort jobs in progress unless the jobs are a within a few chunks ahead
            // of the comparison chunk.
            if ((job.chunk.index < comparisonChunk.index) || (job.chunk.index - comparisonChunk.index) >= numActiveWorkers) {
                worker.abortJob();
            }
        });
    };

    this.abortRequest = function abortRequest(mediaRequest, shouldAbortFunction) {
        var foundRequest = false;
        DEBUG && _log.trace("Aborting job that contains mediaRequest " + mediaRequest.toString());
        // If it's currently in progress
        _workers.forEach(function(worker) {
            var job = worker.getCurrentJob();
            if (!job) {
                return;
            }
            DEBUG && job.mediaRequest && _log.trace("Current job has mediaRequest: " + job.mediaRequest.toString());
            if (job.mediaRequest &&
                job.mediaRequest.getRequestId() === mediaRequest.getRequestId()){
                foundRequest = true;
                worker.abortJob(shouldAbortFunction);
                if(!job.chunk.media){
                    job.chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
                }
            }
        });
        if ( !foundRequest ){
            // If it's still in the job queue, remove it
            var jobToRemove;
            _innerQueue.forEach(function(job) {
                DEBUG && job.mediaRequest && _log.trace("Queued job has mediaRequest: " + job.mediaRequest.toString());
                if(job.mediaRequest && job.mediaRequest.getRequestId() === mediaRequest.getRequestId()){
                    DEBUG && _log.trace("Removing MediaRequest: " + job.mediaRequest.toString() + " from job queue");
                    jobToRemove = job;
                }
            });
            if (jobToRemove) {
                foundRequest = _innerQueue.list.remove(jobToRemove, function(job, jobToRemove){ return job.mediaRequest.getRequestId() === jobToRemove.mediaRequest.getRequestId();});
                if(!jobToRemove.chunk.media){
                    jobToRemove.chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
                }
            }
        }

        if( !foundRequest ){
            return false;
        }
        return true;
    };
    /**
    * Abort all jobs in progress.
    * @param {Function=} shouldAbortFunction
    * @param {number=} bitrateToCompare -- condition on the bitrate above which jobs should be cleared
     */
    this.abortJobs = function abortJobs(shouldAbortFunction, bitrateToCompare) {
        if (!playback.streamingSession){
            DEBUG && _log.trace("No jobs to abort since there is no streaming session yet!");
            return;
        }
        if (!config.abortInProgressDownload){
            DEBUG && _log.trace("No jobs to abort since config.abortInProgressDownload is false");
            return;
        }
        _workers.forEach(function(worker) {
            var job = worker.getCurrentJob();
            if (!job || !job.mediaRequest) {
                DEBUG && _log.trace("No current job to abort on the MediaDownloadWorker");
                return;
            }
            var shouldAbort = shouldAbortFunction ? shouldAbortFunction(job, bitrateToCompare) : true;
            if(!job.chunk.media){
                job.chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
            }
            if (shouldAbort && config.pruneRequestsFromNative) {
                //DEBUG && _log.trace("Aborting an ongoing job that has mediaRequest: " + job.mediaRequest.toString());
                playback.streamingSession.abortRequest(job.mediaRequest, false /*not re-issue the request again */);
            }
        });
    };

    // Set the maximum number of active workers
    this.setActiveWorkers = function setActiveWorkers(n) {
        var maxWorkers = _workers.length;
        var newActiveWorkerCount = Number$clamp(n, 0, maxWorkers);

        for (var i = 0; i < maxWorkers; i++) {
            _workers[i].setEnabled(i < newActiveWorkerCount);
        }
    };

    /**
    * Clear the job queue of jobs.
    * @param {Function=} shouldClearFunction
    * @param {number=} bitrateToCompare -- condition on the bitrate above which jobs should be cleared
    */
    this.clearJobs = function clearJobs(shouldClearFunction, bitrateToCompare) {
        if (!config.abortInProgressDownload){
            DEBUG && _log.trace("No jobs to clear since config.abortInProgressDownload is false");
            return;
        }
        var _newInnerQueue;
        var jobsToClear = [];

        _innerQueue.forEach(function(job) {
            if (job.mediaRequest && playback.streamingSession && config.pruneRequestsFromNative) {
                var shouldClear = shouldClearFunction ? shouldClearFunction(job, bitrateToCompare) : true;
                if(shouldClear){
                    DEBUG && _log.trace("clearing job with mediaRequest " + job.mediaRequest.toString());
                    jobsToClear.push(job);
                } else {
                    // if there is anything we should keep
                    // create a new queue to store it.
                    if (!_newInnerQueue){
                        _newInnerQueue = new buckets.Queue();
                    }
                    DEBUG && _log.trace("keeping job with mediaRequest " + job.mediaRequest.toString());
                    _newInnerQueue.enqueue(job);
                }
            }
            if (!job.chunk.media) {
                job.chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
            }
        });
        jobsToClear.forEach(function(job){
            // ASE's abortRequest will trigger DownloadJobManager.abortRequest(),
            // which will remove the job from _innerQueue.
            // Thus, we should not call abortRequest inside the above forEach loop
            // Otherwise, the queue will be cut into two link list
            playback.streamingSession.abortRequest(job.mediaRequest, false);
        });
        _innerQueue.clear();
        if (_newInnerQueue) {
            _innerQueue = _newInnerQueue;
            if (DEBUG) {
                var debugstr = " after clearJobs(), _innerQueue now contains mediaRequest: ";
                _innerQueue.forEach(function(job){
                    debugstr += job.mediaRequest.toString() + ", ";
                });
                _log.trace(debugstr);
            }
        }
    };

    this.needsWork = function _needsWork() {
        return _innerQueue.size() < 2;
    };

    // initialize the workers
    for (var i = 0; i < numWorkers; i++) {
        var worker = new MediaDownloadWorkerASE(_self, playback, i < numActiveWorkers, (i + 1));
        worker.addEventListener(MediaDownloadWorkerASE$JobCompleted, function jobCompleted() {
            _eventSource.fire(DownloadJobManagerASE$JobCompleted);
        });
        _workers.push(worker);
    }
}
var DownloadJobManagerASE$JobAdded = 1;
var DownloadJobManagerASE$JobCompleted = 2;



// -- cadmium-ase/MediaDownloaderASE.js
/**
 * @constructor
 */
function MediaDownloaderASE(playback) {

    var _log = new playback.log.CategoryLog('MediaDownloaderASE'),
        _httpPlayback = playback.httpPlayback,
        _mediaBuffer,
        _maxConcurrentDownloads = config.maxParallelConnections,
        _updateMonitorTimeMs = 500,
        _updateMonitorId,
        _updateThrottle = new Throttle(MediaDownloaderASE$MaxUpdateFrequencyMs),
        _downloaderContext = {
            mediaDownloader: this,
            downloadJobManager: {}
        },
        _lastHeaderDownloadFailureResult,
        checkForSafeBufferLevel = _checkForSafeBufferLevel,
        ASEEnum = require(48),
        Fragment = require(50).Fragment,
        FragmentListView = require(50).FragmentListView;


    _downloaderContext.downloadJobManager = _createDownloadManager(config.parallelDownloadManagerType);
    _downloaderContext.downloadJobManager.setActiveWorkers(config.initParallelConnections);
    _downloaderContext.cdnTestReason = 'startup';
    _downloaderContext.failedDownloadRetryWaits = config.failedDownloadRetryWaitsASE;
    _downloaderContext.failedDownloadRetryIndex = 0;
    playback.downloaderContext = _downloaderContext;


    debug$assert(_httpPlayback);

    _init();

    //--- Public API
    this.howLongToNormalState = _howLongToNormalState;

    /**
    * Clear download jobs that are either planned or in progress (by aborted the download). A shouldAbort function
    * can be optionally passed in which will on abort any in progress jobs that pass whatever test the function specifies.
    * Note this only applies to inProgress jobs, waiting jobs are unconditionally cleared.
    *
    * @param {Function} shouldAbortFunction() a function that should return true if a job should be excluded.
    */
    this.clearInProgressDownloads = _clearInProgressDownloads;

    /**
     * Fulfill a Media Request. This is meant to be called by MediaRequest.open();
     * @param {Object} mediaRequest the media request to fulfill
     * @param {String} the base url to use for the media download
     * @param {Object} byteRange
     * @export
     */
    this.fulfillRequest = _fulfillRequest;
    this.abortRequest = _abortRequest;
    this.setPrimaryCDN = _setPrimaryCDN;
    this.setActiveWorkers = _setActiveWorkers;
    this.getCurrentStateName = NOOP;
    this.resetFailedDownloadRetryIndex = _resetFailedDownloadRetryIndex;
    this.abortAndClearDownloads = _abortAndClearDownloads;

    this.getMaxProgress = function _getMaxProgress() {
        return 0.99;
    };

    this.getLastHeaderDownloadFailureResult = function (){
        return _lastHeaderDownloadFailureResult;
    };
    // --------------------------------------------------------------------------------
    // -- private implementation
    function _init() {
        DEBUG && _log.info("MediaDownloaderASE is created");
        _updateMonitorId = setInterval(_update, _updateMonitorTimeMs);

        var jobCompletionHandler = function _jobCompletedHandler() {
            _update();
        };
        _downloaderContext.downloadJobManager.addEventListener(DownloadJobManagerASE$JobCompleted, jobCompletionHandler);

        playback.addEventListener(Playback$closing, function() {
            _downloaderContext.downloadJobManager.removeEventListener(DownloadJobManagerASE$JobCompleted, jobCompletionHandler);
            clearInterval(_updateMonitorId);
            _updateThrottle.dispose();
        });

        //-- start updating and listening to media playback progress
        _update();

        playback.addEventListener(Playback$throttledMediaTimeChanged, function() {
            // do not update inline of a media time change
            // do so we handle [throttledMediaTimeChanged] followed with [repositioned] properly
            _update();
        });

        //TODO: ASE - should Manager be aware of Media Rebuffers? We only report network rebuffer for now
        playback.addEventListener(Playback$bufferUnderrun, function(args) {
            // presenter ran out of buffer...
            if (args.cause == Playback$BUFFER_UNDERRUN_CAUSE_NETWORK) {
                // if it was because downloader didn't keep up, go into buffering state
                _downloaderContext.downloadJobManager.setActiveWorkers(1);
                checkForSafeBufferLevel = _checkForSafeBufferLevel;
                playback.bufferingState.set(BufferingState$BUFFERING);
                playback.streamingSession.underflow(playback.mediaPresenter.getElementTime());
                _update();
            }
        });

        playback.addEventListener(Playback$repositioned, function() {
            _update();
        });
    }

    function _setActiveWorkers(numOfConnections){
        var numConn = numOfConnections;
        if (numConn < 1){
            numConn = 1;
            DEBUG && _log.trace("Trying to set number of connection to be less than 1, reset it to 1");
        } else if (numConn > config.maxParallelConnections){
            numConn = config.maxParallelConnections;
            DEBUG && _log.trace("Trying to set number of connection to be larger than max (", config.maxParallelConnections, "), reset it to the maximum value");
        }
        DEBUG && _log.trace("set number of active workers to ", numConn );
        _downloaderContext.downloadJobManager.setActiveWorkers(numConn);
    }

    function _translateChunkInfosToASEFragments(chunkInfos){
        var fragDataBuffer = new ArrayBuffer(Fragment.BYTES_PER_FRAGMENT * chunkInfos.length),
            fragDataView = new DataView(fragDataBuffer);
        var totalTimeMs = 0;
        for (var i = 0; i < chunkInfos.length; i++) {
            var chunkInfo = chunkInfos[i];
            var startingByte = Fragment.BYTES_PER_FRAGMENT * i;
            fragDataView.setUint32(startingByte, chunkInfo.length & 0x7fffffff); // size (in bytes)
            fragDataView.setUint32(startingByte + 4, chunkInfo.startTime); // startPts
            fragDataView.setUint32(startingByte + 8, chunkInfo.offset / 0x10000 ); // offset high 32 bits (setUint32 uses lower 32 bits of value)
            fragDataView.setUint32(startingByte + 12, ( ( chunkInfo.offset  & 0xffff ) << 16 ) + ( chunkInfo.duration )); // offset high 16 bits and duration in ms
            totalTimeMs += chunkInfo.duration;
        }
        return {
            fragments: new FragmentListView(fragDataBuffer),
            avgFragmentDurationMs: Math.round(totalTimeMs / chunkInfos.length)
        };
    }

    /**
    * @param {Function} shouldAbortFunction a filter function to determine whether a job should be aborted or not
    * @param {Function=} shouldClearFunction a filter function to determine whether a job should be cleared or not
    **/
    function _clearInProgressDownloads(shouldAbortFunction, shouldClearFunction) {
        if (!config.abortInProgressDownload){
            return;
        }
        _downloaderContext.downloadJobManager.abortJobs(shouldAbortFunction);
        _downloaderContext.downloadJobManager.clearJobs(shouldClearFunction);
    }
    function _setPrimaryCDN(mediaRequest){
        if(!mediaRequest.stream){
            mediaRequest.stream = _findStream(mediaRequest);
        }

        var stream = mediaRequest.stream;
        if (!playback.primaryCdn) {
            var streamCdnList = filter.call(playback.cdnList, function(cdn) {
                return isUrl(stream.downloadUrls[cdn.id]);
            });
            if (streamCdnList.length) {
                playback.streamCdnList = streamCdnList;
                playback.primaryCdn = streamCdnList[0];
            }
        }

        var mediaRequestCDN = playback.cdnList.filter(function(cdn) {
            return cdn.id === mediaRequest.serverId;
        });
        if (mediaRequestCDN.length > 0) {
            mediaRequestCDN = mediaRequestCDN[0];
        } else {
            // we cannot find the cdn server from our cdn list.
            // This should never happen, but if happens,
            // we use primaryCdn (which is the first CDN in our cdn list)
            if (!playback.primaryCdn) {
                playback.closeWithError(new PlayerError(ErrorCodes.NCCP_AUTHORIZE_VERIFY));
            }
            mediaRequestCDN = playback.primaryCdn;
        }

        if (playback.cdn.value !== mediaRequestCDN) {
            // playback.cdn is the main cdn we are using
            mediaRequestCDN.serverSelReason = mediaRequest.serverSelReason;
            playback.cdn.set(mediaRequestCDN);
        }
    }

    function _findStream(mediaRequest){
        // Find streams
        var stream;
        function _filterStream(stream, index, array) {
            return (stream.downloadableId === mediaRequest.streamId);
        }

        if (mediaRequest.mediaType === ASEEnum.MEDIA_REQUEST_TYPE.AUDIO) {
            var audioStreamList = playback.getAudioStreamList();
            if (audioStreamList.some(_filterStream)) {
                stream = audioStreamList.filter(_filterStream)[0];
            } else {
                DEBUG && _log.trace("Cannot find the audio stream requested by Manager, use the lowest quality");
                stream = audioStreamList[0];
            }
        } else if (mediaRequest.mediaType === ASEEnum.MEDIA_REQUEST_TYPE.VIDEO) {
            var videoStreamList = playback.getVideoStreamList();
            if (videoStreamList.some(_filterStream)) {
                stream = videoStreamList.filter(_filterStream)[0];
            }
        } else {
            _log.error("Media Request MediaType unrecognizable");
        }

        if (stream === undefined) {
            _log.error("the downloading stream does not exist");
        }

        return stream;
    }

    function _abortRequest(mediaRequest){
        var aborted = _downloaderContext.downloadJobManager.abortRequest(mediaRequest);
        if (aborted){
            DEBUG && _log.trace("Aborted request (ID: " + mediaRequest.getRequestId() + ")");
        } else {
            DEBUG && _log.trace("Can't find job to abort request (ID: " + mediaRequest.getRequestId() + "), we might have cleared it already.");
        }
    }

    function _fulfillRequest(mediaRequest, url, byteRange) {
        var requestFormatStr = "Fulfilling bitrate:{0} a/v:{1} ({2}) mediaRequest id {3}, chunk id:{4}.";
        var logMessage;

        // create a job for the mediaRequest using url and byte range
        var chunk, stream, job, chunkIndex;

        stream = _findStream(mediaRequest);

        mediaRequest.stream = stream;

        _setPrimaryCDN(mediaRequest);

        var streamType = mediaRequest.mediaType === ASEEnum.MEDIA_REQUEST_TYPE.VIDEO ? "video" : "audio";
        if ( mediaRequest.isHeader ) {
            //If it's a header request, we will download it without going through MediaDownloadWorkerASE
            logMessage = String$format(requestFormatStr, stream.bitrate.toString(), streamType, mediaRequest.isHeader ? "header" : "chunk", mediaRequest.getRequestId(), "N/A");
            DEBUG && _log.trace(logMessage);

            //Fake the onloadstart event
            mediaRequest.readyState = MediaRequest.READYSTATES.SENT;
            var evt = {
                'mediaRequest': mediaRequest,
                'readyState': mediaRequest.readyState,
                'timestamp': clock$getTime()
            };
            mediaRequest.notifyLoadstart(evt);
            evt = {
                'mediaRequest': mediaRequest,
                'readyState': mediaRequest.readyState,
                'timestamp': clock$getTime(),
                'connect': false
            };
            mediaRequest.notifyFirstbyte(evt);
            playback.headerDownloadsInProgress++;


            var headerDownloadCallback = function(result) {
                var evt = {
                        'mediaRequest': mediaRequest,
                        'timestamp': clock$getTime(),
                        'response': result.raw
                };
                playback.headerDownloadsInProgress--;
                if (result.success) {
                    playback.downloaderContext.failedDownloadRetryIndex = 0;
                    mediaRequest.readyState = MediaRequest.READYSTATES.DONE;
                    //get raw data and pass it to Manager
                    mediaRequest.response = result.raw;
                    //pass-in the parsed fragments directly from ChunkInfos
                    var fragmentsInfo = _translateChunkInfosToASEFragments(stream.header.chunkInfos);
                    mediaRequest.fragments = fragmentsInfo.fragments;

                    if (stream.header.drmProtected){
                        mediaRequest.drmType = stream.header.codec;
                    }
                    mediaRequest.drmProtected = stream.header.drmProtected;
                    mediaRequest.avgFragmentDurationMs = fragmentsInfo.avgFragmentDurationMs;
                    mediaRequest.notifyComplete(evt);
                } else {
                    DEBUG && _log.trace("MediaRequest Header Download Failed, ErrorSubCode:" + result.errorSubCode);
                    _lastHeaderDownloadFailureResult = result;

                    // duplicating functionality of assessHeaderDownloadState() so we can error-out playback when needed
                    var audioStream = playback.getAudioStreamList().firstAbove(0, true);
                    var videoStream = playback.getVideoStreamList().firstAbove(0, true);
                    // if we don't have at least one video and one audio stream with header
                    if (!audioStream || !videoStream) {
                        // if we got proxy error
                        // or we don't have any more downloads in progress
                        // end playback
                        if (result.errorSubCode === ErrorSubCodes.HTTP_PROXY || playback.headerDownloadsInProgress <= 0) {
                            playback.closeWithError(new PlayerError(ErrorCodes.INIT_HEADER_MEDIA, _lastHeaderDownloadFailureResult));
                        }
                    }
                }
            };

            stream.downloadHeader(headerDownloadCallback);

        } else {
            if (_mediaBuffer === undefined) {
                _mediaBuffer = playback.mediaBuffer;
            }
            debug$assert(_mediaBuffer);
            // If it's a media request, we will create a job for it (current Cadmium 'job' only meaningful for non-header requests)
            // Get Chunk Infos
            var chunkInfos = stream.header.chunkInfos;
            var chunkInfo = chunkInfos.filter(function(chunk, index) {
                return (chunk.offset <= mediaRequest.byteStart);
            });


            if (chunkInfo.length === 0) {
                // if we couldn't find the right chunk, start from the beginning
                chunkInfo = chunkInfos[0];
            } else {
                // filter returns a list, instead of an object
                chunkInfo = chunkInfo[(chunkInfo.length - 1)];
            }

            chunkIndex = chunkInfo.index;

            // XXX - TY: we are not using it for now
            // attach the mediaRequest to the correct MediaBuffer chunk (bidirectional link)
            if (mediaRequest.mediaType === ASEEnum.MEDIA_REQUEST_TYPE.AUDIO) {
                chunk = _mediaBuffer.audioChunks[chunkIndex];
            } else if (mediaRequest.mediaType === ASEEnum.MEDIA_REQUEST_TYPE.VIDEO) {
                chunk = _mediaBuffer.videoChunks[chunkIndex];
            }
            //!!! Don't set chunk.mediaRequest here
            //!!! We should only attach mediaRequest to a chunk once it's properly attached to the chunk
            mediaRequest.chunk = chunk;

            //Making sure mediaRequest represent the same chunkInfo as in Cadmium

            debug$assert(mediaRequest.durationMs === chunk.duration);
            debug$assert(mediaRequest.byteStart === chunkInfo.offset);
            debug$assert(mediaRequest.byteEnd === chunkInfo.offset + chunkInfo.length - 1);

            if (!mediaRequest.isHeader){
                if(mediaRequest.ptsStart !== chunk.startTime){
                    DEBUG && _log.trace(" Mismatch of ptsStart between ASE MediaRequest and Cadmium Native Chunk map");
                    mediaRequest.ptsStart = chunk.startTime;
                    mediaRequest.ptsEnd = chunk.startTime + chunk.duration - 1;
                }
            }

            logMessage = String$format(requestFormatStr, stream.bitrate.toString(), streamType, mediaRequest.isHeader ? "header" : "chunk", mediaRequest.getRequestId(), chunk.index);
            DEBUG && _log.trace(logMessage);
            job = {
                stream: stream,
                chunk: chunk,
                recommendation: {
                    videoStream: stream
                },
                mediaRequest: mediaRequest
            };
            _downloaderContext.downloadJobManager.enqueue(job);
        }
    }

    function _createDownloadManager(type) {
        // Todo ASE: Implement SubChunkDownloadJobManagerASE
        //if (type === "subchunk") {
        //   return new SubChunkDownloadJobManagerASE(_maxConcurrentDownloads, _maxConcurrentDownloads, playback);
        //}
        return new DownloadJobManagerASE(_maxConcurrentDownloads, 1, playback);
    }

    function _howLongToNormalState() {
        // todo ASE: Implement so buffering progress will be accurate(ish)
        // return _currentDownloaderState.howLongToNormalState();
    }

    function _update() {
        _updateThrottle.schedule(_innerUpdate);
    }
    // The main update function.
    function _innerUpdate() {
        if (playback.state.value == Playback$STATE_NORMAL) {
            checkForSafeBufferLevel();
        }
    }

    function _checkForSafeBufferLevel() {
        var safeBufferLevel = config.parallelSafeBufferThreshhold;
        if (_mediaBuffer && _mediaBuffer.getNormalizedBufferLength() > safeBufferLevel) {
            _downloaderContext.downloadJobManager.setActiveWorkers(_maxConcurrentDownloads);
            checkForSafeBufferLevel = NOOP;
        }
    }

    function _resetFailedDownloadRetryIndex(){
        _downloaderContext.failedDownloadRetryIndex = 0;
    }

    // determine whether a request should be aborted
    // conditions are: (1) video chunk and (2) must be a bitrate higher than the lowest available
    /**
     *
     * @param {Object} job - download job we are trying to abort
     * @param {number} bitrateToCompare - bitrate above which we should abort; lower one by default
     * @returns {boolean} - should we abort
     */
    function _shouldAbortFunc (job, bitrateToCompare) {
        return job.mediaRequest.mediaType === ASEMediaStream$VIDEO &&
            job.mediaRequest.bitrate > bitrateToCompare;
    };

    // helper function to abort jobs in cases when we want to force a new bitrate
    /**
     * @param {number=} bitrateToCompare -- abort everything above this bitrate
     */
    function _abortAndClearDownloads (bitrateToCompare) {
        var lowestBitrate = playback.getVideoStreamList()[0].bitrate;
        var bitrate = (bitrateToCompare && bitrateToCompare >= lowestBitrate)  ? bitrateToCompare : lowestBitrate;

        if (config.pruneRequestsFromNative) {
            if (config.abortInProgressDownload) {
                _downloaderContext.downloadJobManager.clearJobs(_shouldAbortFunc, bitrate);
                _downloaderContext.downloadJobManager.abortJobs(_shouldAbortFunc, bitrate);
            }
            playback.mediaBuffer.pruneASERequests();

        }
    }
}

var MediaDownloaderASE$MaxUpdateFrequencyMs = 200;



// -- cadmium-ase/MediaHttpASE.js
/**
 * @constructor
 */
function MediaHttpASE(playback) {
    // --------------------------------------------------------------------------------
    // -- initialization & internal api
    var _eventSource = new EventSource(),
        _log = new playback.log.CategoryLog('MediaHttpASE'),
        ASEEnums = require(48);

    return {
        addEventListener: _eventSource.addListener,
        removeEventListener: _eventSource.removeListener,
        download: _download
    };

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _download(request, completionCallback) {
        request.playback = playback;
        var pingJob;

        if (playback.cdn.value && config.pingOnConnectTimeout) {
            pingJob = {
                pinger: new CDNPinger(playback.httpPlayback),
                maxExtensions: config.maxParallelConnections, // scale the number of extensions by the number of connections since we are splitting the bandwidth
                numExtensions: 0,
                cdn: playback.cdn.value
            };
        }

        var response = http.download(request, completionCallback, pingJob);
        playback.fireEvent(HttpPlayback$downloadstarted, response);

        if (request.mediaRequestASE) {
            var mediaRequest = request.mediaRequestASE;
            if (mediaRequest.readyState === MediaRequest.READYSTATES.OPENED ||
                mediaRequest.readyState === MediaRequest.READYSTATES.FAILED /*retry*/ ) {
                mediaRequest.readyState = MediaRequest.READYSTATES.SENT;
                var event = {
                    'mediaRequest': mediaRequest,
                    'timestamp': clock$getTime()
                };
                mediaRequest.notifyLoadstart(event);
            }
        }

        response.addCallback(_downloadCompleteCallback);
        response.setProgressCallback(_onprogress);
        response.setErrorCallback(_onerror);

        function _onprogress(event) {
            var request = event['mediaRequest'],
                mediaRequest = request.mediaRequestASE,
                bytesLoaded = event['bytes'];
            if (mediaRequest === undefined) {
                DEBUG && _log.trace("this onprogress events is not for MediaHttpASE, url: " + request.url);
                return;
            }

            if (mediaRequest.readyState === MediaRequest.READYSTATES.SENT) {
                _onfirstbyte(event);
            }

            if(isNumber(bytesLoaded)){
                event['mediaRequest'] = mediaRequest;
                event['timestamp'] = clock$getTime();
                if(bytesLoaded > mediaRequest.bytesReceived){
                    //onProgress event can come out of order
                    event['newBytes'] = bytesLoaded - mediaRequest.bytesReceived;
                    event['bytesLoaded'] = bytesLoaded;
                    mediaRequest.notifyProgress(event);
                }
            }
        }

        function _onfirstbyte(event) {
            var mediaRequest = event['mediaRequest'].mediaRequestASE;
            mediaRequest.readyState = MediaRequest.READYSTATES.RECEIVING;
            var newevent = {};
            //Note: in cadmium world, we have no information on whether a connection is newly established
            //However, it might be still useful to log the response time
            if(event['connect']){
                //This FirstByte event is issued when xhr response header is received
                //Response time information is available in the event and we will want to keep it
                newevent = event;
                newevent['mediaRequest'] = mediaRequest;
                newevent['readyState'] = mediaRequest.readyState;
            } else {
                //This firstByte is a fake event that we are generating for bookkeeping purposes
                newevent = {
                    'mediaRequest': mediaRequest,
                    'readyState': mediaRequest.readyState,
                    'timestamp': clock$getTime(),
                    'connect': false
                };
            }
            mediaRequest.notifyFirstbyte(newevent);
        }

        function _onerror(event) {
            var request = event['mediaRequest'],
                nativeCode = event['errorcode'],
                httpCode = event['httpcode'],
                mediaRequest = request.mediaRequestASE;
            var platform = require(61),
                AEC = platform.aseErrorCodes;
            var aseEvent;

            if (mediaRequest === undefined) {
                DEBUG && _log.trace("this onerror events is not for MediaHttpASE, url: " + request.url);
                return;
            }
            if (mediaRequest.readyState === MediaRequest.READYSTATES.FAILED) {
                //No need to propogate the error if the request is already in the FAILED state
                return;
            }
            if (nativeCode === ErrorSubCodes.HTTP_ABORT){
                //Abort is not an error
                mediaRequest.readyState = MediaRequest.READYSTATES.ABORTED;
                aseEvent = event;
                aseEvent['mediaRequest'] = mediaRequest;
                aseEvent['readyState'] = mediaRequest.readyState;
                mediaRequest.notifyAbort(aseEvent);
                if (config.pruneRequestsFromNative){
                    playback.mediaBuffer.pruneASERequests();
                }
                return;
            }

            mediaRequest.readyState = MediaRequest.READYSTATES.FAILED;
            var aseErrorCode;
            switch(nativeCode){
                case ErrorSubCodes.HTTP_UNKNOWN:
                    aseErrorCode = AEC.AS_CONNECTION_CLOSED;
                    break;
                case ErrorSubCodes.HTTP_XHR:
                    aseErrorCode = AEC.AS_HTTP_PROTOCOL_ERROR;
                    break;
                case ErrorSubCodes.HTTP_PROTOCOL:
                    if (httpCode > 400 && httpCode < 500){
                        aseErrorCode = AEC.AS_HTTP_RESPONSE_4XX;
                    } else if (httpCode >= 500) {
                        aseErrorCode = AEC.AS_HTTP_RESPONSE_5XX;
                    } else {
                        aseErrorCode = AEC.AS_HTTP_PROTOCOL_ERROR;
                    }
                    break;
                case ErrorSubCodes.HTTP_OFFLINE:
                    aseErrorCode = AEC.AS_CONNECTION_NETWORK_DOWN;
                    break;
                case ErrorSubCodes.HTTP_TIMEOUT:
                    aseErrorCode = AEC.AS_HTTP_TRANSACTION_TIMEOUT;
                    break;
                case ErrorSubCodes.HTTP_READTIMEOUT:
                    aseErrorCode = AEC.AS_HTTP_TRANSACTION_TIMEOUT;
                    break;
                case ErrorSubCodes.HTTP_PARSE:
                    aseErrorCode = AEC.AS_HTTP_MESSAGE_LENGTH_ERROR;
                    break;
                case ErrorSubCodes.HTTP_BAD_URL:
                    aseErrorCode = AEC.HTTP_RESPONSE_4XX;
                    break;
                default:
                    aseErrorCode = AEC.AS_HTTP_TRANSACTION_TIMEOUT;
                    break;
            }
            aseEvent = event;
            aseEvent['mediaRequest'] = mediaRequest;
            aseEvent['readyState'] = mediaRequest.readyState;
            aseEvent['errorcode'] = aseErrorCode;
            aseEvent['nativecode'] = nativeCode;
            mediaRequest.notifyNetworkError(aseEvent);
        }

        function _downloadCompleteCallback(response) {
            var mediaRequest = response.request.mediaRequestASE;
            var event;
            if (DEBUG && mediaRequest === undefined) {
                _log.trace("this oncomplete events is not for MediaHttpASE, url: " + response.request.url);
            }
            if (mediaRequest !== undefined) {
                if (response.success) {
                    DEBUG && _log.trace('Download complete (ID:'+ mediaRequest.getRequestId()+'), buffer status: ' + JSON.stringify(playback.mediaBuffer.getLogFields()));
                    if (mediaRequest.readyState !== MediaRequest.READYSTATES.DONE) {
                        if (mediaRequest.readyState === MediaRequest.READYSTATES.ABORTED){
                            DEBUG && _log.warn("Unexpected compelte from aborted MediaRequest (" + mediaRequest + ")");
                            return;
                        } else if (mediaRequest.readyState === MediaRequest.READYSTATES.FAILED) {
                            DEBUG && _log.info("Successful retry and oncomplete event from failed MediaRequest (" + mediaRequest + ")");
                            //return;
                        } else if (mediaRequest.readyState === MediaRequest.READYSTATES.SENT) {
                            //this mediarequest never got onProgress events,
                            //we need to trigger onFirstByte event, so that the counting in Manager is correct.
                            //Since we set connect as false, the measurement is turned off and will not be skewed by this faked event
                            _onfirstbyte({
                                'mediaRequest': response.request
                            });
                        } else if (mediaRequest.readyState !== MediaRequest.READYSTATES.SENT
                                 && mediaRequest.readyState !== MediaRequest.READYSTATES.RECEIVING) {
                            //the valid state is SENT or RECEIVING
                            DEBUG && _log.warn("Unexpected oncomplete event from MediaRequest whose readyState, " + mediaRequest.readyState + ", is not SENT nor RECEIVING");
                        }
                        mediaRequest.readyState = MediaRequest.READYSTATES.DONE;
                        if (!mediaRequest.isHeader) {
                            // headers' complete event is notified through the stream.downloadHeader callback
                            // we might want to consolidate this in the future

                            event = {
                                'mediaRequest': mediaRequest,
                                'readyState': mediaRequest.readyState,
                                'timestamp': clock$getTime(),
                                'cadmiumResponse': response
                            };
                            mediaRequest.completionEvent = event;
                            mediaRequest.notifyComplete(event);
                        }
                    }
                } else {
                    DEBUG && _log.trace('Download failed (ID:'+ mediaRequest.getRequestId()+'), buffer status: ' + JSON.stringify(playback.mediaBuffer.getLogFields()));
                    if (mediaRequest.readyState === MediaRequest.READYSTATES.ABORTED){
                        DEBUG && _log.trace("Download failure was triggered by aborting MediaRequest (" + mediaRequest + ")");
                    } else {
                        event = {
                            'mediaRequest': response.request,
                            'timestamp': clock$getTime(),
                            'errorcode': response.errorSubCode,
                            'httpcode': response.errorHttpCode
                        };
                        _onerror(event);
                    }
                }
            }
            playback.fireEvent(HttpPlayback$downloadcomplete, response);
        }
        return response;
    }
}



// -- cadmium-ase/BandwidthMeterASE.js
/**
 * @constructor
 */
function BandwidthMeterASE(playback) {
    var _log;
    if (DEBUG){
        _log = new playback.log.CategoryLog('BandwidthMeterASE');
        _log.debug('Starting BandwidthMeterASE');
    }


    this.getLatency = function () {
        if (playback.responseTime === -1){
            var result = playback.streamingManager.networkMonitor.get();
            if (result.responseTime){
                playback.responseTime = result.responseTime.average;
            }
            //since we got the result, might as well update the throughput
            if (result.throughput){
                playback.throughput = result.throughput.average;
            }
        }
        return playback.responseTime;
    };
    this.getThroughput =  function () {
        if (playback.throughput === -1){
            var result = playback.streamingManager.networkMonitor.get();
            //since we got the result, might as well update the responseTime
            if (result.responseTime){
                playback.responseTime = result.responseTime.average;
            }
            if (result.throughput){
                playback.throughput = result.throughput.average;
            }
        }
        return playback.throughput;
    };
    this.getThroughput60 = this.getThroughput;
    this.calculateDownloadTime = _calculateDownloadTime;
    this.calculateSustainableVideoBitrate = _calculateSustainableVideoBitrate;
    this.calculateNormalizedBandwidth = _calculateNormalizedBandwidth;


    function _calculateDownloadTime(sizeInBytes) { //unit is in milliseconds
        if (playback.responseTime === -1 || playback.throughput === -1){
            var result = playback.streamingManager.networkMonitor.get();
            if (result.responseTime){
                playback.responseTime = result.responseTime.average;
            }
            if (result.throughput){
                playback.throughput = result.throughput.average;
            }
        }

        if (playback.responseTime === -1 || playback.throughput === -1){
            return Number.MAX_VALUE;
        }
        return playback.responseTime + sizeInBytes * 8 / playback.throughput;
    }

    function _calculateSustainableVideoBitrate() {
        if (playback.streamingBitrate === -1){
            if (playback.downloadedVideo){
                return playback.downloadedVideo.value.stream.bitrate;
            }
            DEBUG && _log.trace("trying to get sustainableVideoBitrate before we even started downloading anything.");
            return;
        }
        return playback.streamingBitrate;
    }

    function _calculateNormalizedBandwidth() {
        if (playback.throughput === -1){
            var result = playback.streamingManager.networkMonitor.get();
            //since we got the result, might as well update the responseTime
            playback.responseTime = result.responseTime.average;
            playback.throughput = result.throughput.average;
        }
        return playback.throughput;
    }
}



// -- cadmium-ase/MediaDownloadWorkerASE.js
/**
* @constructor
*/
function MediaDownloadWorkerASE(jobQueue, playback, active, id) {
    var _log = new playback.log.CategoryLog('MediaDownloadWorkerASE'),
        _mediaBuffer,
        _mediaHttp = playback.mediaHttp,
        _isActive = active,
        _currentJob, // the currently job being downloaded, if any.
        _activeTask,
        _self = this,
        _context = playback.downloaderContext,
        _jobQueueRecurringMonitor = new RecurringTimer(Math$min(config.videoChunkSizeMilliseconds, config.audioChunkSizeMilliseconds)/2, _update),
        _eventSource = new EventSource();
    this.addEventListener = _eventSource.addListener;
    this.tryRecoverFromStall = function _tryRecoverFromStall(){
        if (http$isOnLine()) {
            if(playback.streamingSession){
                playback.streamingSession._errorDirector.resetFailures();
            }
            _update();
        }
    };

    jobQueue.addEventListener(DownloadJobManagerASE$JobAdded, function (continueHint) {
        if (!_activeTask && _isActive) {
            continueHint.handled = true;
            _update();
        }
    });

    playback.addEventListener(Playback$closing, function() {
            _jobQueueRecurringMonitor.clearTimer();
    });

    playback.addEventListener(Playback$repositioned, function() {
            _update();
    });

    playback.addEventListener(Playback$tryRecoverFromStall, this.tryRecoverFromStall);

    http.addEventListener(http$onlinechanged, this.tryRecoverFromStall);

    playback.addEventListener(Playback$closing, function(){
        http.removeEventListener(http$onlinechanged, this.tryRecoverFromStall);
    });

    debug$assert(_mediaHttp);

    // --------------------------------------------------------------------------------
    // -- Public API
    this.isEnabled = function _isEnabled() {
        return _isActive;
    };

    this.setEnabled = function _setEnabled(isEnabled) {
        _isActive = isEnabled;
    };

    this.shutdown = function _shutdown() {
        this.setEnabled(false);
    };
    this.getCurrentJob = function _getCurrentJob() {
        return _currentJob;
    };

    /**
    * @param {Function=} shouldAbortFunction a filter function to determine whether a job should be aborted or not
    **/
    this.abortJob = function abortJob(shouldAbortFunction) {
        if (_activeTask && _currentJob) {
            var shouldAbort = shouldAbortFunction ? shouldAbortFunction(_currentJob) : true;
            if (shouldAbort) {
                var mediaRequestToBeAborted = _currentJob.mediaRequest;
                DEBUG && shouldAbortFunction && shouldAbortFunction(_currentJob) && _log.debug("excluded job's bitrate: "+ _currentJob.recommendation.videoStream.bitrate);
                _currentJob.chunk.media = null;
                if(_currentJob.chunk.mediaRequest === mediaRequestToBeAborted){
                    DEBUG && _log.warn("Trying to abort a DONE MediaRequest (ID:" + _currentJob.mediaRequest.getRequestId() + ") on chunk " + _currentJob.chunk.index);
                    _currentJob.chunk.mediaRequest = undefined;
                }
                _currentJob.chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
                DEBUG && _log.trace("Aborted download of chunk:" + _currentJob.chunk.index);
                if(_activeTask.response){
                    _activeTask.response.abort();
                }
                _activeTask = null;
                _currentJob = null;
            }
        }
    };

    // --------------------------------------------------------------------------------
    // -- private implementation
    function _update() {
        try {
            if (!_activeTask  && _isActive) {
                // find the next valid job
                _currentJob = jobQueue.peek();
                if (_currentJob) {
                    var mediaRequestASE = _currentJob.mediaRequest,
                        hasRoomToDownload = true;
                    if ( !mediaRequestASE.isHeader) {
                        //check to see if we actually have a space in mediaBuffer for actual download
                        if (!_mediaBuffer) {
                            _mediaBuffer = playback.mediaBuffer;
                        }
                        if (config.maxBufferSizeBytes) {
                            //byte based buffer
                            if (_mediaBuffer.getNormalizedBufferLength() > config.maxBufferSizeBytes){
                                hasRoomToDownload = false;
                            }
                        } else {
                            //time based buffer
                            if ( !_mediaBuffer.hasEnoughBufferToStoreNextJob(_currentJob) ){
                                hasRoomToDownload = false;
                            }
                        }
                    }
                    if (hasRoomToDownload) {
                        _currentJob = jobQueue.dequeue();
                        DEBUG && _log.trace("kick start downloadJob for MediaRequest:" + _currentJob.mediaRequest.getRequestId());
                        _downloadJob(_currentJob);
                    } else {
                        _mediaBuffer.compact();
                        if (jobQueue.size() > 1) {
                            // if there are other jobs in the queue
                            // we should take out the currentJob and put it back at the back of the jobqueue to avoid head-of-line blocking
                            //DEBUG && _log.trace("JobQueue size: " + jobQueue.size() + ", putting downloadJob at the back of the queue");
                            _currentJob = jobQueue.dequeue();
                            jobQueue.enqueue(_currentJob, true);
                            if (DEBUG) {
                                var debugstr = " after re-enqueue, jobQueue now contains mediaRequest: ";
                                jobQueue.forEach(function(job){
                                    debugstr += job.mediaRequest.toString() + ", ";
                                });
                                _log.trace(debugstr);
                            }
                        }
                        _currentJob = null;
                        DEBUG && _log.trace("Don't have room for downloading MediaRequest:" + mediaRequestASE.getRequestId() + ", set timer in another " + Math$min(config.videoChunkSizeMilliseconds, config.audioChunkSizeMilliseconds)/2 + " ms");
                        _jobQueueRecurringMonitor.setTimer();
                    }
                } else {
                    _jobQueueRecurringMonitor.clearTimer();
                }
            }            
        } catch (e) {
            _log.error('Exception in update.', e);
        }
    }

    function _resetChunk(chunk) {
        if (chunk) {
            chunk.media = null;
            chunk.mediaRequest = undefined;
            chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
        }
    }

    function _downloadJob(job) {

        var chunkToDownload = job.chunk,
            recommendation = job.recommendation,
            mediaRequestASE = job.mediaRequest;

        if ( chunkToDownload.media &&
            mediaRequestASE.readyState === MediaRequest.READYSTATES.DONE ){
            DEBUG && _log.trace("MediaRequest ID:" + mediaRequestASE.getRequestId + " ( chunk " + chunkToDownload.index +") has been fulfilled");
            return;
        }

        if ( chunkToDownload.downloading === MediaBuffer$CHUNK_DOWNLOADING || chunkToDownload.downloading === MediaBuffer$CHUNK_DOWNLOADED ){
            DEBUG && _log.trace("Chunk " + chunkToDownload.index + " (pts: " + chunkToDownload.startTime + ") is already being downloading/ed, downloading state:" + chunkToDownload.downloading );
        }


        if ( config.pruneRequestsFromNative && chunkToDownload.media && chunkToDownload.media.stream.bitrate >= job.stream.bitrate ){
            //We already have the chunk, no need to download
            DEBUG && _log.warn("chunk " + chunkToDownload.index + " job is redundent, chunk pts: " + chunkToDownload.startTime);
            if(chunkToDownload.mediaRequest){
                DEBUG && _log.warn("existing mediaRequest: " + chunkToDownload.mediaRequest.getRequestId() + ", redundent mediaRequest: " + mediaRequestASE.getRequestId());
            } else {
                DEBUG && _log.warn("mediaRequest doesn't exist for chunk :" + chunkToDownload.index + ", but media is downloaded !?");
            }
            chunkToDownload.setDownloading(MediaBuffer$CHUNK_DOWNLOADED);
            playback.streamingSession.abortRequest(mediaRequestASE);
            return;
        }

        if ( config.pruneRequestsFromNative ){
            debug$assert(chunkToDownload.downloading !== MediaBuffer$CHUNK_DOWNLOADING && chunkToDownload.downloading !== MediaBuffer$CHUNK_DOWNLOADED);
        }

        // if we need to download a chunk, do so
        var chunkIndex = chunkToDownload.index,
            stream = job.stream;

        if (chunkToDownload.type === CadmiumMediaStream$VIDEO) {
            // does this stream have the chunk we need?
            if (!(stream.header && stream.header.chunkInfos[chunkIndex])) {
                DEBUG && _log.warn('Stream is missing header or has less chunks than primary, falling back to primary', { 'BitrateOld': stream.bitrate, 'BitrateNew': playback.primaryVideoStream.bitrate });
                stream = playback.primaryVideoStream;
            }
            if (stream != playback.videoStream.value) {
                DEBUG && _log.trace('Stream switch', { 'BitrateOld': playback.videoStream.value.bitrate, 'BitrateNew': stream.bitrate, 'Chunk Index': chunkIndex });
                playback.videoStream.set(stream, { chunkStartTime: stream.header.chunkInfos[chunkIndex].startTime,
                                                   streamTput: mediaRequestASE.streamTput,
                                                   networkMonitorTput: mediaRequestASE.networkMonitorTput });
            }
        } else if (chunkToDownload.type == CadmiumMediaStream$AUDIO) {
            // currently cadmium doesn't support audio stream bitrate adaptation,
            // however, during the audio track switch, we will re-do the adaptation
            //stream = playback.audioStream.value;
            if (stream != playback.audioStream.value) {
                playback.audioStream.set(stream);
            }
        } else {
            debug$assert(false);
            return;
        }

        var chunkInfo = stream.header.chunkInfos[chunkIndex];

        if (chunkInfo) {
            var cdn = filter.call(playback.cdnList, function (cdn) {
                return mediaRequestASE.serverId === cdn.id;
            })[0];
            var mediaRequest = MediaDownloadWorker$createRequest(chunkToDownload, stream, cdn);
            //TODO: ASE
            //XXX - we might want to keep the parser for validation purposes
            //delete mediaRequest.parser;
            mediaRequest.mediaRequestASE = mediaRequestASE;

            DEBUG && _log.trace('Downloading chunk', chunkToDownload, stream, {
                'Offset': mediaRequest.offset,
                'Length': mediaRequest.length
            });

            chunkToDownload.setDownloading(MediaBuffer$CHUNK_DOWNLOADING);
            DEBUG && _log.trace('set chunk ' +  chunkToDownload.index + ' to downloading');
            CadmiumMediaStream$switchType(stream.type, playback.downloadingAudio, playback.downloadingVideo).set({
                chunk: chunkToDownload,
                stream: stream,
                cdn: cdn
            });

            // kick off the download
            var newTask = {
                type: MediaDownloadWorker$TASK_CHUNKDOWNLOAD,
                stream: stream,
                chunk: chunkToDownload,
                mediaRequest: mediaRequest
            };
            _activeTask = newTask;
            newTask.response = _mediaHttp.download(mediaRequest, _onTaskComplete);
            job.response = newTask.response;
        }

        function _onTaskComplete(result) {
            _taskCompleteHandler(result);
            _eventSource.fire(MediaDownloadWorkerASE$JobCompleted);
            _currentJob = null;
            if (_activeTask) {
                _activeTask = null;
            }
        }
        function _taskCompleteHandler(result) {
            //Error is now handled through Manager
            //MediaHttpASE will trigger errors on mediaRequest when error happens
            //But Cadmium will need to handle the retry of download
            var request;
            var _context = playback.downloaderContext;
            if (playback.state.value != Playback$STATE_NORMAL) {
                return;
            }
            if (result && result.success) {
                _context.failedDownloadRetryIndex = 0;
                // we downloaded a chunk
                request = result.request;
                if (playback.bufferingState.value == BufferingState$STALLED) {
                        playback.bufferingState.set(BufferingState$BUFFERING);
                }
            } else {
                // we failed to download a chunk
                if (playback.bufferingState.value == BufferingState$BUFFERING
                    && _context.failedDownloadRetryIndex >= (_context.failedDownloadRetryWaits.length - 1)) {
                        playback.bufferingState.set(BufferingState$STALLED);
                }

                if (_currentJob) {
                    if ( _currentJob.mediaRequest.getRequestId() === result.request.mediaRequestASE.getRequestId()){
                        if (_currentJob.response){
                            _currentJob.response = null;
                        }
                        _resetChunk(_currentJob.chunk);
                    } else {
                        DEBUG && _log.trace('current job (MediaRequest: ' + _currentJob.mediaRequest.getRequestId() + ' is not the failed Job ('+ result.request.mediaRequestASE.getRequestId() +')');
                    }
                }
                if (!result || result.errorSubCode != ErrorSubCodes.HTTP_ABORT) {
                    if (result && result.errorSubCode == ErrorSubCodes.HTTP_PROXY) {
                        playback.closeWithError(new PlayerError(ErrorCodes.MEDIA_DOWNLOAD, result.errorSubCode));
                    } else {
                        if ((++_context.failedDownloadRetryIndex) >= _context.failedDownloadRetryWaits.length) {
                            _context.failedDownloadRetryIndex = _context.failedDownloadRetryWaits.length - 1;
                        }
                    }
                }
                // retry after a timeout
                // the _currentJob will be reset to null when (1) the job is aborted or (2) we don't have enough room for the download
                // thus, we will only retry if not the above mentioned cases

                if ( result.request.mediaRequestASE &&
                    result.request.mediaRequestASE.readyState !== MediaRequest.READYSTATES.ABORTED) {
                    var _retryJob = {
                            stream: result.request.stream,
                            chunk: result.request.mediaRequestASE.chunk,
                            recommendation: {
                                videoStream: result.request.stream
                            },
                            mediaRequest: result.request.mediaRequestASE
                    };
                    DEBUG && _log.trace("Scheduled a retry after the failed download for mediaRequest ID:" + result.request.mediaRequestASE.getRequestId() + " in " + _context.failedDownloadRetryWaits[_context.failedDownloadRetryIndex] + " ms");
                    setTimeout( function () {
                        DEBUG && _log.trace("retry timer fired");
                        if (_retryJob.mediaRequest.inprogress){
                            DEBUG && _log.trace("Another retry is ongoing for mediaRequest ID: " + _retryJob.mediaRequest.getRequestId());
                        } else if (_retryJob.chunk.media) {
                            DEBUG && _log.trace("Media is already downloaded for mediaRequest ID: " + _retryJob.mediaRequest.getRequestId());
                        } else if (_retryJob.mediaRequest.readyState === MediaRequest.READYSTATES.ABORTED){
                            DEBUG && _log.trace("mediaRequest ID: " + _retryJob.mediaRequest.getRequestId() + " is aborted ");
                        } else {
                            DEBUG && _log.trace("creating retry Job for mediaRequest ID: " + _retryJob.mediaRequest.getRequestId() + ", chunk ID: " + _retryJob.chunk.index);
                            _retryJob.mediaRequest.inprogress = true;
                            playback.downloaderContext.downloadJobManager.enqueue(_retryJob);
                        }
                    } , _context.failedDownloadRetryWaits[_context.failedDownloadRetryIndex]);
                } else {
                    DEBUG && _log.trace("no download job is associated with the failed download. The job is either aborted or we run out of buffer space.");
                }

            }
            // After processing check to see if there is more work.
            dispatch(_update);
        }
    }
}

//Using MediaDownloadWorker$createRequest instead of creating our own
//@param {number=} minimumNumberOfBytes
/*function MediaDownloadWorkerASE$createRequest(nextChunkToDownload, stream, cdn, minimumNumberOfBytes) {
    var chunkInfos = stream.header.chunkInfos,
        offset = chunkInfos[nextChunkToDownload.index].offset,
        length = 0;

    // initialize chunks to download with first chunk, add if necessary
    var chunks = [],
        infos = [];

    do {
        var info = chunkInfos[nextChunkToDownload.index];
        length += info.length;
        chunks.push(nextChunkToDownload);
        infos.push(info);

        nextChunkToDownload = nextChunkToDownload.next;
    } while (length < minimumNumberOfBytes && nextChunkToDownload);

    return {
        responseType: http$RESPONSETYPE_BINARY,
        parser: MediaDownloader$parseChunkMedia,
        url: stream.downloadUrls[cdn.id],
        offset: offset,
        length: length,
        cdn: cdn,
        track: stream.track,
        stream: stream,
        chunks: chunks,
        infos: infos,
        diagCaption: stream.type + '-' + stream.bitrate + '-' + chunks.map(function (chunk) { return chunk.index; }).join('+'),
        cacheBuster: true
    };
};*/


// Todo ASE: Deprecate this. We shouldn't need it for ASE.
/*var MediaDownloadWorkerASE$TASK_CHUNKDOWNLOAD = 1,
    MediaDownloadWorkerASE$TASK_COOLDOWN = 2,
    MediaDownloadWorkerASE$TASK_CDNSELECTION = 3;*/

/**
* @const
* @type {number}
*/
var MediaDownloadWorkerASE$JobCompleted = 1;



// -- cadmium-ase/MediaElementASE-BR.js
/**
 * Encapsulates differences in MSE/EME between browsers.
 * ASE accesses this via the MediaSourceASE shim layer.
 *
 * @param {Object} playback
 * @constructor
 */
function MediaElement(playback) {
    var EVENT_PREFIX = MediaElement$getEventPrefix();

    var _self = this,
        _log = new playback.log.CategoryLog('MediaElementASE'),
        _eventSource = new EventSource(),
        _videoElement = MediaElement$createVideoElement(playback.videoSize),
        _sourceBufferList = [],
        _addedSourceBuffer = 0,
        _mediaSource,
        _aseMediaSourceId, /* the corresponding MediaSource's ID */
        _mediaKeys,
        _url,
        _seekInProgress,
        _keySystemId = config.keySystemId,
        _keySession,
        _keySessionId,
        _keyChallenge,
        _currentTime = 0,
        _counters = [],
        _renewalTimer,
        _usePromiseBasedEme;

    var _sourceOpenFired,
        _licenseChallengeRequested,
        _keyMessageProcessed,
        _keyMessageForCdmIdProcessed,
        _keyIsAdded,
        _keyAddedProcessed,
        _licenseState = config.limitedDurationLicense ? licenseStates$INIT : licenseStates$NOTVALID,
        _secureStopManager,
        _resolveVideoAppend = NOOP,
        _waitForVideoAppend = Promise.resolve(),
        _outputDownscaledLogged;

    var _createdMediaKeys;

    if (config.limitedDurationLicense && config.licenseRenewalRequestDelay) {
        _waitForVideoAppend = new Promise(function (res, rej) {
            _resolveVideoAppend = res;
            playback.addEventListener(Playback$closing, res); // for preventing memory leak.
        });
    }
    _log.trace('Created Media Element');

    if (config.secureStopEnabled) {
        playback.state.addListener(function () {
            if (playback.state.value == Playback$STATE_NORMAL) {
                _secureStopManager = playback.secureStopManager;
            }
        })
    }

    if (config.promiseBasedEme) {
        if (isPromiseBasedEmeSupported()) {
            _usePromiseBasedEme = true;
        } else {
            _log.error('Promise based eme requested but platform does not support it', {
                "browserua": userAgent
            });
        }
    }
    // --------------------------------------------------------------------------------
    // -- initialization & internal api

    mixIn(_self, /** @lends {MediaElement.prototype} */ ({

        addEventListener: _eventSource.addListener,
        removeEventListener: _eventSource.removeListener,

        videoElement: _videoElement,

        getCurrentTime: _getCurrentTime,
        seek: _seek,
        getSeeking: _getSeeking,

        // for ASE
        addSourceBuffer: _addSourceBuffer,
        addSourceBuffers: _addSourceBuffers,
        removeSourceBuffer: _removeSourceBuffer,
        endOfStream: _endOfStream,
        destroy: _destroy,
        setASEMediaSourceId: function (sourceId) {
            _aseMediaSourceId = sourceId;
        },

        sourceBuffers: _sourceBufferList,

        addLicense: _addLicense,

        didDecodingStart: _didDecodingStart,

        getConstrictionActive: _getConstrictionActive,

        open: _open,
        close: _close,

        getFrameCount: _createCounter(function () {
            if (_videoElement) {
                var playbackQuality = _getPlaybackQuality();
                return playbackQuality ? playbackQuality['totalVideoFrames'] : _videoElement['webkitDecodedFrameCount'];
            }
        }),

        getDroppedFrameCount: _createCounter(function () {
            if (_videoElement) {
                var playbackQuality = _getPlaybackQuality();
                return playbackQuality ? playbackQuality['droppedVideoFrames'] : _videoElement['webkitDroppedFrameCount'];
            }
        }),

        getCorruptedFrameCount: _createCounter(function () {
            if (_videoElement) {
                var playbackQuality = _getPlaybackQuality();
                return playbackQuality && playbackQuality['corruptedVideoFrames'];
            }
        }),

        getFrameDelayCount: _createCounter(function () {
            if (_videoElement) {
                var playbackQuality = _getPlaybackQuality();
                return playbackQuality && Math$round(playbackQuality['totalFrameDelay'] * MILLISECONDS_PER_SECOND);
            }
        })

    }));

    // --------------------------------------------------------------------------------
    // -- private implementation
    function _open() {
        playback.addEventListener(Playback$shouldUpdateVideoDiagInfo, _onShouldUpdateVideoDiagInfo);

        if (!MediaElement$mediaSourceExtensionsSupported) {
            _closeWithError(ErrorCodes.PLAY_MSE_NOTSUPPORTED);
            return;
        }

        if (playback.videoStream.value.header.drmProtected) {
            if (!MediaElement$encryptedMediaExtensionsSupported) {
                _closeWithError(ErrorCodes.PLAY_MSE_EME_NOTSUPPORTED);
                return;
            }

            if (MediaKeys && MediaKeys['isTypeSupported']) {
                try {
                    if (!MediaKeys['isTypeSupported'](_keySystemId, 'video/mp4')) {
                        _tryGetTypeNotSupportedDetails(function (result) {
                            _closeWithError(ErrorCodes.PLAY_MSE_EME_TYPE_NOTSUPPORTED, result);
                        });
                        return;
                    }
                } catch (e) {
                    _closeWithException(ErrorCodes.PLAY_MSE_EME_TYPE_NOTSUPPORTED, e);
                    return;
                }
            }
        }

        try {
            _mediaSource = new MediaSource();
        } catch (e) {
            _closeWithException(ErrorCodes.PLAY_MSE_CREATE_MEDIASOURCE, e);
            return;
        }

        try {
            _url = URL.createObjectURL(_mediaSource);
        }
        catch (e) {
            _closeWithException(ErrorCodes.PLAY_MSE_CREATE_MEDIASOURCE_OBJECTURL, e);
            return;
        }

        try {
            _mediaSource.addEventListener('sourceopen', _onSourceOpen);
            _mediaSource.addEventListener(EVENT_PREFIX + 'sourceopen', _onSourceOpen);
            _videoElement.addEventListener('error', _onError);
            _videoElement.addEventListener('seeking', _onSeeking);
            _videoElement.addEventListener('seeked', _onSeeked);
            _videoElement.addEventListener('timeupdate', _onTimeUpdate);
            _videoElement.addEventListener('loadstart', function () {
                _log.trace('Video element event: loadstart')
            });

            var needKeyEvent = _usePromiseBasedEme ? 'encrypted' : EVENT_PREFIX + 'needkey';
            _videoElement.addEventListener(needKeyEvent, _onNeedKey);

            var rootElement = playback.rootElement,
                lastChild = rootElement['lastChild'];

            if (lastChild) {
                rootElement['insertBefore'](_videoElement, lastChild);
            } else {
                rootElement['appendChild'](_videoElement);
            }

            if (config.disableVideoRightClickMenu) {
                _videoElement['addEventListener']('contextmenu', MediaElement$contextMenuHandler);
            }

            _videoElement['src'] = _url;

            globalEvents.addListener(globalEvents$hiddenchanged, _onHiddenChanged);
            _onHiddenChanged();

        } catch (e) {
            _closeWithException(ErrorCodes.PLAY_MSE_CREATE_MEDIASOURCE_OPEN, e);
            return;
        }
    }

    function _close() {
        if (_url) {
            // snapshot the counts, so we can drop the _videoElement
            _refreshCounters();
            globalEvents.removeListener(globalEvents$hiddenchanged, _onHiddenChanged);

            if (_secureStopManager && _keyIsAdded) {
                _secureStopManager.init();

                try {
                    if (_keySession) {
                        _keySession.close();
                    } else {
                        _videoElement['webkitCancelKeyRequest'](_keySystemId, _keySessionId); // old eme secure stop for chrome
                    }
                } catch (e) {
                    _log.error('Exception on keysession close ', ErrorCodes.PLAY_MSE_EME_SESSION_CLOSE, e);
                    _secureStopManager.terminate({
                        'ErrorCode': ErrorCodes.PLAY_MSE_EME_SESSION_CLOSE
                    });
                }

                if (MediaElement$getDrmType() == DrmType$PLAYREADY) {
                    var prevSession = new SecureStopManager$createKeySession(playback, _keySessionId, _secureStopManager);
                }
                _secureStopManager.waitForComplete()['then'](_completeClose);

            } else {
                _completeClose();
            }
        }
        if (_renewalTimer) {
            clearTimeout(_renewalTimer);
        }
    }

    /**
     * @param {Object=} secureStopSummary
     */

    function _completeClose(secureStopSummary) {
        var preserveLastFrame = false;
        if (config.preserveLastFrame && _shouldPreserveLastFrame()) {
            preserveLastFrame = true;
        }

        if (config.clearVideoSrc) {
            // must do this, so it doesn't leak memory due to a browser bug
            if (!preserveLastFrame) {
                _videoElement['removeAttribute']('src');
                _videoElement['load'] && _videoElement['load']();
            }
            if (_videoElement['webkitDeleteKey']) {
                _videoElement['webkitDeleteKey'](_keySystemId, _keySessionId);
            }
        }

        URL.revokeObjectURL(_url);
        // Tell the key session it can close so that the EME will get cleaned up.
        if (_keySession && !secureStopSummary) {
            try {
                _keySession.close();
            } catch (e) {
                _log.error('Exception on keysession close ', ErrorCodes.PLAY_MSE_EME_SESSION_CLOSE, e);
            }
        }

        //unbind event handlers from the key session for memory leak?

        if (config.disableVideoRightClickMenu) {
            _videoElement['removeEventListener']('contextmenu', MediaElement$contextMenuHandler);
        }
        if (!preserveLastFrame) {
            playback.rootElement['removeChild'](_videoElement);
        }

        // Set the references to native code to null so that they will dereference and there is no memory leak.
        _mediaSource = null;
        _videoElement = null;
        _url = "";
    }

    function _shouldPreserveLastFrame() {
        var err = playback.fatalError,
            code = err && err.errorCode;
        return code && ([ErrorCodes.PAUSE_TIMEOUT, ErrorCodes.INACTIVITY_TIMEOUT].indexOf(code) >= 0);
    }

    /**
     * Gets the presentation time of the video element.
     *
     * @param {boolean=} allowFatalError
     */
    function _getCurrentTime(allowFatalError) {
        try {
            if (_videoElement) {
                _currentTime = _videoElement['currentTime'];
            }
        }
        catch (e) {
            _log.error('Exception while getting VIDEO.currentTime', e);
            if (allowFatalError) {
                _closeWithException(ErrorCodes.PLAY_MSE_GETCURRENTTIME, e);
            }
        }
        return Math$round(_currentTime * MILLISECONDS_PER_SECOND);
    }

    /**
     * Seeks the video element to the provided time. Should be called oly after data has been appended for this position and getSeeking() is false.
     *
     * @param {number} time
     */
    function _seek(time) {
        debug$assert(!_seekInProgress);

        // snapshot the counts, because they might reset
        _refreshCounters();

        var currentTime = _getCurrentTime(true);
        if (Math$abs(currentTime - time) <= MediaPresenter$SMALL_TIME) {
            // TODO: can we still wait for an event here, say only timeupdate?
        } else {
            try {
                _log.trace('Setting video elements currentTime', {
                    'From': Number$formatMillisecond(currentTime),
                    'To': Number$formatMillisecond(time)
                });
                _seekInProgress = {};
                _videoElement['currentTime'] = time / MILLISECONDS_PER_SECOND;
            }
            catch (e) {
                _log.error('Exception while setting VIDEO.currentTime', e);
                _closeWithException(ErrorCodes.PLAY_MSE_SETCURRENTTIME, e);
            }
        }
    }

    /**
     * Is there a seek in progress?
     */
    function _getSeeking() {
        return !!_seekInProgress;
    }

    function _tryCompleteSeek() {
        if (_seekInProgress &&
            _seekInProgress.observedSeeked &&
            _seekInProgress.observedTimeupdate) {

            _seekInProgress = undefined;
            _eventSource.fire(MediaElement$seeked);

        }
    }

    /**
     *
     * @param {number} type
     */
    function _addSourceBuffer(type) {
        var bufferId = parseInt10(_aseMediaSourceId.toString() + _sourceBufferList.length.toString()),
            aseId = {
                sourceId: _aseMediaSourceId,
                bufferId: bufferId
            },
            codecSelector = _sourceBufferCodecStringSelector.bind(null, config.videoCodecs, playback.primaryAudioStream),
            sourceBuffer;

        try {
            sourceBuffer = new MediaElementSourceBuffer(playback, type, codecSelector, _mediaSource, aseId, _log);
        } catch(e) {
            var message = exceptionToString(e);

            _log.error('Unable to add source buffer.', {
                'mime': codecSelector(type),
                'error': message
            });

            playback.closeWithError(new PlayerError(ErrorCodes.PLAY_MSE_SOURCEADD,
                {
                    errorSubCode: type === ASEMediaStream$AUDIO ? ErrorSubCodes.MSE_AUDIO : ErrorSubCodes.MSE_VIDEO,
                    errorDetails: message
                })
            );
            return;
        }

        _sourceBufferList.push(sourceBuffer);
        if (type == playback.streamingManager.MEDIA_VIDEO && sourceBuffer.firstChunkAppend) {
            sourceBuffer.firstChunkAppend.addListener(_resolveVideoAppend);
        }
        return sourceBuffer;
    }
    
    /**
     * Select the correct codec string for audio or video source buffer
     * @param videoCodecs the video codecs supported by the platform
     * @param primaryAudioStream the audio stream currently selected for the playback
     * @param mediaType ASEMediaStream$VIDEO or ASEMediaStream$AUDIO
     * @returns {string} a codec string for the source buffer.
     * @private
     */
    function _sourceBufferCodecStringSelector(videoCodecs, primaryAudioStream, mediaType) {
        var codecString;
        switch(mediaType) {
            case ASEMediaStream$VIDEO:
                codecString = videoCodecs;
                break;
            case ASEMediaStream$AUDIO:
                codecString = primaryAudioStream.header.codec == Box$CODEC_EC3 ? MEDIA_TYPE_AUDIO_DDPLUS : MEDIA_TYPE_AUDIO_HEAAC;
                break;
            default:
                break;
        }

        return codecString;
    }

    /**
     *
     * @param {Array} typeArr
     * @private
     */
    function _addSourceBuffers(typeArr) {
        var arrayLength = typeArr.length;
        for (var i = 0; i < arrayLength; i++) {
            _addSourceBuffer(typeArr[i]);
        }
        // TODO ASE -- Will we ever need to call cb.onerror()
        _eventSource.fire(MediaElement$sourceBuffersAdded);
        return true;
    }

    /**
     *
     * @param {Object} sourceBuffer
     */
    function _removeSourceBuffer(sourceBuffer) {
        // must remove the source buffer from the bookkeeping list
        var arrayLength = _sourceBufferList.length;
        for (var i = 0; i < arrayLength; i++) {
            if (compareByProperties(sourceBuffer, _sourceBufferList[i])) {
                _sourceBufferList = _sourceBufferList.splice(i, 1);
            }
        }
        _mediaSource['removeSourceBuffer'](sourceBuffer);
    }

    function _endOfStream() {
        DEBUG && _log.trace('Calling endOfStream on mediaSource');
        if (config.callEndOfStream) {
            _mediaSource['endOfStream']();
        }
    }

    /**
     *
     * @param {{ondestroy: Function, onerror: Function}} cb -- callback to ASE
     */
    function _destroy(cb) {
        DEBUG && _log.trace('Called MediaSource.destroy()');
        _sourceBufferList = [];
        cb && cb.ondestroy();
        return true;
    }

    /**
     *
     * @param {Object} licenseResponse
     */
    function _addLicense(licenseResponse) {
        var data = licenseResponse.data;

        if ((DEV || DEBUG) && MediaElement$isClearkey()) {
            data = MediaElement$_mockClearkeyLicense(playback);
        }

        if (DEBUG) _log.debug('License response', objectToStringTrace(data));
        _keyIsAdded = true;
        _addKey(data, _keyChallenge, _keySessionId);
        if (config.limitedDurationLicense) {
            _updateLicenseState();
            debug$assert(_licenseState == licenseStates$FETCHED_LIMITED || _licenseState == licenseStates$FETCHED_FULL);
        }
    }

    /**
     * @param {Uint8Array} data
     * @param {Uint8Array=} keyChallenge
     * @param {string=} keySessionId
     */
    function _addKey(data, keyChallenge, keySessionId) {
        if (DEBUG || config.enableEmeVerboseLogging) {
            _log.trace('KeySession update', data && base64$encode(data));
        }

        try {
            if (_keySession) {
                var waitForKeyAdded = _keySession['update'](data);
                if (waitForKeyAdded && waitForKeyAdded.then) {
                    waitForKeyAdded.then(_onKeyAdded).catch(function (e) {
                        _log.error('keySession update promise rejected', e);
                        var errorData = MediaElement$getUnprefixedEmeErrorResult(e);
                        _closeWithError(ErrorCodes.PLAY_MSE_EVENT_KEYERROR, errorData);
                    });
                }
            } else {
                _videoElement['webkitAddKey'](_keySystemId, data, keyChallenge, keySessionId);
            }
        }
        catch (e) {
            _log.error('Exception calling keySession.update or addKey', e);
            _closeWithException(ErrorCodes.PLAY_MSE_KEYSESSION_UPDATE, e);
        }
    }

    function _onSeeking() {
        _log.trace('Video element event: seeking');
        if (_seekInProgress) {
            _seekInProgress.observedSeeking = true;
        } else {
            _closeWithError(ErrorCodes.PLAY_MSE_UNEXPECTED_SEEKING);
        }
    }

    function _onSeeked() {
        _log.trace('Video element event: seeked');
        if (_seekInProgress) {
            debug$assert(_seekInProgress.observedSeeking);
            _seekInProgress.observedSeeked = true;
            _tryCompleteSeek();
        } else {
            _closeWithError(ErrorCodes.PLAY_MSE_UNEXPECTED_SEEKED);
        }
    }

    function _onTimeUpdate() {
        DEBUG && _log.debug('Video element event: timeupdate', {'ElementTime': Number$formatMillisecond(_getCurrentTime(false))});
        if (_seekInProgress) {
            _seekInProgress.observedTimeupdate = true;
            _tryCompleteSeek();
        }
        _eventSource.fire(MediaElement$currentTimeChanged);
    }

    function _onSourceOpen(event) {
        DEBUG && _log.trace('Received event: sourceopen');
        if (!_sourceOpenFired) {
            _sourceOpenFired = true;
            _eventSource.fire(MediaElement$sourceopen, event);
        }
    }

    function _onError(e) {
        var o = MediaElement$getErrorResult(e, ErrorSubCodes$toMediaErrorSubCode);
        _log.error('Video element event: error', o.logInfo);

        if (_secureStopManager && _secureStopManager.isBeingProcessed() && !config.secureStopIgnoreVideoError) {
            var errorData = {
                'ErrorCode': ErrorCodes.SECURE_STOP_VIDEO_ERROR
            };
            mixIn(errorData, ErrorSubCodes$errorResultToLogFields(o.errorResult));
            _secureStopManager.terminate(errorData);
        } else {
            _closeWithError(ErrorCodes.PLAY_MSE_EVENT_ERROR, o.errorResult);
        }
    }

    function _onKeyError(e) {
        var o = MediaElement$getErrorResult(e, ErrorSubCodes$toMediaKeyErrorSubCode);
        _log.error('Received event: keyerror', o.logInfo);
        if (_secureStopManager && _secureStopManager.isBeingProcessed(e)) {
            if (!SecureStopManager$specialCaseForChrome(e)) {
                var errorData = {
                    'ErrorCode': ErrorCodes.SECURE_STOP_KEY_ERROR
                };
                mixIn(errorData, ErrorSubCodes$errorResultToLogFields(o.errorResult));
                _secureStopManager.terminate(errorData);
            }
        } else {
            _closeWithError(ErrorCodes.PLAY_MSE_EVENT_KEYERROR, o.errorResult);
        }
    }

    function _onNeedKey(event) {
        var emeLog,
            eme;

        DEBUG && _log.trace('Received event: ' + event['type']);

        function _getFreshLicense() {
            playback.emeSession = _createEmeSession(event['initDataType']);
            _setLicense(emeLog, base64$decode(playback.psshb64));
        }

        if (!_licenseChallengeRequested) {
            _licenseChallengeRequested = true;
            if (!EmeSession) {
                _closeWithError(ErrorCodes.LICENSE, ErrorSubCodes.EME_ERROR_NODRMSESSSION);
                return;
            }

            if (!playback.psshb64) {
                _log.error('Missing the PSSH on the video track, closing the player');
                _closeWithError(ErrorCodes.PLAY_MSE_EME_MISSING_PSSH);
                return;
            }

            if (DEBUG) {
                _log.debug('License init data type', event['initDataType']);
            }

            if (isLimitedDurationLicenseSupported(config) && config.prepareCadmium && videoPreparer) {
                videoPreparer.getCachedData(playback.movieId, 'ldl')
                    .then(function (emeSession) {
                        playback.emeSession = emeSession;
                        // let it complete the flow for eme and wait to resolve lr.
                        return playback.emeSession.waitForLicenseReceived.then(function () {
                            return _setLicense(emeLog, base64$decode(playback.psshb64), true).then(function () {
                                if(emeSession.closedKeySession) {
                                    //typically happens when we get a fatal keysession error or keystatus
                                    _closeWithError(ErrorCodes.EME_LDL_KEYSSION_ALREADY_CLOSED); 
                                    return;
                                }
                                var logger = new playback.log.CategoryLog('Eme');
                                //update the existing eme session from cache
                                playback.emeSession.updateProperties({
                                    log: logger,
                                    onMilestone: playback.notifyMilestone // will be used when we add milestones for license renewals in endplay
                                }, {
                                    requests: _createDrmRequestsInstance(logger), // will be used for sending stop commmand
                                    onerror: _closeWithError
                                });
                                var pendingLicenseChallenge = playback.emeSession.pendingLicenseChallenge;
                                if (pendingLicenseChallenge) {
                                    _handleLicenseRequestEvent(pendingLicenseChallenge);
                                }
                                playback.importMilestones(playback.emeSession.milestones || {});
                            });
                        });
                    }).catch(function (e) {
                        _log.warn('eme not in cache', e);
                        _getFreshLicense(); //either cache is empty or expired entry.
                    });
            } else {
                _getFreshLicense();
            }
        }
    }

    // Create a new requests object, this will need to have a license and secure
    // stop methods that will handle sending any requests that will need to
    // be made during the licensing process.
    function _createDrmRequestsInstance(log) {
        return new DrmRequests(log, playback.nccpPlayback.getLicense, playback.nccpPlayback.stopAndRelease, {
            isDebug: DEBUG,
            isDev: DEV,
            cert: playback.cert,
            http: http
        });
    }

    // only for first license request. Not renewals
    function _handleLicenseRequestEvent(licenseChallenge) {
        playback.fireEvent(MediaPresenter$needlicense, licenseChallenge);
    }

    function _createEmeSession(initDataType) {

        var session,
            requests,
            emeLog;

        if (!DrmRequests) {
            _closeWithError(ErrorCodes.LICENSE, ErrorSubCodes.EME_ERROR_NODRMREQUESTS);
        }

        emeLog = new playback.log.CategoryLog('Eme');
        requests = _createDrmRequestsInstance(emeLog);

        // Create a new instance of an EmeSession, this will do the complete
        // license flow
        return new EmeSession(emeLog, initDataType, playback.notifyMilestone, {
            isDebug: DEBUG,
            isDev: DEV,
            isSecureStopEnabled: config.secureStopEnabled,
            secureStopTimeouts: {
                messageTimeout: config.secureStopKeyMessageTimeoutMilliseconds,
                changedTimeout: config.secureStopKeyAddedTimeoutMilliseconds
            },
            clock: {getTime: clock$getTime},
            requests: requests,
            promiseBased: _usePromiseBasedEme,
            videoElement: _videoElement,
            useCdmId: config.useCdmId,
            verboseLogging: config.enableEmeVerboseLogging,
            onerror: _closeWithError,
            notifyLicenseRequest: _handleLicenseRequestEvent,
            playbackInitiated: true,
            serverCertificate: config.useSetServerCertificateApi && config.serverCertificate,
            ignoreKeyStatusOutputNotAllowed: config.ignoreKeyStatusOutputNotAllowed
        });
    }

    /**
     * @param {Object} emeLog
     * @param {Uint8Array} initData
     * @param {boolean=} applyExistingLicense
     *
     */
 function _setLicense(emeLog, initData, applyExistingLicense) {
        function renewLicense() {
            playback.emeSession.renew().catch(function (err) {
                _log.error('Unable to set the license', {
                    'code': err.code,
                    'subCode': err.subCode,
                    'extCode': err.extCode,
                    'edgeCode': err.edgeCode,
                    'message': err.message,
                    'errorDetails': err.errorDetails,
                    'errorData': err.errorData,
                    'state': err.state
                });
                if (err.cause && err.cause.errorDetails) {
                    err.errorDetails = err.errorDetails ? err.errorDetails + err.cause.errorDetails : err.cause.errorDetails;
                }
                _closeWithError(err.code, err, err.extCode);
            });
        }

        var licenseType;

        _log.info('Setting the license');

        if (DEBUG) {
            _log.debug('License init data', objectToStringTrace(initData));
        }

        licenseType = _getLicenseType();
        _updateLicenseState();

		if (config.getDrmHeaderFromMedia) {
			// Use the DRM header from the media, and not the one from the manifest
	        var psshBox = playback.primaryVideoStream.header.moovBox.children.filter(function (box) {
	            return box.type == 'pssh' && box.drmSystemId == DrmSystemId$PLAYREADY;
	        })[0];
			initData = psshBox.raw;
		}
		// END HACK


        var waitForLicense;
        if (applyExistingLicense) {
            
            if (config.setMediaKeysEarly) {
                waitForLicense = playback.emeSession.applyExistingLicense(_videoElement).then(function () {
                    return _setMediaKeys(playback.emeSession.mediaKeys);
                });
            } else {
                waitForLicense = playback.emeSession.applyExistingLicense(_videoElement);
            }
            
        } else {
            waitForLicense = playback.emeSession.create(_keySystemId).then(function(result) {
                
                if (config.setMediaKeysEarly) {
                    return _setMediaKeys(playback.emeSession.mediaKeys).then(function () {
                        return playback.emeSession.license(licenseType, initData);
                    });
                } else {
                    return playback.emeSession.license(licenseType, initData);
                }
            });
        }

        return waitForLicense.then(function(result) {
            if (config.setMediaKeysEarly) {
                return Promise.resolve({
                    success: true
                });
            } else {
                return _setMediaKeys(playback.emeSession.mediaKeys);
            }
        }).then(function (result) {
            _log.info('license set');
            _eventSource.fire(MediaElement$licenseadded, {
                keySessionId: playback.emeSession.getSessionId()
            });
            _waitForVideoAppend.then(function () {
                if (config.limitedDurationLicense && config.licenseRenewalRequestDelay && (_licenseState == licenseStates$FETCHING_LIMITED || _licenseState == licenseStates$FETCHED_LIMITED)) {
                    _renewalTimer = setTimeout(renewLicense, config.licenseRenewalRequestDelay);
                }
            });
        }).catch(function (err) {
            _log.error('Unable to set the license', {
                'code': err.code,
                'subCode': err.subCode,
                'extCode': err.extCode,
                'edgeCode': err.edgeCode,
                'message': err.message,
                'errorDetails': err.errorDetails,
                'errorData': err.errorData,
                'state': err.state
            });
            if (err.cause && err.cause.errorDetails) {
                err.errorDetails = err.errorDetails ? err.errorDetails + err.cause.errorDetails : err.cause.errorDetails;
            }
            if (applyExistingLicense) {
                var errorMessage = (err && err.message) ? err.message : 'failed to set license';
                throw new Error(errorMessage); //this is being caught  
            } else {
                _closeWithError(err.code, err, err.extCode);
            }
        });
    }

    function _setMediaKeys(mediaKeys) {
        if (_usePromiseBasedEme) {
            return new Promise(function (resolve, reject) {
                if (_videoElement) {
                    _videoElement['setMediaKeys'](mediaKeys).then(function (result) {
                        resolve({
                            success: true
                        });
                    }).catch(function (err) {
                        var ex = MediaElement$getUnprefixedEmeErrorResult(err);
                        reject({
                            success: false,
                            code: ErrorCodes.PLAY_MSE_SETMEDIAKEYS,
                            subCode: ex.errorSubCode,
                            extCode: ex.errorExternalCode,
                            errorDetails: ex.errorDetails,
                            message: 'Set media keys is a failure',
                            cause: err
                        });
                    });
                } else {
                    return Promise.resolve({
                        success: true
                    });
                }
            });
        } else {
            // Prefixed eme sessions are handled inside the node modules because the call
            // needs to happen before licensing can start
            return Promise.resolve({
                success: true
            });
        }
    }

    function _generateLicenseChallenge(initDataType, initData) {

        if (DEBUG) {
            _log.debug('License init data type', initDataType);
            _log.debug('License init data', objectToStringTrace(initData));
        }

        if (!_videoElement) {
            // we might be closed
            return;
        }

        playback.notifyMilestone('lg');

        try {
            // if we have MediaKeys and we shouldn't prefer old EME API... use MediaKeys
            if (!_usePromiseBasedEme && MediaKeys && !(config.preferOldEme && _videoElement['webkitGenerateKeyRequest'])) {
                if (_videoElement['msSetMediaKeys']) {
                    _mediaKeys = new MediaKeys(_keySystemId);
                    _videoElement['msSetMediaKeys'](_mediaKeys);
                } else if (_videoElement['setMediaKeys']) {
                    _mediaKeys = new MediaKeys(_keySystemId);
                    _videoElement['setMediaKeys'](_mediaKeys);
                }
                else if (_videoElement['webkitSetMediaKeys']) {
                    _mediaKeys = new MediaKeys(_keySystemId);
                    _videoElement['webkitSetMediaKeys'](_mediaKeys);
                }
            }

            if (_usePromiseBasedEme) {
                var supportedConfigs = [{
                    'initDataTypes': ["cenc"],
                    'persistentState': "required",
                    //audioCapabilities: [], // Can't be empty array, add the audio codecs.
                    'videoCapabilities': [{
                        'contentType': MEDIA_TYPE_VIDEO_H264,
                        'robustness': "HW_SECURE_DECODE"
                    }, {
                        'contentType': MEDIA_TYPE_VIDEO_H264,
                        'robustness': "SW_SECURE_DECODE"
                    },]
                    //label: "M43+" // For debugging - only supported in Chrome 43+.
                }, {
                    'initDataTypes': ["cenc"],
                    'persistentState': "required"
                } // For M42.
                ];

                navigator['requestMediaKeySystemAccess'](_keySystemId, supportedConfigs).then(function (keySystemAccess) {
                    DEBUG && _log.trace('keySystem Access resolved', keySystemAccess);
                    DEBUG && _log.trace('supportedconfig', JSON.stringify(keySystemAccess['getConfiguration']()));
                    return keySystemAccess['createMediaKeys']();
                }).then(function (createdMediaKeys) {
                    DEBUG && _log.trace('createMediaKeys resolved', createdMediaKeys);
                    _createdMediaKeys = createdMediaKeys;
                    return _videoElement['setMediaKeys'](createdMediaKeys);
                }).then(function () {
                    DEBUG && _log.trace('setMediaKeys resolved');
                    var keySession = _createdMediaKeys['createSession']();

                    keySession.addEventListener('message', _onKeyMessage);
                    keySession.addEventListener('keystatuseschange', function (e) {
                        DEBUG && _log.trace('Received event: ' + e['type']);
                        // subject to change
                        try {
                            var keyStatuses = e['target']['keyStatuses'];
                            keyStatuses.forEach(function (status, keyId, map) {
                                DEBUG && _log.trace('key status: ' + status);
                                if (status == 'expired') {
                                    _closeWithError(ErrorCodes.PLAY_MSE_EME_KEY_STATUS_CHANGE_EXPIRED);
                                }
                                if (status == 'internal-error') {
                                    _closeWithError(ErrorCodes.PLAY_MSE_EME_KEY_STATUS_CHANGE_INTERNAL_ERROR);
                                }
                                if (status == 'output-not-allowed') {
                                    _closeWithError(ErrorCodes.PLAY_MSE_EME_KEY_STATUS_CHANGE_OUTPUT_NOT_ALLOWED);
                                }
                                // This is an optional EME feature. Lets log it to see its frequency and support.
                                if (status == 'output-downscaled') {
                                    if (!_outputDownscaledLogged) {
                                        _outputDownscaledLogged = true;
                                        _log.error('output-downscaled');
                                    }
                                }
                            });
                        } catch (ex) {
                            _log.error('Exception in iterating keystatuses', ex);
                        }
                    });

                    keySession['generateRequest'](initDataType, initData);
                    _keySession = keySession;
                }).catch(function (e) {
                    _log.error('Exception creating keySession', e);
                    var errorData = MediaElement$getUnprefixedEmeErrorResult(e),
                        errorCode = ErrorCodes.PLAY_MSE_EME_CREATE_KEYSESSION_FAILED;

                    if (errorData.errorSubCode == ErrorSubCodes.EME_MEDIA_UNAVAILABLE_CDM) {
                        errorCode = ErrorCodes.PLAY_MSE_GENERATEKEYREQUEST;
                    }
                    _closeWithError(errorCode, errorData);
                });
            }
        }
        catch (e) {
            _log.error('Exception creating MediaKeys', e);
            _closeWithException(ErrorCodes.PLAY_MSE_CREATE_MEDIAKEYS, e);
            return;
        }

        if (!_usePromiseBasedEme) {
            try {
                var keyEventSource;
                if (_mediaKeys) {
                    _keySession = _mediaKeys['createSession']('video/mp4', initData, null);
                    keyEventSource = _keySession;
                } else {
                    _videoElement['webkitGenerateKeyRequest'](_keySystemId, initData);
                    keyEventSource = _videoElement;
                }

                keyEventSource.addEventListener(EVENT_PREFIX + 'keyerror', _onKeyError);
                keyEventSource.addEventListener(EVENT_PREFIX + 'keymessage', _onKeyMessage);
                keyEventSource.addEventListener(EVENT_PREFIX + 'keyadded', _onKeyAdded);
            } catch (e) {
                _log.error('Exception generating key request', e);
                _closeWithException(ErrorCodes.PLAY_MSE_GENERATEKEYREQUEST, e);
            }
        }
    }

    function _onKeyMessage(event) {
        var messageType = event['messageType'],
            logMessage = 'Received event: ' + event['type'] + (messageType ? (' , ' + messageType ) : '');
        DEBUG && _log.trace(logMessage);

        var sessionId = event['sessionId'] || (_keySession && _keySession['sessionId']),
            message = event['message'],
            drmType = MediaElement$getDrmType();
        if (message instanceof ArrayBuffer) {
            message = new Uint8Array(message);
        }

        if (DEBUG || config.enableEmeVerboseLogging) {
            _log.trace('KeySession message', message && base64$encode(message));
        }

        if (!_keyMessageForCdmIdProcessed && config.useCdmId) {
            _keyMessageForCdmIdProcessed = true;
            // if this feature is enabled, we should ignore first keymessages challenge
            // and call back with "addKey" with "cdm_id:" + event.message, which will trigger
            // special logic in Chrome R26+ to generate 2nd keymessage event.message of which
            // which will include cdm_id
            debug$assert(MediaElement$getDrmType() == DrmType$WIDEVINE);

            var magicCdmIdPrefix = [99, 100, 109, 95, 105, 100, 58]; // 'cdm_id:' as Latin1 encoded byte array
            var magicMessage = new Uint8Array(magicCdmIdPrefix.length + message.length);
            magicMessage.set(magicCdmIdPrefix, 0);
            magicMessage.set(message, magicCdmIdPrefix.length);
            if (DEBUG) _log.debug('License cdm_id', objectToStringTrace(magicMessage));
            _addKey(magicMessage, message, sessionId);
            return;
        }

        if (playback.cert && compareArrays([8, 4], message)) {
            // This supports Widevine's "ChromeOS Remote Attestation" feature.
            // This feature allows the CDM to complete the attestation process
            // to tell the server client is operating 'verified mode', which can
            // allow playback of higher-valued content.
            //
            // This feature is enabled with the SUPPORTS_WIDEVINE_ATTESTATION
            // platform variable. When the message is exactly [8,4],we know we
            // must send the Netflix Server Certificate to the CDM.
            //
            // NOTE: This is the 'short-circuit' method. Normally the client
            // requests the Server Certificate from the server and then hands it
            // to the CDM. But since the cert rarely changes, we can save a
            // round-trip here by simply sending in the known cert directly.
            // If the server certificate has to change, we will change the server
            // piece and this client code at the same time.
            debug$assert(MediaElement$getDrmType() == DrmType$WIDEVINE);
            var serverCert = base64$decode(playback.cert);
            _addKey(serverCert, message, sessionId);
            return;
        }

        // For FPS, if message is encoded "certificate" string, we need to give the fps app data to the CDM
        if (drmType == DrmType$FPS && compareArrays([99, 101, 114, 116, 105, 102, 105, 99, 97, 116, 101], message)) {
            playback.notifyMilestone('scs');
            MediaElement$getFairplayCert(playback).then(function (result) {
                playback.notifyMilestone('scr');
                _addKey(result.certificate, message, sessionId);
            }).catch(function (err) {
                _closeWithError(ErrorCodes.NCCP_FPSAPPDATA, err);
            });
            return;
        }

        if (_secureStopManager && _secureStopManager.isWaitingForKeyMessage()) {


            _secureStopManager.updateWithKeyMessage({
                success: true,
                challenge: message,
                drmType: MediaElement$getDrmType(),
                keySessionId: _keySessionId
            });


            _secureStopManager.waitForServerResponse()['then'](function (result) {
                if (result.success) {
                    _addKey(result.ack, result.challenge, _keySessionId);
                }
            });
        }

        if (!_keyMessageProcessed || (config.limitedDurationLicense && (_licenseState !== licenseStates$FETCHED_FULL))) {

            _keyMessageProcessed = true;
            try {
                _keySessionId = sessionId;
                var psshData;

                // get the netflix pssh box
                playback.primaryVideoStream.header.moovBox.children.forEach(function (box) {
                    if (box.type == 'pssh' && box.drmSystemId == DrmSystemId$WIDEVINE) {
                        psshData = box.data;
                    }
                });

                if (MediaElement$getDrmType() == DrmType$PLAYREADY) {
                    // for playready, the challenge might be part of the message
                    var extracted = MediaElement$extractFromPlayreadyMessage(message, 'PlayReadyKeyMessage', 'Challenge');
                    if (extracted) {
                        _keyChallenge = base64$decode(extracted);
                    } else {
                        _keyChallenge = message;
                    }
                } else {
                    _keyChallenge = message;
                }

                var licenseChallenge = {
                    drmType: MediaElement$getDrmType(),
                    data: _keyChallenge,
                    psshData: psshData
                };

                if (config.limitedDurationLicense) {
                    _updateLicenseState(); // init to fetching limited or fetched_limited to fetching_full
                    debug$assert(_licenseState == licenseStates$FETCHING_LIMITED || _licenseState == licenseStates$FETCHING_FULL);
                    if (_licenseState == licenseStates$FETCHING_FULL) {
                        licenseChallenge.renewal = true;
                    }
                    licenseChallenge.licenseType = _licenseState === licenseStates$FETCHING_LIMITED ? Enums.LICENSE_TYPE.LIMITED : Enums.LICENSE_TYPE.STANDARD;
                }

                if (MediaElement$isClearkey()) {
                    // for debug builds, allow use of a clear key
                    // for clearkey we make a license request with a hardcoded challenge to get an lTicket
                    licenseChallenge = MediaElement$createMockLicenseChallenge();
                }

                if (DEBUG) _log.debug('License challenge', objectToStringTrace(licenseChallenge.data));
                _eventSource.fire(MediaElement$needlicense, licenseChallenge);
            }
            catch (e) {
                _log.error('Exception creating license challenge', e);
                _closeWithException(ErrorCodes.PLAY_MSE_PARSECHALLENGE, e);
            }
        }
    }

    function _onKeyAdded(event) {
        var logMessage = event ? 'Received event: keyadded' : 'addKey promised resolved';
        _log.trace(logMessage);

        // ignore keyadded message untill we know that _keyIsAdded
        if (_keyIsAdded) {
            if (!_keyAddedProcessed) {
                _keyAddedProcessed = true;
                _eventSource.fire(MediaElement$licenseadded, {keySessionId: _keySessionId});
            }
            // For PlayReady and Safari, send an explicit renewal request for license. Note: renew only after video media is appended. Don't renew if secure stop is in progress (secureStopManager.started() is true)
            var licenseRenewalMethod = _getLicenseRenewalMethod();
            if (licenseRenewalMethod) {
                _waitForVideoAppend.then(function () {
                    _renewalTimer = setTimeout(licenseRenewalMethod, config.licenseRenewalRequestDelay);
                });
            }
        }

        if (_secureStopManager && _secureStopManager.isWaitingForKeyAdded()) {
            _secureStopManager.updateWithKeyAdded();
        }
    }

    function _onHiddenChanged() {
        if (document['hidden'] === true) {
            _counters.forEach(function (counter) {
                counter.refresh();
                counter.startIgnoring();
            });
        } else {
            _counters.forEach(function (counter) {
                counter.refresh();
                counter.stopIgnoring();
            });
        }
    }

    function _getLicenseRenewalMethod() {
        if (config.limitedDurationLicense && config.licenseRenewalRequestDelay && (_licenseState == licenseStates$FETCHING_LIMITED || _licenseState == licenseStates$FETCHED_LIMITED)) {
            switch (MediaElement$getDrmType()) {
                case DrmType$FPS:
                    return _renewFpsLicense;
                case DrmType$PLAYREADY:
                    return _renewPlayReadyLicense;
            }
        }
    }

    function _renewFpsLicense() {
        DEBUG && _log.debug('request for renewal');
        _addKey(utf8$getBytes('renew'));
        _renewalTimer = undefined;
    }

    function _renewPlayReadyLicense() {
        DEBUG && _log.debug('request for renewal');

        _manageEventHandlers(_keySession, 'removeEventListener');
        var keyId = Box$getKeyId(playback.primaryVideoStream.header.moovBox);
        var guid = Box$convertKeyIdToGuid(keyId);
        var drmKeyId = base64$encode(guid);
        var cdmData = formatPlayReadyProactiveLicenseCdmData([drmKeyId]);
        _keySession = _mediaKeys['createSession']('video/mp4', new Uint8Array(), cdmData);
        _manageEventHandlers(_keySession, 'addEventListener');

        _renewalTimer = undefined;

        /**
         * @param {Array} keyIds
         */
        function formatPlayReadyProactiveLicenseCdmData(keyIds) {
            var keyIdElements = '';
            keyIds.forEach(function (value) {
                keyIdElements += "<KeyID>" + value + "</KeyID>";
            });

            var cdmData =
                "<PlayReadyCDMData type=\"LicenseAcquisition\">" +
                "<LicenseAcquisition version=\"1.0\" " +
                "Proactive=\"true\">" +
                "<KeyIDs>" +
                keyIdElements +
                "</KeyIDs>" +
                "<CustomData></CustomData>" +
                "</LicenseAcquisition></PlayReadyCDMData>";

            return new Uint8Array(String$stringToArrayBuffer(cdmData));
        };
    }

    /**
     * @param {number} errorCode
     * @param {*=} errorResult
     * @param {*=} errorExternalCode
     */
    function _closeWithError(errorCode, errorResult, errorExternalCode) {
        playback.closeWithError(new PlayerError(errorCode, errorResult, errorExternalCode));
    }

    /**
     * @param {number} errorCode
     * @param {*=} exception
     */
    function _closeWithException(errorCode, exception) {
        var errorResult = {
            errorSubCode: ErrorSubCodes.EXCEPTION,
            errorDetails: exceptionToString(exception)
        };

        // Typically exceptions thrown my MS code have 8-byte hex code in them, try to extract that
        var errorExternalCode;
        try {
            errorExternalCode = exception['message']['match'](/(?:[x\W\s]|^)([0-9a-f]{8})(?:[x\W\s]|$)/i)[1]['toUpperCase']();
            if (errorExternalCode && errorExternalCode.length == 8) {
                errorResult.errorExternalCode = errorExternalCode;
            }
        }
        catch (e) {
        }

        playback.closeWithError(new PlayerError(errorCode, errorResult));
    }

    function _createCounter(getActualCount) {
        var counter = new OneWayCounter();
        _counters.push(counter);

        function refresh() {
            var n = getActualCount();
            if (isNumber(n)) {
                counter.addObservation(n);
            }
        }

        function getCountClosed() {
            refresh();
            return counter.getCount();
        }

        counter.refresh = refresh;

        return getCountClosed;
    }

    function _refreshCounters() {
        _counters.forEach(function (counter) {
            counter.refresh();
        });
    }

    function _didDecodingStart() {
        if (_videoElement) {
            if (_videoElement['readyState'] >= 2) {
                var webkitDecodedFrameCount = _videoElement['webkitDecodedFrameCount'];
                if (webkitDecodedFrameCount === undefined || webkitDecodedFrameCount > 0 || config.webkitDecodedFrameCountIncorrectlyReported) {
                    _self.didDecodingStart = _didDecodingStart = RETURN_TRUE;
                    return true;
                }
            }
        }
        return false;
    }

    function _getConstrictionActive() {
        var ts = _getGraphicsTrustStatus();
        return !!(ts && (ts['constrictionActive'] == true));
    }

    function _onShouldUpdateVideoDiagInfo(args) {
        if (_videoElement) {
            var videoDiagInfo = args.videoDiagInfo;
            var ts = _getGraphicsTrustStatus();
            if (ts) {
                videoDiagInfo['ConstrictionActive'] = ts['constrictionActive'];
                videoDiagInfo['Status'] = ts['status'];
            }
            try {
                videoDiagInfo['readyState'] = '' + _videoElement['readyState'];
                videoDiagInfo['currentTime'] = '' + _videoElement['currentTime'];
                videoDiagInfo['pbRate'] = '' + _videoElement['playbackRate'];
            }
            catch (e) {
            }
            var i = _sourceBufferList.length;
            var sourceBuffer;
            while (i--) {
                sourceBuffer = _sourceBufferList[i];
                var streamType = '';
                if (sourceBuffer.type == playback.streamingManager.MEDIA_AUDIO) {
                    streamType = 'audio';
                } else if (sourceBuffer.type == playback.streamingManager.MEDIA_VIDEO) {
                    streamType = 'video';
                }
                mixIn(videoDiagInfo, sourceBuffer.getBufferedRangesForLog(), {prefix: streamType});

                if (config.enableLastChunkLogging && playback.fatalError && playback.streamingManager.MEDIA_VIDEO == sourceBuffer.type) {  // additional logging for S7381.
                    var mediaSegment = shallowCopy(sourceBuffer.getCurrentSegment()),
                        length = mediaSegment['data'] && mediaSegment['data']['length'];
                    if (length < 3000) { // headers only
                        mediaSegment['data'] = convertTypedArraytoArray(mediaSegment['data']).join();
                        mixIn(videoDiagInfo, mediaSegment, {
                            prefix: sourceBuffer.type
                        });
                    }
                }

            }
            if (_mediaSource) {
                var duration = _mediaSource['duration'];
                if (duration && !(isNaN(duration))) {
                    videoDiagInfo['duration'] = (duration).toFixed(4);
                }
            }

            if (config.logMediaPipelineStatus) {
                try {
                    var emeSession = playback.emeSession,
                        keySession = emeSession && emeSession.keySession;
                    if (keySession) {
                        var expiration = keySession['expiration'];
                        if (!isNaN(expiration)) {
                            videoDiagInfo['exp'] = expiration;
                        }
                        var keyStatuses = keySession['keyStatuses']['entries']();
                        if (keyStatuses['next']) {
                            var next = keyStatuses['next']()['value'];
                            if (next) {
                                videoDiagInfo['keyStatus'] = next[1];
                            }
                        }
                    }
                } catch (e) {
                }
            }
        }
    }

    function _getPlaybackQuality() {
        if (_videoElement) {
            return (_videoElement['getVideoPlaybackQuality'] && _videoElement['getVideoPlaybackQuality']()) ||
                _videoElement['videoPlaybackQuality'] ||
                _videoElement['playbackQuality'];
        }
    }

    function _getGraphicsTrustStatus() {
        return _videoElement && _videoElement['msGraphicsTrustStatus'];
    }

    function _tryGetTypeNotSupportedDetails(callback) {
        var timeoutMonitor = new TimeoutMonitor(500, function () {
            wrapup();
        });
        timeoutMonitor.ensureTimer();

        try {
            var psshBox = playback.videoStream.value.header.moovBox.children.filter(function (box) {
                return box.type == 'pssh' && box.drmSystemId == DrmSystemId$PLAYREADY;
            })[0];
            var mediaKeys = new MediaKeys(_keySystemId);
            var keySession = mediaKeys['createSession']('video/mp4', psshBox.raw, null);
            keySession.addEventListener(EVENT_PREFIX + 'keyerror', function (e) {
                var o = MediaElement$getErrorResult(e, ErrorSubCodes$toMediaKeyErrorSubCode);
                wrapup(o.errorResult);
            });
        }
        catch (e) {
            wrapup();
        }

        /**
         * @param {Object=} result
         */
        function wrapup(result) {
            wrapup = NOOP;
            timeoutMonitor.stopTimer();
            callback(result);
        }
    }

    function _updateLicenseState() {
        _licenseState++;
    }

    function _getLicenseType() {
        if (config.limitedDurationLicense && _licenseState === licenseStates$INIT) {
            return Enums.LICENSE_TYPE.LIMITED;
        }
        return Enums.LICENSE_TYPE.STANDARD;
    }

    /**
     * @param {Object} source
     * @param {string} action
     */
    function _manageEventHandlers(source, action) {
        source[action](EVENT_PREFIX + 'keyerror', _onKeyError);
        source[action](EVENT_PREFIX + 'keymessage', _onKeyMessage);
        source[action](EVENT_PREFIX + 'keyadded', _onKeyAdded);
    }
}

function MediaElement$getDrmType() {
    if (MediaElement$isClearkey()) {
        return DrmType$CLEARKEY;
    }

    if (/widevine/i.test(config.keySystemId)) {
        return DrmType$WIDEVINE;
    } else if (/fps/i.test(config.keySystemId)) {
        return DrmType$FPS;
    } else if (/adobe/i.test(config.keySystemId)) {
        return DrmType$PRIMETIME;
    } else {
        return DrmType$PLAYREADY;
    }
}

function MediaElement$getEventPrefix() {
    return (window['WebKitMediaKeys'] || HTMLVideoElement.prototype['webkitGenerateKeyRequest']) ? 'webkit' : HTMLVideoElement.prototype['msSetMediaKeys'] ? 'ms' : '';
}

function MediaElement$isClearkey() {
    //return (DEV || DEBUG) && /clearkey/i.test(config.keySystemId);
    return (/clearkey/i).test(config.keySystemId);
}

function MediaElement$createMockLicenseChallenge() {
    if (DEV || DEBUG) {
        switch (MediaElement$isClearkey() ? config.clearKeyMockDrmType : MediaElement$getDrmType()) {
            case DrmType$WIDEVINE:
                return {
                    drmType: DrmType$WIDEVINE,
                    data: base64$decode('CAESnQEKTAgAEkgAAAACAAABEo4ev+A3goCWymU4tPb0vLUcK3GRzwN+mL6qJJJJB+Eo+f9JtUoWXNnDPmVHU3600p+36N88LBzZJRehL0kilT4SRQpDCiwAAAAEAAAAADk4AU4ayHCi3hDkW4+JfapWbr93i39rh+iWpe3TXtzHCVmQBRABGhExMzU5Nzc2MzI0LjY5MjgyNxgBIMSUsogFGiCSW2k5baw8CQzhvust2mckAQDDJem20vz+d3FYfzLN+Q=='),
                    psshData: base64$decode('AAAABAAAAAA5OAFOGshwot4Q5FuPiX2qVm6/d4t/a4folqXt017cxwlZkAU=')
                };
                break;
            case DrmType$PLAYREADY:
                return {
                    drmType: DrmType$PLAYREADY,
                    data: '<?xml version="1.0" encoding="utf-8"?><soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"><soap:Body><AcquireLicense xmlns="http://schemas.microsoft.com/DRM/2007/03/protocols"><challenge><Challenge xmlns="http://schemas.microsoft.com/DRM/2007/03/protocols/messages"><LA xmlns="http://schemas.microsoft.com/DRM/2007/03/protocols" Id="SignedData" xml:space="preserve"><Version>1</Version><ContentHeader><WRMHEADER xmlns="http://schemas.microsoft.com/DRM/2007/03/PlayReadyHeader" version="4.0.0.0"><DATA><PROTECTINFO><KEYLEN>16</KEYLEN><ALGID>AESCTR</ALGID></PROTECTINFO><KID>AAAAADk4AU4AAAAAAAAAAA==</KID><CHECKSUM>QKnhD5bxbiA=</CHECKSUM></DATA></WRMHEADER></ContentHeader><ClientInfo><ClientVersion>1.2.0.1404</ClientVersion></ClientInfo><RevocationLists><RevListInfo><ListID>ioydTlK2p0WXkWklprR5Hw==</ListID><Version>10</Version></RevListInfo><RevListInfo><ListID>BOZ1zT1UnEqfCf5tJOi/kA==</ListID><Version>11</Version></RevListInfo><RevListInfo><ListID>Ef/RUojT3U6Ct2jqTCChbA==</ListID><Version>13</Version></RevListInfo></RevocationLists><LicenseNonce>8Cv2MZPiy34TMZ8vACYWrA==</LicenseNonce> <EncryptedData xmlns="http://www.w3.org/2001/04/xmlenc#" Type="http://www.w3.org/2001/04/xmlenc#Element"><EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"></EncryptionMethod><KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#"><EncryptedKey xmlns="http://www.w3.org/2001/04/xmlenc#"><EncryptionMethod Algorithm="http://schemas.microsoft.com/DRM/2007/03/protocols#ecc256"></EncryptionMethod><KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#"><KeyName>WMRMServer</KeyName></KeyInfo><CipherData><CipherValue>DH6TfdISVaxzsSdg9Gqg3RWw49AZySx/H5TL26QvBycZ7RQRBeLZpWaUNyv/l6vArHrT5yg4R0i3AY1VVOEAIq2WzSUfesfUOOBOTEGcoLUzpZLVFcIKRARrEjRK6dSnGPfiAEpew36znOaDJR0AmcgzTMGyVSQf91n9z65p6Nw=</CipherValue></CipherData></EncryptedKey></KeyInfo><CipherData><CipherValue>bM5GKs/o3lSxkQ4//ywGFK5rb9z1vtoujhmtYyetGfbG3dxMPltFwtlCGpZkjhojVKg4AIdBX+WzNllsnaBLzPylk6oOEzViE4MK3YM4UXJ+Choh4byGSMGeGFcKPnN73QbWlcPE1Vh9v6CZC39lVkeSKixuZcPxBS/g5BbDZhJQQjlZv3fCcKsX/xt9zD2yvFFcd75ZhwjO0qD2TACCrhA2UQ4v8eQ3IAyyx+Agmq5Bu/7/68VlCz5T2oTOdAwvMBGgt4de3lGJCCDPtXmKZ6CW45eJgeMNhDEZYylAGSs4FAeTpILNXTbDsAhkee5LPRGq8X7LXIMczt9i3mfymcsrL8FgR73AevOSt0O2RGEn1Q5rjoEbaJ2AAMf7FTYW8sVPMmN2puoMOY+wmuGwWceRJKddNsBbr44sg4vXANXIW3szBaWhpqZHJMLo4C7pFb0VJuiORmTle2XERFCMYPiOvIjIdGs1k6wpc6KDxPhhSpMKHBmJS+VsXS6+NGA2KPDDFU9v/C7herXj55/CuN1N1ckOTl7fAZ4Ftb26bOTop+ARW000wolrOc2JehTklDT99oRGe/Dlm9WXu5CM6Gbpd64cxxbo9Un/mdTLMQ6zauxy0pDca8xOcWlq+Ht76Cdb/hEja4POZrm6/9tYccutDaZHwufzD9rIAztPnnZOqpW6PL/HqE6ibi6FC3NUd6zKtMU0nICaUNUN8UG/DBVa/+jnPoEbcK27m2EgGx2AC4AmI/8HXhEncErCpvuMeA2bXVqAQaxQorcMY3ODDmsNYfp9yNuJVg1r/kjmWkcWWUMz/AFtLjRugPkuug9YCmy1cByDuoxClUz0O9MHvRfPb+Ayd0nR4fDLtyaI8GVOtjLuvy8jZ12IPsHReUI8BBN763Uieqx2CVZU30CXb4h1J1yG7ioLLh4YWVTYpgW8r2fF+nxne0S5W2IOhI6zASWYPYOCyxdAMwTfJWn+bvzhiOASuOCmJxU4aUmm4iQFtVzlUhf5y7VB8BevnfThS7ja6vpsP5OXo6i3He5ZQzHQwY04hKRPc0iJ8r5NIlFS7LeBPFGsQogv1zVrCGUEEfwMG8FlZ3OUY0hWOVQbFHt9kmsmRBuiAz8Z5Wmg/vg+9l6IAt+1rntcsp2b8bfj7+Af0D6qoIB6rKaDVy7FqZ1ViVFIOUVC6kagYLEw0UuuA5/GMdqQgzIL/vtPg5joz/F3HAk9Dhyq7p9k7Dgzx7tv+CJfN2cI3HTomPqQY6VxIayGXeFRmby+YjYma1ffODfYrFrUw09nneRCIn+/yDRT6otUHBvAuQLU75PXYD3PITP+aOFv6ukAEnpBtEJWqFcpD9RMHz2m+w3OzHqisVDGMFxyXfDDBfEf/hWm5yFaUtRoehLirrlR7EIKYt34UtzV80APN++pM19iH+jQwBRZbEqjHFNjsiWSdgKoY+KLFiHEk+kJxBhq01c8O7Wj55hmDkqMEV163ce+DKrEswVUurt0jXib1NETj66gAXl9TVovJ5jd71Oo2YCM/5wnTd2I/itaid8BvJ8geyp5x5O2DrdDRZwcCzK0GNQaY3Doaht2cU0qaVqY1yGs7diKo/MRLMybY+U8VQxi26WtTp2GD3IZXgFAJ0Lh0yOfXVQfxmwTwNSCazC6Jlsbpp9NMn8rmGyPzfuZ+1evABGFnm+jfqKSEP/J20xDe22c6DA0UTsQ6dCWYn/dUt4jZwD5xPEm/tzE1g2FVWiZRs3FyXRFlyi6AAHLmsa5Ve+c5emXrgPEneDZYY5tx1tODL1vnnNhgOmUKX93Kx8Bl+Avu/xy+KAxgI3osz2VAnODl6eJ9wQ16Zda7HT967UDR3LVF0SY1Soi/c4yR4kzfXhobuH/qqArVBM0TxVXmQ1x3VNSTZJLRGVr/HvwTvuuRA+tz9+eSvW9np1TwkGNtAfAG3R6Qkws+WsAJUTLovTo+DvsBC4PgfEVzVsQSIO2Myd4mb/rJT7MTHg7v8UxcuR0mzCjsAA+iivUIM9MWUU5cJgn+SdDGp5YLW05UTUFiOh4YKK8zW/oQLZKFtzsCXDpJ5loE6psia7BUwY0pgindjfyPkh75YpmjbzFHKr1vzNtLoIOdtSaINycZ0HlAjfY7vDFSSgqFjmPFtNh6RPEano7CsVwRWis9B6y1wyCBUEzzWT9rX5P34FF+orBshL2E6rfL9XrUIS3nTPslLa/1mgSni0JZpsRl4laY1sWPPXSPOMZNakyZ9rRC0bGBizL94dNaPin1KCbfZH9Cbu95NsoUcdDXX3wIIbTo9sXjLCSijpYOCvI2bEsU7m566syT41FGssjJnQlsmdOwo6OwfbE01+h3PSGbAxu3nDWNxACb6JVtO3krTbhgzCZTO8R3TY5B6cYsE2ij4Gej56QaB2OzpZ0H6on4zDuz9aFPrAOyvNC06/SxCS35azzvC7R63U2RHPJHzS7G9oZ4NnTgJleQDGfisT7hdvfdcIkjspoA4r2CiacfEM7OqCtGbyZ6+QT8449xoNLzD2igAHb8XYGQ4y/fWh2sTr67lNto99gAWU9LqaTEBc2lo2ZVzNGcnT1FmQC39nbjF5lTbIr/PdPS21bqAOY3Z4uXQROzNwmSGie4t69B7oJHeeUQ+FufQnnu9cWZDxMDpkfqCbo+m2Jx9PdqBIjQmdNwc9mBwY4L8F2jmImrd727hVVdVj4x6iT0HvsZMArBvpBHJ2pxYB+64kbAIWV/G6Scd/5srqZWdGPdoU20a634uqA4jLFhGaxxGTjyTzTqkX5UQ3Rl18ZQhQIkGC5WnHkkDMqQ87/O534GH3jPZSQ0kgu9taWWPeXlNj6EqD5J0EqsfS/7wX/YIkGiqugppIWnUBdWgHuBGn++QQN/wl0z92SmayQxCP7ReftQfj0b/HQ3Gx3vplEf++dQleJFym9NfHt6Tc2ULTBykpUyrPbQCRiEdQG7AboSQkO4Q/wruSysK/DuClR38QLhuwkNInxdLtOkCfLUaqHQNzCWBWDwC7EzK5TyXwOBjgyCEiHSiv3FyIsMFyGB9aq3juojgeoL7uzgJGbRZpjA9RiXHHA7WrEMNXSxeChCdegpFC4kiUN4y1N3dL97lo/lncyWf9mBA3D/AOgbJn5WfzI0du/p2OaVuiYgIMuhQIKM5MTlG2zUYpP7cS+Y/1Xb5n16KRVZDZcKCd84fStGbZqOBi3iCsFR9t4P6Ri2ET5qDbpid7OtlxJIPggqR+6E8Bbmg5Boh+/liuEoVZeG55b8a7n+BLFzQEiITTt5055Y50BNvOA0B8CDJJdX1Tb3Gt8TTrCodhjagyQxhW9TMdQGHfmhokT9F71lCz5aRqudsEpwYX+XeTmh91gbtIfRR+OV5ybxIj+ZNdrO1aQOkiz/mo/N0VFTR6nc7Jgjl1bAW4yVzLFqCp6fZi39dcjUf1ftLHShATylXOsc9e9a6nLsJe4rNZU6zVheeEhvBuTpNsA5yZfkQbpu+Xi8uSy+ge0pSXkV7nrQy2hduQMH7FWA/7a1TQiesFoG4GQJsTfu0FukJR8H1Sr+I1hqj1cj3QofJ3iIzarnnyl0CFA+TV0y5di7eZRyGyyiA/zlE6ZOBLw4emMuERgseyaCSlVDBTh4J5XhI6aP2BoyvKo1VQWl6RVkJF80L7GdEy6X5Kx3HQKIDAET85e0HYAsecd6Q07nNV0zne96XYX5qNB2LehqSwpL9PjoQrrtW/wx4VXcHndIzQs/bDhwnXSbTUgotfdJCXSC/WlOOwKZcqZobqG6TlCwW0hoK9zGo0evADB+8SRyd2l+oyDekyWB4qW05Gw7Gd3vjCmzcrIWVxZN2TBvn5g+DRU9/Iig/07BGFvLweOluElVV4JXSN+311wWQNJuVEoshUeG0GJYVei4nLhk6zV+v9rdAbXP3WJkEw9OB2bQguLanaHcdlJLuOpYoxW53fnq+Dtf1b5fzW/dtqrK2TjLulBqcuV1xp2zZGoG7UQupTGJmcFh/xIgZhbsDTe0j52/5GexCi3sl1GLJz8HHYS0s+iBm4E4Vl+nLWymqVnRxhqO6ofb0bUblYM36jF7uCwsGdBYjcHT1iJuiblTBzpxqOy0qZpt3JKseingUhoE6FbxF9cNVdC8/y7/UZ7UonhmEffoCb2I2fueK5CKVJ+D1TgpCrIqrAS0v/LGYaxgAaZJrOX4mKRfuB3RnPukK82sJHftKOS</CipherValue></CipherData></EncryptedData></LA><Signature xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo xmlns="http://www.w3.org/2000/09/xmldsig#"><CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"></CanonicalizationMethod><SignatureMethod Algorithm="http://schemas.microsoft.com/DRM/2007/03/protocols#ecdsa-sha256"></SignatureMethod><Reference URI="#SignedData"><DigestMethod Algorithm="http://schemas.microsoft.com/DRM/2007/03/protocols#sha256"></DigestMethod><DigestValue>owfbkNGSLOMEB1Jf8wN32jYG0jk0uTtXHO8qOdFC4ck=</DigestValue></Reference></SignedInfo><SignatureValue>yK+I0Vu/ODitoEsXOrUxfWKLPUfUUsDedfh6lTKHFrk33KSF1cJL/S23c52kXUeKR0OfiIpL6ZMyLv+0KRdF5w==</SignatureValue><KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#"><KeyValue><ECCKeyValue><PublicKey>02wKwwXlNa0Pk0gnsKcRzxRJLVX+VUlSYSaVfFdR8H1D4Ir1coKDqhn6N1Z81Zr3ELvAIZ5pUhxObRpT2Jr6Lg==</PublicKey></ECCKeyValue></KeyValue></KeyInfo></Signature></Challenge></challenge></AcquireLicense></soap:Body></soap:Envelope>',
                    psshData: base64$decode('AAAABAAAAAA5OAFOGshwot4Q5FuPiX2qVm6/d4t/a4folqXt017cxwlZkAU=')
                };
                break;
            case DrmType$FPS:
                return {
                    drmType: DrmType$FPS,
                    data: base64$decode('AAAAAQAAAACLFUwD+FLJ9g93poh1VloOW/JhDubu1UEJ6SyTBGGYryB6JJge0z9h0sxZaDL1NjCCtoNHtf8ghqEV9YAOnjGXVT8TTICqnj8Cn2ziqSBFYxmKObgpSn6tmZpah81814SVUrHI8eoWf4TdYpoWqzFgPhgZYk6f6MhlpkUapkkHitthgg3puW3aQk8h+5aqrjAoDRR1S0xQ5CJzTe/Se+9kPXcpLwAAFdCi5DTMgboviRywF0aof+E86J09p+ZvjNZFFMF+rTvEO2QTL0z9JyTjPEHzZwJiOZIhupeX/nknxIShe3dcE8V4d1vw6BkLVIKw9MukzCG7rYLcUCd9Uf1tEHH3QpyioDXZRQ0PyGNAMDlSbot/lGXMW0OL9g/kc6fxumta/lmAqfHOY+dK1ng5dw2hwKLb9lw2wT0biQ2eCeIEMQI0Q5xgWtW0Hx6+XvfQjO5ZneATFdDRtHG9+Nk0XQ5qXtaeFkHqbqBzH0kEH3pIp7h+Y5eOkgLwDCj/Xqq32TQqAfoXGd01XIyF0hndnGLZVIT06wxZaadTcP18G++15ZVlqa+5Sv2bl6mdJT1p18DmxA/usTJ78q+pcnLGGNkMgkryEeYcT3BeamuwED9yNIs+HCwHzRGRK5WWxp81XeUI4S/wOXafAYVRGMiwsENO4Xz5kuZDpJJve1oiYoOjfdwpcmLYSvTgpm9l84FKzJVMC6Zjz4QEd3yhQ/EfcSuSMLs6pnkZ0f5p+8pcqKYbhIP8pvfeAKQrEIJZIn42gwdv5AzShdmMVMVK7eD5fG6iUEBfCVRujzwHob5Fh9x1dWUZU3bLNRG6w5IGIJ5PRFulPFXB19aoRjybF+pP8IpEll0EJR6U9wiUWxpWMsrv2+9QsGZFcJp4JWjt1vIVqzgIfIsgDkp7gRu2NK7VVxWP+usaxP8V6FlkXExTe77kD1sSQFqHPpGjL9caU5rNdxLKx01A8H1QC35x8R76IxzEfgGhKut1K77k+/N6RC9YBf3e3MC5jpCXzcyQhWuoa6sB+4R0YJE51h225vy2bpfLuCX72JcI4TjXMtQwXzxFJDG9d8NdT07sv6j5Zz0exXIEamFyPUadLK42SZJ4VmggSYGl3M8IJXpTFW9A4gZfSYFJsW6LQk+l3PaNPFNZrWUQx/9LnFLNN2bhKoCkTHxGyOiI2nZNiQ7A/GPHDqGWZZHVvJl7VUFfjoaZJDtpq8OITru0s1cTo5XHxF5bmkkgMGqhvXXoOuyTOv1hfdlOzF5gk9vJehd5K9Mawgdq05k2d6xfUyhN3R+A+YwCtTT12vLyNZwJqjV0MQ1JA97x+79rUHb0mmQzm0xgQ+svPPSKzK852uq3i6dW7evhbvCbevSXZYgOKYzOHj+jWTV1ijAtNNS/Gglgy7aCBUmmzhvR7KAUFUrKIiO2XBOqgXZFzTCWYbu34Xnz6B7R/6Baf8vV7FDDPb+mVJ/FXpw/4nxbq8EmpecnOvSCRSYV2vFT2A76x8tYSfWIB1VGbfIcWX9bjX5bwGZ+oFwcYTxKRuJi8mQVZP5cRtIayisCJ3axD2oUqKHyNq6CNZqay9dpI4xPkFyk/FTlEpvzN8Wz2331FIHMZFt1I+s1NDcUg0iQ5B3vVXeaDD4a3rIT8XsTEyMBlds9IENoEIGWy8qjW4/YSp+Z6D+s2a4dKjPCikZVp/++IIdO6oF10lLTABcSY+XK89fFYpM1zW6V2Idm8YSUrlOmIqyCY4W2q6UULpN3Ccxq5SBxrNYDkXVAeWVEcw8Mego4NKeENIHleBXipyKL0FXAUCfZ0HMVaJmklDvPL2BYSAsAWw695bqLUTE4LLrYMLgk2ch+ZKt60NAvLBXgaLnuD0q9j7lIxg6WdGONmsCBa16hIzSjAMpQGhZvDtEeiPNPk249cNpCZiijPJue8bND1LdE0Tn0Hm7infuUYiBG9nzvZ1sLApqjJBYjhhK1e8j6kyTf+i6FAM4jukUIaez9AytSvLotY0BlTKtSxF194pNnBoi4dTz+IY/hUbXAOat+l5p7tOwNVhU8I6qg1JSKiSoNbdrGzaXSJarKNS31gJG+yNuzVq9KzPeme/92Np++TSvL3hs5GSpGToHXqBTQ/Qh3JMMDRl++/oXY0N6s+KBhGRM3+WDrMZlg0Q2DQ2PcerJPI7lwr5kdtXp7Id7ayNCvlZaDTaRDWx98U3gXnmxh/DTmSs/5wlq5TlBKrN0FOsltzb0C/gB86jcCqkTF/GosIBJIoSlzwJPj2Z73SNifitvnQI4+QxBcg3IQQwN9JDlpMfqyzSPcjg8Yxd6ST38YtObJMSfT87Km1h/j4Pm1TxddCDDWfpYB96/5eZAVg95etSesEKkXswUf6ARDiaMh401x04W1pa8+Lrx5pfg8aAOoBCGVNPD7jVL+TQNKjHUtxvKRmFL9zdUQwrgwGu5z8aiPH1aLNVDppVkPxrLWfCZezahoP1i6d/z+oh/1j7goOP7sxaQJCQM1V+/NLIKfukvI2AL8uoN8tH/NSqfQtWB/F5vTFf/BQmkz0KO7TSfPMYrLNyXdUTDsb5vOstLxwTwMwBz72uOp7WaBkTeIwMtrfhpqzBaX2zpiDhLPFEkpH430taV/5PLvbxhWp5Z3mfhGAad3d6tvo/T9UxwLIXvUwin/nFeFq1ECwarO7zq7HyURB+IndMV04cpvkdJysvHphi/Y6CE2jgls1vMAWt4K+2GBMLFSIo2JtBBhQE8vUfnnnC3OFTf46xKWC5K5pIZAAFsF1agNthyvE3YLUIBlJsNhm/4w6P4P+1vQSLjzmyk97NWjhixxD7jvs1NcqFrC+SMWbd2hEIkGcDAwqNh67n+PZ/5n+Nz2hLOKR9uMUkD3itDXXcZ2VJaMkdWDTLKd3Y08OlxBOcUOCcza1Kt2qHrO2reAe+WHCEAh+QpmeaXNkF0Lsitg/+WfT0BH3RkcOgdkuThELm/ITM85JGxv6F5fn5VpE65pY6v1JHizgjXX4pmC0OLWjoMf5pGbiSKrChQDruGU2sdOPGgsXTUZQJ4ZqWt8kpL+ATZLM8/NSS1Zvq/uPuvcrajk7zuHE7Y+P1BS7+74sd2CXyCZIHqvv+1HRubviB/CJtlsdDyTQPPE6DPywWYSYvg3CurI0Sf1xD++bGy7y7OiFj+VdxZSoRaitrUkzkA9PJOE5Qheu/uIzaae86eXGIU6bNTRjemJrohm+UAaNm65FnG+TNjxxrqOkUCpofuDzLebpYbtQKG/4+UJI8wqSASqLsBE4kpkRykPqc0u6tVsF7ytjHyFk3prf6q8iIk+DQLX8fKwh7Qu7bYMfOIQwveXMTYLq1cvk+xzMef/31iVJ5YE9j7MfMyiTEVzATzweLCX92vCY/6vDTuPHk3LZK1YVAKYjfYqvo/w2PZmOgx8lNHgjo26klXeV5WMWbXHAWeNmW0zPpzZ/5HHICusI1V75iIGGFDg5phb0rgs4ic4TYABZfkZdnWqMNzg/sEPxXDJByJcd5rUflKO9gYNohU0CSTCfr3OHeNIvN9Suoxyv/IMG8Zsc5Fj4BL2xUfDaenWZODeK+m5B76JKjhcvVYQA8y4onPPv2uw5SWxbN/eIo+RWq//bCXjCI5KqWgXJJwfkayBSfBZNd5IgwwoAGTBIbhGBwnF/+M3/Letx3RVyo4jzHX15QxR4d/mob6c+yvaJ7YokBZNWw41g8hNzRZRBXq/xFh5jmceVdjLi+US74+CBLt5RUL+ycYAVERsWZg6MCT72Q8S9ECkGN7dBUogrCZe5mm70HzhKZnSa8tcY0pBoh1koiIKFjAoDeX0ECpW509vq9ybcWeK6rpqAk+L/e6NoNqJRblZwdsWvrE5d5ZTcw3YkiGJ4LeTH6oXawCLf0GIcB0PLay1Pk8L5RDn9PQcW8rBpfQCM/dkOrZNMVXK/+dTDPjIm2B2DXyU8qDOrAowXhJdzliOdK+BAgA8eR5EKH09hxGGLkdgu1xrA7A8pGt85qXWxbLVjhGDaiUR/7cX4IwlDsJkWQhOAIT9kfUG4t3h9JxOOjy9QYObWDwjddKpEbNVDj+e4X6gMccC5yqez3vwa0HL6x56C4KK8h3XVjVOc+i+PqwLI1f9xekUQIACuefZpNe6LK/ZW7nH2CvhYR0fmZM1217tBRH1Ak+ke8oUaPF5ItmkV1ftnwWCGRQO/1hVDx6oAkEKW4EzNHMiBX/54glhl6ry+odbYa9t/kyjyuBwhmzvQQNJtOkYNN/jLwwrouktjevVNvApA1fk/CXyF3prwCwbTnz7NMSDpSJERNfVh8sMjJp4yLH9N4+5IItrMlBO+VuI5ymmGWlcssOxGzkJfG6WjAUJT3XMActWJZC5V0GbJOroSAPP3SQNeb5XivNWXTU6T0B4CLVCfKcDtPNWRo6WmRKxtceZhYtFTTkg53WE5cSZbhQvdMmYJESmUD80eoxbtGp7rAxtfUsCZt6NwwmBuZCYYnE9BB8RT6zOBWj4pKOLFiuLPhVhlIqjpT7034SlvZfru58g7KE9dNHxKVzWBmmuGhNSOojnQQdwdRlqD8QbbMu+/jTEPZOJ4ZJGdrEp92wOTQZD26ugaGAm4njABgbg5fWXV6uQ7Ys5V8bg5ie1CLGFWO0Sm3qZaNggyPNB6dWIDP7KAzj+shjW9a+lfo5Lqy6s1D6NmEg0Sw66Tplzq/tJMAbByxWiEmY336TwiaqOUrHB/jPkFXwQyNjIkMisHMTQ1EiG4BM0rXeFZ1Uo9u5hhSjsWcWNvq0z3nrQiFArF34xQQbONThQk0Mwj9dAOrt9Hf3z7afdESy+EQ3yyqcyOg7fcpZyOW4lm80bjoZMPDLJLEBpN3aP0K3Es8rq9nwAQ6QAaQcdoUW46A1oazQkJX8j3ow+1QlpIBisYNBxVOUXmt4nLY4sh/57VvCxmyb+n31fBsDTpqyevk65ZaHHx+zqiYHofEvmVXb10mnFr4YEEelOV8hFKnDZZXgS4h/40NmotObcMkr5BDLb4ul01kDEvetT3KMY6gymgBkqB2xVSd5XMpseb/PEwPmUdEbGrQAKhBVxL++qc1NoqFpmN4S6XTKmilmMlFxPDfUTvj/sD2QfiKmBtiJDwQ8o3xL77ZMR24bOr1EtT64FsUYhEScGlTH/ntDlPBbPV8HVuO4FhzbQg47eiCD4P9xYjQd1xMOT8NZoUQL0SAefoQuCdVv9jfPxUzLKmTCgxbS7InXYWkMcCnE5+ttSprTkZ9ePM1go64MzZ72SrVl2VuI3710FEZhRucIFSc4zlW+F4tVmYOND2lMy3ZBvK2XJ2XS6YjWEluyZNgSbvG6D3+upAsiv+Lvb11Jx2HB8/nzkFOZG4sKwyqfnyTWufOdOw8C3aAErtxUFqix0TBJ0YXIWcIWOXuyxxbzyDbN0zLzwmR/WX8/WY9vql9KimWp4ky+zqjlkjSdI/i3RSUi4oRr7eMbVke+lxVByahI3bpEAXXNWfkdYGU0AEIuYaxVJ9hjxd8Aq89PtfUfMx1B5/OpdE4Y5fexqQkPS04YKiJlEDbXTHaLCeOxG7fkaMnylkuYaqTAgtneXJt5Hni3BmDkYBefxwsvqMLsOjUH0o2qrp3ZmSwgfpSdKwlri0ud/OvJQ6+zMS1lXJaT+NaiDpj2A/txktYrNQmrEVRwWMdnJzOvB3miQ26R5EH5NgPShSjZU7H7kLicdn/9p+xf5o8tigZQ6D8gBzOUtHbFi2+p6YpM7uc/oIC11E13zp7eRc0UqVTqWiKgVdU7ZyLGyy2pw1GBU8Nx/n/myruy+rcP0jclQ4hs1eW6P1oDr8GP0FJON/Iv04O6Gbkqt8KIDbAwn17cPsecFUii+Iz/3lFcrZ2PZYx1Lom4dreksYdCer/YNZaqqI/IWLl4sZ2Rn/TYKVKmtyMsvAectvXY0kOXIUf54Qss0QMGm9vUtdHeKsk1IAcGE5NeZZwJQB/VRLovcRDfUWTLQAI2+EH8oQal4W2fN4qx9yMn4HvRnQ9lcqvqzPNSSy2QTwNuJ1a9uxjkJrC3kwr5mFXH6YIMjifv93AqL3y962S4uyDU+UscBJa1k7kfq1e/2R8Odi1jN3C0M8oDCx2bf56NOYq0p9beHI+Jz4vyMBPA1etHKECr4GB8irweAvy1aVOUhWkRSqJm/uAV/NXtRNsLHKH+9fw/IEH9MF2ucIrkJ/3Zww9AEflvtlQV/PS2/YquYuHS7SgHZzp7umkZrMYxGsYRvNLD/op4WWwdknxCRjdlMyMD9avZEIGjvtMIxg2DcZK3CHslJ1pTB05CwtIX3QkpwupmU53uya+PEmUIySeEpMU9pVwA67mzc32D7c8qJ8PUE4g8TglNGuAnIzl31kqDEk2veVrO36FB/6MKO7h1eTHQxxb0tmXdYWv898BlAvoiekiKRvZs1ZLNaU5JXQyiUkVE2bC6fGdhAc5tBahKk4X+1iw52m27PQeOJ5UMnwB3QeQ4nSD8Jwixf/WZR9Y0ai0x+onWQfnoNEyD1V1nvvTHoPRh0Qlp6/gO0fddzIjfWL8tY4X7oEbb+Tefm87oeC35k3Z1eQEq7hH6PrtLPngUAILVu4q9nal65duzupJs4pvFWK/BhIU7KftWWF8aJrDVCmhf7Wqc6XLQbGfZNB1isvI+DTA/31r/v1fRxrVjrq0r5DDBHiBoG3DEeWk78VsiM6hkDFlUSSik4eBoUXdOT84XsH7Zp8eRntFOv4LCRRRMGz3jn/0ruhgc59f5KnI76JDsHcctcG2u+J0m6+AbpIgbueqkNxqaFG0Scxni/EkhCKQi/dGs9pLHo6rosu2uVRZ7KhWombLDHf+AbrGfxgyOG+2JvTj3eQdpVtNCIkkqwqLmNBwIy6RIbLpVht639jYKYRh6klxRParmj9BhAR7FdE8Qu0n1MHag9HhtFnURQHawhWGJeoTsFXWJD/np9MJr4UeRHNJ9HtGEjWSTSETsYNsQKJUWohw/Yh+eNo4MoiAerINhU9RFSxSNx3mEZNFtR2D9Y6R9akJpnz4Jht1H/8TUXmEGc22lCT2/RgrUyAdkryUHG/fYo54g0MJYX+xsj8raL5HG9M98UUzRatMh2ZGMLxewsnWOD28Fgg83m7pI3Z2VEDuSPaSQbDk/MPQXG/D8qF6lQd6uE5J0n+jNdP8VwYrbg8vOBGiF5nmBTsfUu6RZpiy1y9lgy2HLqHriYJBv0vswFdHwuqzMbB14Pzv5HKWQFh/Tg6bHlyEosuPmJtm/VKD/mQOxaceWU45JE/4GX4NCgUsqAJhAqDtec58VT2U4mr0l7CgK67ApJXmS15CSqGl6Gcz7NGrhWt7DrzJQfOlYgyIxA6UIVJ5oNGrYLpNOxigb7fsNCE3uifKfln3mahi4LPukwhFxhuUYe5bQFCOAHxEpzXFbIr8MYV8PYkkWSh3NPsY+eOPAprZD9UN/qG1maSrxUr/4xrkvwTW2JGaT3wWw+OYjGssaXtDmAlXrf8pY7pZzmVrB2NFOBccIPPkLiefM68/ZYYTtpVcwDKI7P17AVF07qDmCKGTkCLj3tDkv2ysV5de5KR9hGXzLOeOOVUcD7ObhuAeezTW9fNw0uPFmuWrMF0y2DtSeDYhsUhu6deAqHZjstQrIBIbPemiBdsc13WdK/'),
                    psshData: base64$decode('AAAABAAAAAA5P4r+OJqb3vlcR/0FjOLLgfD7ysnxrlLgbJASGzZ2EoW6EFo=')
                };
        }
    }
}

function MediaElement$createVideoElement(videoSize) {
    var renderSize = MediaElement$getRenderSize(),
        newWidth = renderSize['height'] * (videoSize['width'] / videoSize['height']),
        newLeft = (renderSize['width'] - newWidth) / 2;

    return config.setVideoElementSize ?
        createElement('VIDEO', 'position:absolute;width:' + newWidth + 'px;height:' + renderSize['height'] + 'px;left:' + newLeft + 'px;top:0px') :
        createElement('VIDEO', 'position:absolute;width:100%;height:100%');
}

function MediaElement$getRenderSize() {
    var devicePixelRatio = window['devicePixelRatio'] || 1,
        physicalWidth = DEVICE_RENDER_WIDTH || window['screen']['width'] * devicePixelRatio,
        physicalHeight = DEVICE_RENDER_HEIGHT || window['screen']['height'] * devicePixelRatio;

    return {
        'width': physicalWidth,
        'height': physicalHeight
    };
}

function MediaElement$contextMenuHandler(e) {
    e['preventDefault']();
    return false;
}

var MediaElement$mediaSourceExtensionsSupported = (
    MediaSource &&
    HTMLVideoElement &&
    URL &&
    HTMLVideoElement.prototype['play']
);

var MediaElement$encryptedMediaExtensionsSupported = (
    MediaElement$mediaSourceExtensionsSupported &&
    (HTMLVideoElement.prototype['webkitGenerateKeyRequest'] || MediaKeys)
);

var MediaElement$superhdSupported = (
    !SUPERHD_SUPPORT_IS_BASED_ON_RESOLUTION ||
    (MediaElement$getRenderSize()['height'] >= 1080)
);

var MediaElement$ddplusSupported = (
    MediaSource &&
    MediaSource['isTypeSupported'] &&
    MediaSource['isTypeSupported'](MEDIA_TYPE_AUDIO_DDPLUS)
);

var licenseStates$NOTVALID = 0,
    licenseStates$INIT = 1,
    licenseStates$FETCHING_LIMITED = 2,
    licenseStates$FETCHED_LIMITED = 3,
    licenseStates$FETCHING_FULL = 4,
    licenseStates$FETCHED_FULL = 5;

var MediaElement$sourceopen = 1,
    MediaElement$currentTimeChanged = 2,
    MediaElement$seeked = 3,
    MediaElement$needlicense = 4,
    MediaElement$licenseadded = 5,
    MediaElement$sourceBuffersAdded = 6;

/**
 * @param {...string} tags
 */
function MediaElement$extractFromPlayreadyMessage(data, tags) {
    // playready data is UTF-16 or UTF-7 encoded XML
    // do a rought decoding and find the value using regex
    var xml = '',
        i,
        l = data.length,
        c;

    for (i = 0; i < l; i++) {
        c = data[i];
        if (c > 0) {
            xml += String$fromCharCode(c);
        }
    }

    // extract value from xml via RegExp
    // basicaly look for a something like this: '<[ns:]tag1 [args]>.....<[ns:]tag2 [args]>****VALUE****</[ns:]tag2>.....<[ns:]tag1>'
    var reString = '\\s*(.*)\\s*';
    var tag;
    for (i = arguments.length - 1; i > 0; i--) {
        tag = arguments[i];
        // early exit if there is no matching string
        if (xml.search(tag) < 0) {
            return;
        }
        tag = '(?:[^:].*:|)' + tag; // non-capturing prefix for with or without namespace
        reString = '[\\s\\S]*<' + tag + '[^>]*>' + reString + '<\/' + tag + '>[\\s\\S]*';
    }
    var re = new RegExp(reString);
    var matches = xml.match(re);
    if (matches) {
        return matches[1];
    }
}

function MediaElement$getFairplayCert(playback) {
    return new Promise(function (resolve, reject) {
        var certificatePem = playback.cert,
            certificateDerBase64,
            certificateDer;

        try {
            if (!certificatePem) {
                throw new Error('Missing Certificate');
            }

            certificateDerBase64 = certificatePem.match(/-----BEGIN CERTIFICATE-----([\s\S]*)-----END CERTIFICATE-----/)[1];
            if (!isValidString(certificateDerBase64)) {
                throw new Error('Bad PEM');
            }

            certificateDer = base64$decode(certificateDerBase64);
            resolve({
                success: true,
                certificate: certificateDer
            });
        }
        catch (e) {
            reject({
                success: false,
                errorSubCode: ErrorSubCodes.EXCEPTION,
                errorDetails: exceptionToString(e)
            });
        }
    });
}

if (DEBUG || DEV) {
    var MediaElement$_mockClearkeyLicense = function (playback) {
        var drmKeyId = (new DataStream(Box$getKeyId(playback.primaryVideoStream.header.moovBox))).readULong();
        var clearKey;

        if (!clearKey) {
            try {
                clearKey = base64$decode(window['netflixMockClearDrmKeys']['' + drmKeyId]);
            }
            catch (e) {
            }
        }

        if (!clearKey) {
            try {
                clearKey = base64$decode(config.clearKeys['' + drmKeyId]);
            }
            catch (e) {
            }
        }

        if (clearKey) {
            return clearKey;
        } else {
            var s = window.prompt('Mock license!!! Please enter clear key as HEX string for MovieId: ' + playback.movieId + ', DrmKeyId: ' + drmKeyId);
            try {
                if (!s) throw new Error('missing key');
                s = s.replace(/(0x)|([^0-9a-fA-F])/g, '');
                var array = base16$decode(s);
                if (array.length != 16) throw new Error('bad key');
                return array;
            }
            catch (e) {
                throw new Error('unable to parse clear key');
            }
        }
    };
}

function MediaElement$getErrorResult(e, subCodeParser) {
    var target = e['target'];
    var targetError = target && target['error'];
    var errorCode = e['errorCode'];

    // Old spec in chrome: e.errorCode.code, e.systemCode
    // IE11 has e.target.error.msExtendedCode

    var code = targetError && targetError['code'];
    if (!isDefined(code)) {
        code = errorCode && errorCode['code'];
    }

    var systemCode = targetError && targetError['msExtendedCode'];
    if (!isDefined(systemCode)) {
        systemCode = targetError && targetError['systemCode'];
    }
    if (!isDefined(systemCode)) {
        systemCode = e['systemCode'];
    }

    var logInfo = mixIn({}, {
        'code': code,
        'systemCode': systemCode
    }, {onlyIfDefined: true});

    var errorResult = {
        errorSubCode: subCodeParser(code),
        errorDetails: makeCsv(logInfo)
    };

    // make sure it's a number
    systemCode = parseInt10(systemCode);
    if (isNumber(systemCode)) {
        // msExtendedCode or systemCode makes most sence as 4 byte hex (0x8004FF32 etc), log it as such
        errorResult.errorExternalCode = base16$fromInt(systemCode, 4);
    }

    return {
        errorResult: errorResult,
        logInfo: logInfo
    };
}

function MediaElement$getUnprefixedEmeErrorResult(ex) {
    var result = {};
    if (isDefined(ex['code'])) {
        result.errorSubCode = ErrorSubCodes$toMediaKeyErrorSubCode(ex['code']);
    } else {
        result.errorSubCode = ErrorSubCodes.EXCEPTION;
    }
    try {
        var systemCode = ex['message'].match(/\((\d*)\)/)[1];
        result.errorExternalCode = base16$fromInt(systemCode, 4);
    } catch (e) {
    }

    result.errorDetails = exceptionToString(ex);
    return result;
}



// -- cadmium-ase/MediaElementSourceBufferASE.js
/**
 * Used by MediaElementASE to encapsulate SourceBuffer functionality compatible with JS-ASE
 *
 * @param {Object} playback
 * @param {number} streamType
 * @param {Function} codecSelector
 * @param {Object} mediaSource W3C MediaSource
 * @param {{sourceId: number, bufferId: number}} aseId MediaSourceASE.sourceID, SourceBufferASE.bufferID
 * @param {Object} log
 * @constructor
 */
function MediaElementSourceBuffer(playback, streamType, codecSelector, mediaSource, aseId, log) {
    var _eventSource = new EventSource(),
        _type = streamType,
        _typeId = codecSelector(_type),
        _logFields = { 'Type': _type },
        _sourceBuffer,
        _isBusy = false,
        _busyChangedHandler,
        _calledEndOfStream = false,
        _self = this,
        _updateFirstAppend,
        _currentSegment = {
            'data': [],
            'state': '',
            'operation': ''
        };
    mixIn(this, /** @lends {MediaElementSourceBuffer.prototype} */ ({
        addEventListener: _eventSource.addListener,
        removeEventListener: _eventSource.removeListener
    }));
    if(config.limitedDurationLicense && config.licenseRenewalRequestDelay){
         _updateFirstAppend = true;
         // fps license is renewed after the first video chunk is appended.
        _self.firstChunkAppend = new ObservableProperty();
    }

    log.trace('Adding source buffer' , _logFields , { 'TypeId': _typeId });
    _sourceBuffer = mediaSource['addSourceBuffer'](_typeId);
    MediaElementSourceBuffer$detectFeatures(_sourceBuffer);

    if (MediaElementSourceBuffer$supportsEvents) {
        _sourceBuffer['addEventListener']('updatestart', function () {
            DEBUG && log.debug('SourceBuffer event: updatestart', _logFields);
            _currentSegment['state'] = 'updatestart';
        });
        _sourceBuffer['addEventListener']('update', function () {
            DEBUG && log.debug('SourceBuffer event: update', _logFields);
            _currentSegment['state'] = 'update';
        });
        _sourceBuffer['addEventListener']('updateend', function () {
            DEBUG && log.debug('SourceBuffer event: updateend', _logFields, _getBufferedRangesForLog());
            _isBusy = false;
            _busyChangedHandler && _busyChangedHandler();
            _currentSegment['state'] = 'updateend';
            if(_updateFirstAppend && _sourceBuffer['buffered'].length){
                _updateFirstAppend = false;
                _self.firstChunkAppend.set(true);
                DEBUG && log.debug('first media chunk appended ', _logFields);
            }
        });
        _sourceBuffer['addEventListener']('error', function () {
            DEBUG && log.debug('SourceBuffer event: error', _logFields);
            playback.closeWithError(new PlayerError(ErrorCodes.PLAY_MSE_SOURCEBUFFER_ERROR, MediaPresenter$geErrorSubCodeByMediaType(_type)));
        });
        _sourceBuffer['addEventListener']('abort', function () {
            DEBUG && log.debug('SourceBuffer event: abort', _logFields);
        });
    }

    playback.addEventListener(Playback$closed, function () {
        // Set the references to native code to null so that they will dereference and there is no memory leak.
        _sourceBuffer = null;
    });

    mixIn(_self,
        /** @lends {MediaElementSourceBuffer.prototype} */
        ({
            mediaType: _type, //used by JSASE
            type: _type, // used by cadmium
            appendMediaRequest: _appendMediaRequest, // called by ASE
            appendBuffer: _appendBuffer, // called from ASE; appends headers, not media data
            appendBufferFromMediaPresenter: _appendBufferFromMediaPresenter, // called from MediaPresenter
            remove: _remove,
            getBusy: function () { return _isBusy; },
            updating: function () { return _isBusy; },
            setBusyChangedHandler: function (busyChangedHandler) { _busyChangedHandler = busyChangedHandler },
            getBufferedRangesForLog: _getBufferedRangesForLog,
            getCurrentSegment: function (){ return _currentSegment;},
            buffered: function () { return _sourceBuffer['buffered']; },
            setTimestampOffset: _setTimestampOffset,
            endOfStream: _endOfStream,
            /* exposed by NRDPSourceBuffer, not used by Cadmium */
            bufferId: aseId.bufferId,
            sourceId: aseId.sourceId,
            toString: function() { return "SourBuffer (type: " + _type + ")"; }
        })
    );

    function _setTimestampOffset(offset, timescale) {
        try {
            _sourceBuffer['timestampOffset'] = offset * 1000 / timescale; // set offset in ms
        } catch (e) {
            log.warn('SourceBuffer timeOffset not supported', e);
        }
    }
    // --------------------------------------------------------------------------------
    // -- private implementation
    function _appendBuffer( data ){
        // Cadmium currently doesn't need to append header,
        // since it's all handled in CadmiumMediaStream.
        // Eventually, we will want to remove CadmiumMediaStream, then we should move the functionality here.
        return true;
    }
    /**
     *
     * ASE will call this when the first byte of the response is received.
     * Since we can only truly append when the whole request is complete,
     * we need to listen to the oncomplete event and only then do the append.
     *
     * There are cases when the download is already complete at the time this function is called
     * in which case we call the completion callback function synchronously.
     *
     * @param {Object} mediaRequest
     *
     */
    function _appendMediaRequest(mediaRequest) {
        var message = String$format("MediaRequest {0} readystate: {1}",mediaRequest.getRequestId(), mediaRequest.readyState);
        DEBUG && log.debug(message);

        /**
         *
         * @param {Object} event
         *
         * A mediaRequest has completed. Call notifyChunksDownloaded to update the MediaBuffer,
         * which in turn will trigger a decoder feeding.
         */
        function completeRequest(event) {

            var cadResponse = event['cadmiumResponse'],
                cadRequest = cadResponse.request;
            playback.mediaBuffer.notifyChunksDownloaded(
                cadRequest.chunks,
                cadRequest.infos,
                cadRequest.stream,
                cadResponse.content,
                cadRequest.cdn,
                cadResponse.measurements,
                cadRequest.mediaRequestASE
            );
            DEBUG && log.trace("COMPLETE REQUEST called for chunk index: " +  cadRequest.chunks[0].index + ", mediaRequest:" + cadRequest.mediaRequestASE.toString());
        }

        // Request is already complete call completeRequest synchronously.
        if (mediaRequest.readyState === MediaRequest.READYSTATES.DONE) {
            completeRequest(mediaRequest.completionEvent);
        } else if (!mediaRequest.appended) {
            // If this is a retry, then mediaRequest has added the listeners, and we don't need to add the listeners again.
            mediaRequest._listenerGroup.on(mediaRequest,
                                       MediaRequest.EVENTS.ONCOMPLETE,
                                       completeRequest);
        }
        return true;
    }

    /**
     *
     * @param {Array} data
     *
     * Append data to a SourceBuffer directly, whithout going through ASE/MediaReuqests.
     * This is useful for several reasons:
     *  1) Nudging the SoureBuffer in MSIE by appending empty boxes so it does not freeze
     *  2) Appending initSegments
     *  2) TODO: keeping the ability to swim if MediaBuffer already has the data during seek and no new MediaRequest is issued.
     *
     */
    function _appendBufferFromMediaPresenter(data) {
        DEBUG && log.debug('Appending buffer request came from MediaPresenter, not ASE.');
        DEBUG && log.debug('SourceBuffer ' + MediaElementSourceBuffer$appendMethodName + ' begin', _logFields, _getBufferedRangesForLog());

        debug$assert(!_isBusy);
        _setupCurrentOperation('append', data);
        _sourceBuffer[MediaElementSourceBuffer$appendMethodName](data);

        DEBUG && log.debug('SourceBuffer ' + MediaElementSourceBuffer$appendMethodName + ' end', _logFields, _getBufferedRangesForLog());

        if (MediaElementSourceBuffer$supportsEvents) {
            _isBusy = true;
        }
    }

    function _endOfStream() {
        // mark the sourceBuffer so MediasSource knows that endOfStream has been called on this specific buffer
        _calledEndOfStream = true;
    }

    function _remove(from, to) {
        debug$assert(!_isBusy);

        try {
            if (MediaElementSourceBuffer$supportsRemove) {
                _setupCurrentOperation('remove');
                DEBUG && log.debug('SourceBuffer remove', _logFields, { 'From': from, 'To': to });
                _sourceBuffer['remove'](from, to);
                if (MediaElementSourceBuffer$supportsEvents) {
                    _isBusy = true;
                }
            }
        }
        catch (e) {
            log.error('SourceBuffer remove exception', e, _logFields);
            // fail silently, if this happens we might hit OOM at one point, we might as well keep going as much as we can
        }

    }

    function _getBufferedRangesForLog() {
        try {
            var buffered = _sourceBuffer['buffered'];
            var ranges, i, l, size = 0;
            if (buffered) {
                ranges = [];
                i = 0;
                l = buffered['length'];
                for (i = 0; i < l; i++) {
                    var start = buffered['start'](i);
                    var end = buffered['end'](i);
                    size += (end - start);
                    debug$assert(end > start);
                    ranges.push(start + '-' + end);
                }
            }

            if (MediaElementSourceBuffer$supportsRemove) {
                // Assert if source buffer content gets to big, we should be timely removing this data
                debug$assert(size < 85);
            }

            if (ranges) {
                return { 'Buffered': size.toFixed(3), 'Ranges': ranges.join('|') };
            }
        }
        catch (e) {
        }
    }

    /**
    * @param {string} operation
    * @param {Uint8Array|Array=} data
    */
    function _setupCurrentOperation(operation, data){
        _currentSegment['data'] = data || [];
        _currentSegment['state'] = 'init';
        _currentSegment['operation'] = operation;
    }
}


var MediaElementSourceBuffer$appendMethodName;
var MediaElementSourceBuffer$supportsRemove;
var MediaElementSourceBuffer$supportsEvents;

function MediaElementSourceBuffer$detectFeatures(sourceBuffer) {
    // we can't use SourceBuffer prototype because Chrome R31+ has old and new MSE spec implemented
    // and the window.SourceBuffer doesn't match the source buffer returned by MediaSource.addSourceBuffer
    // this is why we wait until we have firstst buffer, and detect features on it
    MediaElementSourceBuffer$detectFeatures = NOOP;
    MediaElementSourceBuffer$appendMethodName = sourceBuffer['appendBuffer'] ? 'appendBuffer' : 'append';
    MediaElementSourceBuffer$supportsRemove = !config.avoidSBRemove && !!sourceBuffer['remove'];
    MediaElementSourceBuffer$supportsEvents = !!sourceBuffer['addEventListener'];
};



// -- cadmium-ase/MediaPresenterASE-BR.js
/**
* @constructor
*
* This component essentially uses the "rendering" api (MSE/EME through MediaElement) to render data from playback.MediaBuffer.
* It should implement .seek(), and update playback.mediaTime and playback.presentingState as appropriate.
*/
function MediaPresenter(playback) {
    var _log = new playback.log.CategoryLog('MediaPresenterASE'),
        _closed,
        _initialized,
        _okToPlayPause,
        _diagnostics = playback.diagnostics,
        _mediaEnded = false,
        _mediaBuffer = playback.mediaBuffer,
        _mediaTime = 0,
        _decoderIntrplayCount = 0,
        _networkIntrplayCount = 0,
        _lastSeekTime,
        _pendingSeek,
        _justLicensed = false,
        _mediaElement = playback.mediaElement,
        _videoElement = playback.mediaElement.videoElement,
        _videoElementIsPaused,
        _audio = {
            type: CadmiumMediaStream$AUDIO,
            decoderContent: []
            // sourceBuffer
            // currentStream
            // nextChunk
            // shouldRemoveFromBuffer
        },
        _video = {
            type: CadmiumMediaStream$VIDEO,
            decoderContent: []
            // sourceBuffer
            // currentStream
            // nextChunk
            // shouldRemoveFromBuffer
        },
        _trackByType = {},
        _minDecoderBufferMilliseconds = config.minDecoderBufferMilliseconds,
        _optimalDecoderBufferMilliseconds = config.optimalDecoderBufferMilliseconds,
        _maxDecoderBufferMilliseconds = config.maxDecoderBufferMilliseconds,
        _endOfStreamCalled,
        _decoderTimeoutMonitor,
        _syncWithVideoElementThrottle = new Throttle(MediaPresenter$SMALL_TIME);

    _trackByType[CadmiumMediaStream$AUDIO] = _audio;
    _trackByType[CadmiumMediaStream$VIDEO] = _video;

    debug$assert(_maxDecoderBufferMilliseconds > _minDecoderBufferMilliseconds, 'bad config');
    debug$assert(_maxDecoderBufferMilliseconds > _optimalDecoderBufferMilliseconds, 'bad config');
    debug$assert(config.prebufferMinAudioMilliseconds >= _optimalDecoderBufferMilliseconds, 'bad config');
    debug$assert(config.prebufferMinVideoMilliseconds >= _optimalDecoderBufferMilliseconds, 'bad config');

    // --------------------------------------------------------------------------------
    // -- initialization & public API

    _mediaElement.addEventListener(MediaElement$sourceBuffersAdded, function () {
        _log.trace('sourceBuffers have been created. Initialize MediaPresenter.');
        try {
            _init();
        }
        catch (e) {
            _log.error('Exception while initializing', e);
            _closeWithError(ErrorCodes.PLAY_INIT_EXCEPTION);
        }
    });

    mixIn(this, /** @lends {MediaPresenter.prototype} */ {
        seek: function (time) { _seek(time, Playback$REPOSITION_CAUSE_SEEK); },
        getElementTime: function () { return _mediaElement.getCurrentTime(false); },
        getFrameCount: _mediaElement.getFrameCount,
        getDroppedFrameCount: _mediaElement.getDroppedFrameCount,
        getCorruptedFrameCount: _mediaElement.getCorruptedFrameCount,
        getFrameDelayCount: _mediaElement.getFrameDelayCount,
        getConstrictionActive: _mediaElement.getConstrictionActive,
        decoderHasEnoughData: _decoderHasEnoughData,
        mediaElement: _mediaElement,
        getIntrplayCount: _getIntrplayCount
    });

    // --------------------------------------------------------------------------------
    // -- initialize
    function _init() {
        _log.trace('Video element initializing');

        var primaryAudioStream = playback.primaryAudioStream,
            primaryVideoStream = playback.videoStream.value,
            primaryAudioStreamHeader = primaryAudioStream.header,
            primaryVideoStreamHeader = primaryVideoStream.header,
            drmProtected = primaryVideoStreamHeader.drmProtected || primaryAudioStreamHeader.drmProtected,
            licenseIsDelivered,
            metadataIsLoaded;


        // set the source buffers which have already been created
        var len = _mediaElement.sourceBuffers.length;
        while (len--) {
            _setSourceBuffer(_mediaElement.sourceBuffers[len]);
        }

        if (!_trySwitchToStream(primaryAudioStream)) return;
        if (!_trySwitchToStream(primaryVideoStream)) return;

        if (drmProtected) {
            _log.trace('Waiting for needkey');
        } else {
            _log.warn('Movie is not DRM protected', { 'MovieId': playback.movieId, 'DownloadableId': primaryVideoStream.downloadableId });
        }

        _log.trace('Waiting for loadedmetadata');

        playback.addEventListener(Playback$playbackstart, sendStart);

        if (drmProtected) {

            // listen to license events

            _mediaElement.addEventListener(MediaElement$needlicense, function (licenseChallenge) {
                if (_closed) {
                    return;
                }
                _log.info('Requesting license');
                if(!licenseChallenge.renewal){
                    playback.notifyMilestone('lc');
                }
                
                playback.nccpPlayback.license(licenseChallenge, function (result) {
                    _log.info('Received license');
                    if (_closed) {
                        return;
                    }
                    if(!licenseChallenge.renewal){
                        playback.notifyMilestone('lr');
                    }
                    
                    if (result.success) {
                        var licenseResponse = result.response;
                        try {
                            _mediaElement.addLicense(licenseResponse);
                            _log.trace('Added license');
                        }
                        catch (e) {
                            _log.error('Exception adding license', e);
                            _closeWithError(ErrorCodes.PLAY_MSE_ADDKEY);
                        }
                    } else {
                        _closeWithError(ErrorCodes.LICENSE, result);
                    }
                });

                // proxy the license challenge to other components
                playback.fireEvent(MediaPresenter$needlicense, licenseChallenge);
            });

            _mediaElement.addEventListener(MediaElement$licenseadded, function (event) {
                licenseIsDelivered = true;
                _justLicensed = true;
                playback.notifyMilestone('ld');
                // Note: do not do dispatch(tryCompleteInitialization), so the tryCompleteInitialization can change itself to BADOP
                dispatch(function () { tryCompleteInitialization(); });
                playback.fireEvent(Playback$licenseAdded, event);
            });

        } else {

            // there is no DRM, so just pretend license is delivered
            licenseIsDelivered = true;

        }

        addSingleEventListener(_videoElement, 'loadedmetadata', function () {
            _log.trace('Video element event: loadedmetadata');
            metadataIsLoaded = true;
            playback.notifyMilestone('md');

            // start appending media
            playback.addEventListener(MediaBuffer$changed, _mediaBufferOrSourceBufferChanged);
            _audio.sourceBuffer.setBusyChangedHandler(_mediaBufferOrSourceBufferChanged);
            _video.sourceBuffer.setBusyChangedHandler(_mediaBufferOrSourceBufferChanged);
            _mediaBufferOrSourceBufferChanged();

            // Note: do not do dispatch(tryCompleteInitialization), so the tryCompleteInitialization can change itself to BADOP
            dispatch(function () { tryCompleteInitialization(); });
        });

        globalEvents.addListener(globalEvents$beforeunload, _close, ORDERPROPERTY$early);
        playback.addEventListener(Playback$closing, _close, ORDERPROPERTY$early);
        // don't listen to audioTrack changes directly, because we want the mediaBuffer to process the change first,  then it will call this event
        playback.addEventListener(MediaBuffer$trackchanged, _mediaBuffer_trackchanged);
        playback.paused.addListener(_syncWithVideoElement);
        playback.muted.addListener(_updateVolume);
        playback.volume.addListener(_updateVolume);
        playback.bufferingState.addListener(_syncWithVideoElement);
        _seek(playback.bookmarkTime || 0, Playback$REPOSITION_CAUSE_INITIAL);
        _updateVolume();

        function sendStart(){
            playback.nccpPlayback.start().catch(function(err) {
                _closeWithError(ErrorCodes.START, err);
                return;
            });
            playback.removeEventListener(Playback$playbackstart, sendStart);
        }

        function tryCompleteInitialization() {
            if (_closed) {
                return;
            }

            if (licenseIsDelivered && metadataIsLoaded) {
                tryCompleteInitialization = BADOP;

                _mediaElement.addEventListener(MediaElement$seeked, function() {
                    _syncWithVideoElement();
                    playback.fireEvent(MediaPresenter$seeked);
                });
                _mediaElement.addEventListener(MediaElement$currentTimeChanged, function(){
                    _syncWithVideoElement();
                    playback.fireEvent(MediaPresenter$currentTimeChanged);
                });
                _videoElement.addEventListener('ended', function () {
                    _log.trace('Video element event: ended');
                    _syncWithVideoElement();
                });
                _videoElement.addEventListener('play', function () {
                    _log.trace('Video element event: play');
                    _syncWithVideoElement();
                });
                _videoElement.addEventListener('pause', function () {
                    _log.trace('Video element event: pause');
                    _syncWithVideoElement();
                    playback.fireEvent(MediaPresenter$paused);
                });
                _videoElement.addEventListener('playing', function () {
                    _log.trace('Video element event: playing');
                });

                _initialized = true;
                _tryFeedDecoder();

                _log.trace('Video element initialization complete');
                playback.notifyMilestone('vi');

                if (config.delayPlayPause) {
                    // HACK: IE11 freezes if play or pause is called within ~300 ms after adding a license
                    setTimeout(function () {
                        _okToPlayPause = true;
                        _syncWithVideoElement();
                    }, config.delayPlayPause);
                } else {
                    _okToPlayPause = true;
                }

                startMonitoringForDecoderTimeouts();
                dispatch(_syncWithVideoElement);
            }
        }

        function startMonitoringForDecoderTimeouts() {
            // monitor decoder for timeouts
            if (config.decoderTimeoutMilliseconds) {
                debug$assert(!_decoderTimeoutMonitor);
                _decoderTimeoutMonitor = new TimeoutMonitor(config.decoderTimeoutMilliseconds, function () {
                    _closeWithError(ErrorCodes.PLAY_MSE_DECODER_TIMEOUT);
                });
                function _startOrStopDecoderTimeoutMonitor() {
                    var state;
                    if (playback.presentingState.value == PresentingState$WAITING && playback.state.value == Playback$STATE_NORMAL && playback.bufferingState.value == BufferingState$NORMAL) {
                        _decoderTimeoutMonitor.ensureTimer();
                        state = 'ensureTimer';
                    } else {
                        _decoderTimeoutMonitor.stopTimer();
                        state = 'stopTimer';
                    }
                    _log.trace('Timer update: ' + state, {
                        'presentingState': playback.presentingState.value,
                        'playbackState': playback.state.value,
                        'bufferingState': playback.bufferingState.value
                    });
                };
                playback.presentingState.addListener(_startOrStopDecoderTimeoutMonitor);
                playback.bufferingState.addListener(_startOrStopDecoderTimeoutMonitor);
                playback.state.addListener(_startOrStopDecoderTimeoutMonitor);
                _startOrStopDecoderTimeoutMonitor();
            }
        }
    }


    function _setSourceBuffer (sb) {
        if (sb.type === ASEMediaStream$AUDIO) {
            try {
                _audio.sourceBuffer = sb;
            } catch (e) {
                _closeWithError(ErrorCodes.PLAY_MSE_SOURCEADD, {
                    errorSubCode: ErrorSubCodes.MSE_AUDIO,
                    errorDetails: exceptionToString(e)
                });
            }
        } else if (sb.type === ASEMediaStream$VIDEO) {
            try {
                _video.sourceBuffer = sb;
            } catch (e) {
                _closeWithError(ErrorCodes.PLAY_MSE_SOURCEADD, {
                    errorSubCode: ErrorSubCodes.MSE_VIDEO,
                    errorDetails: exceptionToString(e)
                });
            }
        }
    }

    function _mediaBufferOrSourceBufferChanged() {
        // either mediaBuffer has new data, or video/audio source buffer is no longer busy
        if (_initialized) {
            // after init just go through regular syncing, which will feed the data
            _syncWithVideoElement();
        } else {
            if (config.appendMediaBeforeInit) {
                // before init (if configured to do so), feed 
                _tryFeedDecoder();
            }
        }
    }

    function _mediaBuffer_trackchanged() {
        var seekTo = playback.mediaTime.value - config.seekBackOnAudioTrackChangeMilliseconds;
        // don't seek further back than last seek time... 
        // Need this restriction so we don't hit an area without video buffer, or keep seeking back when audio track is changed several times in a row
        seekTo = Math$max(seekTo, _lastSeekTime);
        _seek(seekTo, Playback$REPOSITION_CAUSE_TRACK_CHANGED);
    }

    function _getIntrplayCount(){
        return {
            decoderIntrplayCount: _decoderIntrplayCount,
            networkIntrplayCount: _networkIntrplayCount
        };
    }

    function _decoderHasEnoughData() {
        var presentingState = playback.presentingState.value,
            decoderBufferThreshold = presentingState == PresentingState$WAITING ? _optimalDecoderBufferMilliseconds : _minDecoderBufferMilliseconds,
            decoderHasEnoughData = _doesDecoderHaveEnough(_audio, decoderBufferThreshold) && _doesDecoderHaveEnough(_video, decoderBufferThreshold);

        return decoderHasEnoughData;
    }

    // --------------------------------------------------------------------------------
    // -- feed media to decoder, seek, play, pause, check for rebuffers, check for state changes
    function _syncWithVideoElement() {
        if (_closed || !_initialized)
            return;

        var seeking = _mediaElement.getSeeking();

        if (!seeking) {
            // unless we already initiated the seek process, feed the decoder data around current time
            // Note:seek glitches (at least on IE11) when media is removed after "seeking" event but before "seeked"
            _tryFeedDecoder();
        }

        // TODO ASE -- how do we handle this GTV hack?
        if (!MediaElementSourceBuffer$supportsRemove) {
            // HACK: GTV-Chrome bug work around 
            // For older chrome, we have to append data even if we are seeking or it won't complete.
            // This conflicts with the hack above were we SHOULDN'T try to touch decider in IE11 untill seek is complete.
            _tryFeedDecoder();
        }

        var bufferingStateIsNormal = (playback.bufferingState.value == BufferingState$NORMAL);
        var presentingState = playback.presentingState.value;
        // if we are not playing, wait "optimal" level... if we are, use "min" level is ok
        var decoderBufferThreshold = presentingState == PresentingState$WAITING ? _optimalDecoderBufferMilliseconds : _minDecoderBufferMilliseconds;
        var decoderHasEnoughData;

        decoderHasEnoughData = _doesDecoderHaveEnough(_audio, decoderBufferThreshold) && _doesDecoderHaveEnough(_video, decoderBufferThreshold);

        // play or pause as necessary
        if (!playback.paused.value && decoderHasEnoughData && bufferingStateIsNormal && !seeking && !_pendingSeek) {
            _safeVideoElementPlay();
        } else {
            _safeVideoElementPause();
        }

        // if there is a seek, wait for it to complete
        if (seeking) {
            return;
        }

        // if there is a pending seek, and we can seek.. do so
        if (_pendingSeek) {
            if (bufferingStateIsNormal && decoderHasEnoughData) {
                _mediaElement.seek(_mediaTime);
                _pendingSeek = false;
                if (!MediaElementSourceBuffer$supportsRemove) {
                    // HACK: GTV-Chrome bug work around 
                    // because remove is not supported, chrome tends to drop newly appended chunks when seeking back, since we set currentTime only after seeking
                    // to workaround this, re-append those chunks after calling into seek
                    _resetDecoderContent();
                }
                // we need to re-run this logic, do so in next dispatch cycle
                dispatch(_syncWithVideoElement);
                return;
            }
        }

        var elementTime = _mediaElement.getCurrentTime(true);

        if (_pendingSeek || seeking) {
            // waiting for seek to complete is same as waiting for the decoder
            presentingState = PresentingState$WAITING;
        } else if (_videoElement['ended']) {
            // did the playback end?
            if (presentingState == PresentingState$PLAYING) {
                // don't switch to ended state unless we were playing
                // otherwise we might ping pong between ENDED and WAITING states
                _mediaTime = playback.duration;
                presentingState = PresentingState$ENDED;
                _safeVideoElementPause();
            }
        } else if (bufferingStateIsNormal && decoderHasEnoughData) {
            // did the playback start?
            if (_mediaElement.didDecodingStart()) {
                presentingState = _videoElement['paused'] ? PresentingState$PAUSED : PresentingState$PLAYING;
            } else {
                // TODO: this is a little hacky approach, where we poll the element untill it starts decoding
                //       consider revisting this if CAD-56 is resolved.
                _syncWithVideoElementThrottle.schedule(_syncWithVideoElementOnTimer);
            }
        } else {
            // keep buffering, or rebuffer
            presentingState = PresentingState$WAITING;
        }

        // unless playback is busy, read the time from the VIDEO element
        if (presentingState != PresentingState$WAITING && presentingState != PresentingState$ENDED) {
            if (elementTime < _mediaTime) {
                var delta = _mediaTime - elementTime;
                // TODO: remove this workarond for [CAD-59]
                if (elementTime) {
                    if (delta > MediaPresenter$SMALL_TIME) {
                        // is the difference significant?
                        var elementTimeLogFields = { 'ElementTime': Number$formatMillisecond(elementTime), 'MediaTime': Number$formatMillisecond(_mediaTime) };
                        if (delta > MediaPresenter$REWIND_TOLERNACE) {
                            // is it going to affect playback adversely (delta above tolerance)?
                            _log.error('VIDEO.currentTime became much smaller', elementTimeLogFields);
                            _closeWithError(ErrorCodes.PLAY_MSE_UNEXPECTED_REWIND);
                        } else {
                            _log.warn('VIDEO.currentTime became smaller', elementTimeLogFields);
                        }
                    }
                }
            } else {
                _mediaTime = Number$clamp(elementTime, 0, playback.duration);
            }
        }

        _updateMediaTime();
        _checkForChunkSwitch();
        // rebuffer is when we go from playing to waiting state
        var rebuffer = (presentingState == PresentingState$WAITING) && (playback.presentingState.value == PresentingState$PLAYING);
        playback.presentingState.set(presentingState, {
            isBufferUnderrun: true
        });
        if (rebuffer) {
            playback.fireEvent(Playback$bufferUnderrun, {
                cause: _mediaBuffer.getBufferLength() > decoderBufferThreshold ? Playback$BUFFER_UNDERRUN_CAUSE_MEDIA : Playback$BUFFER_UNDERRUN_CAUSE_NETWORK
            });

            if (_mediaBuffer.getBufferLength() > decoderBufferThreshold) {
                _decoderIntrplayCount++;
            } else {
                _networkIntrplayCount++;
            }
        }
    }

    function _syncWithVideoElementOnTimer() {
        if (config.nudgeSourceBuffer) {
            // HACK for IE11 bug CAD-882
            // we basically append an empty "free" mp4 box
            if (!_audio.sourceBuffer.getBusy()) {
                DEBUG && _log.debug('Nudging source buffer');
                _audio.sourceBuffer.appendBufferFromMediaPresenter(new Uint8Array([0, 0, 0, 8, 102, 114, 101, 101]));
            }
        }
        _syncWithVideoElement();
    }

    function _doesDecoderHaveEnough(track, ms) {
        var nextChunk = track.nextChunk;
        if (!nextChunk) {
            // nothing left to feed, so no matter what "ms" decoder is full
            return true;
        }
        var decoderLatest = track.decoderLatest;
        var currentChunk = decoderLatest && decoderLatest.chunk;
        return currentChunk && (currentChunk.endTime - _mediaTime >= ms);
    }

    // --------------------------------------------------------------------------------
    // -- update volume on video element
    function _updateVolume() {
        if (_closed) {
            return;
        }

        _videoElement.volume = playback.volume.value;
        _videoElement.muted = playback.muted.value;
    }

    // --------------------------------------------------------------------------------
    // -- feed the media in to audio and video tracks
    // -- do so while decoder has less than _maxDecoderBufferMilliseconds and the chunks do have media
    function _tryFeedDecoder() {
        _tryFeedBuffer(_audio);
        _tryFeedBuffer(_video);

        if (_closed) {
            return;
        }
        if (!_audio.nextChunk && !_video.nextChunk && !_audio.sourceBuffer.getBusy() && !_video.sourceBuffer.getBusy()) {
            if (!_endOfStreamCalled) {
                _endOfStreamCalled = true;
                _mediaElement.endOfStream();
            }
        }
    }

    function _tryFeedBuffer(track) {
        if (_closed) {
            return;
        }
        var sourceBuffer = track.sourceBuffer;
        var decoderContent = track.decoderContent;
        if (!sourceBuffer.getBusy()) {
            // keep track of what is the latest chunk that updated is ended for
            track.decoderLatest = decoderContent[decoderContent.length - 1];

            if (track.shouldRemoveFromBuffer) {
                track.shouldRemoveFromBuffer = false;
                sourceBuffer.remove(0, CadmiumMediaStream$switchType(track.type, _mediaBuffer.audioChunks, _mediaBuffer.videoChunks).last.endTime / MILLISECONDS_PER_SECOND);
            }
        }
        var nextChunk = track.nextChunk;
        while (nextChunk && nextChunk.media && nextChunk.startTime - _mediaTime <= _maxDecoderBufferMilliseconds) {
            // reset the flag when we feed a chunk
            _endOfStreamCalled = false;
            if (!_trySourceAppendMedia(nextChunk)) {
                break;
            }
            nextChunk = nextChunk.next;
        }
        track.nextChunk = nextChunk;

        if (!sourceBuffer.getBusy()) {
            // did append complete synchroniously?
            track.decoderLatest = decoderContent[decoderContent.length - 1];
        }
    }

    function _trySwitchToStream(stream) {
        debug$assert(stream && stream.header);
        if (!(stream && stream.header)) {
            return false;
        }

        var type = stream.type;
        var track = _trackByType[type];
        var forceAppendInitSegment = false;
        if (config.appendInitSegmentAfterLicense && type == 'video' && _justLicensed) {
            forceAppendInitSegment = true;
        }

        if (track.currentStream != stream || forceAppendInitSegment) {
            try {
                if (track.sourceBuffer.getBusy()) {
                    return;
                }
                var initSegment = stream.header.initSegment;
                _log.trace('Feeding init segment to decoder', stream, { 'Bytes': initSegment.length });
                track.sourceBuffer.appendBufferFromMediaPresenter(initSegment);
                track.currentStream = stream;
                if (config.appendInitSegmentAfterLicense && stream.type == 'video' && _justLicensed) {
                    _justLicensed = false;
                }
            }
            catch (e) {
                _log.error('Exception while appending initialization segment', e, { 'Type': type });
                _closeWithError(ErrorCodes.PLAY_MSE_SOURCEAPPEND_INIT, MediaPresenter$geErrorSubCodeByMediaType(type));
                return;
            }
        }
        return true;
    }

    function _trySourceAppendMedia(chunk) {
        debug$assert(chunk && chunk.media);
        var media = chunk.media;
        var type = chunk.type;
        var track = _trackByType[type];

        if (!_trySwitchToStream(media.stream)) {
            return;
        }

        if (_closed) {
            return;
        }

        if (track.sourceBuffer.getBusy()) {
            return;
        }

        try {
            var arrayBuffer = media.arrayBuffer;
            _log.trace('Feeding media segment to decoder', chunk, { 'Bytes': media.length }, media.stream);
            track.sourceBuffer.appendBufferFromMediaPresenter(arrayBuffer);
            track.decoderContent.push({
                chunk: chunk,
                stream: media.stream,
                cdn: media.cdn
            });

            if (!_pendingSeek || MediaElementSourceBuffer$supportsRemove) {
                // HACK: GTV-Chrome bug work around 
                // another ugly hack... since we are going to re-append the data after seek when remove is not supported
                // don't tell the buffer about chunks being appended, so it doesn't drop the array buffer of those
                _mediaBuffer.notifyAppendedToDecoder(chunk);
            }
        }
        catch (e) {
            if (e.name != "QuotaExceededError") {
                _log.error('Exception while appending media', chunk, e);
                _closeWithError(ErrorCodes.PLAY_MSE_SOURCEAPPEND, MediaPresenter$geErrorSubCodeByMediaType(type));
            } else {
                playback.decoderQuotaExceededCount = playback.decoderQuotaExceededCount ? playback.decoderQuotaExceededCount + 1 : 1;
            }
            return;
        }

        return true;
    }

    function _safeVideoElementPlay() {
        if (_videoElement['ended']) return;
        if (!_okToPlayPause) return;
        if (_videoElementIsPaused || _videoElementIsPaused === undefined) {
            _log.trace('Calling play on element');
            _videoElement['play']();
            _videoElementIsPaused = false;
        }
    }

    function _safeVideoElementPause() {
        if (_videoElement['ended']) return;
        if (!_okToPlayPause) return;
        if (!_videoElementIsPaused || _videoElementIsPaused === undefined) {
            _log.trace('Calling pause on element');
            _videoElement['pause']();
            _videoElementIsPaused = true;
        }
    }

    /**
    * @param {string=} type
    */
    function _checkForChunkSwitch(type) {
        if (!type) {
            _checkForChunkSwitch(CadmiumMediaStream$AUDIO);
            _checkForChunkSwitch(CadmiumMediaStream$VIDEO);
            return;
        }
        var track = _trackByType[type];
        var decoderContent = track.decoderContent;
        var entry;
        var changed;
        while ((entry = decoderContent[0]) && entry.chunk.startTime <= _mediaTime) {
            if (_mediaTime < entry.chunk.endTime) {
                var presented = CadmiumMediaStream$switchType(type, playback.presentedAudio, playback.presentedVideo);
                if (!compareByProperties(entry, presented.value)) {
                    changed = true;
                    presented.set(entry);
                }
                break;
            } else {
                decoderContent.shift();
                _mediaBuffer.notifyDroppedByDecoder(entry.chunk);
            }
        }

        // don't do this if we called end of stream, or it will re-open the stream and never "ended" it
        if (changed && !_endOfStreamCalled) {
            // Drop data from media buffer that is in past time.
            // As a precaution, only drop up to previous chunk.
            var prevChunk = entry.chunk.previous;
            var toTime = prevChunk && (prevChunk.startTime - 1);
            if (toTime > 0) {
                var sourceBuffer = track.sourceBuffer;
                if (!sourceBuffer.getBusy()) {
                    sourceBuffer.remove(0, toTime / MILLISECONDS_PER_SECOND);
                }
            }
        }
    }

    /**
    * @param {boolean=} forceEvent
    */
    function _updateMediaTime(forceEvent) {
        playback.mediaTime.set(_mediaTime);
        if (forceEvent) {
            playback.flushThrottledMediaTimeChanged();
        }
    }

    function _seek(time, cause) {
        if (_closed)
            return;

        // find a time we can actually seek to
        var videoChunk = _mediaBuffer.videoChunks.getForTime(Number$clamp(time, 0, MAX_MEDIA_TIME)),
            seekTime = videoChunk.startTime;

        if(config.preciseSeeking){
            seekTime = Math$round(time);
            
            seekTime = Number$clamp(seekTime, 0, playback.maxSeekablePosition);
            if (config.workaroundValueForSeekIssue) {
                seekTime = Number$clamp(seekTime, 0, (playback.maxSeekablePosition - config.workaroundValueForSeekIssue));
            }
        }
        var audioChunk = _mediaBuffer.audioChunks.getForTime(seekTime);
        
        if (config.seekDelta) {
            seekTime += config.seekDelta;
        }

        if (cause == Playback$REPOSITION_CAUSE_INITIAL) {
            // store the first seek for logging in startup
            playback.bookmarkTimeActual = seekTime;
        }

        // seek
        _checkForChunkSwitch();
        var oldMediaTime = _mediaTime;
        _log.info('Seeking', { 'Requested': Number$formatMillisecond(time), 'Actual': Number$formatMillisecond(seekTime), 'Cause': cause });
        playback.fireEvent(Playback$repositioning, { oldMediaTime: oldMediaTime, newMediaTime: seekTime, cause: cause });
        playback.presentingState.set(PresentingState$WAITING);
        _audio.seekChunk = audioChunk;
        _video.seekChunk = videoChunk;
        _resetDecoderContent();
        if (cause != Playback$REPOSITION_CAUSE_INITIAL) {
            _audio.shouldRemoveFromBuffer = true;
            _video.shouldRemoveFromBuffer = true;
        }
        _lastSeekTime = _mediaTime = seekTime;
        // Note: must be set to null before "repositioned", so PlayTimeTracker works properly
        playback.presentedAudio.set(null);
        playback.presentedVideo.set(null);
        _updateMediaTime(true);
        playback.fireEvent(Playback$repositioned, { oldMediaTime: oldMediaTime, newMediaTime: seekTime, cause: cause });

        // setting _pendingSeekTime will make _syncWithVideoElement seek when able
        _pendingSeek = true;
        _syncWithVideoElement();
    }

    function _resetDecoderContent() {
        _audio.nextChunk = _audio.seekChunk;
        _audio.decoderContent = [];
        _audio.decoderLatest = undefined;
        _video.nextChunk = _video.seekChunk;
        _video.decoderContent = [];
        _video.decoderLatest = undefined;
        _mediaBuffer.notifyDroppedAllByDecoder();
    }

    /**
    * @param {number} errorCode
    * @param {*=} errorResult
    * @param {*=} errorExternalCode
    */
    function _closeWithError(errorCode, errorResult, errorExternalCode) {
        if (_closed) {
            return;
        }
        playback.closeWithError(new PlayerError(errorCode, errorResult, errorExternalCode));
    }

    function _close() {
        if (_closed) {
            return;
        }
        _log.info('Closing.');
        globalEvents.removeListener(globalEvents$beforeunload, _close);
        _closed = true;
        try {
            if (config.muteVolumeOnPlaybackClose) {
                _videoElement.volume = 0;
                _videoElement.muted = true;
            }

            _safeVideoElementPause();
            _mediaElement.close();
        }
        catch (e) {
        }
    }
}

function MediaPresenter$geErrorSubCodeByMediaType(type) {
    return CadmiumMediaStream$switchType(type, ErrorSubCodes.MSE_AUDIO, ErrorSubCodes.MSE_VIDEO);
}

// a small enough to segment in milliseconds (~duration of one frame in >30 fps content)
var MediaPresenter$SMALL_TIME = 50;
// sometimes VIDEO element glitches and it's currentTime goes backwards, tolerate this to some extend
// this should be a number smaller than a chunk of media
var MediaPresenter$REWIND_TOLERNACE = 1000;


// -- cadmium-ase/download-track.js
/*
 * (c) 1997-2014 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

////////////////////
// DownloadTrack
////////////////////

/**
* @constructor
*/
function DownloadTrack(downloadConfig){
    var platform = require(61);
	var _eventSource = new EventSource();
	this._config = downloadConfig;
	this._log = new platform.playbackLog.CategoryLog('DownloadTrack');
	this._mediaDownloader = platform.getMediaDownloader();
    this._trackId = undefined;
    this._failing = false;
    this._failureCode = undefined;
    this._nativeCode = undefined;
    this._failingDestination = undefined;


    mixIn(this,
        /** @lends {DownloadTrack.prototype} */
        _eventSource);

    Object.defineProperties(this, /** @lends {DownloadTrack.prototype} */{
        trackId:     { get: function() { return this._trackId; } },
        created:     { get: function() { return (this._trackId === undefined); } },
        config:      { get: function() { return this._config; } },
        failing:     { get: function() { return this._failing; } },
        failureCode: { get: function() { return this._failureCode; } },
        nativeCode:  { get: function() { return this._nativeCode; } },
        failingDestination: { get: function() { return this._failingDestination; } }
    } );
}
DownloadTrack.prototype.constructor = DownloadTrack;

///////////////////////
//Event Handlers
///////////////////////
DownloadTrack.prototype.onpipelinedisabled = function onpipelinedisabled(evt){};
DownloadTrack.prototype.onnetworkfailing = function onnetworkfailing(evt){};

////////////////////////
//Helper function
////////////////////////
/**
* @export
*/
DownloadTrack.prototype.destroy = function destroy(){
    DEBUG && this._log.debug("DownloadTrack (" + this + ") is destroyed");
	this._trackId = undefined;
};

DownloadTrack.prototype.toString = function toString(){
	return "id:" + this._trackId + " config: " + JSON.stringify(this._config);
};

DownloadTrack.prototype.toJSON = function toJSON(){
	return "Download Track id:" + this._trackId + " config: " + JSON.stringify(this._config);
};

DownloadTrack.prototype.getTrackId = function getTrackId(){
	return this._trackId;
};

DownloadTrack.prototype.setTrackId = function setTrackId(trackId){
	this._trackId = trackId;
    DEBUG && this._log.debug("DownloadTrack (" + this + ") is being set up");
};

DownloadTrack.prototype.isValid = function isValid(){
    if(this._trackId === undefined ){
        return false;
    }
    return true;
};

// Only here to meet the API, NRDJS uses this to enforce some inline functionalities. Cadmium doesn't need to do that.
DownloadTrack.execute = function(){};

/**
* @param {Object} config
* @export
*/
DownloadTrack.prototype.reconfigure = function reconfigure( config ){
    // Cadmium only cares about the number of connections defined in download track
    var numconn = config['connections'];
    if ( this._config['connections'] !== numconn ){
        this._config = config;
        this._mediaDownloader.setActiveWorkers(numconn);
    }
};
/**
* Whether the current download track is using parallel connections
* @export
*/
DownloadTrack.prototype.isParallel = function isParallel(){
   return (this._config['connections'] > 1 ? true : false);
};



// -- cadmium-ase/media-request.js
/*
 * (c) 1997-2014 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var _nextMediaRequestId = 0;

////////////////////////////////////////
// MediaRequest - Cadmium Implementation
////////////////////////////////////////
/**
* @constructor
*/
function MediaRequest(track, label){
    var platform = require(61);
    var _eventSource = new EventSource(),
        NOOP = function(){};

    //response
    this.durationMs = undefined;
    this.location = undefined;
    this.stream = undefined;
    this.byteStart = undefined;
    this.byteEnd = undefined;
    this.ptsStart = undefined;
    this.ptsEnd = undefined;
    this.inprogress = undefined;
    this.addEventListener = _eventSource.addListener.bind(this);
    this.removeEventListener = _eventSource.removeListener.bind(this);
    this.emit = _eventSource.fire.bind(this);
    this._track = track;
    this._label = label;

    this._requestId = _nextMediaRequestId++;
    this._mediaDownloader = platform.getMediaDownloader();
    this._log = new platform.playbackLog.CategoryLog('MediaRequest');

    this._responseType = undefined;
    this._url = undefined;
    this._byteRange = undefined;

    this._readyState = MediaRequest.READYSTATES.UNSENT;
    this._priorState = undefined;                           // state before failure - restored with new URL
    this._status = undefined;
    this._failureCode = undefined;
    this._failureString = undefined;
    this._nativeCode = undefined;
    this._bytesReceived = 0;
    this.previousBytesReceived = 0;
    this._response = undefined;
    this._headers = undefined;
    // Request timestamps (absolute)
    this._loadTime = undefined;
    this._firstbyteTime = undefined;
    this._lastEventTime = undefined;
    this._lastOnprogressTime = undefined;

    // Response times
    this._connect = undefined;      // If true, first response time includes TCP connect time
    this._responseTimes = [ ];

    this._created = false;


    //TODO: get response header from native cadmium
    //this._headers = undefined;

    DEBUG && this._log.debug("creating MediaRequest:");

    mixIn(this,
        /** @lends {MediaRequest.prototype} */
        ({
            notifyLoadstart: _notifyLoadstart,
            notifyFirstbyte: _notifyFirstbyte,
            notifyProgress: _notifyProgress,
            notifyComplete: _notifyComplete,
            notifyAbort: _notifyAbort,
            notifyNetworkError: _notifyNetworkError,
            open: _open,
            cleanup: _cleanup,
            swapUrl: _swapUrl,
            abort: _abort,
            pause: NOOP, //TODO: ASE -- implement pause
            getResponseHeader: NOOP, // TODO: _getResponseHeader,
            getAllResponseHeaders: NOOP, //TODO: _getAllResponseHeaders,
            getRequestId: _getRequestId,
            toString: _toString,
            toJSON: _toString
        })
    );

    // --------------------------------------------------------------------------------
    // -- private implementation
    function _addOcHints( url )
    {
        if ( this._enclosingByteRange )
        {
            url = url + "&ebr=" + this._enclosingByteRange["start"] + "+" + this._enclosingByteRange["sizes"].join('+');
        }

        if ( this._lookAheadHint )
        {
            url = url + "&s=" + ( this._lookAheadHint ? "1" : "0" );
        }

        return url;
    }

    // Event Notifier Functions
    function _notifyLoadstart(evt){
        if ( this._readyState === MediaRequest.READYSTATES.OPENED )
        {
            this.inprogress = true;
            this._lastEventTime = evt["timestamp"];
            this._loadTime = this._lastEventTime;
            DEBUG && this._log.debug("ASE_EVENTS: MediaRequest (" + this + ") emits ONLOADSTART event");
            this._readyState = MediaRequest.READYSTATES.SENT;
            this.emit(MediaRequest.EVENTS.ONLOADSTART, evt);
        }
    }
    function _notifyFirstbyte(evt){
        if ( this._readyState < MediaRequest.READYSTATES.RECEIVING )
        {
            // only set response time if it is non-zero
            // only set for non-header Media Requests since header events are not issued properly
            this._responseTimes = [];
            var responseTime = evt["timestamp"] - this._loadTime;
            if ( !this.isHeader && responseTime > 0) {
                // set to true so that ASE considers the time to first byte as the response time
                this._connect = true;
                this._responseTimes.push(responseTime);
            }

            this._lastEventTime = evt["timestamp"];
            this._firstbyteTime = this._lastEventTime;
            DEBUG && this._log.debug("ASE_EVENTS: MediaRequest (" + this + ") emits ONFIRSTBYTE event");

            this._readyState = MediaRequest.READYSTATES.RECEIVING;
            this.emit(MediaRequest.EVENTS.ONFIRSTBYTE, evt);
        }
    }
    function _notifyProgress(evt){
        // Ignore progress when not in receiving state
        if ( this._readyState === MediaRequest.READYSTATES.RECEIVING )
        {
            DEBUG && this._log.debug("ASE_EVENTS: MediaRequest (" + this + ") emits ONPROGRESS event");
            this._lastEventTime = evt["timestamp"];
            evt['newBytes'] = evt['bytesLoaded'] - this._bytesReceived;
            this._bytesReceived = evt['bytesLoaded'];

            /*
             * If this  is the first onprogress event (i.e. lastOnprogressTime is undefined)
             * then ignore it because it is not accurate.
             * It generally comes within 1-2ms of the onFirstbyte event and reports 3.5KB of new data,
             * making the effective bandwidth ~28Mbps even when we are on a 1Mbps connection.
             *
             */
            if (isDefined(this._lastOnprogressTime)) {
                this.emit(MediaRequest.EVENTS.ONPROGRESS, evt);
            }
            this._lastOnprogressTime = this._lastEventTime;
        }
    }
    function _notifyComplete(evt){
        if ( this._readyState === MediaRequest.READYSTATES.SENT
            || this._readyState === MediaRequest.READYSTATES.RECEIVING )
        {
            this.inprogress = false;
            DEBUG && this._log.debug("ASE_EVENTS: MediaRequest (" + this + ") emits ONCOMPLETE event");
            this._lastEventTime = evt["timestamp"];
            this._readyState = MediaRequest.READYSTATES.DONE;
            evt['newBytes'] = this.totalBytes - this._bytesReceived;
            this._bytesReceived = this.totalBytes;
            if(this.isHeader){
                this._response = evt["response"];
            }
            this.emit(MediaRequest.EVENTS.ONCOMPLETE, evt);
        }
    }
    function _notifyAbort(evt){
        this.inprogress = false;
        DEBUG && this._log.debug("ASE_EVENTS: MediaRequest (" + this + ") emits ONABORT event");
        this.emit(MediaRequest.EVENTS.ONABORT, evt);
    }
    function _notifyNetworkError(evt){
        this._lastEventTime = evt["timestamp"];
        this._status = evt["httpcode"];
        this._failureCode = evt["errorcode"];
        this._failureString = MediaRequest.ERRORCODES.name[ this._failureCode ];
        this._nativeCode = evt["nativecode"];

        DEBUG && this._log.debug("ASE_EVENTS: MediaRequest (" + this + ") emits NetworkError event (" + JSON.stringify(evt) + ")");
        this.emit(MediaRequest.EVENTS.ONERROR, evt);
        this.inprogress = false;
    }

    function _abort(){
        this._readyState = MediaRequest.READYSTATES.ABORTED;
        this._mediaDownloader.abortRequest(this);
        return true;
    }


    function _open(url, byteRange, responseType, headers, enclosingByteRange, lookAheadHint )
    {
        DEBUG && this._log.debug("media request created, responseType:"+ this.responseType);
        this.started = false;
        this.active = false;
        this._byteRange = byteRange;
        this._url = url;
        this._hintedUrl = _addOcHints( url );
        this._responseType = responseType;
        DEBUG && this._log.debug("media request created, responseType:"+ this._responseType);

        // make sure we have a url
        if (!url)
        {
            DEBUG && this._log.warn("Missing url in MediaRequest.open");
            throw "missing url";
        }

        if ( lookAheadHint )
        {
            this._enclosingByteRange = enclosingByteRange ||
                            { "start" : byteRange["start"], "sizes" : [ byteRange["end"]-byteRange["start"] + 1 ] };
            this._lookAheadHint = lookAheadHint;
        }
        // Link it to MediaDownloaderASE to translate MediaRequest to Jobs
        // Once opened, the onopen() will be called and readyState will transit from UNSET -> OPENED
        this._readyState = MediaRequest.READYSTATES.OPENED;
        this._mediaDownloader.fulfillRequest(this, url, byteRange);

        // open() will always be successful in the cadmium world
        return true;
    }

    function _cleanup(){
        DEBUG && this._log.debug("Media Request (" + this._requestId + ") cleanup ");
        return true;
    }

    /**
    * @param {String} url
    */
    function _swapUrl(url){
        DEBUG && this._log.debug("Media Request (" + this._requestId + ") swap to a new url " + url);
        this._mediaDownloader.setPrimaryCDN(this);
        return true;
        //Do not initiate download here, since pipeline is swapping every single mediaRequests in both sent and unsent arrays
    }

    //TODO: get response header from native cadmium
    /*function _getResponseHeader( name ) {

        if ( this._headers === undefined ) return null;

        var result = this._headers
                        .filter( function( hdr ) { return hdr.substr( 0, name.length + 1 ) == ( name + ':' ); } )
                        .map( function( hdr ) { return hdr.split(':').slice( 1 ).join(':').trim(); } )
                        .join( ', ' );
        return ( result === "" ) ? null : result;
    }

    function _getAllResponseHeaders() {
        if ( this._headers === undefined ) return "";

        return this._headers.join( '\r\n' );
    }*/


    ////////////////////////
    //Helper function
    ////////////////////////
    function _getRequestId(){
        return this._requestId;
    }

    function _toString(){
        var debugStr = "ID: " + this._requestId + ", isHeader:" + this.isHeader + ", pts:" + this.ptsStart + ", responseType: " + this._responseType + ", duration: " + this.durationMs + ", readystate: " + this._readyState;
        if (this.stream) {
            debugStr += ", bitrate:" + this.stream.bitrate;
        }
        return debugStr;
    }

    Object.defineProperties(this, /** @lends {MediaRequest.prototype} */{
        readyState:     { get: function() { return this._readyState; } },
        status:         { get: function() { return this._status; } },         // HTTP status code (only valid in FAILED state)
        failureCode:    { get: function() { return this._failureCode; } },      // valid in FAILED state
        failureString:  { get: function() { return this._failureString; } },    // valid in FAILED state
        nativeCode:     { get: function() { return this._nativeCode; } },      // valid in FAILED state
        bytesReceived:  { get: function() { return this._bytesReceived; } },    // valid after RECEIVING state
        response:       { get: function() { return this._response; } },           // valid in DONE state

        track:          { get: function() { return this._track; } },            // valid in all states
        label:          { get: function() { return this._label; } },            // valid in all states
        url:            { get: function() { return this._url; } },
        responseType:   { get: function() { return this._responseType; } },     // valid after open()
        byteRange:      { get: function() { return this._byteRange; } },        // valid after open()
        totalBytes:     { get: function() {                                     // valid after open()
                                return this._byteRange["end"] - this._byteRange["start"] + 1; } },
        loadTime:       { get: function() { return this._loadTime; } },         // timestamp of onloadstart
        firstbyteTime:  { get: function() { return this._firstbyteTime; } },    // timestamp of onfirstbyte
        lastEventTime:  { get: function() { return this._lastEventTime; } },      // timestamp of last event
        connect:        { get: function() { return this._connect; } },          // true if first response time includes TCP connect
        responseTimes:  { get: function() { return this._responseTimes; } },    // response times in ms
        readyStateName: { get: function() { return MediaRequest.READYSTATES.name[ this._readyState ]; } }
    });
}




MediaRequest.EVENTS = {
                //ONOPEN:                     "mr0",// Not used
                ONLOADSTART:                "mr1",  // OPENED -> SENT
                ONFIRSTBYTE:                "mr2",  // SENT -> RECEIVING
                ONPROGRESS:                 "mr3",  // (optional event in RECEIVING state)
                ONCOMPLETE:                 "mr4",  // RECEIVING -> DONE
                ONABORT:                    "mr5",  // (any except DONE) -> ABORTED
                ONERROR:                    "mr6"  // (any except DONE, ABORTED) -> FAILED
                //ONREADYSTATECHANGE:         "mr7",// Not used
            };
/**
* @const
*/
MediaRequest.READYSTATES =
            {
                UNSENT:                     0,      // Object created
                OPENED:                     1,      // open() has been called
                SENT:                       2,      // HTTP request has been sent (approx)
                RECEIVING:                  3,      // Data is arriving
                //PAUSED:                     4,    // Not used
                DONE:                       5,      // Complete
                FAILED:                     6,      // Failure
                ABORTED:                    7,      // Aborted by user

                name:[
                    'UNSENT',
                    'OPENED',
                    'SENT',
                    'RECEIVING',
                    //'PAUSED',
                    'DONE',
                    'FAILED',
                    'ABORTED'
                ]
            };

/**
* @const
*/
MediaRequest.RESPONSETYPES =
            {
                ARRAYBUFFER:                0,
                STREAM:                     1,

                name:[
                    'ARRAYBUFFER',
                    'STREAM'
                ]
            };

/**
* @const
*/
MediaRequest.ERRORCODES =
            {

                /**************************************************************
                 *  If you add any errors here, make sure they are
                 *  handled in ErrorDirector's map.
                 **************************************************************/
                NO_ERROR:                           -1,

                DNS_ERROR:                          0,
                DNS_TIMEOUT:                        1,
                DNS_QUERY_REFUSED:                  2,
                DNS_NOT_FOUND:                      3,

                CONNECTION_REFUSED:                 4,
                CONNECTION_TIMEOUT:                 5,
                CONNECTION_CLOSED:                  6,
                CONNECTION_RESET:                   7,
                CONNECTION_RESET_ON_CONNECT:        8,
                CONNECTION_RESET_WHILE_RECEIVING:   9,
                CONNECTION_NET_UNREACHABLE:         10,
                CONNECTION_NO_ROUTE_TO_HOST:        11,
                CONNECTION_NETWORK_DOWN:            12,
                CONNECTION_NO_ADDRESS:              13,
                CONNECTION_ERROR:                   14,

                HTTP_CONNECTION_ERROR:              15,
                HTTP_CONNECTION_TIMEOUT:            16,
                HTTP_CONNECTION_STALL:              17,

                HTTP_PROTOCOL_ERROR:                18,

                HTTP_RESPONSE_4XX:                  19,
                HTTP_RESPONSE_420:                  20,
                HTTP_RESPONSE_5XX:                  21,
                HTTP_TOO_MANY_REDIRECTS:            22,
                HTTP_TRANSACTION_TIMEOUT:           23,
                HTTP_MESSAGE_LENGTH_ERROR:          24,
                HTTP_HEADER_LENGTH_ERROR:           25,

                DNS_BAD_FAMILY:                     26,
                DNS_BAD_FLAGS:                      27,
                DNS_BAD_HINTS:                      28,
                DNS_BAD_NAME:                       29,
                DNS_BAD_STRING:                     30,
                DNS_CANCELLED:                      31,
                DNS_CHANNEL_DESTROYED:              32,
                DNS_CONNECTION_REFUSED:             33,
                DNS_EOF:                            34,
                DNS_FILE:                           35,
                DNS_FORMAT_ERROR:                   36,
                DNS_NOT_IMPLEMENTED:                37,
                DNS_NOT_INITIALIZED:                38,
                DNS_NO_DATA:                        39,
                DNS_NO_MEMORY:                      40,
                DNS_NO_NAME:                        41,
                DNS_QUERY_MALFORMED:                42,
                DNS_RESPONSE_MALFORMED:             43,
                DNS_SERVER_FAILURE:                 44,
                SOCKET_ERROR:                       45,
                TIMEOUT:                            46,
                HTTPS_CONNECTION_ERROR:             47,
                HTTPS_CONNECTION_TIMEOUT:           48,
                HTTPS_CONNECTION_REDIRECT_TO_HTTP:  49,
                HTTP_RESPONSE_420:                  50,

                name: [
                    'DNS_ERROR',
                    'DNS_TIMEOUT',
                    'DNS_QUERY_REFUSED',
                    'DNS_NOT_FOUND',
                    'CONNECTION_REFUSED',
                    'CONNECTION_TIMEOUT',
                    'CONNECTION_CLOSED',
                    'CONNECTION_RESET',
                    'CONNECTION_RESET_ON_CONNECT',
                    'CONNECTION_RESET_WHILE_RECEIVING',
                    'CONNECTION_NET_UNREACHABLE',
                    'CONNECTION_NO_ROUTE_TO_HOST',
                    'CONNECTION_NETWORK_DOWN',
                    'CONNECTION_NO_ADDRESS',
                    'CONNECTION_ERROR',
                    'HTTP_CONNECTION_ERROR',
                    'HTTP_CONNECTION_TIMEOUT',
                    'HTTP_CONNECTION_STALL',
                    'HTTP_PROTOCOL_ERROR',
                    'HTTP_RESPONSE_4XX',
                    'HTTP_RESPONSE_420',
                    'HTTP_RESPONSE_5XX',
                    'HTTP_TOO_MANY_REDIRECTS',
                    'HTTP_TRANSACTION_TIMEOUT',
                    'HTTP_MESSAGE_LENGTH_ERROR',
                    'HTTP_HEADER_LENGTH_ERROR',

                    'DNS_BAD_FAMILY',
                    'DNS_BAD_FLAGS',
                    'DNS_BAD_HINTS',
                    'DNS_BAD_NAME',
                    'DNS_BAD_STRING',
                    'DNS_CANCELLED',
                    'DNS_CHANNEL_DESTROYED',
                    'DNS_CONNECTION_REFUSED',
                    'DNS_EOF',
                    'DNS_FILE',
                    'DNS_FORMAT_ERROR',
                    'DNS_NOT_IMPLEMENTED',
                    'DNS_NOT_INITIALIZED',
                    'DNS_NO_DATA',
                    'DNS_NO_MEMORY',
                    'DNS_NO_NAME',
                    'DNS_QUERY_MALFORMED',
                    'DNS_RESPONSE_MALFORMED',
                    'DNS_SERVER_FAILURE',
                    'SOCKET_ERROR',
                    'TIMEOUT',
                    'HTTPS_CONNECTION_ERROR',
                    'HTTPS_CONNECTION_TIMEOUT',
                    'HTTPS_CONNECTION_REDIRECT_TO_HTTP',
                    'HTTP_RESPONSE_420'
                ]
            };



// -- cadmium-ase/media-source.js
/**
 * Shim layer to expose relevant MediaElement properties to ASE.
 *
 *
 * @param {Object} player
 * @constructor
*/

function MediaSourceASE( player ) {
    var platform = require(61);
    var log = new platform.playbackLog.CategoryLog('MediaSourceASE');
    log.trace('Inside MediaSourceASE');

    var _self = this,
        _mediaElement = platform.getMediaElement(),
        _eventSource = new EventSource();

    _self.readyState = MediaSourceASE.READYSTATES.CLOSED;
    _self.sourceBuffers = _mediaElement.sourceBuffers;
    _self.addSourceBuffer = _mediaElement.addSourceBuffer;
    _self.addSourceBuffers = _mediaElement.addSourceBuffers;
    _self.removeSourceBuffer = _mediaElement.removeSourceBuffer;
    _self.destroy = _mediaElement.destroy;
    _self.sourceId = platform.getMediaSourceCounter();
    platform.incrementMediaSourceCounter();
    /* exposed by NRDPMediaSource, not used by Cadmium*/
    _self.duration = undefined;

    _mediaElement.setASEMediaSourceId(_self.sourceId);
    //_mediaElement.open() is called when mediaElement is newed, 
    //so that we can streamline the control flow in ASE

    this.readyState = MediaSourceASE.READYSTATES.OPEN;
}
MediaSourceASE.READYSTATES ={
    CLOSED:                     0,
    OPEN:                       1,
    ENDED:                      2,

    name:[
        'CLOSED',
        'OPEN',
        'ENDED'
    ]
};



// -- cadmium-ase/getSampleManifestASE.js
/**
 * This function returns a hardcoded manifest object in the format that JS-ASE expects.
 * The manifest is for Example Short.
 *
 * It is likely that the URLs below will expire and the object will become useless.
 * To get a real-time manifest object for whatever title you are playing, do:
 * parseNccpAuthorizationResponse = parseNccpAuthorizationResponseASE
 * which replaces the code that parses the auth response.
 *
 *
 */
function getSampleManifestASE (playback) {
    return playback.manifest = {
        "movieId": "70136810",
        "mticket": {
            "tokendata": "NONE",
            "signature": "NONE"
        },
        "tracks": [
            {
                "type": 1,
                "stereo": false,
                "ict": false,
                "max_framerate_value": "6138",
                "max_framerate_scale": "256",
                "streams": [
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDPCozaaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=qmZdhJnSVuewknAnuYgxTkcnHT0",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDPCozaaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=mUxVGE1Bi67Hqrnv6XMF1k-Kn9w",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDPCozaaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=0BzH5IbTZudq3vdKQbnzHL3iVWA",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803786989",
                        "bitrate": 235,
                        "hd": false,
                        "superhd": false,
                        "res_w": 426,
                        "res_h": 240,
                        "pix_w": 4,
                        "pix_h": 3,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOAYXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=Vs-SpsEleNdI3AHfHVQkDkNq4zI",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDOAYXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=OOcO9b3wON4Y1d3k7fUnN5sPiTA",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOAYXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=ucktNc06mqV1tHXEgsax-26M924",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803787213",
                        "bitrate": 375,
                        "hd": false,
                        "superhd": false,
                        "res_w": 512,
                        "res_h": 288,
                        "pix_w": 4,
                        "pix_h": 3,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOBIDRaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=qlkphJC0PBrNordDF1rK7ZLTjWI",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDOBIDRaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=d47hAA5gUPiSOt1T95bCMNYEnRk",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOBIDRaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=VPdUHarD6TBNLzdQOI2YzGQCqK4",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803787742",
                        "bitrate": 560,
                        "hd": false,
                        "superhd": false,
                        "res_w": 682,
                        "res_h": 384,
                        "pix_w": 4,
                        "pix_h": 3,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOBoTSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=pcxTRO04Jo2vNOF9Gmg8FTOCjoI",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDOBoTSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=pU2xXEofj8hNVpwQAf6QpPO76n0",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOBoTSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=k16wQ2XWbOjrDKl-7jDE62PYXM8",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803787501",
                        "bitrate": 750,
                        "hd": false,
                        "superhd": false,
                        "res_w": 682,
                        "res_h": 384,
                        "pix_w": 4,
                        "pix_h": 3,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBA4TUaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=QKiihTkVPkUMYakkCaEUoDujliw",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDBA4TUaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=OXB5GQnolbBpbHeGNdftRUV62N4",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBA4TUaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=YzKippu4ekAeqNOrE42Ldhu1-ok",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803788007",
                        "bitrate": 1050,
                        "hd": false,
                        "superhd": false,
                        "res_w": 853,
                        "res_h": 480,
                        "pix_w": 4,
                        "pix_h": 3,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBAYzSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=hWZY8Aiwknnx8O7ZFFEMyprGdwM",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDBAYzSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=oCVRgMWvBT-U8CTcmzMchjwx8jk",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBAYzSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=CUM7dF82nRTdjySxcIL7o2i4JKw",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803788281",
                        "bitrate": 1750,
                        "hd": false,
                        "superhd": false,
                        "res_w": 853,
                        "res_h": 480,
                        "pix_w": 32,
                        "pix_h": 27,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBAIXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=hriGYUr_P8VGRIS25dldXzG6iYE",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDBAIXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=iyDwqgqPlKEmMm28-eWhCeBHtLk",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBAIXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=EKhUov4Ti-UZbR0yGMiUrXbLi2s",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803788313",
                        "bitrate": 2350,
                        "hd": true,
                        "superhd": false,
                        "res_w": 1280,
                        "res_h": 720,
                        "pix_w": 1,
                        "pix_h": 1,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBBITQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=26ETtjjD6kERrIZH-Qc4D_QGECM",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDBBITQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=pO6OCkW8os7S7fO7nsvQUxwLenU",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBBITQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=ls-qxBVqEEYK04_8tuyHxm0k0EY",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803788703",
                        "bitrate": 3000,
                        "hd": true,
                        "superhd": false,
                        "res_w": 1280,
                        "res_h": 720,
                        "pix_w": 1,
                        "pix_h": 1,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    }
                ]
            },
            {
                "type": 0,
                "track_id": "65737c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "disallowedtimedText": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "none"
                ],
                "streams": [
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHKAI3aaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=xTppQNrnwh_AO1bW5Yf9X_C07zs",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHKAI3aaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=ptS23btm-JCZy2YIiqmSqejFgso",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHKAI3aaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=Qtg2b4ZMMeGXzkKQMio2-GGlwIw",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816293399",
                        "bitrate": 64,
                        "channels": "2.0",
                        "language": "es",
                        "trackType": "PRIMARY"
                    },
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHMAIbVaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=rkSf03qm-Hg_og9IWYDhBCCqHy8",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHMAIbVaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=rY3YnOVex3xr8VTAZHww8bAY0Dw",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHMAIbVaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=XBmm_dm6oCbM86Mhs5owAc6c_OA",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816295326",
                        "bitrate": 96,
                        "channels": "2.0",
                        "language": "es",
                        "trackType": "PRIMARY"
                    }
                ]
            },
            {
                "type": 0,
                "track_id": "66727c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "disallowedtimedText": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "none"
                ],
                "streams": [
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KJ2MrgSzMAYTTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=6FxACMnxIlBjeirDNhGAq4McmKk",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KJ2MrgSzMAYTTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=zrMkNaBJh91dJvZfVUvZIkxr_Aw",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KJ2MrgSzMAYTTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=32Bk2t0fRRChAgd9sc5rh36nbQ8",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1774345200",
                        "bitrate": 64,
                        "channels": "2.0",
                        "language": "fr",
                        "trackType": "PRIMARY"
                    },
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHNBYbXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=BoeLnHGpIBFgoou4GMi3lK7YvTk",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHNBYbXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=2HPV-9bpUd9HClEtqn097uCFF6I",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHNBYbXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=1n77Zzty_BR6P9IK4NGCxlmUvJ8",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816294624",
                        "bitrate": 96,
                        "channels": "2.0",
                        "language": "fr",
                        "trackType": "PRIMARY"
                    }
                ]
            },
            {
                "type": 0,
                "track_id": "7a687c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "disallowedtimedText": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c"
                ],
                "streams": [
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHIA4zSaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=lY-Fmmqcqg3_t_ukYja13fFPupk",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHIA4zSaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=Q8U_DiaTZ3SCtomTGfbgBLgHTrA",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHIA4zSaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=K3McDdXSB7eptsfWDjykbXToXYM",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816291081",
                        "bitrate": 64,
                        "channels": "2.0",
                        "language": "zh",
                        "trackType": "PRIMARY"
                    },
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHKCoTXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=plhuwrIPllKFQxpejM_6T8zbex4",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHKCoTXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=xNnbfFQ5xim4XNCr7FYm_UkmTgY",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHKCoTXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=xwiRrEPhz_ns_OfVR0Q2YkHQk2E",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816293904",
                        "bitrate": 96,
                        "channels": "2.0",
                        "language": "zh",
                        "trackType": "PRIMARY"
                    }
                ]
            },
            {
                "type": 0,
                "track_id": "656e7c322e307c5072696d6172797c747275657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "disallowedtimedText": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c"
                ],
                "streams": [
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHLBYfXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=XjSqEv1CYrOcUt0kRObfNmZSqMA",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHLBYfXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=jYE51yKSaI0CLdExbzFc3KOeNvk",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHLBYfXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=sqNReiPj8D8-e-7GUzuteS5xYpw",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816292634",
                        "bitrate": 64,
                        "channels": "2.0",
                        "language": "en",
                        "trackType": "PRIMARY"
                    },
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHMBYPTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=vMcMutSI6h8JEBRe0mkVWqbibPg",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHMBYPTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=gZch8uZCx-frRDg8AEscRX5IXrU",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHMBYPTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=76tySe_D_cx4jjs-6LutpfwZSqs",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816295670",
                        "bitrate": 96,
                        "channels": "2.0",
                        "language": "en",
                        "trackType": "PRIMARY"
                    }
                ]
            },
            {
                "type": 0,
                "track_id": "64657c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "disallowedtimedText": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c"
                ],
                "streams": [
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHIC4bXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=V7hts0k2y0yVr6SHil2kNbAaKyk",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHIC4bXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=_BekWjpX0ZcIMhPcYFs0_QmDKz8",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHIC4bXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=m82To290gn_Uw80yYmKEE1MEYag",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816291824",
                        "bitrate": 64,
                        "channels": "2.0",
                        "language": "de",
                        "trackType": "PRIMARY"
                    },
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHPBoXbaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=jwg3ij1Bo6WbJ3Eg3JckjIbVqiI",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHPBoXbaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=P-SPsGfj6FMsA6lqMI6rgYAD2OY",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHPBoXbaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=WuEcP_whfKVf6kQMP0T69oosM_o",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816296518",
                        "bitrate": 96,
                        "channels": "2.0",
                        "language": "de",
                        "trackType": "PRIMARY"
                    }
                ]
            }
        ],
        "trickplays": [
            {
                "urls": [
                    "http://tp.akam.nflximg.com/tpa3/897/1980102897.bif"
                ],
                "width": "320",
                "height": "180",
                "pixelAspectX": "1",
                "pixelAspectY": "1",
                "interval": "10",
                "id": "1980102897"
            },
            {
                "urls": [
                    "http://tp.akam.nflximg.com/tpa1/083/1980103083.bif"
                ],
                "width": "240",
                "height": "122",
                "pixelAspectX": "1",
                "pixelAspectY": "1",
                "interval": "10",
                "id": "1980103083"
            }
        ],
        "duration": 670000,
        "locations": [
            {
                "key": "sjc002.ix-cr-01-high",
                "rank": 2,
                "level": 1,
                "weight": 160
            },
            {
                "key": "20",
                "rank": 5,
                "level": 0,
                "weight": 100
            },
            {
                "key": "lax001.ix-cr-02-high",
                "rank": 3,
                "level": 1,
                "weight": 140
            },
            {
                "key": "19",
                "rank": 4,
                "level": 0,
                "weight": 120
            },
            {
                "key": "ix.phl001.a-high",
                "rank": 1,
                "level": 1,
                "weight": 180
            }
        ],
        "servers": [
            {
                "name": "c001.phl001.ix.nflxvideo.net",
                "type": "OPEN_CONNECT_APPLIANCE",
                "id": 17328,
                "key": "ix.phl001.a-high",
                "rank": 1,
                "lowgrade": false
            },
            {
                "name": "c015.sjc002.ix.nflxvideo.net",
                "type": "OPEN_CONNECT_APPLIANCE",
                "id": 11066,
                "key": "sjc002.ix-cr-01-high",
                "rank": 2,
                "lowgrade": false
            },
            {
                "name": "c047.lax001.ix.nflxvideo.net",
                "type": "OPEN_CONNECT_APPLIANCE",
                "id": 10988,
                "key": "lax001.ix-cr-02-high",
                "rank": 3,
                "lowgrade": false
            },
            {
                "name": "akamaitp",
                "type": "BIG_CDN",
                "id": 19,
                "key": "19",
                "rank": 4,
                "lowgrade": false
            },
            {
                "name": "akamaiso",
                "type": "BIG_CDN",
                "id": 20,
                "key": "20",
                "rank": 5,
                "lowgrade": false
            }
        ],
        "video_tracks": [
            {
                "type": 1,
                "stereo": false,
                "ict": false,
                "max_framerate_value": "6138",
                "max_framerate_scale": "256",
                "streams": [
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDPCozaaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=qmZdhJnSVuewknAnuYgxTkcnHT0",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDPCozaaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=mUxVGE1Bi67Hqrnv6XMF1k-Kn9w",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDPCozaaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=0BzH5IbTZudq3vdKQbnzHL3iVWA",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803786989",
                        "bitrate": 235,
                        "hd": false,
                        "superhd": false,
                        "res_w": 426,
                        "res_h": 240,
                        "pix_w": 4,
                        "pix_h": 3,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOAYXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=Vs-SpsEleNdI3AHfHVQkDkNq4zI",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDOAYXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=OOcO9b3wON4Y1d3k7fUnN5sPiTA",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOAYXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=ucktNc06mqV1tHXEgsax-26M924",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803787213",
                        "bitrate": 375,
                        "hd": false,
                        "superhd": false,
                        "res_w": 512,
                        "res_h": 288,
                        "pix_w": 4,
                        "pix_h": 3,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOBIDRaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=qlkphJC0PBrNordDF1rK7ZLTjWI",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDOBIDRaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=d47hAA5gUPiSOt1T95bCMNYEnRk",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOBIDRaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=VPdUHarD6TBNLzdQOI2YzGQCqK4",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803787742",
                        "bitrate": 560,
                        "hd": false,
                        "superhd": false,
                        "res_w": 682,
                        "res_h": 384,
                        "pix_w": 4,
                        "pix_h": 3,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOBoTSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=pcxTRO04Jo2vNOF9Gmg8FTOCjoI",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDOBoTSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=pU2xXEofj8hNVpwQAf6QpPO76n0",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDOBoTSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=k16wQ2XWbOjrDKl-7jDE62PYXM8",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803787501",
                        "bitrate": 750,
                        "hd": false,
                        "superhd": false,
                        "res_w": 682,
                        "res_h": 384,
                        "pix_w": 4,
                        "pix_h": 3,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBA4TUaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=QKiihTkVPkUMYakkCaEUoDujliw",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDBA4TUaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=OXB5GQnolbBpbHeGNdftRUV62N4",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBA4TUaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=YzKippu4ekAeqNOrE42Ldhu1-ok",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803788007",
                        "bitrate": 1050,
                        "hd": false,
                        "superhd": false,
                        "res_w": 853,
                        "res_h": 480,
                        "pix_w": 4,
                        "pix_h": 3,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBAYzSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=hWZY8Aiwknnx8O7ZFFEMyprGdwM",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDBAYzSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=oCVRgMWvBT-U8CTcmzMchjwx8jk",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBAYzSaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=CUM7dF82nRTdjySxcIL7o2i4JKw",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803788281",
                        "bitrate": 1750,
                        "hd": false,
                        "superhd": false,
                        "res_w": 853,
                        "res_h": 480,
                        "pix_w": 32,
                        "pix_h": 27,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBAIXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=hriGYUr_P8VGRIS25dldXzG6iYE",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDBAIXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=iyDwqgqPlKEmMm28-eWhCeBHtLk",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBAIXQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=EKhUov4Ti-UZbR0yGMiUrXbLi2s",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803788313",
                        "bitrate": 2350,
                        "hd": true,
                        "superhd": false,
                        "res_w": 1280,
                        "res_h": 720,
                        "pix_w": 1,
                        "pix_h": 1,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    },
                    {
                        "type": 1,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBBITQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=26ETtjjD6kERrIZH-Qc4D_QGECM",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGQshSDBBITQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=pO6OCkW8os7S7fO7nsvQUxwLenU",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGQshSDBBITQaaSWdnuQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=ls-qxBVqEEYK04_8tuyHxm0k0EY",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "playready-h264mpl30-dash",
                        "downloadable_id": "1803788703",
                        "bitrate": 3000,
                        "hd": true,
                        "superhd": false,
                        "res_w": 1280,
                        "res_h": 720,
                        "pix_w": 1,
                        "pix_h": 1,
                        "framerate_value": 6138,
                        "framerate_scale": 256
                    }
                ]
            }
        ],
        "hasDrm": true,
        "hasClear": false,
        "audio_tracks": [
            {
                "type": 0,
                "track_id": "65737c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "disallowedtimedText": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "none"
                ],
                "streams": [
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHKAI3aaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=xTppQNrnwh_AO1bW5Yf9X_C07zs",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHKAI3aaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=ptS23btm-JCZy2YIiqmSqejFgso",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHKAI3aaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=Qtg2b4ZMMeGXzkKQMio2-GGlwIw",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816293399",
                        "bitrate": 64,
                        "channels": "2.0",
                        "language": "es",
                        "trackType": "PRIMARY"
                    },
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHMAIbVaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=rkSf03qm-Hg_og9IWYDhBCCqHy8",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHMAIbVaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=rY3YnOVex3xr8VTAZHww8bAY0Dw",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHMAIbVaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=XBmm_dm6oCbM86Mhs5owAc6c_OA",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816295326",
                        "bitrate": 96,
                        "channels": "2.0",
                        "language": "es",
                        "trackType": "PRIMARY"
                    }
                ]
            },
            {
                "type": 0,
                "track_id": "66727c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "disallowedtimedText": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "none"
                ],
                "streams": [
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KJ2MrgSzMAYTTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=6FxACMnxIlBjeirDNhGAq4McmKk",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KJ2MrgSzMAYTTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=zrMkNaBJh91dJvZfVUvZIkxr_Aw",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KJ2MrgSzMAYTTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=32Bk2t0fRRChAgd9sc5rh36nbQ8",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1774345200",
                        "bitrate": 64,
                        "channels": "2.0",
                        "language": "fr",
                        "trackType": "PRIMARY"
                    },
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHNBYbXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=BoeLnHGpIBFgoou4GMi3lK7YvTk",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHNBYbXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=2HPV-9bpUd9HClEtqn097uCFF6I",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHNBYbXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=1n77Zzty_BR6P9IK4NGCxlmUvJ8",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816294624",
                        "bitrate": 96,
                        "channels": "2.0",
                        "language": "fr",
                        "trackType": "PRIMARY"
                    }
                ]
            },
            {
                "type": 0,
                "track_id": "7a687c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "disallowedtimedText": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c"
                ],
                "streams": [
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHIA4zSaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=lY-Fmmqcqg3_t_ukYja13fFPupk",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHIA4zSaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=Q8U_DiaTZ3SCtomTGfbgBLgHTrA",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHIA4zSaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=K3McDdXSB7eptsfWDjykbXToXYM",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816291081",
                        "bitrate": 64,
                        "channels": "2.0",
                        "language": "zh",
                        "trackType": "PRIMARY"
                    },
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHKCoTXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=plhuwrIPllKFQxpejM_6T8zbex4",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHKCoTXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=xNnbfFQ5xim4XNCr7FYm_UkmTgY",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHKCoTXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=xwiRrEPhz_ns_OfVR0Q2YkHQk2E",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816293904",
                        "bitrate": 96,
                        "channels": "2.0",
                        "language": "zh",
                        "trackType": "PRIMARY"
                    }
                ]
            },
            {
                "type": 0,
                "track_id": "656e7c322e307c5072696d6172797c747275657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "disallowedtimedText": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c"
                ],
                "streams": [
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHLBYfXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=XjSqEv1CYrOcUt0kRObfNmZSqMA",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHLBYfXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=jYE51yKSaI0CLdExbzFc3KOeNvk",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHLBYfXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=sqNReiPj8D8-e-7GUzuteS5xYpw",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816292634",
                        "bitrate": 64,
                        "channels": "2.0",
                        "language": "en",
                        "trackType": "PRIMARY"
                    },
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHMBYPTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=vMcMutSI6h8JEBRe0mkVWqbibPg",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHMBYPTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=gZch8uZCx-frRDg8AEscRX5IXrU",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHMBYPTaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=76tySe_D_cx4jjs-6LutpfwZSqs",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816295670",
                        "bitrate": 96,
                        "channels": "2.0",
                        "language": "en",
                        "trackType": "PRIMARY"
                    }
                ]
            },
            {
                "type": 0,
                "track_id": "64657c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "disallowedtimedText": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c"
                ],
                "streams": [
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHIC4bXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=V7hts0k2y0yVr6SHil2kNbAaKyk",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHIC4bXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=_BekWjpX0ZcIMhPcYFs0_QmDKz8",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHIC4bXaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=m82To290gn_Uw80yYmKEE1MEYag",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816291824",
                        "bitrate": 64,
                        "channels": "2.0",
                        "language": "de",
                        "trackType": "PRIMARY"
                    },
                    {
                        "type": 0,
                        "urls": [
                            {
                                "url": "http://ipv6_1.lagg0.c047.lax001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHPBoXbaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=jwg3ij1Bo6WbJ3Eg3JckjIbVqiI",
                                "cdn_id": "10988"
                            },
                            {
                                "url": "http://198.45.62.144/?o=AQHaLKnhKgAlvg7KKGUpgCHPBoXbaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=P-SPsGfj6FMsA6lqMI6rgYAD2OY",
                                "cdn_id": "11066"
                            },
                            {
                                "url": "http://ipv6_1.lagg0.c001.phl001.ix.nflxvideo.net/?o=AQHaLKnhKgAlvg7KKGUpgCHPBoXbaaSWdmyQ3PU_lYttz2KuCXr7GxjNtXBfVSB3fDuKZoNi3YodUsgJnXPN8XT2vxBKCyt1KJJxWJ9WGsQJUuYHJvBRJ2Em4e80g7--&v=3&e=1415771983&t=WuEcP_whfKVf6kQMP0T69oosM_o",
                                "cdn_id": "17328"
                            }
                        ],
                        "content_profile": "heaac-2-dash",
                        "downloadable_id": "1816296518",
                        "bitrate": 96,
                        "channels": "2.0",
                        "language": "de",
                        "trackType": "PRIMARY"
                    }
                ]
            }
        ],
        "audioTrackList": [
            {
                "id": "65737c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "channels": "2.0",
                "codecName": "AAC",
                "disallowedSubtitleTracks": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "none"
                ],
                "isNative": false,
                "language": "es",
                "languageDescription": "Spanish",
                "rawTrackType": "primary",
                "trackType": "PRIMARY"
            },
            {
                "id": "66727c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "channels": "2.0",
                "codecName": "AAC",
                "disallowedSubtitleTracks": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "none"
                ],
                "isNative": false,
                "language": "fr",
                "languageDescription": "French",
                "rawTrackType": "primary",
                "trackType": "PRIMARY"
            },
            {
                "id": "7a687c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "channels": "2.0",
                "codecName": "AAC",
                "disallowedSubtitleTracks": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c"
                ],
                "isNative": false,
                "language": "zh",
                "languageDescription": "Chinese",
                "rawTrackType": "primary",
                "trackType": "PRIMARY"
            },
            {
                "id": "656e7c322e307c5072696d6172797c747275657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "channels": "2.0",
                "codecName": "AAC",
                "disallowedSubtitleTracks": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c"
                ],
                "isNative": true,
                "language": "en",
                "languageDescription": "English",
                "rawTrackType": "primary",
                "trackType": "PRIMARY"
            },
            {
                "id": "64657c322e307c5072696d6172797c66616c73657c6e6f6e657c756e6b6e6f776e7c756e6b6e6f776e7c417564696f7c756e6b6e6f776e7c7c",
                "channels": "2.0",
                "codecName": "AAC",
                "disallowedSubtitleTracks": [
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c6e627c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c70742d42527c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c66727c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                    "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c"
                ],
                "isNative": false,
                "language": "de",
                "languageDescription": "German",
                "rawTrackType": "primary",
                "trackType": "PRIMARY"
            }
        ],
        "timedtexttracks": [
            {
                "type": "timedtext",
                "id": "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c5375627469746c65737c756e6b6e6f776e7c546578747c636f6d6d656e746172797c61346639633637322d663464662d346131362d616437322d3738663663623239333963327c7361346639633637322d663464662d346131362d616437322d3738663663623239333963322e6c",
                "downloadableId": "1111614247",
                "rawTrackType": "subtitles",
                "trackType": "PRIMARY",
                "ttDownloadables": {
                    "simplesdh": {
                        "hashAlgo": "sha1",
                        "hashValue": "XDKfnmBtGfTxrgZzk9sjd6z0RxM=",
                        "downloadUrls": {
                            "20": "http://so0.akam.nflximg.com/soa2/247/1111614247.dfxp?v=1&e=1415683657&t=zmv6fvYzcaKBeEabvqq7SLqg2gA"
                        },
                        "size": 107001
                    },
                    "dfxp-ls-sdh": {
                        "hashAlgo": "sha1",
                        "hashValue": "fomzIy6aQ4HmuBCT+yQ7Ubk+8NM=",
                        "downloadUrls": {
                            "20": "http://so0.akam.nflximg.com/soa6/792/1111616792.dfxp?v=1&e=1415683657&t=QZxQ9VYWIcesYz-KGN4epslLmc8"
                        },
                        "size": 124043
                    }
                },
                "language": "es-x-cm",
                "languageDescription": "Spanish",
                "cdnlist": [
                    {
                        "name": "c059.sjc002.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 12731,
                        "key": "sjc002.ix-cr-02-high",
                        "rank": 1,
                        "lowgrade": false
                    },
                    {
                        "name": "c300.sjc002.dev.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 15693,
                        "key": "sjc002.ix-cr-01-high",
                        "rank": 2,
                        "lowgrade": false
                    },
                    {
                        "name": "c085.lax004.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 14960,
                        "key": "lax004.ix-asr-01-high",
                        "rank": 3,
                        "lowgrade": false
                    },
                    {
                        "name": "akamaitp",
                        "type": "BIG_CDN",
                        "id": 19,
                        "key": "19",
                        "rank": 4,
                        "lowgrade": false
                    },
                    {
                        "name": "akamaiso",
                        "type": "BIG_CDN",
                        "id": 20,
                        "key": "20",
                        "rank": 5,
                        "lowgrade": false
                    }
                ]
            },
            {
                "type": "timedtext",
                "id": "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c5375627469746c65737c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                "downloadableId": "778566404",
                "rawTrackType": "subtitles",
                "trackType": "PRIMARY",
                "ttDownloadables": {
                    "dfxp-ls-sdh": {
                        "hashAlgo": "sha1",
                        "hashValue": "8I4VoRmHyCKdPJRXplTJqcwf28A=",
                        "downloadUrls": {
                            "20": "http://so0.akam.nflximg.com/soa6/404/778566404.dfxp?v=1&e=1415683657&t=uYy5qaMZ5TqLwj6zOA6plt1qOhQ"
                        },
                        "size": 134421
                    },
                    "simplesdh": {
                        "hashAlgo": "sha1",
                        "hashValue": "Ems7qgwiPsalPuwgU0ol4i56pX0=",
                        "downloadUrls": {
                            "20": "http://so0.akam.nflximg.com/soa5/394/778566394.dfxp?v=1&e=1415683657&t=e2jabKftYQgiuRcMNaPot23Hp2Q"
                        },
                        "size": 81337
                    }
                },
                "language": "es",
                "languageDescription": "Spanish",
                "cdnlist": [
                    {
                        "name": "c059.sjc002.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 12731,
                        "key": "sjc002.ix-cr-02-high",
                        "rank": 1,
                        "lowgrade": false
                    },
                    {
                        "name": "c300.sjc002.dev.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 15693,
                        "key": "sjc002.ix-cr-01-high",
                        "rank": 2,
                        "lowgrade": false
                    },
                    {
                        "name": "c085.lax004.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 14960,
                        "key": "lax004.ix-asr-01-high",
                        "rank": 3,
                        "lowgrade": false
                    },
                    {
                        "name": "akamaitp",
                        "type": "BIG_CDN",
                        "id": 19,
                        "key": "19",
                        "rank": 4,
                        "lowgrade": false
                    },
                    {
                        "name": "akamaiso",
                        "type": "BIG_CDN",
                        "id": 20,
                        "key": "20",
                        "rank": 5,
                        "lowgrade": false
                    }
                ]
            },
            {
                "type": "timedtext",
                "id": "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c65737c466f726365647c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                "downloadableId": "778592140",
                "rawTrackType": "forced",
                "trackType": "PRIMARY",
                "ttDownloadables": {
                    "simplesdh": {
                        "hashAlgo": "sha1",
                        "hashValue": "f1T8f1y8LC9KnpshA2Su8GABcp4=",
                        "downloadUrls": {
                            "20": "http://so0.akam.nflximg.com/soa5/140/778592140.dfxp?v=1&e=1415683657&t=Tf4nGeiQP1ocfznwzpnSHvDaQio"
                        },
                        "size": 617
                    },
                    "dfxp-ls-sdh": {
                        "hashAlgo": "sha1",
                        "hashValue": "B48oqRnlcwHVPl3L4+typjOyQbg=",
                        "downloadUrls": {
                            "20": "http://so0.akam.nflximg.com/soa4/630/778597630.dfxp?v=1&e=1415683657&t=sQaL-iggc8FS5Rh4df7AUPjKUt8"
                        },
                        "size": 1002
                    }
                },
                "language": "es-x-fn",
                "languageDescription": "Off",
                "cdnlist": [
                    {
                        "name": "c059.sjc002.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 12731,
                        "key": "sjc002.ix-cr-02-high",
                        "rank": 1,
                        "lowgrade": false
                    },
                    {
                        "name": "c300.sjc002.dev.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 15693,
                        "key": "sjc002.ix-cr-01-high",
                        "rank": 2,
                        "lowgrade": false
                    },
                    {
                        "name": "c085.lax004.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 14960,
                        "key": "lax004.ix-asr-01-high",
                        "rank": 3,
                        "lowgrade": false
                    },
                    {
                        "name": "akamaitp",
                        "type": "BIG_CDN",
                        "id": 19,
                        "key": "19",
                        "rank": 4,
                        "lowgrade": false
                    },
                    {
                        "name": "akamaiso",
                        "type": "BIG_CDN",
                        "id": 20,
                        "key": "20",
                        "rank": 5,
                        "lowgrade": false
                    }
                ]
            },
            {
                "type": "timedtext",
                "id": "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c656e7c436c6f73656443617074696f6e737c756e6b6e6f776e7c546578747c7072696d6172797c7c",
                "downloadableId": "38782057",
                "rawTrackType": "closedcaptions",
                "trackType": "ASSISTIVE",
                "ttDownloadables": {
                    "dfxp-ls-sdh": {
                        "hashAlgo": "sha1",
                        "hashValue": "9xQmn17BQtU/3iWAR57xrNO+5bw=",
                        "downloadUrls": {
                            "20": "http://so0.akam.nflximg.com/soa2/057/38782057.dfxp?v=1&e=1415683657&t=le9dVRrzxPkMD54LBfF1-_FKq2E"
                        },
                        "size": 137582
                    },
                    "simplesdh": {
                        "hashAlgo": "sha1",
                        "hashValue": "dzYswvxETB2lRD3BenaWfXnyOuw=",
                        "downloadUrls": {
                            "20": "http://so0.akam.nflximg.com/soa6/989/2030152989.dfxp?v=1&e=1415683657&t=8dLdpcnUTILXRL6ZX9vsheX7G9k"
                        },
                        "size": 96350
                    }
                },
                "language": "en",
                "languageDescription": "English",
                "cdnlist": [
                    {
                        "name": "c059.sjc002.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 12731,
                        "key": "sjc002.ix-cr-02-high",
                        "rank": 1,
                        "lowgrade": false
                    },
                    {
                        "name": "c300.sjc002.dev.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 15693,
                        "key": "sjc002.ix-cr-01-high",
                        "rank": 2,
                        "lowgrade": false
                    },
                    {
                        "name": "c085.lax004.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 14960,
                        "key": "lax004.ix-asr-01-high",
                        "rank": 3,
                        "lowgrade": false
                    },
                    {
                        "name": "akamaitp",
                        "type": "BIG_CDN",
                        "id": 19,
                        "key": "19",
                        "rank": 4,
                        "lowgrade": false
                    },
                    {
                        "name": "akamaiso",
                        "type": "BIG_CDN",
                        "id": 20,
                        "key": "20",
                        "rank": 5,
                        "lowgrade": false
                    }
                ]
            },
            {
                "type": "timedtext",
                "id": "6e6f6e657c554e4b4e4f574e7c756e6b6e6f776e7c66616c73657c656e7c5375627469746c65737c756e6b6e6f776e7c546578747c636f6d6d656e746172797c61346639633637322d663464662d346131362d616437322d3738663663623239333963327c7361346639633637322d663464662d346131362d616437322d3738663663623239333963322e6c",
                "downloadableId": "1098606018",
                "rawTrackType": "subtitles",
                "trackType": "PRIMARY",
                "ttDownloadables": {
                    "simplesdh": {
                        "hashAlgo": "sha1",
                        "hashValue": "Ewdkq6v7uTm4WDwCMP5blmNaY/0=",
                        "downloadUrls": {
                            "20": "http://so0.akam.nflximg.com/soa3/018/1098606018.dfxp?v=1&e=1415683657&t=ZAZDtMh_oBfsaY4BwYtEa48y_Ig"
                        },
                        "size": 112833
                    },
                    "dfxp-ls-sdh": {
                        "hashAlgo": "sha1",
                        "hashValue": "dNid/3s2eWwun1r5mXmkRx4AXY0=",
                        "downloadUrls": {
                            "20": "http://so0.akam.nflximg.com/soa2/838/1098608838.dfxp?v=1&e=1415683657&t=P2rU6C1wM2smCaxJUS29zaGxl4U"
                        },
                        "size": 263609
                    }
                },
                "language": "en-x-cm",
                "languageDescription": "English",
                "cdnlist": [
                    {
                        "name": "c059.sjc002.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 12731,
                        "key": "sjc002.ix-cr-02-high",
                        "rank": 1,
                        "lowgrade": false
                    },
                    {
                        "name": "c300.sjc002.dev.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 15693,
                        "key": "sjc002.ix-cr-01-high",
                        "rank": 2,
                        "lowgrade": false
                    },
                    {
                        "name": "c085.lax004.ix.nflxvideo.net",
                        "type": "OPEN_CONNECT_APPLIANCE",
                        "id": 14960,
                        "key": "lax004.ix-asr-01-high",
                        "rank": 3,
                        "lowgrade": false
                    },
                    {
                        "name": "akamaitp",
                        "type": "BIG_CDN",
                        "id": 19,
                        "key": "19",
                        "rank": 4,
                        "lowgrade": false
                    },
                    {
                        "name": "akamaiso",
                        "type": "BIG_CDN",
                        "id": 20,
                        "key": "20",
                        "rank": 5,
                        "lowgrade": false
                    }
                ]
            }
        ]
    };
}


// -- heuristics/MediaStreamFilter.js
/**
* @constructor
*/
function MediaStreamFilter(playback) {
    var _self = this,
        _filters = [];

    // --------------------------------------------------------------------------------
    // -- public API

    _self.shouldDisallowStream = _shouldDisallowStream;

    //---------
    // private implementation

    MediaStreamFilter$_filterConstructors.forEach(function (createFilter) {
        var filter = createFilter(playback);
        if (filter) {
            _filters.push(filter);
        }
    });

    if (_filters.length > 0) {
        playback.addEventListener(Playback$playbackstart, _dropBuffer);
    }

    /**
    * Returns "falsy" if stream is ok to use. Or array of filterIds that are preventing this from being used.
    */
    function _shouldDisallowStream(stream) {
        var disallowedBy = [];
        var i = _filters.length;
        while (i--) {
            var filter = _filters[i];
            if (filter.shouldDisallowStream(stream)) {
                disallowedBy.push(filter.filterId);
            }
        }
        if (disallowedBy.length) {
            return disallowedBy;
        }
    }

    // drop chunks from buffer based on stream filters
    function _dropBuffer() {
        playback.mediaBuffer.discardVideoMediaBasedOnFilter();
    }
}

/**
* @param {function(Playback): {filterId:string,shouldDisallowStream:function(CadmiumMediaStream)}} createFilter
*/
function MediaStreamFilter$register(createFilter) {
    MediaStreamFilter$_filterConstructors.push(createFilter);
}

var MediaStreamFilter$_filterConstructors = [];


// -- heuristics/MediaStreamFilter-droppedFrames.js
// filters out streams that drop frames
MediaStreamFilter$register(MediaStreamFilter$createDroppedFramesFilter);

var HISTORICAL_DROPPED_FRAMES_HISTORY_PERSIST_KEY = 'DroppedFramesHistory';
var HISTORICAL_DROPPED_FRAMES_SESSION_PERSIST_KEY = 'DroppedFramesSession';

function MediaStreamFilter$createDroppedFramesFilter(playback) {

    var _log = new playback.log.CategoryLog('DFF'),
        _observationsByHeight = {},
        _policy = config.droppedFrameRateFilterPolicy,
        _droppedFramesSession = {},
        _droppedFramesHistory = [],
        _sortedHeights = [],
        _lastTickInfo,
        _intervalMilliseconds = 1000,
        _maxObservations = config.droppedFrameRateFilterMaxObservation,
        _minStreamHeight = config.droppedFrameRateFilterMinHeight,
        _streamHeightCutoff = MAX_RESOLUTION,
        _shouldCheckAbove,
        _intervalId,
        _storageSessionLimit = config.droppedFramesStorageSessionLimit,
        _storageInterval = config.droppedFramesStorageInterval,
        _storageIntervalId,
        _numCores = navigator['hardwareConcurrency'] || 0,
        _previousSessionFlag;

    if (!config.droppedFrameRateFilterEnabled) {
        // return nothing, if filter is not enabled
        return;
    }

    /**
    * @param {CadmiumMediaStream} stream
    */
    function shouldDisallowStream_droppedFrames(stream) {
        // sanity check, never disallow lowest stream
        if (stream.lower && stream.height > _minStreamHeight) {
            return stream.height >= getStreamHeightCutoff();
        }
    }

    function onStateChanged() {
        var playing = (playback.presentingState.value == PresentingState$PLAYING && playback.state.value == Playback$STATE_NORMAL);
        if (_intervalId) {
            if (!playing) {
                // stop ticking
                clearInterval(_intervalId);
                _intervalId = undefined;
                _lastTickInfo = undefined;

                if (_storageSessionLimit) {
                    clearInterval(_storageIntervalId);
                    _storageIntervalId = undefined;
                }
            }
        } else {
            if (playing) {
                // start ticking
                _intervalId = setInterval(tick, _intervalMilliseconds);

                if (_storageSessionLimit) {
                    _storageIntervalId = setInterval(_storeSessionData, _storageInterval);
                }
            }
        }
    }

    function tick() {
        // see if we can capture an observation, which is number of dropped frames since last tick for current stream

        var chunk = playback.presentedVideo.value;
        var stream = chunk && chunk.stream;
        var height = stream && stream.height;
        if (height > 0) {
            var now = clock$getTime();
            var droppedFrameCount = playback.mediaPresenter.getDroppedFrameCount();
            // if there was something to compare to, and it was within reasonable time
            if (_lastTickInfo && now - _lastTickInfo.time < 2 * _intervalMilliseconds) {
                // and ignore the observations that had a resolution switch
                if (height == _lastTickInfo.height) {
                    var droppedFrameDelta = droppedFrameCount - _lastTickInfo.droppedFrameCount;
                    addObservation(height, droppedFrameDelta);
                    addObservationToHistory(height, droppedFrameDelta);
                }
            }
            _lastTickInfo = {
                time: now,
                droppedFrameCount: droppedFrameCount,
                height: height
            };
            playback.playbackInfoPanel.setCustom('DFR', _observationsByHeight);
        }
    }

    function _storeSessionData() {
        var sessionData = {
            'xid': playback.xid,
            'data': _droppedFramesSession
        };
        storage.save(HISTORICAL_DROPPED_FRAMES_SESSION_PERSIST_KEY, sessionData);
    }

    function _loadHistory() {
        debug$assert(storage);

        playback.addEventListener(Playback$closing, function () {
            _storeSessionData();
        });

        // load the dropped frame history
        _droppedFramesHistory = [];
        storage.load(HISTORICAL_DROPPED_FRAMES_HISTORY_PERSIST_KEY, function (result) {
            if (result.success) {
                _droppedFramesHistory = result.data;
            }

            // load the dropped frame history from the previous session
            var droppedFrameSession = {};
            storage.load(HISTORICAL_DROPPED_FRAMES_SESSION_PERSIST_KEY, function (result) {
                if (result.success) {
                    droppedFrameSession = result.data;
                }

                // only add previous session data to the history, if there is any
                if (droppedFrameSession && droppedFrameSession['data'] && Object.keys(droppedFrameSession['data']).length) {
                    _droppedFramesHistory.push(droppedFrameSession);

                    // remove old session data
                    if (_droppedFramesHistory.length > _storageSessionLimit) {
                        _droppedFramesHistory.shift();
                    }

                    // save the combined dropped frames history
                    storage.save(HISTORICAL_DROPPED_FRAMES_HISTORY_PERSIST_KEY, _droppedFramesHistory);

                    // clear the previous session data
                    storage.save(HISTORICAL_DROPPED_FRAMES_SESSION_PERSIST_KEY, {});
                }
            });
        });
    }

    function addObservation(height, droppedFrames) {
        // we observed, that within last second, stream with [height], dropped [droppedFrames] frames
        var a = _observationsByHeight[height];
        if (!a) {
            // set-up data structures for this height
            _observationsByHeight[height] = a = [];
            if (height > _minStreamHeight) {
                // don't need to track streams lower than min height
                _sortedHeights.push(height);
                Array$sortNumbers(_sortedHeights);
            }
        }
        // we should re-check this height against the policy, if there was a dropped frame and we aren't alrady planning to check for lower height
        if (droppedFrames > 0 && !(_shouldCheckAbove < height)) {
            _shouldCheckAbove = height;
        }
        a.push(droppedFrames);
        if (a.length > _maxObservations) {
            a.shift();
        }
    }

    function addObservationToHistory(height, droppedFrames) {
        var observations = _droppedFramesSession[height];
        if (!observations) {
            _droppedFramesSession[height] = observations = {};
        }

        var count = observations[droppedFrames];
        observations[droppedFrames] = count ? count + 1 : 1;
    }

    function getStreamHeightCutoff() {

        _getStreamHeightCutoffFromPreviousSession();

        if (_shouldCheckAbove) {
            var length = _sortedHeights.length,
                i,
                height,
                observations;

            for (i = 0; i < length; i++) {
                height = _sortedHeights[i];
                if (height >= _shouldCheckAbove && height < _streamHeightCutoff) {
                    observations = _observationsByHeight[height];
                    if (observations && MediaStreamFilter$createDroppedFramesFilter$checkPolicy(_policy, observations)) {
                        if (_streamHeightCutoff != height) {
                            _log.warn('Restricting resolution due to high number of dropped frames', { 'MaxHeight': height });

                            playback.bitrateRestriction.set({
                                'reason': 'droppedFrames',
                                'height': height
                            });

                            if (config.droppedFrameRateFilterWithoutRebufferEnabled) {
                                // cancel current downloads
                                if (!config.useASE){
                                    playback.mediaDownloader.clearInProgressDownloads(function (job) {
                                        return job.recommendation.videoStream.height >= height;
                                    });
                                }
                                // clear buffer based on resolution restriction, but try not to rebuffer
                                dispatch(playback.mediaBuffer.discardVideoMediaBasedOnFilterWithoutRebuffer);
                            } else {
                                dispatch(playback.mediaBuffer.discardVideoMediaBasedOnFilter);
                            }

                            return config.droppedFrameRateFilterBasedOnPreviousSession = _streamHeightCutoff = height;
                        }
                    }
                }
            }
            _shouldCheckAbove = undefined;
        }

        return _streamHeightCutoff;
    }

    function _getStreamHeightCutoffFromPreviousSession() {
        // limit the resolution based on dropped frames in any previous session
        if (!_previousSessionFlag && config.droppedFrameRateFilterBasedOnPreviousSessionPolicy && config.droppedFrameRateFilterBasedOnPreviousSession) {
            if (playback.cpuSpeed < config.droppedFrameRateFilterBasedOnPreviousSessionPolicy[_numCores]) {
                _streamHeightCutoff = Math$min(_streamHeightCutoff, config.droppedFrameRateFilterBasedOnPreviousSession);

                playback.bitrateRestriction.set({
                    'reason': 'droppedFramesPreviousSession',
                    'height': config.droppedFrameRateFilterBasedOnPreviousSession
                });
            }
        }

        _previousSessionFlag = true;
    }

    function _getAverages() {
        var averages = {};

        if (_droppedFramesSession) {
            _sortedHeights.forEach(function (height) {
                var observations = _droppedFramesSession[height];
                if (observations) {
                    var totalOccurences = 0,
                        totalDroppedFrames = 0;

                    enumerateOwnProperties(observations, function (numberOfDroppedFrames, numberOfOccurences) {
                        totalDroppedFrames += parseInt10(numberOfDroppedFrames);
                        totalOccurences += numberOfOccurences;
                    });

                    averages[height] = totalDroppedFrames / totalOccurences;
                }
            });
        }

        return averages;
    }

    function _getPercentiles(droppedFramesList) {
        var percentiles = {};

        droppedFramesList.forEach(function (droppedFrames) {
            percentiles[droppedFrames] = {};
        });

        if (_droppedFramesSession) {
            Array$sortNumbers(droppedFramesList);

            _sortedHeights.forEach(function (height) {
                var observations = _droppedFramesSession[height];
                if (observations) {
                    var totalOccurences = 0,
                        totalOccurencesGreaterThanOrEqualToLimit = 0;

                    enumerateOwnProperties(observations, function (numberOfDroppedFrames, numberOfOccurences) {
                        totalOccurences += numberOfOccurences;
                    });

                    var numberOfDroppedFramesBuckets = Object.keys(observations);
                    Array$sortNumbers(numberOfDroppedFramesBuckets);
                    var bucketIndex = numberOfDroppedFramesBuckets.length - 1;
                    var currentBucket = numberOfDroppedFramesBuckets[bucketIndex];

                    for (var i = droppedFramesList.length - 1; i >= 0; i--) {
                        var droppedFrames = droppedFramesList[i];

                        while (currentBucket >= droppedFrames && bucketIndex >= 0) {
                            var occurences = observations[currentBucket];
                            if (occurences) {
                                totalOccurencesGreaterThanOrEqualToLimit += occurences;
                            }

                            currentBucket = numberOfDroppedFramesBuckets[--bucketIndex];
                        }

                        percentiles[droppedFrames][height] = Math$round(totalOccurencesGreaterThanOrEqualToLimit / totalOccurences * 100);
                    }
                }
            });
        }

        return percentiles;
    }

    if (_storageSessionLimit) {
        playback.addEventListener(Playback$authorized, _loadHistory);
    }

    playback.droppedFrames = {
        getAverages: _getAverages,
        getPercentiles: _getPercentiles
    };

    playback.state.addListener(onStateChanged);
    playback.presentingState.addListener(onStateChanged);

    return {
        filterId: 'df',
        shouldDisallowStream: shouldDisallowStream_droppedFrames
    };
}

function MediaStreamFilter$createDroppedFramesFilter$checkPolicy(policy, observations) {
    // does the given [policy] = [ [4, 15] /* if more than 4 observation of 15+ dropped frames */, [20, 1] ],
    // kick-on for given [observations]
    var length = policy.length,
        i,
        oLength = observations.length,
        j,
        dfr,
        max,
        p;

    for (i = 0; i < length; i++) {
        p = policy[i];
        max = p[0];
        dfr = p[1];
        for (j = 0; j < oLength; j++) {
            if (observations[j] >= dfr) {
                if (--max <= 0) {
                    return true;
                }
            }
        }
    }
}



// -- heuristics/MediaStreamFilter-lackOfOutputProtection.js
// filters out HD streams if the Constriction is active
// Constriction is when the CDM downscales the ouput to 480p. This happens when no trusted path (proper video driver and HDCP monitor) is detected.
MediaStreamFilter$register(function createFilter_lackOfOutputProtection(playback) {

    /**
    * @param {CadmiumMediaStream} stream
    */
    function shouldDisallowStream_lackOfOutputProtection(stream) {
        var requiresHdcp = stream.requiresHdcp;
        if (requiresHdcp) {
            var mediaPresenter = playback.mediaPresenter;
            if (mediaPresenter && mediaPresenter.getConstrictionActive()) {
                // if constiction is active, only allow non-HD streams
                return requiresHdcp;
            }
        }
    }

    return {
        filterId: 'op',
        shouldDisallowStream: shouldDisallowStream_lackOfOutputProtection
    };

});



// -- heuristics/MediaStreamFilter-remoteAttestation.js
if (REMOTE_ATTESTATION_IMPLIES_HW_ACCELERATION) {
    // Presense of remote attestation implies GPU acceleration

    // Allow HD only if there is evidence of remote attestation in license.
    MediaStreamFilter$register(MediaStreamFilter$remoteAttestationFilter);
}

function MediaStreamFilter$remoteAttestationFilter(playback) {

    var _log = new playback.log.CategoryLog('RAF'),
        _hasRemoteAttestation;

    /**
    * @param {CadmiumMediaStream} stream
    */
    function shouldDisallowStream_remoteAttestationFilter(stream) {
        if (!_hasRemoteAttestation) {
            return stream.requiresHdcp || stream.contentProfile !== videoProfile$H264_MPL30;
        }
    }

    function onNeedLicense(args) {
        playback.removeEventListener(MediaPresenter$needlicense, onNeedLicense);

        // only exampline the first license challenge
        // If it has RA info in it, we are ok to play HD streams.

        try {
            if (isRemoteAttestationPresentInChallenge(args.data)) {
                _hasRemoteAttestation = true;
                playback.setVideoDiagInfo('HasRA', true);
            }
            _log.trace('RA check', { 'HasRA': _hasRemoteAttestation });
        }
        catch (e) {
            _log.error('RA check exception', e);
        }
    }

    playback.addEventListener(MediaPresenter$needlicense, onNeedLicense);

    return {
        filterId: 'ra',
        shouldDisallowStream: shouldDisallowStream_remoteAttestationFilter
    };

}


// -- heuristics/MediaStreamFilter-incorrectChunks.js
MediaStreamFilter$register(MediaStreamFilter$incorrectChunks);
 
/**
 * If for some reason a stream does not have the same number of chunks as the mediaBuffer expects, disable that stream.
 * @param playback
 */
function MediaStreamFilter$incorrectChunks(playback) {
    
    if (!config.incorrectChunkCountEnabled) {
        // return nothing, if filter is not enabled
        return;
    }

    var _log = new log.CategoryLog('IncorrectChunks Filter'),
        invalidStreamMap = {};

    function logInvalidStream (stream) {
        if (!invalidStreamMap[stream.downloadableId]) {
            invalidStreamMap[stream.downloadableId] = stream;
            _log.error("Stream disabled because chunk count does not match media buffer", {'downloadableId': stream.downloadableId});
        }
    }

    /**
    * @param {CadmiumMediaStream} stream
    */
    function shouldDisallowStream_incorrectChunksFilter(stream) {
        if (!stream.header) {
            return false
        } else {
            if (stream.header.chunkInfos.length !== playback.mediaBuffer.videoChunks.length) {
                logInvalidStream(stream);
                return true;
            } else {
                return false;
            }
        }
    }

    return {
        filterId: 'ic',
        shouldDisallowStream: shouldDisallowStream_incorrectChunksFilter
    };

}


// -- heuristics/SustainableBitrateMeter.js
/**
* @constructor
*/
function SustainableBitrateMeter(mediaBuffer, audioStream) {
    var _testDuration,
        _audioChunkDuration,
        _videoChunkDuration,
        _audioChunkCount,
        _videoChunkCount,
        _audioChunkSize;

    debug$assert(mediaBuffer);

    var audioChunks = mediaBuffer.audioChunks;
    var videoChunks = mediaBuffer.videoChunks;
    var lastChunk;

    // try to ignore the last chunk, since it's shorter than a typical chunk size
    lastChunk = audioChunks.last.previous || audioChunks.last;
    _audioChunkDuration = Math$floor(lastChunk.endTime / (lastChunk.index + 1));
    lastChunk = videoChunks.last.previous || videoChunks.last;
    _videoChunkDuration = Math$floor(lastChunk.endTime / (lastChunk.index + 1));

    // how long will it take us to download audioChunkDuration * videoChunkDuration worth of content (so it's round number of video and audio chunks)?
    _testDuration = _audioChunkDuration * _videoChunkDuration;
    _audioChunkCount = _videoChunkDuration; // _testDuration / audioChunkDuration
    _videoChunkCount = _audioChunkDuration; // _testDuration / videoChunkDuration

    // audio chunk size is fixed...
    _audioChunkSize = _audioChunkDuration * (audioStream.bitrate * KBPStoBPMS);

    // an approximate video bitrate, given current chunk sizes and audio bitrate that we can sustain.
    // this value should be used keeping VBR in mind (for example 1000 bitrate stream can vary from 500 to 1500).
    function _calculateSustainableVideoBitrate(bandwidth, latency) {
        // solve following equasion for videoChunkSize
        // mediaDuration = downloadTime = audioChunkCount * (_latency + audioChunkSize / _bandwidth) + videoChunkCount * (_latency + videoChunkSize / _bandwidth);
        var videoChunkSize = (((_testDuration - _audioChunkCount * (latency + _audioChunkSize / bandwidth)) / _videoChunkCount) - latency) * bandwidth;
        return Math$floor((videoChunkSize / _videoChunkDuration) * BPMStoKBPS);
    };

    this.calculateSustainableVideoBitrate = _calculateSustainableVideoBitrate;
};


// -- heuristics/BandwidthMeter.js
/**
 * @constructor
 */
function BandwidthMeter(playback) {
    var _log = new playback.log.CategoryLog('BandwidthMeter'),
        _sustainableBitrateMeter,
        _measurements = [],
        _latency = 100,
        _throughput = 1000 * KBPStoBPMS,  // BytesPerMillisecond
        _throughput60 = 0, // throughput in the first 60 seconds
        _transferTime = 0,
        _totalBytes = 0,
        _latestCDN,
        _latestRequestTime;

    DEBUG && _log.debug('Starting BandwidthMeter');
    playback.addEventListener(HttpPlayback$downloadcomplete, _onDownloadComplete);
    playback.addEventListener(Playback$closing, function () {
        _initThroughputTimer && _initThroughputTimer.stopTimer();
    });

    var _initThroughputTimer = new TimeoutMonitor(60000, _getThroughput60);
    _initThroughputTimer.ensureTimer();

    this.getLatency = function () { return _latency};
    this.getThroughput =  function () { return _throughput};
    this.getThroughput60 = function () {return _throughput60};
    this.getTotalBytes = function () { return _totalBytes};
    this.getTransferTime = function () { return _transferTime};
    this.getLatestCDN = function () { return _latestCDN};
    this.getLatestRequestTime = function () { return _latestRequestTime};
    this.calculateDownloadTime = _calculateDownloadTime;
    this.calculateSustainableVideoBitrate = _calculateSustainableVideoBitrate;
    this.calculateNormalizedBandwidth = _calculateNormalizedBandwidth;

    function _onDownloadComplete(response) {
        var measurements = response.measurements;
        var request = response.request;
        if (request.cdn) {
            _latestCDN = request.cdn.location.id;
        }
        _latestRequestTime = measurements.requestTime;
        if (response.success && measurements.contentLength > BandwidthMeter$smallContentLength && response.type == http$RESPONSETYPE_BINARY) {
            var predictedDownloadTime = _calculateDownloadTime(measurements.contentLength);
            var actualDownloadTime = measurements.responseEndTime - measurements.requestTime;
            DEBUG && _log.debug('Download complete', {
                'Length': measurements.contentLength,
                'Acuracy': (predictedDownloadTime / actualDownloadTime).toFixed(2),
                'PredictedTime': Number$formatMillisecond(predictedDownloadTime),
                'ActualTime': Number$formatMillisecond(actualDownloadTime)
            });

            _measurements.push(measurements);
            while (_measurements.length > BandwidthMeter$_maxMeasurements) {
                _measurements.shift();
            }
            _calculateAggregate();
        }
    };

    function _calculateAggregate() {
        var i,
            adjustedLatency,
            adjustedResponseStartTime,
            totalLatency = 0,
            measurement,
            measurementsCount = _measurements.length;
        // reset variables for this aggregation cycle
        _totalBytes = 0;
        _transferTime = 0;
        if (measurementsCount > 0) {
            // Latency, is the average of all clamped [responseStartTime - requestTime]
            // Bandwidth, is total bytes transfered over the period while network was used
            // Since we can assume that measurements are sorted by "responseEndTime", start from latest measurement
            // and walk backwards, looking for gaps in network usage.

            var networkUsageStart;
            var networkUsageEnd;
            i = measurementsCount;
            while (i--) {
                measurement = _measurements[i];
                adjustedLatency = calculateLatency(measurement);
                adjustedResponseStartTime = measurement.requestTime + adjustedLatency;
                totalLatency += adjustedLatency;
                _totalBytes += measurement.contentLength;

                // does the current measurement ovelap with the "networkUsageStart-networkUsageEnd" range?
                if (!(measurement.responseEndTime > networkUsageStart)) {
                    // nope, found a gap
                    // add the usage time to total and start a new "networkUsageStart-networkUsageEnd" segment
                    _transferTime += (networkUsageEnd - networkUsageStart) || 0;
                    networkUsageEnd = measurement.responseEndTime;
                }
                networkUsageStart = adjustedResponseStartTime;
            }
            _transferTime += (networkUsageEnd - networkUsageStart) || 0;

            _latency = Math$ceil(totalLatency / measurementsCount); // latencies are already clamped
            _throughput = Number$clamp(_totalBytes / _transferTime, BandwidthMeter$_minThroughput, BandwidthMeter$_maxThroughput);
            playback.fireEvent(BandwidthMeter$aggregateUpdated);
        }
        DEBUG && _log.debug('Network speed', { 'Throughput': (_throughput * BPMStoKBPS).toFixed(0) + ' KBPS', 'Latency': _latency.toFixed(0) + ' ms' });
    };

    function _calculateDownloadTime(sizeInBytes) {
        return _latency + sizeInBytes / _throughput;
    };

    function _calculateSustainableVideoBitrate() {
        debug$assert(playback.mediaBuffer);
        _sustainableBitrateMeter = _sustainableBitrateMeter || new SustainableBitrateMeter(playback.mediaBuffer, playback.primaryAudioStream);
        var bitrate = _sustainableBitrateMeter.calculateSustainableVideoBitrate(_throughput, _latency);
        debug$assert(bitrate + playback.audioStream.value.bitrate <= (_throughput * BPMStoKBPS));
        return bitrate;
    };

    function _calculateNormalizedBandwidth() {
        return calculateNormalizedBandwidth(_latency, _throughput);
    };

    function _getThroughput60() {
        _throughput60 = _throughput;
        _initThroughputTimer.stopTimer();
    }
};

function calculateNormalizedBandwidth(latency, throughput) {
    // normalized bandwidth is declared as bandwidth for downloading CBR 1750 in 4 second chunks.
    var sizeInBytes = 1750 * 1024 * 4 / 8;
    return Math$floor((sizeInBytes / (latency + sizeInBytes / throughput)) * BPMStoKBPS);
};

function calculateLatency(downloadMeasurements) {
    // clamp latency, to deal with large receive buffers (in some cases whole download looks like one large latency, then instancely receives the data)
    // TODO: make this configurable and AB test the results
    debug$assertUInt(downloadMeasurements.requestTime);
    debug$assertUInt(downloadMeasurements.responseStartTime);
    debug$assertUInt(downloadMeasurements.responseEndTime);
    var latency = Math$min(
        downloadMeasurements.responseStartTime - downloadMeasurements.requestTime,
        (downloadMeasurements.responseEndTime - downloadMeasurements.requestTime) * BandwidthMeter$_maxLatencyFraction);
    latency = Math$floor(latency);
    latency = Number$clamp(latency, BandwidthMeter$_minLatency, BandwidthMeter$_maxLatency);
    return latency;
};

function calculateLatencyAndThroughput(downloadMeasurements) {
    var latency = calculateLatency(downloadMeasurements);
    var transferTime = (downloadMeasurements.responseEndTime - (downloadMeasurements.requestTime + latency));
    var throughput = Number$clamp(Math$floor(downloadMeasurements.contentLength / transferTime), BandwidthMeter$_minThroughput, BandwidthMeter$_maxThroughput);
    debug$assertUInt(transferTime);
    debug$assertUInt(downloadMeasurements.contentLength);
    return {
        latency: latency,
        throughput: throughput
    };
};

var BandwidthMeter$_minThroughput = 100 * KBPStoBPMS; // BytesPerMillisecond
var BandwidthMeter$_maxThroughput = 40000 * KBPStoBPMS; // BytesPerMillisecond

var BandwidthMeter$_minLatency = 1;
var BandwidthMeter$_maxLatency = 2000;
// latency can't be more than 80% of the total time
var BandwidthMeter$_maxLatencyFraction = 0.8;

var BandwidthMeter$_maxMeasurements = 10;

// responses with less than this bytes are not taken into account
var BandwidthMeter$smallContentLength = 1024;


// -- heuristics/PlaybackHeuristics.js
/**
* @constructor
*/
function PlaybackHeuristics(playback) {
    var _log = new playback.log.CategoryLog('PlaybackHeuristics'),
        _bandwidthMeter = playback.bandwidthMeter,
        _diagnostics = playback.diagnostics,
        _diagnostics$buffersimulation = 'buffersimulation',
        _diagBuffersimulationModel = {},
        _rebuferForecastSimulationResult,
        _videoStreamList,
        _prebufferMaxMilliseconds = config.prebufferMaxMilliseconds;

    // --------------------------------------------------------------------------------
    // -- public API

    mixIn(this,
    /** @lends {PlaybackHeuristics.prototype} */
    ({
        getAudioRecommendation: _getAudioRecommendation,

        getPrebufferingRecommendation: _getPrebufferingRecommendation,

        getBufferingRecommendation: _getBufferingRecommendation,

        isRebufferForecasted: _isRebufferForecasted,

        shouldAbortDownloads: _shouldAbortDownloads,

        getSafeToDownloadAdditionalData: _getSafeToDownloadAdditionalData,

        getMinimumSafeBufferLevel: _getMinimumSafeBufferLevel
    }));

    // --------------------------------------------------------------------------------
    // -- private implementation

    // diagnostic panel
    if (DEBUG) {
        _diagnostics.register(_diagnostics$buffersimulation, function () {
            return _diagBuffersimulationModel;
        });
    }

    playback.addEventListener(MediaBuffer$changed, function () {
        // every time we get more data, make forecast recalculate
        _rebuferForecastSimulationResult = undefined;
    });

    playback.addEventListener(Playback$playbackstart, function() {
        _prebufferMaxMilliseconds = config.rebufferMaxMilliseconds;
    });

    function _getAudioRecommendation(mustHaveHeader) {
        // this is called when we only just donloaded some headers, so it's avery rough estimation
        // basically we want to pick higher audio stream, only if we are very confident that we have decent bandwidth
        var audioBitrate = _bandwidthMeter.calculateNormalizedBandwidth() / config.audioBandwidthDenominator;
        return playback.getAudioStreamList().firstBelow(audioBitrate, mustHaveHeader);
    };

    // comes up with a video stream recommendation for what to do when prebuffering
    /**
     * @param {boolean=} carreraFallbackToDefault
     */
    function _getPrebufferingRecommendation(carreraFallbackToDefault) {
        _updateStreamList(carreraFallbackToDefault);

        var sustainableVideoBitrate = _bandwidthMeter.calculateSustainableVideoBitrate(),
            bestVideoBitrate = Math$round(interpolateArrays(config.prebufferBitrate, sustainableVideoBitrate)[0]);

        // TODO: would be nice to maxBufferSizeBytes into account, but this isn't really a real scenario unless byte limit is very small
        // and we want to limit prebuffer bitrate

        var videoStream = _videoStreamList.firstBelow(bestVideoBitrate + 1, true);

        // Only glitch can cause us not to find a stream... there is always a stream with header
        debug$assert(videoStream);
        videoStream = videoStream || playback.primaryVideoStream;

        // simulate buffer levels for that stream...
        var mediaBuffer = playback.mediaBuffer,
            simulationParams = config.prebufferSimulationParams,
            simulationResult = _simulateBufferLevels(_bandwidthMeter, simulationParams[2], videoStream),
            nextAudioChunkThatNeedsMedia = mediaBuffer.getNextAudioChunkThatNeedsMedia(),
            nextVideoChunkThatNeedsMedia = mediaBuffer.getNextVideoChunkThatNeedsMedia(),
            remainingAudio = nextAudioChunkThatNeedsMedia ? mediaBuffer.audioChunks.last.endTime - nextAudioChunkThatNeedsMedia.startTime : 0,
            remainingVideo = nextVideoChunkThatNeedsMedia ? mediaBuffer.videoChunks.last.endTime - nextVideoChunkThatNeedsMedia.startTime : 0,
            currentAudio = mediaBuffer.getAudioBufferLength(),
            currentVideo = mediaBuffer.getVideoBufferLength();

        var needMoreAudioMilliseconds = -simulationResult.lowestAudioBufferLevel + config.minDecoderBufferMilliseconds + (simulationParams[0] || 0),
            needMoreVideoMilliseconds = -simulationResult.lowestVideoBufferLevel + config.minDecoderBufferMilliseconds + (simulationParams[1] || 0);

        needMoreAudioMilliseconds = Math$max(
            needMoreAudioMilliseconds,
            config.prebufferMinAudioMilliseconds - currentAudio);

        needMoreAudioMilliseconds = Math$min(
            needMoreAudioMilliseconds,
            Math$max(_prebufferMaxMilliseconds - currentAudio, 0),
            remainingAudio);

        needMoreVideoMilliseconds = Math$max(
            needMoreVideoMilliseconds,
            config.prebufferMinVideoMilliseconds - currentVideo);
        needMoreVideoMilliseconds = Math$min(
            needMoreVideoMilliseconds,
            Math$max(_prebufferMaxMilliseconds - currentVideo, 0),
            remainingVideo);

        DEBUG && _log.debug('Prebuffering recommended at ' + videoStream.bitrate, {
            'BestBitrate': bestVideoBitrate,
            'SustainableVideo': sustainableVideoBitrate,
            'SimulatedLowest': Number$formatMillisecond(simulationResult.lowestAudioBufferLevel) + ' / ' + Number$formatMillisecond(simulationResult.lowestVideoBufferLevel),
            'NeedMore': Number$formatMillisecond(needMoreAudioMilliseconds) + ' / ' + Number$formatMillisecond(needMoreVideoMilliseconds)
        }, mediaBuffer);

        _setSimulatedBufferLevels(simulationResult.simulatedBufferLevels);

        // also let's get a header for a stream that would be better suited to prebuffer at
        var betterVideoStream = _videoStreamList.firstBelow(bestVideoBitrate + 1, false);
        if (betterVideoStream == videoStream && betterVideoStream.header) {
            // and if we have that, get the header for a stream we would be switching up to
            betterVideoStream = _getBestHeaderToDownload(videoStream);
        }

        return {
            videoStream: videoStream,
            getHeaderFor: betterVideoStream,
            needMoreAudioMilliseconds: needMoreAudioMilliseconds,
            needMoreVideoMilliseconds: needMoreVideoMilliseconds
        };
    };

    // comes up with a video stream recommendation for what to do while playback is in progress
    function _getBufferingRecommendation() {
        _updateStreamList();

        var recommendation = _getVideoStreamRecommendationBasedOnBandwidth();
        var videoStream = recommendation.videoStream;

        // do we have extra time in buffer to afford this download?
        var getHeaderFor = _getBestHeaderToDownload(videoStream);
        if (getHeaderFor) {
            var lowestBufferLevel = Math$min(recommendation.lowestAudioBufferLevel, recommendation.lowestVideoBufferLevel);
            var headerDownloadTime = _bandwidthMeter.calculateDownloadTime(getHeaderFor.estimateHeaderSize());
            if (!(headerDownloadTime <= lowestBufferLevel)) {
                // we can't maintain current bitrate and get a header
                // in this case, although a little counter-intuitive, but we should make sure we have lowest bitrate stream headers
                var lowestStream = _videoStreamList[0];
                getHeaderFor = (!lowestStream.header) ? lowestStream : null;
            };
        }

        return {
            videoStream: videoStream,
            getHeaderFor: getHeaderFor
        };
    };

    function _isRebufferForecasted() {
        _updateStreamList();
        var lowestStreamWithHeader = _videoStreamList.firstAbove(0, true);
        _rebuferForecastSimulationResult = _simulateBufferLevels(_bandwidthMeter, 0, lowestStreamWithHeader);
        return _rebuferForecastSimulationResult.lowestAudioBufferLevel < 0 || _rebuferForecastSimulationResult.lowestVideoBufferLevel < 0;
    };

    function _shouldAbortDownloads() {
        var currentVideoBitrate = playback.videoStream.value.bitrate,
            lowestStream = _videoStreamList.firstAbove(0, false),
            lowestVideoBitrate = lowestStream.bitrate,
            belowSafeBufferLevel = playback.mediaBuffer.getNormalizedBufferLength() < config.abortDownloadBufferThreshhold;

        return belowSafeBufferLevel && currentVideoBitrate !== lowestVideoBitrate && _isRebufferForecasted();
    }

    function _getSafeToDownloadAdditionalData(sizeInBytes) {
        var recommendation = _getVideoStreamRecommendationBasedOnBandwidth();
        var lowestBufferLevel = {
            lowestAudioBufferLevel: recommendation.lowestAudioBufferLevel - config.additionalDownloadSimulationParams[0],
            lowestVideoBufferLevel: recommendation.lowestVideoBufferLevel - config.additionalDownloadSimulationParams[1],
        }
        lowestBufferLevel = Math$min(lowestBufferLevel.lowestAudioBufferLevel, lowestBufferLevel.lowestVideoBufferLevel);
        var downloadTime = _bandwidthMeter.calculateDownloadTime(sizeInBytes);
        downloadTime *= (1 + config.additionalDownloadSimulationParams[2] * 0.01);
        return downloadTime < lowestBufferLevel;
    }

    function _getMinimumSafeBufferLevel() {
        _updateStreamList();

        var highestVideoStream = _videoStreamList[_videoStreamList.length - 1],
            simulationResult = _simulateBufferLevels(_bandwidthMeter, config.bufferingSimulationParams[2], highestVideoStream),
            videoBufferLevel = playback.mediaBuffer.getVideoBufferLength();

        return  videoBufferLevel - simulationResult.lowestVideoBufferLevel;
    }

    function _getBestHeaderToDownload(videoStream) {
        var getHeaderFor = _getSwitchUpStream(videoStream);
        while (getHeaderFor && getHeaderFor.header) {
            // first priority is a header for a stream we will be switching up to
            // after that, back-fill the lower streams
            getHeaderFor = getHeaderFor.lower;
        }
        return getHeaderFor;
    };

    /**
    * @param {boolean=} carreraFallbackToDefault
    */
    function _updateStreamList(carreraFallbackToDefault) {
        var streams = playback.createFilteredVideoStreamList();

        if (carreraFallbackToDefault) {
            streams = _filterStreamsForCarreraFallback(streams);
        }

        var streamsLength = streams.length;
        CadmiumMediaStreams$addMethodsToArray(streams);
        for (var i = 0; i < streamsLength; i++) {
            streams[i].lower = streams[i - 1];
            streams[i].higher = streams[i + 1];
        };
        _videoStreamList = streams;
    };

    function _getSwitchUpStream(videoStream) {
        var higherVideoStream = _videoStreamList.firstAbove(videoStream.bitrate);

        // try the first bitrate above current one
        // Note: this will also handle the case when the videoStream is no longer available
        if (!higherVideoStream.higher) {

            // if there is nothing higher, we are done
            return higherVideoStream;
        }

        var bufferLength = playback.mediaBuffer.getBufferLength(),
            switchUpSimulationParams = interpolateArrays(config.bufferingSwitchUpSimulationParams, bufferLength),
            switchUpBitrate = interpolateArrays(config.switchUpToBitrate, videoStream.bitrate)[0];

        // not more than the max sustainable
        switchUpBitrate = Math$min(switchUpBitrate, _bandwidthMeter.calculateSustainableVideoBitrate() / (1 + switchUpSimulationParams[2] / 100));

        var switchUpStream = _videoStreamList.firstBelow(switchUpBitrate + 1);

        if (switchUpStream.bitrate <= higherVideoStream.bitrate) {
            // always at least one bitrate higher than current
            return higherVideoStream;
        } else {
            return switchUpStream;
        };
    };

    /**
    * @param {Array=} switchUpSimulatedBufferLevels
    */
    function _setSimulatedBufferLevels(simulatedBufferLevels, switchUpSimulatedBufferLevels) {
        if (DEBUG) {
            _diagBuffersimulationModel = {
                'current': simulatedBufferLevels,
                'switchUp': switchUpSimulatedBufferLevels
            };
            _diagnostics.notifyUpdated(_diagnostics$buffersimulation);
        }
    };

    function _getVideoStreamRecommendationBasedOnBandwidth() {
        // start with higher or current stream
        var simulationResult,
            nextHighestStreamSimulatedLevels,
            lastDownloadedVideoStream = playback.downloadedVideo.value.stream,
            videoStream = _getSwitchUpStream(lastDownloadedVideoStream),
            lowestVideoStreamWithHeader,
            bufferLength = playback.mediaBuffer.getBufferLength(),
            staySimulationParams = interpolateArrays(config.bufferingSimulationParams, bufferLength),
            switchUpSimulationParams = interpolateArrays(config.bufferingSwitchUpSimulationParams, bufferLength);

        var simulationParams,
            audioRebufferThreshold,
            videoRebufferThreshold;

        while (videoStream) {
            if (videoStream.header) {
                simulationParams = videoStream.bitrate > lastDownloadedVideoStream.bitrate ? switchUpSimulationParams : staySimulationParams;
                audioRebufferThreshold = config.minDecoderBufferMilliseconds + (simulationParams[0] || 0),
                videoRebufferThreshold = config.minDecoderBufferMilliseconds + (simulationParams[1] || 0);

                lowestVideoStreamWithHeader = videoStream;
                simulationResult = _simulateBufferLevels(_bandwidthMeter, simulationParams[2], videoStream);
                if (simulationResult.lowestAudioBufferLevel < audioRebufferThreshold || simulationResult.lowestVideoBufferLevel < videoRebufferThreshold) {
                    DEBUG && _log.debug('Simulation of ' + videoStream.bitrate + ', will rebuffer', {
                        'LowestLevels': Number$formatMillisecond(simulationResult.lowestAudioBufferLevel) + ' / ' + Number$formatMillisecond(simulationResult.lowestVideoBufferLevel)
                    });

                    if (videoStream.bitrate <= lastDownloadedVideoStream.bitrate && config.doNotSwitchDownIfBufferIsAboveMilliseconds && bufferLength > config.doNotSwitchDownIfBufferIsAboveMilliseconds) {
                        DEBUG && _log.debug('Above doNotSwitchDownIfBufferIsAboveMilliseconds threshold, staying on current stream', playback.mediaBuffer);
                        break;
                    }

                    nextHighestStreamSimulatedLevels = simulationResult.simulatedBufferLevels;
                }
                else {
                    // we do not anitcipate a rebuffer, pick this stream
                    DEBUG && _log.debug('Simulation of ' + videoStream.bitrate + ', will not rebuffer', {
                        'LowestLevels': Number$formatMillisecond(simulationResult.lowestAudioBufferLevel) + ' / ' + Number$formatMillisecond(simulationResult.lowestVideoBufferLevel)
                    });
                    break;
                }
            }
            videoStream = videoStream.lower;
        }

        _setSimulatedBufferLevels(simulationResult.simulatedBufferLevels, nextHighestStreamSimulatedLevels);

        if (videoStream) {
            DEBUG && _log.debug('Feasable stream found', videoStream);
        } else {
            videoStream = lowestVideoStreamWithHeader;
            DEBUG && _log.debug('No feasable streams found, using lowest that has a header', videoStream);
        }

        return {
            videoStream: videoStream,
            lowestAudioBufferLevel: simulationResult.lowestAudioBufferLevel - audioRebufferThreshold,
            lowestVideoBufferLevel: simulationResult.lowestVideoBufferLevel - videoRebufferThreshold
        };
    };

    function _selectAudioStreamWithHeader() {
        for (var audioTrackIndex in playback.audioTrackList) {
            for (var streamIndex in playback.audioTrackList[audioTrackIndex].streams) {
                if (playback.audioTrackList[audioTrackIndex].streams[streamIndex].header != null) {
                    return playback.audioTrackList[audioTrackIndex].streams[streamIndex];
                }
            }
        }
        return null;    // There is no way we should ever get here, but if we do it will just get an exception just like 
                        // it did before trying to finding a usable stream.
    }

    function _simulateBufferLevels(bandwidthMeter, bandwidthReduction, videoStream) {
        var bandwidthRatio = ((bandwidthReduction || 0) / 100.0) + 1,
            mediaTime = playback.mediaTime.value,
            mediaBuffer = playback.mediaBuffer,
            audioStream = playback.audioStream.value,
            audioChunks = mediaBuffer.audioChunks,
            videoChunks = mediaBuffer.videoChunks,
            audioChunkInfos = audioStream.header && audioStream.header.chunkInfos,
            videoChunkInfos = videoStream.header.chunkInfos,
            simulatedBufferLevels = [];

        if (audioChunkInfos == null) {
            audioStream = _selectAudioStreamWithHeader();
            audioChunkInfos = audioStream.header.chunkInfos;
        }
        simulatedBufferLevels['reduction'] = bandwidthReduction;

        debug$assert(mediaBuffer);
        var maxBufferSize = config.maxBufferSizeMilliseconds; 
        if (config.maxBufferSizeBytes) {
            // This is a quick way to take maxBufferSizeBytes into account, by converting it to MS based on average bitrate.
            // TODO: take maxBufferSizeBytes into account by doing what MediaBuffer does. 
            var combinedBytesPerMilllisecond = (audioStream.bitrate + videoStream.bitrate) * KBPStoBPMS * VBR_CEIL;
            maxBufferSize = Math$min(maxBufferSize, Math$floor(config.maxBufferSizeBytes / combinedBytesPerMilllisecond));
        }
        var maxForwardBufferSize = maxBufferSize - config.backBufferSizeMilliseconds;

        debug$assertInt(maxForwardBufferSize);

        // for simulation, buffer level is the cushion from a rebuffer
        // hence we subtract the minDecoderBufferMilliseconds

        var audioChunk = audioChunks.getForTime(mediaTime);
        var audioBufferLevel = Math$max(audioChunk.startTime - mediaTime, 0);

        var videoChunk = videoChunks.getForTime(mediaTime);
        var videoBufferLevel = Math$max(videoChunk.startTime - mediaTime, 0);

        function pushCurrent() {
            if (DEBUG) {
                simulatedBufferLevels.push({
                    'mediaTime': mediaTime,
                    'audioBufferLevel': audioBufferLevel,
                    'audioBitrate': audioStream.bitrate,
                    'videoBufferLevel': videoBufferLevel,
                    'videoBitrate': videoStream.bitrate
                });
            }
        };

        function appendExistingMedia() {
            // Note: check for [< maxForwardBufferSize] so we take future buffer compaction into account
            while (audioChunk && audioChunk.media && audioBufferLevel < maxForwardBufferSize) {
                audioBufferLevel += audioChunk.duration;
                audioChunk = audioChunk.next;
            }
            while (videoChunk && videoChunk.media && videoBufferLevel < maxForwardBufferSize) {
                videoBufferLevel += videoChunk.duration;
                videoChunk = videoChunk.next;
            }
        };
        appendExistingMedia();
        // we switch down after we pass this marker
        var switchDownMediaTime = mediaTime + videoBufferLevel + config.highStreamSimulationMilliseconds;
        function switchDownIfNeedTo() {
            if (mediaTime >= switchDownMediaTime) {
                // find a lower stream tha thas a header
                for (var lowerVideoStream = videoStream.lower; lowerVideoStream && !lowerVideoStream.header; lowerVideoStream = lowerVideoStream.lower) { };

                // if there is one, switch down
                if (lowerVideoStream) {
                    videoStream = lowerVideoStream;
                    videoChunkInfos = lowerVideoStream.header.chunkInfos;
                }
                // and kill this function, so we don't run it again
                switchDownIfNeedTo = NOOP;
            }
        };

        var predictionLimitMediaTime = config.simulationLimitMilliseconds ? mediaTime + Math$min(videoBufferLevel, audioBufferLevel) + config.simulationLimitMilliseconds : MAX_MEDIA_TIME;

        var lowestAudioBufferLevel = audioBufferLevel,
            lowestVideoBufferLevel = videoBufferLevel;

        var chunkInfo,
            downloadSize,
            downloadTime,
            waitTime,
            audioBufferGain,
            videoBufferGain;

        pushCurrent();

        while (mediaTime < predictionLimitMediaTime) {
            // if there is buffer, use it
            appendExistingMedia();
            downloadSize = 0;
            audioBufferGain = 0;
            videoBufferGain = 0;

            // don't go above max buffer level
            // this is where we wait for the buffer levels to drop bellow max level
            waitTime = Math$min(audioBufferLevel - maxForwardBufferSize, videoBufferLevel - maxForwardBufferSize);
            if (waitTime > 0) {
                mediaTime += waitTime;
                audioBufferLevel -= waitTime;
                videoBufferLevel -= waitTime;
                pushCurrent();
            }

            // download data
            if (audioChunk && (audioBufferLevel < videoBufferLevel || !videoChunk)) {
                // Next chunk is audio if: we need more audio AND (have less audio OR no more video)
                chunkInfo = audioChunkInfos[audioChunk.index];
                downloadSize = chunkInfo.length;
                audioBufferGain = chunkInfo.duration;
                audioChunk = audioChunk.next;
            } else if (videoChunk) {
                // otherwise it's a video chunk, if we have one
                // switch down to lower video stream, if we need to
                switchDownIfNeedTo();
                chunkInfo = videoChunkInfos[videoChunk.index];
                // work-around the alternative stream being shorter than primary stream
                if (chunkInfo) {
                    downloadSize = chunkInfo.length;
                    videoBufferGain = chunkInfo.duration;
                    videoChunk = videoChunk.next;
                }
            }

            if (downloadSize > 0) {
                // we downloaded a single chunk

                // estimate how long it took to download it
                downloadTime = bandwidthMeter.calculateDownloadTime(downloadSize) * bandwidthRatio;

                // by the time download completes, we will consume just as much milliseconds of buffer as it took to download that chunk
                mediaTime += downloadTime;
                audioBufferLevel -= downloadTime;
                videoBufferLevel -= downloadTime;
                pushCurrent();

                // and this is the lowest buffer level,
                // right before the download is complete, but before appending the media we downloaded
                if (lowestAudioBufferLevel > audioBufferLevel) {
                    lowestAudioBufferLevel = audioBufferLevel;
                }
                if (lowestVideoBufferLevel > videoBufferLevel) {
                    lowestVideoBufferLevel = videoBufferLevel;
                }

                // and finally append the buffer we gained with the download
                audioBufferLevel += audioBufferGain;
                videoBufferLevel += videoBufferGain;
                pushCurrent();
            }
            else {
                // nothing else to download, we are done
                break;
            }
        }

        return {
            lowestAudioBufferLevel: lowestAudioBufferLevel,
            lowestVideoBufferLevel: lowestVideoBufferLevel,
            simulatedBufferLevels: simulatedBufferLevels
        };
    };
    /**
     * @param {Object} streams to filter
     *
     * If during Carrera, we fall back to default CDN selection, we need to disallow the higher Carrera streams
     */
    function _filterStreamsForCarreraFallback(streams) {
        var initialVideoBitratesForCarreraFallback =
                playback.getVideoStreamList().toBitrates(config.initialVideoBitratesForCarreraFallback),
            len = streams.length,
            toReturn = [];
        for (var i=0; i<len; i++) {
            if (initialVideoBitratesForCarreraFallback.indexOf(streams[i].bitrate) !== -1) {
                toReturn.push(streams[i]);
            }
        }
        return toReturn;
    }
};




// -- heuristics/BufferBasedBitrateRestriction.js
/*
 * TY's SIGCOMM submission can be found on confluence: http://go/bufferbased
 * Notation used in the comments:
 * C(t): The system capacity at time t. System capacity includes the overall throughput, including network bandwidth, server response time and client process time.
 * B(t): The buffer occupancy at time t.
 * R(t): The video rate we picked at time t.
 * R_min: The lowest video rate.
 * R_max: The highest video rate.
 */




/**
* @constructor
*/
function BufferBasedBitrateRestriction(playback) {
    
    /** @const */
    var PLAYSTATE_NORMAL = 0;
    /** @const */
    var PLAYSTATE_AFTERSEEK = 1;
    /** @const */
    var PLAYSTATE_AFTERREBUFFER = 2;

    var that = new PlaybackHeuristics(playback),
        _bbconfig = config.bufferBased;
    //configurable QoE nobs
    var _maxReservoirSizeMilliseconds = _bbconfig.maxReservoirSizeMilliseconds,
        _maxOutageProtectionMilliseconds = _bbconfig.maxOutageProtectionMilliseconds,
        _maxCushionSizeInBufferPercentage = _bbconfig.maxCushionSizeInBufferPercentage,
        _reservoirLookAheadChunks = _bbconfig.reservoirLookAheadChunks,
        _startupQualityOptimization = _bbconfig.startupQualityOptimization,
        _dynamicReservoir = _bbconfig.dynamicReservoir,
        _startupPhaseInChunks = _bbconfig.startupPhaseInChunks,
        _isReservoirManualSet = _bbconfig.isReservoirManualSet,
        _manualReservoirMilliseconds = _bbconfig.manualReservoirMilliseconds, //only useful when Reservoir is manually set
        _isCushionManualSet = _bbconfig.isCushionManualSet,
        _manualCushionMilliseconds = _bbconfig.manualCushionMilliseconds,
        _isLookingAhead = _bbconfig.isLookingAhead,
        _isUsingRateMap = _bbconfig.isUsingRateMap,
        _isUsingStrictMaxChunkSize = _bbconfig.isUsingStrictMaxChunkSize, //set true when we cannot cancel a chunk download
        _transitFromInitialPhase = _bbconfig.transitFromInitialPhase,
        _startupSafeRateCalculationEnabled = _bbconfig.startupSafeRateCalculationEnabled,
        _startupThresholdFunctionOfBufferEnabled = _bbconfig.startupThresholdFunctionOfBufferEnabled,
        _startupLookAheadCalculationEnabled = _bbconfig.startupLookAheadCalculationEnabled,
        _startupLookAheadChunks = _bbconfig.startupLookAheadChunks; //only useful when _startupLookAheadCalculationEnabled is true



    //static variable for the states between each decisions
    var _playState = PLAYSTATE_NORMAL,
        _bandwidthMeter = playback.bandwidthMeter,
        _log = new playback.log.CategoryLog('BufferBasedBitrateRestriction'),
        _diagnostics = playback.diagnostics,
        _diagnostics$buffersimulation = 'buffersimulation',
        _maxBufferSizeMilliseconds,
        _videoStreamList,
        _reservoirSizeMilliseconds = 0,
        _cushionSizeMilliseconds = 0,
        _historySize = 10,
        _bufferHistory = [],
        _rateSelectionHistory = [],
        _startupChunks = _startupPhaseInChunks,
        _outageProtectionMilliseconds = 0,
        _chunkMilliseconds,
        _videoRateBeforeSeek,
        _afterSeekTargetStream,
        _highBufferAfterRebufferOrSeek,
        _maxVariationInChunkSize;


    // --------------------------------------------------------------------------------
    // -- public API



    // --------------------------------------------------------------------------------
    // -- private implementation

    playback.addEventListener(Playback$repositioned, function () {
        _playState = PLAYSTATE_AFTERSEEK;
    });

    playback.addEventListener(Playback$bufferUnderrun, function () {
        _playState = PLAYSTATE_AFTERREBUFFER;
    });

    /**
    * Initialize the lists for buffer levels and rate selections
    */
    function _clearHistory() {
        _bufferHistory = [];
        _rateSelectionHistory = [];
    }

    //Borrowed from Playback Heuristics
    //TODO: Maria might move this to MediaBuffer
    function _getMaxBufferSizeMilliseconds() {
        var maxBufferSizeMilliseconds = config.maxBufferSizeMilliseconds, 
            audioStream = playback.audioStream, 
            videoStream = playback.videoStream;
        if (config.maxBufferSizeBytes) {
            // This is a quick way to take maxBufferSizeBytes into account, by converting it to MS based on average bitrate.
            // TODO: take maxBufferSizeBytes into account by doing what MediaBuffer does.
            var combinedBytesPerMilllisecond = (audioStream.bitrate + videoStream.bitrate) * KBPStoBPMS * VBR_CEIL;
            maxBufferSizeMilliseconds = Math$min(maxBufferSizeMilliseconds, Math$floor(config.maxBufferSizeBytes / combinedBytesPerMilllisecond));
        }
        return maxBufferSizeMilliseconds;
    }

    //Borrowed from Playback Heuristics
    function _updateStreamList() {
        var streams = playback.createFilteredVideoStreamList(),
            streamsLength = streams.length;
        CadmiumMediaStreams$addMethodsToArray(streams);
        for (var i = 0; i < streamsLength; i++) {
            streams[i].lower = streams[i - 1];
            streams[i].higher = streams[i + 1];
        }
        _videoStreamList = streams;
    }

    //Borrowed from Playback Heuristics
    function _getBestHeaderToDownload(videoStream) {
        var getHeaderFor = _getSwitchUpStream(videoStream);
        while (getHeaderFor && getHeaderFor.header) {
            // first priority is a header for a stream we will be switching up to
            // after that, back-fill the lower streams
            getHeaderFor = getHeaderFor.lower;
        }
        return getHeaderFor;
    }


    //Borrowed from Playback Heuristics
    function _getSwitchUpStream(videoStream) {
        var higherVideoStream = _videoStreamList.firstAbove(videoStream.bitrate);

        // try the first bitrate above current one
        // Note: this will also handle the case when the videoStream is no longer available
        if (!higherVideoStream.higher) {
            // if there is nothing higher, we are done
            return higherVideoStream;
        }

        var bufferLength = playback.mediaBuffer.getBufferLength(),
            switchUpSimulationParams = interpolateArrays(config.bufferingSwitchUpSimulationParams, bufferLength),
            switchUpBitrate = interpolateArrays(config.switchUpToBitrate, videoStream.bitrate)[0];

        // not more than the max sustainable
        switchUpBitrate = Math$min(switchUpBitrate, _bandwidthMeter.calculateSustainableVideoBitrate() / (1 + switchUpSimulationParams[2] / 100));

        var switchUpStream = _videoStreamList.firstBelow(switchUpBitrate + 1);

        if (switchUpStream.bitrate <= higherVideoStream.bitrate) {
            // always at least one bitrate higher than current
            return higherVideoStream;
        } else {
            return switchUpStream;
        }
    }

    /**
     * If using RateMap (i.e., pick a rate based on the overall average chunk size), return the chunk size of the overall stream.
     * Otherwise, return the average chunk size over the next "numOfChunk".
     *
     * @param {CadmiumMediaStream} videoStream The stream that we will get the chunk map from.
     * @param {number=} startChunkIndex The starting point in the chunker.
     * @param {number=} numOfChunk The number of chunks we will use to calculate the average.
     */
    function _getAverageChunkSize(videoStream, startChunkIndex, numOfChunk) {
        var avgChunkSize = 0,
            startIndex = startChunkIndex || 0, //if startChunkIndex is not defined, use 0
            chunkInfo = videoStream.header.chunkInfos,
            remChunks = chunkInfo.length - startIndex, //the remaining number of chunks
            numChunks = numOfChunk || remChunks; //if numOfChunk is undefined, use the total number of chunks

        var chunkInRange,
            sum;

        numChunks = Math.min(numChunks, remChunks);

        if (_isUsingRateMap) {
            startIndex = 0;
            numChunks = chunkInfo.length;
        }
        if (numChunks > 0) {
            chunkInRange = chunkInfo.slice(startIndex, (startIndex + numChunks));
            if (chunkInRange.length > 0) {
                sum = chunkInRange.reduce(function (x, y) { return { length: (x.length + y.length) }; }, { length: 0 });
                avgChunkSize = sum.length / numChunks;
            }
        }
        return avgChunkSize;
    }


    /**
    * Section 6 in the SIGCOMM submission.
    * We make threshold as a linear function of buffer level between a configurable upperbound and lowerbound.
    *
    * @param {number} currentVideoBufferLevelMilliseconds The video buffer occupancy in milliseconds.
    * @param {number} upperBound The upper bound of the step-up threshold
    * @param {number} lowerBound The lower bound of the step-up threshold
    */
    function _getAdjustedValueFromBufferLevel(currentVideoBufferLevelMilliseconds, upperBound, lowerBound) {
        var targetBufferLevel, adjustedValue;
        /* If the uppper bound is lower than the target threshold, it's a wrong configuration and we will just use the target threshold.*/
        if (upperBound <= lowerBound) {
            return lowerBound;
        }

        targetBufferLevel = _outageProtectionMilliseconds + _reservoirSizeMilliseconds + _cushionSizeMilliseconds;

        if (currentVideoBufferLevelMilliseconds > targetBufferLevel) {
            return lowerBound;
        }
        //(upperbound-lowerbound):B_3000 = ( adjustedValue - lowerbound): (B_3000 - CurrentBuffer)
        adjustedValue = (upperBound - lowerBound) * (targetBufferLevel - currentVideoBufferLevelMilliseconds) / targetBufferLevel + lowerBound;
        return adjustedValue;
    }


    /**
    * Find out the maximum chunk size in the video stream
    * @param {CadmiumMediaStream} videoStream The video stream we want to look into.
    * @param {number=} startIndex The starting chunk for the search (optional).
    * @param {number=} endIndex The ending chunk for the search (optional).
    **/
    function _getMaxChunkSizeInByteFromStream(videoStream, startIndex, endIndex) {
        var chunkInRange;
        var sI = startIndex || 0,
            eI = endIndex || videoStream.header.chunkInfos.length,
            max;

        chunkInRange = videoStream.header.chunkInfos.slice(sI, eI);
        if (chunkInRange.length === 0) {
            return 0;
        }
        max = chunkInRange.reduce(function (x, y) {
            return (x.length > y.length) ? x : y;
        });

        return max.length;
    }

    /**
    * Find out the minimum chunk size in the video stream
    * @param {CadmiumMediaStream} videoStream The video stream we want to look into.
    * @param {number=} startIndex The starting chunk for the search (optional).
    * @param {number=} endIndex The ending chunk for the search (optional).
    **/
    function _getMinChunkSizeInByteFromStream(videoStream, startIndex, endIndex) {
        var chunkInRange;
        var sI = startIndex || 0,
            eI = endIndex || videoStream.header.chunkInfos.length,
            min;

        chunkInRange = videoStream.header.chunkInfos.slice(sI, eI);
        if (chunkInRange.length === 0) {
            return 0;
        }
        min = chunkInRange.reduce(function (x, y) {
            return (x.length < y.length) ? x : y;
        });
        return min.length;
    }

    /**
    * Minimum Cushion size is defined as the time needed to download a chunk with max chunk size when capacity is equal to the lowest video rate.
    * (so that the buffer won't tap into the reservoir area after downloading this chunk.)
    */
    function _getMinCushionSizeInMilliseconds() {
        var lowestVideoStreamWithHeader = _videoStreamList.firstAbove(0, true),
            highestRateVideoDownloadable = _videoStreamList.firstBelow(Number.POSITIVE_INFINITY, true),
            maxChunkSizeInByte = _getMaxChunkSizeInByteFromStream(highestRateVideoDownloadable);

        return maxChunkSizeInByte * BYTEtoBITS / lowestVideoStreamWithHeader.bitrate;
    }

    /**
    * Max Cushion size is defined as 90% of the buffer size.
    * Why 90%, but not 100%?
    * (1) This is because we should be able to step up to the highest rate before the buffer is full.
    * (2) Full buffer can make us not fully utilize the available capacity (we become application-limited).
    */
    function _getMaxCushionSizeInMilliseconds() {
        var maxCushionSize = _maxBufferSizeMilliseconds * _maxCushionSizeInBufferPercentage/100 - _reservoirSizeMilliseconds - _outageProtectionMilliseconds;
        return maxCushionSize;
    }

    /**
    * We should at least to have 2 chunks in the buffer to avoid rebuffer (since video chunk is in finite size and the buffer only increases in steps)
    */
    function _getMinReservoirSizeInMilliseconds() {
        return Math.min(config.minDecoderBufferMilliseconds, _chunkMilliseconds * 2);
    }


    /**
    * Detailed description can be found in Section 5.1 Reservoir Calculation in the SIGCOMM Submission
    *
    * The purpose of Reservoir: the accumulate enough buffer so that we are able to continue to play at R_min even if C(t) = R_min
    * To find out the right size for reservoir, we look at the chunk maps and decide how much buffer we need to accomodate buffer variation at R_min.
    *
    * @param {number} currentVideoIndex The index of the requesting chunk.
    */
    function _getReservoirCalculationFromChunkMap(currentVideoIndex) {
        var lowestStreamWithHeader = _videoStreamList.firstAbove(0, true),
            lowestStreamChunkInfos = lowestStreamWithHeader.header.chunkInfos,
            minReservoirSizeMilliseconds = _getMinReservoirSizeInMilliseconds(),
            reservoirSizeMilliseconds = 0;

        if (!lowestStreamChunkInfos) {
            return _maxReservoirSizeMilliseconds;
        }

        var lastChunkIndex = Math.min(lowestStreamChunkInfos.length, (currentVideoIndex + _reservoirLookAheadChunks));
        var cumulativeDiff = 0;
        for (var index = currentVideoIndex; index < lastChunkIndex; index++) {
            var chunkInfo = lowestStreamChunkInfos[index];
            var worstDownloadTimeMilliseconds = chunkInfo.length * BYTEtoBITS / lowestStreamWithHeader.bitrate; // bits / kbps = ms
            cumulativeDiff += worstDownloadTimeMilliseconds - chunkInfo.duration;
            if (reservoirSizeMilliseconds < cumulativeDiff) {
                //Store the worst possible reservoir size we need.
                //This is necessary, because cumulativeDiff could become smaller if the following chunks are smaller (in bytes)
                reservoirSizeMilliseconds = cumulativeDiff;
            }
        }

        if (reservoirSizeMilliseconds < minReservoirSizeMilliseconds) {
            reservoirSizeMilliseconds = minReservoirSizeMilliseconds;
        } else if (reservoirSizeMilliseconds > Math.min(_maxBufferSizeMilliseconds, _maxReservoirSizeMilliseconds)) {
            //This should never happen, but just in case of the configuration error
            reservoirSizeMilliseconds = Math.min(_maxBufferSizeMilliseconds, _maxReservoirSizeMilliseconds);
        }

        DEBUG && _log.debug("reservoir size :" + reservoirSizeMilliseconds);
        return reservoirSizeMilliseconds;
    }

    /**
    * Calculate the change of buffers between two requests
    *
    * @param {number} lastSelectedRate The video rate used to request the last chunk (in kb/s).
    * @param {number} lastBufferLevel The video buffer level after the last chunk finished download (in milliseconds).
    */
    function _updateHistory(lastSelectedRate, lastBufferLevel) {
        _rateSelectionHistory.push(lastSelectedRate);
        if (_rateSelectionHistory.length > _historySize) {
            _rateSelectionHistory = _rateSelectionHistory.slice(-1 * _historySize);
        }

        _bufferHistory.push(lastBufferLevel);
        if (_bufferHistory.length > _historySize) {
            _bufferHistory = _bufferHistory.slice(-1 * _historySize);
        }
    }

    /**
    * Calculate the change of buffers between two requests
    *
    * @param {number} currentVideoBufferLevelMilliseconds The video buffer occupancy in milliseconds.
    */
    function _getBufferDifference(currentVideoBufferLevelMilliseconds) {
        var bufferDifference = 0;
        if (_bufferHistory.length < 2) {
            return bufferDifference;
        }
        bufferDifference = currentVideoBufferLevelMilliseconds - _bufferHistory[_bufferHistory.length - 2];
        return bufferDifference;
    }

    /**
    * Assuming our capacity C(t) > R_min, for all t > 0. (If C(t) is less than R_min, it's considered a network outage event.)
    * In the case of network bandwidth suddenly drops, one could stuck in a chunk download for a long time.
    * (even with read/connection timeout, the mechansim we have right now is only to retry, since we cannot cancel an existing download).
    *
    * The buffer occupancy will represent how much time we can survive out of these cases.
    * For example, when we have B(t) = 10 seconds in the buffer. In the worst case (C(t) = R_min), we can survive a chunk download if the chunk is less than R_min * 10.
    * As a result, when we pick a chunk to download, B(t) * R_min becomes our upperbound as a chunk size.
    * Chunk bigger than B(t) * R_min might not be fully downloaded in the case of bandwidth drop.
    * This function only has an effect when B(t) is less than (51 + reservoir) seconds. (51 is calculated from: B(t) * 235 = 3000 * 4, where 3000 is R_max)
    *
    * Note: We might not need to have this mechanism if we have proper timeout mechanism. I am using "StrictMaxChunkSizeEnabled" as a nob to turn it on.
    *
    * @param {number} currentVideoBufferLevelMilliseconds The video buffer occupancy in milliseconds.
    */

    function _getMaxAllowableChunkSize(currentVideoBufferLevelMilliseconds) {
        var lowestRateVideoStream = _videoStreamList.firstAbove(0, true),
            highestRateVideoStream = _videoStreamList.firstBelow(Number.POSITIVE_INFINITY, true),
            maxAllowableChunkSizeInBytes = _maxVariationInChunkSize * _chunkMilliseconds * highestRateVideoStream.bitrate / BYTEtoBITS; //Don't limit the chunk size, and make the upperbound limited by the highest bitrate
        if (_isUsingStrictMaxChunkSize) {
            if (_dynamicReservoir) {
                maxAllowableChunkSizeInBytes = (currentVideoBufferLevelMilliseconds - _reservoirSizeMilliseconds) * lowestRateVideoStream.bitrate / BYTEtoBITS;
            } else {
                maxAllowableChunkSizeInBytes = (currentVideoBufferLevelMilliseconds - _getMinReservoirSizeInMilliseconds()) * lowestRateVideoStream.Bitrate / BYTEtoBITS;
            }
        }
        return maxAllowableChunkSizeInBytes;
    }


    /**
    * Make sure the extra buffer occupancy accumulated during the initial phase do not mislead the algorithm.
    * This is possible because the algorithm sees that the buffer level is high and therefore could wrongfully choose a very high rate.
    * As a result, we save the extra buffer for network outage prevention and only keep the enough amount for the algorithm.
    * (enough means enough to provide zero rebuffer guarantee)
    *
    * @param {number} currentVideoBufferLevelMilliseconds The video buffer occupancy in milliseconds.
    */
    function _initializeOutageProtectionSize(currentVideoBufferLevelMilliseconds) {
        //If the buffer accumulates a lot of buffer during (1) the initial phase or (2) the rebuffer phase,
        //move the accumulated portion as the "outage protection".
        _outageProtectionMilliseconds = currentVideoBufferLevelMilliseconds - _reservoirSizeMilliseconds;
        _outageProtectionMilliseconds = Math.max(0, _outageProtectionMilliseconds);

        //OutageProtection + reservoir all together should not be bigger than the upperbound of reservoir
        if ((_outageProtectionMilliseconds + _reservoirSizeMilliseconds) > _maxReservoirSizeMilliseconds) {
            _outageProtectionMilliseconds = _maxReservoirSizeMilliseconds - _reservoirSizeMilliseconds;
        }
        //Outage Protection has its own upperbound as well
        if (_outageProtectionMilliseconds > _maxOutageProtectionMilliseconds) {
            _outageProtectionMilliseconds = _maxOutageProtectionMilliseconds;
        }
    }

   /**
   * Find the desirable chunk size from the curve (given bufferLevel as the input)
   *
   * @param {number} currentVideoBufferLevelMilliseconds The video buffer occupancy in milliseconds.
   */
    function _getSuggestedChunkSizeFromMap(currentVideoBufferLevelMilliseconds) {

        var avgChunkSizeInLowestRate = _videoStreamList.firstAbove(0, true).bitrate * _chunkMilliseconds / BYTEtoBITS,
            avgChunkSizeInHighestRate = _videoStreamList.firstBelow(Number.POSITIVE_INFINITY, true).bitrate * _chunkMilliseconds / BYTEtoBITS,
            algoAllowableChunkSize;

        //Calculate the mapped chunk size from buffer occupancy
        algoAllowableChunkSize = (currentVideoBufferLevelMilliseconds - _reservoirSizeMilliseconds - _outageProtectionMilliseconds) / _cushionSizeMilliseconds * (avgChunkSizeInHighestRate - avgChunkSizeInLowestRate) + avgChunkSizeInLowestRate;
        algoAllowableChunkSize = Math.max(0, algoAllowableChunkSize);
        return algoAllowableChunkSize;
    }

    /**
    * Section 6 in the SIGCOMM submission.
    * During the startup phase, since the buffer level is low, we cannot pick a rate based on the buffer level.
    * Instead, we look at the throughput from the last chunk download, pick the highest safe rate that the throughput can sustain.
    *
    * @param {number} currentVideoBufferLevelMilliseconds The video buffer occupancy in milliseconds.
    * @param {CadmiumMediaStream} lastDownloadedVideoStream The video stream we used to download the previous chunk.
    * @param {number} nextChunkIndex The index of the next chunk we are requesting.
    */
    function _getOptimizedStartupStream(currentVideoBufferLevelMilliseconds, lastDownloadedVideoStream, nextChunkIndex) {
        var startupOptimizedStream,
            bufferDifference,
            avgChunkSize,
            maxChunkSize,
            previousChunkSize,
            safetyMargin,
            safetyMarginUpperBound,
            lookaheadChunks,
            stepupLowerbound,
            lowerBound,
            throughput;
        var streamUp = _videoStreamList.firstAbove(lastDownloadedVideoStream.bitrate, true),
            lowestStream = _videoStreamList.firstAbove(0, true);

        if (_bufferHistory.length <= 1 || nextChunkIndex <= 1) {
            if (_playState === PLAYSTATE_AFTERSEEK || _transitFromInitialPhase) {
                //use the throughput measurement to decide the first video rate choice
                if (config.bandwidthMeterType === 'historical') {
                    throughput = _bandwidthMeter.getTotalBytes() / (_bandwidthMeter.getLatency() + _bandwidthMeter.getTransferTime());
                } else {
                    throughput = _bandwidthMeter.getThroughput();
                }

                if (throughput > streamUp.bitrate * _maxVariationInChunkSize) {
                    //can we sustain the higher bitrate? if yes, try the next higher one
                    startupOptimizedStream = streamUp;
                } else if (throughput < lastDownloadedVideoStream.bitrate * _maxVariationInChunkSize) {
                    //if we cannst sustain the current bitrate, switch down
                    startupOptimizedStream = _videoStreamList.firstBelow(lastDownloadedVideoStream.bitrate, true);
                } else {
                    //otherwise, use the current bitrate
                    startupOptimizedStream = lastDownloadedVideoStream;
                }
            }
            return startupOptimizedStream;
        }

        bufferDifference = _getBufferDifference(currentVideoBufferLevelMilliseconds);
        avgChunkSize = _getAverageChunkSize(lastDownloadedVideoStream, 0, lastDownloadedVideoStream.header.chunkInfos.length);
        maxChunkSize = _getMaxChunkSizeInByteFromStream(lastDownloadedVideoStream);
        previousChunkSize = lastDownloadedVideoStream.header.chunkInfos[nextChunkIndex - 1].length;


        if (_startupSafeRateCalculationEnabled) {
            /*
             * Calculating the threshold from the following equation.
             *
             * If the next highest rate (R+) is a safe rate to step up, our capacity (C) must be larger than R+ * chunkSizeVariance.
             * (Note chunkSizeVariance is controlled by encoding scheme and represents the ratio between the largest chunk size to the average chunk size in bytes.)
             *
             * if C > (R+ * Encoding_coefficient), then time (T) we need to download the chunk would be:
             *
             * T < chunk_size / (R+ * Encoding_coefficient)
             *
             * Since T is the output of the buffer and chunksizeInMilliseconds (4 seconds) is the input,
             * the delta of the buffer before and after the chunk download would be:
             * buffer_delta > chunksize_in_seconds - (chunk_size / (R+ * Encoding_coefficient))
             *
             * Thus, we know if buffer_delta is larger than (chunksize_in_seconds - (chunk_size / (R+ * Encoding_coefficient))),
             * R+ should be a safe rate to step up.
             */

            safetyMarginUpperBound = maxChunkSize / avgChunkSize;
            if (_startupLookAheadCalculationEnabled) {
                lookaheadChunks = Math.min(lastDownloadedVideoStream.header.chunkInfos.length - nextChunkIndex - 1, _startupLookAheadChunks);
                if ((nextChunkIndex + lookaheadChunks + 1) < lastDownloadedVideoStream.header.chunkInfos.length) {
                    safetyMarginUpperBound = _getMinChunkSizeInByteFromStream(lastDownloadedVideoStream, nextChunkIndex, nextChunkIndex + lookaheadChunks) / avgChunkSize;
                }
            }

            if (_startupThresholdFunctionOfBufferEnabled) {
                safetyMargin = _getAdjustedValueFromBufferLevel(currentVideoBufferLevelMilliseconds, safetyMarginUpperBound, 1);
            } else {
                safetyMargin = safetyMarginUpperBound;
            }

            stepupLowerbound = _chunkMilliseconds - previousChunkSize * BYTEtoBITS / (streamUp.bitrate * safetyMargin);

            if (bufferDifference > stepupLowerbound) {
                startupOptimizedStream = streamUp;
            } else if (bufferDifference >= 0) {
                startupOptimizedStream = lastDownloadedVideoStream;
            } else {
                /*
                 * Similarly, when buffer decreased, we use the same formula to find the safest rate to backoff.
                 */
                startupOptimizedStream = streamUp;
                lowerBound = _chunkMilliseconds - previousChunkSize * BYTEtoBITS / (startupOptimizedStream.bitrate * safetyMargin);
                while (bufferDifference < lowerBound) {
                    startupOptimizedStream = _videoStreamList.firstBelow(startupOptimizedStream.bitrate, true);

                    if (startupOptimizedStream === lowestStream) {
                        break;
                    }
                    lowerBound = _chunkMilliseconds - previousChunkSize * BYTEtoBITS / (startupOptimizedStream.bitrate * safetyMargin);
                }

            }
        }

        return startupOptimizedStream;
    }

    /**
    * Select a rate based on the "desirable chunk size" suggested by the curve.
    * To mitigate rate oscillation, We will prefer to stay at the current rate.
    * We will only step up when the "desirable chunk size" is larger than the next "numLookAhead" chunk of the next highest rate.
    * On the other hand, we will only step down if the "desirable chunk size" is smaller than the next "numLookAhead" chunk of the next lowest rate.
    * However, if the next chunk of the current rate is larger than the maximum allowable rate,
    * that is, there is a possiblility for us to rebuffer during the next chunk download,
    * we don't care about rate oscillation anymore, and jump directly to the lowest safe rate whose next chunk size is smaller than the maximum allowable rate.
    *
    * @param{number} currentVideoBufferLevelMilliseconds The video buffer occupancy in milliseconds.
    * @param{CadmiumMediaStream} lastDownloadedVideoStream The video stream that is used for the last chunk
    * @param{number} nextChunkIndex The index of the next chunk.
    * @param{number} numLookAhead The number of chunks we lookahead to calculate the average
    */
    function _getVideoRateFromChunkMap(currentVideoBufferLevelMilliseconds, lastDownloadedVideoStream, nextChunkIndex, numLookAhead) {
        var nextLowestVideoStreamWithHeader = _videoStreamList.firstBelow(lastDownloadedVideoStream.bitrate, true),
            nextHighestVideoStreamWithHeader = _videoStreamList.firstAbove(lastDownloadedVideoStream.bitrate, true),
            lowestVideoStreamWithHeader = _videoStreamList.firstAbove(0, true),
            recVideoStream,
            suggestedChunkSizeFromMap = _getSuggestedChunkSizeFromMap(currentVideoBufferLevelMilliseconds), //Get the desirable chunk size from the curve
            maxAllowableChunkSizeInBytes = _getMaxAllowableChunkSize(currentVideoBufferLevelMilliseconds), //How many bits we can afford to download within a chunk if our bandwidth is as low as the lowest video rate
            nextLowestRateAvgChunkSize = 0,
            nextHighestRateAvgChunkSize = 0,
            nextLowestRateVideoChunkInfos = nextLowestVideoStreamWithHeader.header.chunkInfos,
            nextHighestRateVideoChunkInfos = nextHighestVideoStreamWithHeader.header.chunkInfos,
            nextChunkSize = lastDownloadedVideoStream.header.chunkInfos[nextChunkIndex].length,
            candidateVideoStream = lastDownloadedVideoStream,
            candidateChunkSize;


        //Bounded by zero and the maximum allowable chunk size
        suggestedChunkSizeFromMap = Math.min(suggestedChunkSizeFromMap, maxAllowableChunkSizeInBytes);


        //Find out the average chunksize for the next lower rate
        if (nextLowestRateVideoChunkInfos) {
            //the average chunk size for the next "numLookAhead" chunks
            //if numLookAhead = 1, then we are just looking at the size of the next chunk
            //if we are using Rate Map, the AverageChunkSize() will return the overall average chunk size in the downloadable
            nextLowestRateAvgChunkSize = _getAverageChunkSize(nextLowestVideoStreamWithHeader, nextChunkIndex, numLookAhead);
            if (numLookAhead > 1) {
                //take the max of the size of very next chunk and the average size of the next "numLookAhead" chunks
                nextLowestRateAvgChunkSize = Math.max(nextLowestRateAvgChunkSize,
                    nextLowestRateVideoChunkInfos[nextChunkIndex].length);
            }
        }
        //Find out the average chunksize for the next higher rate
        if (nextHighestRateVideoChunkInfos) {
            //the average chunk size for the next "numLookAhead" chunks
            //if numLookAhead = 1, then we are just looking at the size of the next chunk
            //if we are using Rate Map, the AverageChunkSize() will return the overall average chunk size in the downloadable
            nextHighestRateAvgChunkSize = _getAverageChunkSize(nextHighestVideoStreamWithHeader, nextChunkIndex, numLookAhead);
            if (numLookAhead > 1) {
                //take the max of the size of very next chunk and the average size of the next "numLookAhead" chunks
                nextHighestRateAvgChunkSize = Math.max(nextHighestRateAvgChunkSize,
                    nextHighestRateVideoChunkInfos[nextChunkIndex].length);
            }
        }

        /* Chunk size is bounded by the maximum allowable chunk size (ChunkSize < BufferLevel * lowestRate)
         * If larger then that, there is a possibility to rebuffer during this next chunk.
         * If that happens, then forget about rate oscillation, switch down to the highest safe rate given the buffer level.
         * Note: here we only consider the next chunk, since we don't have enough buffer to care about rate oscillation here.
         */
        if (_isUsingStrictMaxChunkSize && nextChunkSize > maxAllowableChunkSizeInBytes) {

            //there is a chance for the buffer to rebuffer during the next chunk
            while (true) {

                candidateVideoStream = _videoStreamList.firstBelow(candidateVideoStream.bitrate, true);
                if (candidateVideoStream.bitrate === lowestVideoStreamWithHeader.bitrate) {
                    recVideoStream = lowestVideoStreamWithHeader;
                    break;
                }

                candidateChunkSize = candidateVideoStream.header.chunkInfos[nextChunkIndex].length;
                if (candidateChunkSize < maxAllowableChunkSizeInBytes) {
                    recVideoStream = candidateVideoStream;
                    break;
                }
            }
            return recVideoStream;
        }

        //if the chunker for the next highest rate is available (nextHighestRateAvgChunkSize > 0),
        //Check if f(B) is larger then chunk size in the next highest rate.
        if (nextHighestRateAvgChunkSize > 0 && suggestedChunkSizeFromMap > nextHighestRateAvgChunkSize) {
            //switch to a higher bitrate, one bit rate at a time
            recVideoStream = nextHighestVideoStreamWithHeader;
        } else if (nextLowestRateAvgChunkSize > 0 && suggestedChunkSizeFromMap < nextLowestRateAvgChunkSize) {

            //Loop over the lower bitrates and see how many bitrates we need to step down
            candidateVideoStream = nextLowestVideoStreamWithHeader;
            candidateChunkSize = nextLowestRateAvgChunkSize;

            while (candidateChunkSize > suggestedChunkSizeFromMap) {
                recVideoStream = candidateVideoStream;
                candidateVideoStream = _videoStreamList.firstBelow(candidateVideoStream.bitrate, true);

                if (candidateVideoStream.bitrate === lowestVideoStreamWithHeader.bitrate) {
                    break;
                }
                candidateChunkSize = _getAverageChunkSize(candidateVideoStream, nextChunkIndex, numLookAhead);
                if (numLookAhead > 1) {
                    candidateChunkSize = Math.max(candidateChunkSize,
                        candidateVideoStream.header.chunkInfos[nextChunkIndex]);
                }
            }

        } else {
            //keep the current bitrate
            recVideoStream = lastDownloadedVideoStream;
        }
        return recVideoStream;
    }

    /**
    * The main function of the Buffer-Based algorithm
    */
    function _getVideoStreamRecommendationBasedOnBuffer() {
        // start with higher or current stream
        var lastDownloadedVideoStream = playback.downloadedVideo.value.stream,
            recVideoStream, //recommended video stream
            lowestVideoStreamWithHeader = _videoStreamList.firstAbove(0, true),
            currentVideoBufferLevelMilliseconds = playback.mediaBuffer.getBufferLength(),
            nextChunkToDownload = playback.mediaBuffer.getNextChunkToDownload(),
            chunkMilliseconds = nextChunkToDownload.duration,
            updatedReservoirSize = 0,
            bufferDifference = _getBufferDifference(currentVideoBufferLevelMilliseconds),
            startupTransitionPeriod,
            numLookAhead = 1,
            startupOptimizedStream;

        if (_chunkMilliseconds === undefined) {
            //if it is undefined, set the value
            _chunkMilliseconds = chunkMilliseconds;
        }

        if (_maxVariationInChunkSize === undefined) {
            //if it is undefined, set the value
            _maxVariationInChunkSize = _getMaxChunkSizeInByteFromStream(lastDownloadedVideoStream) / _getAverageChunkSize(lastDownloadedVideoStream);
        }

        if (_maxBufferSizeMilliseconds === undefined) {
            //if it is undefined, set the value
            _maxBufferSizeMilliseconds = _getMaxBufferSizeMilliseconds();
        }

        if (_playState === PLAYSTATE_AFTERSEEK) {
            //Since our buffer starts from 0 after seek, we re-enter the startup phase after seek.
            _startupChunks = _startupPhaseInChunks;

            //sum of the bitrates, used later to calculate average bitrate
            if (_rateSelectionHistory.length === 0) {
                _videoRateBeforeSeek = lastDownloadedVideoStream.bitrate;
            }
            else{
                _videoRateBeforeSeek = _rateSelectionHistory.reduce(function (x, y) { return (x + y); }, 0);
            }

            if (_videoRateBeforeSeek > 0) {
                _videoRateBeforeSeek = _videoRateBeforeSeek / _rateSelectionHistory.length;
                //Use the smaller value between the average and the last one
                _videoRateBeforeSeek = Math.min(_videoRateBeforeSeek, _rateSelectionHistory[_rateSelectionHistory.length - 1]);
                _afterSeekTargetStream = _videoStreamList.firstBelow(_videoRateBeforeSeek, true);
            }
            _clearHistory();
        }

        _updateHistory(lastDownloadedVideoStream.bitrate, currentVideoBufferLevelMilliseconds);

        // --- Begin Start-up related configuration ---
        if (!_startupQualityOptimization) {
            _startupChunks = -1; //TODO: make it falsy-friendly
        } else {
            _startupChunks = _startupChunks - 1;
        }

        //Extend start-up period, if buffer is still increasing
        if (_startupChunks === 0 && bufferDifference > 0) {
            _startupChunks = _startupChunks + 1;
        } else if (_startupQualityOptimization && _startupChunks === -1) {
            //last chance
            if (bufferDifference > 0) {
                //if buffer is increasing after the last decrease, give it another try.
                _startupChunks = 1;
            } else {
                //Otherwise, start transiting to rate-map
                startupTransitionPeriod = true;
            }
        }

        // --- End Start-up related configuration ---


        // --- Begin Reservoir Calculation (Section 5.1 in the SIGCOMM submission) ---

        //Initialize Reservoir according to the QoE Knobs
        if (_dynamicReservoir) {

            updatedReservoirSize = _getReservoirCalculationFromChunkMap(nextChunkToDownload.index);
            // We only allow reservoir to increase, not decrease to avoid rate osillation
            if (_reservoirSizeMilliseconds < updatedReservoirSize) {
                _reservoirSizeMilliseconds = updatedReservoirSize;
            }
        } else if (_isReservoirManualSet) {
            _reservoirSizeMilliseconds = _manualReservoirMilliseconds;
            if (_reservoirSizeMilliseconds < _getMinReservoirSizeInMilliseconds()) {
                _reservoirSizeMilliseconds = _getMinReservoirSizeInMilliseconds();
            }
        } else {
            _reservoirSizeMilliseconds = _getMinReservoirSizeInMilliseconds();
        }

        // --- End Reservoir Calculation ----

        // --- Begin Outage Protection Calculation ---
        if (_outageProtectionMilliseconds < 0 || _playState === PLAYSTATE_AFTERREBUFFER || _playState === PLAYSTATE_AFTERSEEK) {
            //During the initial or rebuffer phase, the client could decide to accumulate tons of buffer
            //We will treat these buffered chunks as "outage prevention" and do not let it affect the rate selection process
            //In this way, our algorithm won't jump to a very high rate after recovering from a rebuffer event.
            _initializeOutageProtectionSize(currentVideoBufferLevelMilliseconds);

            //If we accumulated more buffer than (cushion+reservoir+outageProtection), then the rate-map will recommend to download R_max.
            //However, the buffer is accumulated during the "prebuffer" stage (after rebuffer or seek). The logic there accumulate chunks in buffer, since the throughput is very low.
            _highBufferAfterRebufferOrSeek = false;
            if (currentVideoBufferLevelMilliseconds >=
                (_getMaxCushionSizeInMilliseconds() + _reservoirSizeMilliseconds + _outageProtectionMilliseconds)) {
                _highBufferAfterRebufferOrSeek = true;
            }
        }
        // --- End Outage Protection Calculation ---


        // --- Begin Cushion Calculation ---
        if (!_isCushionManualSet && _dynamicReservoir) {
            _cushionSizeMilliseconds = _getMaxCushionSizeInMilliseconds();
        } else if (_isCushionManualSet) {
            _cushionSizeMilliseconds = _manualCushionMilliseconds;
            if (_cushionSizeMilliseconds < _getMinCushionSizeInMilliseconds()()) {
                _cushionSizeMilliseconds = _getMinCushionSizeInMilliseconds();
            } else if (_cushionSizeMilliseconds > _getMaxCushionSizeInMilliseconds()) {
                _cushionSizeMilliseconds = _getMaxCushionSizeInMilliseconds();
            }
        } else {
            _cushionSizeMilliseconds = _getMinCushionSizeInMilliseconds();
        }
        // --- End Cushion Calculation ---

        //Not using it right now, _isLookingAhead is false
        if (_isLookingAhead) {
            numLookAhead = (currentVideoBufferLevelMilliseconds - _reservoirSizeMilliseconds - _outageProtectionMilliseconds) / chunkMilliseconds;
            numLookAhead = numLookAhead < 1 ? 1 : numLookAhead;
        }


        // --- Begin Propose a rate based on Rate/Chunk Map ---
        if (currentVideoBufferLevelMilliseconds < (_reservoirSizeMilliseconds + _outageProtectionMilliseconds)) {
            //already taps into the reservoir area, no choice at all
            recVideoStream = lowestVideoStreamWithHeader;
            _highBufferAfterRebufferOrSeek = false;
        } else if (currentVideoBufferLevelMilliseconds >
            (_reservoirSizeMilliseconds + _outageProtectionMilliseconds + _cushionSizeMilliseconds - chunkMilliseconds)) {
            //Normally, when the buffer is high, it means we can safely play at the highest rate.
            recVideoStream = _videoStreamList.firstBelow(Number.POSITIVE_INFINITY, true);
            //However, if the buffer is accumulated during the "prebuffer" stage (called after a rebuffer, or after seek).
            //In the prebuffer stage, if the client has a very low bandwidth, the logic will accumulate many video chunks before resuming the play and we need to handle this case differently.
            if (_highBufferAfterRebufferOrSeek) {
                if (bufferDifference > 0) {
                    //only step up if buffer is increasing
                    recVideoStream = _videoStreamList.firstAbove(lastDownloadedVideoStream.bitrate, true);
                } else {
                    recVideoStream = lastDownloadedVideoStream;
                }
            } else {
                _startupChunks = -1;
            }
        } else {
            //decide which rate to use based on the curve and the adaptation algorithm operates on top of the curve
            recVideoStream =
                _getVideoRateFromChunkMap(currentVideoBufferLevelMilliseconds, lastDownloadedVideoStream, nextChunkToDownload.index, numLookAhead);

            if (_highBufferAfterRebufferOrSeek) {
                if (bufferDifference >= 0) {
                    //if buffer is not decreasing (including 0), keep using the previous rate
                    recVideoStream = lastDownloadedVideoStream;
                } else {
                    //otherwise, step down
                    recVideoStream = _videoStreamList.firstBelow(lastDownloadedVideoStream.bitrate, true);
                }
            }
        }
        // --- End Propose a rate based on Rate/Chunk Map ---

        // --- Begin Start-up Optimization ---
        // During start-up period, calculate the rate based on the last throughput (and calculate threshold based on the encoding variation) --- see Section 6 in the SIGCOMM submission in detail
        // Compare the rate proposed using rate/chunk map, use whichever is higher.

        if (_startupQualityOptimization && _startupChunks >= 0) {
            startupOptimizedStream = _getOptimizedStartupStream(currentVideoBufferLevelMilliseconds, lastDownloadedVideoStream, nextChunkToDownload.index);

            //Since we have some prior knowledge about the bandwidth prior to the seek.
            //If the start-up optimization is suggesting not to step up a rate,
            //we can still step up towards the target rate (half of the rate before seek) as long as the buffer is increasing.
            if (_afterSeekTargetStream &&
                startupOptimizedStream.bitrate < _afterSeekTargetStream.bitrate) {
                if (bufferDifference > 0) {
                    startupOptimizedStream = _videoStreamList.firstAbove(lastDownloadedVideoStream.bitrate, true);
                } else if (bufferDifference < 0) {
                    //if the buffer is already decreasing, it means the available capacity probably has already changed during the seek.
                    //Then we fall back to the startup Optimization
                    _afterSeekTargetStream = undefined;
                }

            }
            if (_afterSeekTargetStream &&
                startupOptimizedStream.bitrate >= _afterSeekTargetStream.bitrate) {
                //this optimization is unnecessary if the start-up optimization already selected a higher rate
                _afterSeekTargetStream = undefined;
            }

            if (startupOptimizedStream.bitrate > recVideoStream.bitrate) {
                //Only apply start-up optimization if the resulted bitrate is higher than the bitrate suggested by the map
                recVideoStream = startupOptimizedStream;
            }
        } else if (startupTransitionPeriod) {
            //Transition from the start-up optimization to the rate-map function.
            //When we exit the start-up phase, the difference between the rate we used in start-up optimization and the rate suggested by the rate-map could be huge.
            //The question is how to smoothly transit to the rate-map.
            //During the transition period, there are following three cases:

            if (bufferDifference > 0) {
                //(1) if the buffer is increasing, then we keep using the same rate.
                recVideoStream = lastDownloadedVideoStream;
            } else if (recVideoStream.bitrate <= (lastDownloadedVideoStream.bitrate / 2)) {
                //(2) if the buffer is not increasing and the rate suggested by the rate-map is lower than the half of the current rate.
                //Then we step down to 1/2 of the current rate (model after TCP).
                //TODO: future brainstorm needed
                recVideoStream = _videoStreamList.firstBelow(lastDownloadedVideoStream.bitrate / 2, true);
            } else {
                //(3) if the rate suggested by the rate-map is higher than the half of the current rate, then we switch to rate-map.
                startupTransitionPeriod = false;
            }
        }

        _playState = PLAYSTATE_NORMAL;

        if (recVideoStream) {
            DEBUG && _log.debug('Feasable stream found', recVideoStream);
        } else {
            recVideoStream = lowestVideoStreamWithHeader;
            DEBUG && _log.debug('No feasable streams found, using lowest that has a header', recVideoStream);
        }
        return recVideoStream;
    }

    // comes up with a video stream recommendation for what to do while playback is in progress
    function _getBufferingRecommendation() {
        _updateStreamList();

        var videoStream = _getVideoStreamRecommendationBasedOnBuffer(),
            mB = playback.mediaBuffer;

        //Borrowed from Playback Heuristics
        // do we have extra time in buffer to afford this download?
        var getHeaderFor = _getBestHeaderToDownload(videoStream);
        if (getHeaderFor) {
            var lowestBufferLevel = Math$min( mB.getAudioBufferLength(), mB.getBufferLength()) - _chunkMilliseconds;
            var headerDownloadTime = _bandwidthMeter.calculateDownloadTime(getHeaderFor.estimateHeaderSize());
            if (!(headerDownloadTime <= lowestBufferLevel)) {
                // we can't maintain current bitrate and get a header
                // in this case, although a little counter-intuitive, but we should make sure we have lowest bitrate stream headers
                var lowestStream = _videoStreamList[0];
                getHeaderFor = (!lowestStream.header) ? lowestStream : null;
            }
        }

        return {
            videoStream: videoStream,
            getHeaderFor: getHeaderFor
        };
    }


    return {
        getAudioRecommendation: that.getAudioRecommendation,

        getPrebufferingRecommendation: that.getPrebufferingRecommendation,

        getBufferingRecommendation: _getBufferingRecommendation,

        isRebufferForecasted: that.isRebufferForecasted
    };

};




// -- heuristics/PlaybackHeuristicsRandom.js
    /**
    * @constructor
    *
    * An implementation of playback heuristics that randomly switches bitrates. This is used only for testing patforms.
    */
    function PlaybackHeuristicsRandom(playback) {
        // --------------------------------------------------------------------------------
        // -- public API
        /** @lends {PlaybackHeuristicsRandom.prototype} */
        return {
            getAudioRecommendation: _getAudioRecommendation,

            getPrebufferingRecommendation: _getPrebufferingRecommendation,

            getBufferingRecommendation: _getBufferingRecommendation,

            isRebufferForecasted: function () { return false; },

            shouldAbortDownloads: function () { return false; },

            getSafeToDownloadAdditionalData: function(trickplaySize) { return true; },

            getMinimumSafeBufferLevel: function() { return 4000; /* ms */}
        };

        // --------------------------------------------------------------------------------
        // -- private implementation

        function _getAudioRecommendation(mustHaveHeader) {
            var filter = mustHaveHeader ? CadmiumMediaStreams$hasHeaderFilter : CadmiumMediaStreams$doesNotHaveHeaderFilter;
            var audioStreamList = playback.getAudioStreamList().filter(filter);
            return randomArrayElement(audioStreamList);
        };

        // comes up with a video stream recommendation for what to do when prebuffering
        function _getPrebufferingRecommendation() {
            var mediaBuffer = playback.mediaBuffer,
                currentAudio = mediaBuffer.getAudioBufferLength(),
                currentVideo = mediaBuffer.getVideoBufferLength();

            var needMoreAudioMilliseconds = Math$max(config.prebufferMinAudioMilliseconds + config.minDecoderBufferMilliseconds - currentAudio, 0),
                needMoreVideoMilliseconds = Math$max(config.prebufferMinVideoMilliseconds + config.minDecoderBufferMilliseconds - currentVideo, 0);

            var nextAudioChunkThatNeedsMedia = mediaBuffer.getNextAudioChunkThatNeedsMedia(),
                nextVideoChunkThatNeedsMedia = mediaBuffer.getNextVideoChunkThatNeedsMedia(),
                remainingAudio = nextAudioChunkThatNeedsMedia ? mediaBuffer.audioChunks.last.endTime - nextAudioChunkThatNeedsMedia.startTime : 0,
                remainingVideo = nextVideoChunkThatNeedsMedia ? mediaBuffer.videoChunks.last.endTime - nextVideoChunkThatNeedsMedia.startTime : 0;

            needMoreAudioMilliseconds = Math$min(needMoreAudioMilliseconds, remainingAudio);
            needMoreVideoMilliseconds = Math$min(needMoreVideoMilliseconds, remainingVideo);

            return {
                videoStream: _selectRandomVideoStream(true),
                getHeaderFor: _selectRandomVideoStream(false),
                needMoreAudioMilliseconds: needMoreAudioMilliseconds,
                needMoreVideoMilliseconds: needMoreVideoMilliseconds
            };
        };

        // comes up with a video stream recommendation for what to do while playback is in progress
        function _getBufferingRecommendation() {
            return {
                videoStream: _selectRandomVideoStream(true),
                getHeaderFor: _selectRandomVideoStream(false)
            };
        };

        function _selectRandomVideoStream(withHeader) {
            var filter = withHeader ? CadmiumMediaStreams$hasHeaderFilter : CadmiumMediaStreams$doesNotHaveHeaderFilter;
            var videoStreamList = playback.getVideoStreamList().filter(filter);
            return randomArrayElement(videoStreamList);
        };

    };

    // if the config is set, overwrite the default algorithm
/*    if (config.heuristicsAlgorithm == 'random') {
        PlaybackHeuristics = PlaybackHeuristicsRandom;
    }
    callback(SUCCESS);

});*/


// -- heuristics/PlaybackHeuristicsFixed.js
/**
* @constructor
*
* An implementation of playback heuristics that uses pre-determined bitrates. This is used only for testing patforms.
*/
function PlaybackHeuristicsFixed(playback) {

    // --------------------------------------------------------------------------------
    // -- public API

    mixIn(this,
    /** @lends {PlaybackHeuristicsFixed.prototype} */
    ({
        getAudioRecommendation: _getAudioRecommendation,

        getPrebufferingRecommendation: _getPrebufferingRecommendation,

        getBufferingRecommendation: _getBufferingRecommendation,

        isRebufferForecasted: function () { return false; },

        shouldAbortDownloads: function () { return false; },

        getSafeToDownloadAdditionalData:  function () { return true; },

        getMinimumSafeBufferLevel: function() { return 0; }     
    }));

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _getAudioRecommendation(mustHaveHeader) {
        var filter = mustHaveHeader ? CadmiumMediaStreams$hasHeaderFilter : CadmiumMediaStreams$doesNotHaveHeaderFilter;
        var audioStreamList = playback.getAudioStreamList().filter(filter);
        return randomArrayElement(audioStreamList);
    }

    // comes up with a video stream recommendation for what to do when prebuffering
    function _getPrebufferingRecommendation() {
        var recommendation = _getBufferingRecommendation(),
            mediaBuffer = playback.mediaBuffer,
            currentAudio = mediaBuffer.getAudioBufferLength(),
            currentVideo = mediaBuffer.getVideoBufferLength();

        var needMoreAudioMilliseconds = Math$max(config.prebufferMinAudioMilliseconds + config.minDecoderBufferMilliseconds - currentAudio, 0),
            needMoreVideoMilliseconds = Math$max(config.prebufferMinVideoMilliseconds + config.minDecoderBufferMilliseconds - currentVideo, 0);

        var nextAudioChunkThatNeedsMedia = mediaBuffer.getNextAudioChunkThatNeedsMedia(),
            nextVideoChunkThatNeedsMedia = mediaBuffer.getNextVideoChunkThatNeedsMedia(),
            remainingAudio = nextAudioChunkThatNeedsMedia ? mediaBuffer.audioChunks.last.endTime - nextAudioChunkThatNeedsMedia.startTime : 0,
            remainingVideo = nextVideoChunkThatNeedsMedia ? mediaBuffer.videoChunks.last.endTime - nextVideoChunkThatNeedsMedia.startTime : 0;

        needMoreAudioMilliseconds = Math$min(needMoreAudioMilliseconds, remainingAudio);
        needMoreVideoMilliseconds = Math$min(needMoreVideoMilliseconds, remainingVideo);

        recommendation.needMoreAudioMilliseconds = needMoreAudioMilliseconds;
        recommendation.needMoreVideoMilliseconds = needMoreVideoMilliseconds;

        return recommendation;
    }

    // comes up with a video stream recommendation for what to do while playback is in progress
    function _getBufferingRecommendation() {
        var fixedVideoBitrates = config.fixedVideoBitrates;
        var nextVideoChunkThatNeedsMedia = playback.mediaBuffer.getNextVideoChunkThatNeedsMedia();

        if (nextVideoChunkThatNeedsMedia) {
            var startTime = nextVideoChunkThatNeedsMedia.startTime;
            var bitrate;
            var length = fixedVideoBitrates.length;
            var pair;
            var i = 0;
            for (i = 0; i < length; i++) {
                pair = fixedVideoBitrates[i];
                if (startTime >= pair[0]) {
                    bitrate = pair[1];
                } else {
                    break;
                }
            }
        }

        var streams = playback.createFilteredVideoStreamList();
        var videoStream = CadmiumMediaStreams$methods.closestTo.call(streams, bitrate || 0);
        var getHeaderFor = streams.filter(CadmiumMediaStreams$doesNotHaveHeaderFilter)[0];

        return {
            videoStream: videoStream,
            getHeaderFor: getHeaderFor
        };
    }

};


// -- heuristics/CarreraBitrateSelector.js
/**
 * Carrera
 *
 * @constructor
 */
function CarreraBitrateSelector(playback) {
    var _historical,
        _expectedBandwidth,
        _expectedBandwidthValue,
        // <bitrate, playdelay> pairs
        _bitrateHeuristics = {},
        // ordered list of bitrates, high to low
        _bitrates = [],
        _requiredBandwidths = [],
        _initBitrate = 0,
        _initialVideoBitrates,
        _expbwpercsel,
        _selpbdelay;


    // Public methods.
    this.getExpBandwidthValue =  function () { return _expectedBandwidthValue; };
    this.getExpBandwidthPercentileSelection =  function () { return _expbwpercsel; };
    this.getSelectedPlaybackDelay = function () { return _selpbdelay; };
    this.getInitialBitrate = _getInitialBitrate;
    this.getExpBandwidthObject = function () { return _expectedBandwidth; };

    function _getInitialBitrate(cdnLocationId){
        _initialVideoBitrates = playback.getVideoStreamList().toBitrates(config.initialVideoBitrates);
        _historical = playback.historical;

        debug$assert(_historical);
        if (!_historical || !cdnLocationId) {
            return;
        }

        // 1. Get the historical bandwidth object given the current client IP address, CDN choice, and time.
        _expectedBandwidth = _historical.getExpectedBandwidth(cdnLocationId, clock$getAppEpoch() + clock$getTime());
        //debug$assert(_expectedBandwidth);
        if (!_expectedBandwidth || _expectedBandwidth.sampleSize === 0) {
            // historical did not return any data
            return;
        }

        // 2. Get the initial bitrate selection curve and the playback delay budget from config
        enumerateOwnProperties(config.carreraParameters, function(bitrate, delay) {
            _bitrateHeuristics[bitrate] = parseFloat(delay);
            _bitrates.push(parseInt10(bitrate));
        });

        // reverse list of bitrates to start with highest
        _bitrates = Array$sortNumbers(_bitrates).reverse();

        /*
         3. Compute the required bandwidth for each of the available bitrates using the initial bitrate selection curve
            and linear interpolation if necessary.

            Example: Carrera bitrates are 750, 1050 and 1750. Available bitrates are 750,1050 and 1200 and 2350. We
            use linear interpolation between 1050 and 1750 to get the delay budget and therefore the bandwidth requirement
            for the 1200 bitrate.

            Formula for linear interpolation:
            pb = (br - y1) / slope + x1
         */
        _interpolateBitrateDelayDict();


        // 4. Get the list of required bandwidths for difference bitrates
        _requiredBandwidths = _computeRequiredBandwidths();


        // 5. Calculate the value of the expected bandwidth using historical
        _expectedBandwidthValue = _getExpectedBandwidthValue();


        // 6. Find the correct bitrate that matches the estimated bandwidth
        _initBitrate = _findCorrectBitrate();
        return _initBitrate;
    }

    // If there is an initial bitrate not listed in the carrera configs, extrapolate its max delay
    function _interpolateBitrateDelayDict() {
        var point1 = {};
        var point2 = {};

        var lenInitBitrates = _initialVideoBitrates.length;
        var lenCarreraBitrates = _bitrates.length;

        for (var i=0; i<lenInitBitrates; i++) {
            var newBitrate = _initialVideoBitrates[i];

            if (_bitrates.indexOf(newBitrate) === -1 && newBitrate < Array$max(_bitrates))  {
                for (var j=0; j<lenCarreraBitrates-1; j++) {
                    var key1 = _bitrates[j];
                    var key2 = _bitrates[j+1];
                    if (newBitrate >= key2 && newBitrate <= key1) {
                        point1.x = _bitrateHeuristics[key1];
                        point1.y = key1;
                        point2.x = _bitrateHeuristics[key2];
                        point2.y = key2;
                        var slope = (point2.y - point1.y) / (point2.x - point1.x);
                        var playbackDelay = (newBitrate - point1.y) / slope + point1.x;
                        _bitrateHeuristics[newBitrate] = playbackDelay;
                        break;
                    }
                }
            }
        }
    }


    // Calculate the required bandwithd to download 2 audio and video chunks at each bitrate
    function _computeRequiredBandwidths() {
        var requiredBandwidths = [];
        var audioStreamList = playback.getAudioStreamList(),
            videoStreamList = playback.getVideoStreamList();
        var nextAudioChunkToDownload = playback.mediaBuffer.getNextAudioChunkThatNeedsMedia(),
            audioChunkIndex = nextAudioChunkToDownload.index,
            nextVideoChunkToDownload = playback.mediaBuffer.getNextVideoChunkThatNeedsMedia(),
            videoChunkIndex = nextVideoChunkToDownload.index;
        var audioChunks = playback.mediaBuffer.audioChunks,
            videoChunks = playback.mediaBuffer.videoChunks;
        // do this for all bitrates in bitrateHeuristics
        enumerateOwnProperties(_bitrateHeuristics, function (bitrate, delay) {
            var chunksToMeasure,
                bytesInAverageChunk,
                bytesToBuffer;
           // get the stream for this bitrate
            var audioStream = audioStreamList.closestTo(bitrate, true),
                videoStream = videoStreamList.closestTo(bitrate, true);
            var bytesOfAudioChunks = 0,
                bytesOfVideoChunks = 0,
                reqBandwidth,
                i;

            // audio
            chunksToMeasure = Math$min(Math$ceil(config.carreraChunksToAverage) / 4.0, audioChunks.last.index - audioChunkIndex + 1);
            for (i = 0; i < chunksToMeasure; i++) {
                bytesOfAudioChunks += audioStream.header.chunkInfos[audioChunkIndex+ i].length;
            }

            // video
            chunksToMeasure = Math$min(config.carreraChunksToAverage, videoChunks.last.index - videoChunkIndex + 1);
            for (i = 0; i < chunksToMeasure; i++) {
                bytesOfVideoChunks += videoStream.header.chunkInfos[videoChunkIndex+ i].length;
            }

            bytesInAverageChunk = (bytesOfAudioChunks + bytesOfVideoChunks) / chunksToMeasure;
            // we want to be able to get two chunks before starting
            bytesToBuffer = 2 * bytesInAverageChunk;
            reqBandwidth = Math$max((bytesToBuffer/BYTES_TO_KILOBIT) / delay, bitrate);

            var reqBandwidthEntry = {};
            reqBandwidthEntry.bitrate = bitrate;
            reqBandwidthEntry.reqBandwidth = reqBandwidth;
            reqBandwidthEntry.delay = delay;
            requiredBandwidths.push(reqBandwidthEntry);
        });

        // order the requredBandwidths list by bitrate, ascending order
        requiredBandwidths = requiredBandwidths.sort(function(o1,o2){
            if  (parseInt(o1.bitrate) < parseInt(o2.bitrate)) {
                return -1;
            } else if(parseInt(o1.bitrate) > parseInt(o2.bitrate)) {
                return  1;
            } else {
                return  0;
            }
        });
        return requiredBandwidths;
    }


    // Grab the expected bandwidth based on historical and the correct percentile. Discount the number.
    function _getExpectedBandwidthValue() {
        var expectedBandwithValue;
        if (config.carreraHistoricalPercentileToUse === 20) {
            expectedBandwithValue = _expectedBandwidth.bandwidth20Percentile;
        } else if (config.carreraHistoricalPercentileToUse === 90) {
            expectedBandwithValue = _expectedBandwidth.bandwidth90Percentile;
        } else {
            expectedBandwithValue = _expectedBandwidth.bandwidth50Percentile;
        }

        // discount the bandwidth
        var bandwidthReduction = config.prebufferSimulationParams[2];
        bandwidthReduction = 1 - ((bandwidthReduction || 0) * 0.01); // e.g. 60 in config becomes 0.6
        return expectedBandwithValue * bandwidthReduction;
    }


    // Find the highest bitrate with a bandwidth requirement under what we predicted via historical
    function _findCorrectBitrate(){
        var entry;
        var len = _requiredBandwidths.length;
        // traverse the list in reverse order --> highest bitrate to lowest.
        while (len--) {
            entry = _requiredBandwidths[len];
            if (entry.reqBandwidth <= _expectedBandwidthValue) {
                return entry.bitrate;
            }
        }
    }
}


// -- player/Playback.js
/**
 * @constructor
 * @param {?} accountKey     [description]
 * @param {number} movieId   [description]
 * @param {?} playbackParams [description]
 * @param {?} idProvider     [description]
 */
function Playback(accountKey, movieId, playbackParams, idProvider) {
    var _self = this,
        _xid,
        _mediaTimeChangedThrottle = new Throttle(1000),
        _eventSource = new EventSource(),
        _milestones = {},
        _videoDiagInfo = {};

    _self.createTime = clock$getTime();
    if (config.prepareCadmium && videoPreparer) {
        _xid = videoPreparer.getXid(movieId)
    }
    if (!_xid) {
        if (Playback$firstPlaybackXid) {
            _xid = Playback$firstPlaybackXid;
            Playback$firstPlaybackXid = undefined;
        } else {
            _xid = clock$createId();
        }
    }
    Playback$mostRecentPlaybackXid = _xid;

    // events
    _self.addEventListener = _eventSource.addListener;
    _self.removeEventListener = _eventSource.removeListener;
    _self.fireEvent = _eventSource.fire;

    // basic information about this playback
    _self.accountKey = accountKey;
    _self.movieId = movieId;
    _self.playbackParams = playbackParams || {};
    _self.trackingId = _self.playbackParams.trackingId || 0;
    _self.index = ++Playback$_index;
    _self.xid = _xid;
    _self.rootElement = createElement('DIV', 'position:relative;width:100%;height:100%;overflow:hidden');
    // throw a dice, and see if we should log trace info
    _self.logVerbosePlaybackInfo = config.verbosePlaybackInfoDenominator && !(_xid % config.verbosePlaybackInfoDenominator);
    _self.logFields = { 'MovieId': _self.movieId, 'TrackingId': _self.trackingId, 'Xid': _self.xid, 'AccountKey': _self.accountKey };
    _self.milestones = _milestones;
    var _playbackLog = new PlaybackLog(_self);
    _self.log = _playbackLog;
    Playback$mostRecentPlaybackLog = _playbackLog;
    Playback$firstPlaybackLog || (Playback$firstPlaybackLog = _playbackLog);

    var _log = new _self.log.CategoryLog('Playback');

    _log.info('Playback created', _self.logFields);

    if (_self.logVerbosePlaybackInfo) {
        _log.info('Playback selected for trace playback info logging');
    } else {
        _log.trace('Playback not selected for trace playback info logging');
    }

    _self.getCongestionInfo = function (callback) {
		if (config.enableCongestionService) {
			return congestionService.getCongestion(callback);
		} else {
			callback = callback || function () {};
			var congestionInfo = {
                'success': false,
				'name': null,
				'isCongested': null
			}
			callback(congestionInfo);
	        return congestionInfo;
		}
    }

    if (config.prepareCadmium && videoPreparer) {
        videoPreparer.handlePlaybackCreated(_self.movieId);

        _self.addEventListener(Playback$playbackstart, function() {
            videoPreparer.handlePlaybackStarted(_self.movieId);
        });
        _self.addEventListener(Playback$closing, function() {
            videoPreparer.handlePlaybackClosing(_self.movieId);
        });
    }
    // --------------------------------------------------------------------------------
    // -- .state, .fatalError, closing event
    _self.state = new ObservableProperty(Playback$STATE_NOTLOADED);
    _self.state.addListener(function (args) {
        _log.info('Playback state changed', { 'From': args.oldValue, 'To': args.newValue });
        debug$assert(args.newValue > args.oldValue);
    });

    _self.notifyLoading = function () {
        debug$assert(_self.state.value == Playback$STATE_NOTLOADED);
        _self.log.playback.loadTime = _self.loadTime = clock$getTime();
        _self.loadEpoch = clock$getEpoch();
        _self.relativeLoadTime = clock$getTime();
        _self.state.set(Playback$STATE_LOADING);
    };
    _self.notifyLoaded = function () {
        // handle being in in Playback$STATE_CLOSED due to a playback error
        // when .load finishes
        if (_self.state.value == Playback$STATE_LOADING) {
            _self.state.set(Playback$STATE_NORMAL);
        }
    };
    _self.notifyMilestone = function (milestoneId) {
        // track key startup milestones for logging
        _log.trace('Milestone', { 'Id': milestoneId });
        _milestones[milestoneId] = _self.getRelativeTime();
    };
    _self.getAuthDelay = function(){
        if(isNumber(_self.milestones['ats']) && isNumber(_self.milestones['at'])){
            return _self.milestones['at'] - _self.milestones['ats'];
        }
    }
    _self.getBufferedLength = function(){
        return _self.mediaBuffer && _self.mediaBuffer.getBufferLength();
    };
    _self.getIntialHeadersDelay = function(){
        if(isNumber(_self.milestones['shs']) && isNumber(_self.milestones['sh'])){
            return _self.milestones['sh'] - _self.milestones['shs'];
        }
    }
    /**
    * @param {Function=} callback
    */
    _self.close = function (callback) {
        if (callback) {
            if (_self.state.value == Playback$STATE_CLOSED) {
                callback();
            } else {
                // no need to remove the event, _eventSource.dispose() will do it
                _self.addEventListener(Playback$closed, function () {
                    callback();
                });
            }
        }
        _startClosing();
    };
    _self.closeWithError = function (fatalError) {
        // in some cases (erros induced by UI), we are asked to fail with error without being loaded
        // for those cases, we actually need to load so we can send the error to NCCP
        if (_self.state.value == Playback$STATE_NOTLOADED) {
            // just cache the error, and stat loading
            // the load() will call us again
            if (!_self.fatalError) {
                _self.fatalError = fatalError;
                _self.load();
            }
            return;
        }

        function _doStartClosing() {
            _startClosing(fatalError);
        }
        var handleDelay = config.delayErrorHandling && fatalError && config.delayErrorHandling[fatalError.errorCode];
        if (isValidString(handleDelay)) handleDelay = parseInt10(handleDelay);
        // for some errors we don't want to shutdown playback immidiately, rather wait for a more desriptive error
        // for example, in Safari, sourceBuffer.append might throw... but only a followup keyerror event will have the helpfull systemCode we can use to show good error message
        _log.error('Fatal playback error', { 'Error': '' + fatalError, 'HandleDelay': '' + handleDelay });
        if (handleDelay >= 0) {
            setTimeout(_doStartClosing, handleDelay);
        } else {
            _doStartClosing();
        }
    };
    _self.waitForNotifyClosed = function () {
        _shouldWaitForNotifyClosed = true;
    };
    _self.notifyClosed = function () {
        _releaseLockAndCompleteClosing();
    };

    _self.tryRecoverFromStall = function _tryRecoverFromStall() {
        _eventSource.fire(Playback$tryRecoverFromStall);
    };

    var _shouldWaitForNotifyClosed;
    /**
    * @param {Object=} fatalError
    */
    function _startClosing(fatalError) {
        if (_self.state.value == Playback$STATE_NOTLOADED || _self.state.value == Playback$STATE_LOADING || _self.state.value == Playback$STATE_NORMAL) {
            _log.info('Playback closing', _self, fatalError ? { 'ErrorCode': fatalError.displayCode } : undefined);
            globalEvents.removeListener(globalEvents$beforeunload, _onBeforeUnload);

            _self.fatalError = fatalError;
            // update videoDiagInfo right before closing, so we don't loose information after componets are disposed
            _fireShouldUpdateVideoDiagInfo();

            try {
                _eventSource.fire(Playback$closing);
            } catch (e) {
                _log.error('Unable to fire playback closing event', e);
            }
            _self.state.set(Playback$STATE_CLOSING);

            if (!_shouldWaitForNotifyClosed) {
                dispatch(_releaseLockAndCompleteClosing);
            }
        }
    }
    function _releaseLockAndCompleteClosing() {
        debug$assert(_self.state.value == Playback$STATE_CLOSING);
        var lockToken = _self.lockToken;
        _self.lockToken = undefined;
        if (lockToken) {
            storageLock.release(lockToken, function (result) {
                debug$assert(result.success);
                _completeClosing();
            });
        } else {
            _completeClosing();
        }
    }
    function _completeClosing() {
        _completeClosing = NOOP;
        debug$assert(_self.state.value == Playback$STATE_CLOSING);

        var index = Playback$openPlaybacks.indexOf(_self);
        debug$assert(index >= 0);
        Playback$openPlaybacks.splice(index, 1);

        _self.state.set(Playback$STATE_CLOSED);
        _eventSource.fire(Playback$closed, {}, true);
        // stop firing events
        _eventSource.dispose();
    }

    // close the playback (so we stop all donwnloads) when window is unloading
    // also, Playback needs to be the last to handle this... in case say PlayDataManager needs to do something synchroniously
    function _onBeforeUnload() {
        _startClosing();
    }
    globalEvents.addListener(globalEvents$beforeunload, _onBeforeUnload, ORDERPROPERTY$late);

    // --------------------------------------------------------------------------------
    // -- mediaTime

    // current media time, a.k.a. PTS
    _self.mediaTime = new ObservableProperty();
    var _lastThrottledMediaTimeValue;
    function _fireThrottledMediaTimeChanged() {
        var v = _self.mediaTime.value;
        if (_lastThrottledMediaTimeValue != v) {
            _log.trace('MediaTime changed', { 'MediaTime': Number$formatMillisecond(v) });
            _lastThrottledMediaTimeValue = v;
            _eventSource.fire(Playback$throttledMediaTimeChanged);
        }
    }
    _self.mediaTime.addListener(function (args) {
        _mediaTimeChangedThrottle.schedule(_fireThrottledMediaTimeChanged);
    });
    _self.flushThrottledMediaTimeChanged = function () {
        _fireThrottledMediaTimeChanged();
    };

    // --------------------------------------------------------------------------------

    // is playback paused by user?
    // TODO: debug$assertBool(value);
    _self.paused = new ObservableProperty(false);
    _self.paused.addListener(function (args) {
        _log.info('Paused changed', { 'From': args.oldValue, 'To': args.newValue, 'MediaTime': Number$formatMillisecond(_self.mediaTime.value) });
    });

    _self.muted = new ObservableProperty(false);
    _self.volume = new ObservableProperty(config.defaultVolume / 100);

    // state of the presenter
    // TODO: debug$assertBool(value);
    _self.presentingState = new ObservableProperty(PresentingState$WAITING);
    _self.presentingState.addListener(function (args) {
        _log.info('PresentingState changed', { 'From': args.oldValue, 'To': args.newValue, 'MediaTime': Number$formatMillisecond(_self.mediaTime.value) }, _self.mediaBuffer.getLogFields());
    });

    // state of the downloader
    // TODO: debug$assert(value >= 0 && value <= 4);
    _self.bufferingState = new ObservableProperty(BufferingState$BUFFERING);
    _self.bufferingState.addListener(function (args) {
        _log.info('BufferingState changed', { 'From': args.oldValue, 'To': args.newValue, 'MediaTime': Number$formatMillisecond(_self.mediaTime.value) }, _self.mediaBuffer.getLogFields());
    });

    // debug$assert(value);
    _self.audioTrack = new ObservableProperty(null);
    _self.audioTrack.addListener(function (args) {
        debug$assert(args.newValue);
        _log.info('AudioTrack changed',
            args.newValue && { 'ToBcp47': args.newValue.bcp47, 'To': args.newValue.trackId },
            args.oldValue && { 'FromBcp47': args.oldValue.bcp47, 'From': args.oldValue.trackId },
            { 'MediaTime': Number$formatMillisecond(_self.mediaTime.value) }
        );
        _self.audioStream.set(_self.heuristics.getAudioRecommendation());
    });

    _self.videoTrack = new ObservableProperty(null);
    _self.videoTrack.addListener(function (args) {
        _self.videoStream.set(_self.getVideoStreamList()[0]);
    });

    _self.timedTextTrack = new ObservableProperty(null);
    _self.timedTextTrack.addListener(function (args) {
        _log.info('TimedTextTrack changed',
            args.newValue ? { 'ToBcp47': args.newValue.bcp47, 'To': args.newValue.trackId } : { 'To': 'none' },
            args.oldValue ? { 'FromBcp47': args.oldValue.bcp47, 'From': args.oldValue.trackId } : { 'From': 'none' },
            { 'MediaTime': Number$formatMillisecond(_self.mediaTime.value) }
        );
    });
    // unlike .timedTextTrack, this gets set only if timedTextTrack has downloaded it's data
    _self.activeTimedTextTrack = new ObservableProperty(null);
    _self.timedText = new ObservableProperty(null);

    _self.videoStream = new ObservableProperty(null);
    _self.audioStream = new ObservableProperty(null);
    _self.cdn = new ObservableProperty(null);
    _self.cdn.addListener(function (args) {
        var cdn = args.newValue;
        var cdnList = _self.cdnList;
        // make the selected cdn first in list
        cdnList.splice(cdnList.indexOf(cdn), 1);
        cdnList.unshift(cdn);
    });

    // chunk and time that is being presented now {stream, chunk, cdn}
    // unlike .mediaTime, .videoStream, .audioStream, .cdn, which indicate "what we want to show"
    // these indicate what's actually on the screen
    _self.presentedAudio = new ObservableProperty(null);
    _self.presentedVideo = new ObservableProperty(null);

    // chunk that started downloading {stream, chunk, cdn}
    _self.downloadingAudio = new ObservableProperty(null);
    _self.downloadingVideo = new ObservableProperty(null);

    // chunk that was downloaded last {stream, chunk, cdn}
    _self.downloadedAudio = new ObservableProperty(null);
    _self.downloadedVideo = new ObservableProperty(null);

    _self.bitrateRestriction = new ObservableProperty(null);

    // Playback$playbackstart
    // playback is considered started when PresentingState becomes something else by WAITING for the first time
    function _presentingStateChangedForPlaybackStart(e) {
        if (e.newValue != PresentingState$WAITING) {
            _self.presentingState.removeListener(_presentingStateChangedForPlaybackStart);
            _eventSource.fire(Playback$playbackstart);
        }
    }
    _self.presentingState.addListener(_presentingStateChangedForPlaybackStart);

    _self.addEventListener(Playback$playbackstart, function handlePlaybackStart(){
        _self.playDelay = NccpClient$formatMillisecond(_self.getRelativeTime());
        if (DEBUG) {
            _log.info('MovieId: ' + _self.movieId + ' PlayDelay: ' + _self.playDelay + ', milestones: ', _self.milestones);
        }
        var video = (_self.presentedVideo.value || _self.downloadedVideo.value);
        _self.initialVideoBitrate = video.stream.bitrate;
    });

    // Busy is either empty (player is not busy) or {stalled: true|false, progress: 0..1}
    // stalled and progress can be empty
    _self.busy = new ObservableProperty();
    Playback$initBusy(_self);

    // --------------------------------------------------------------------------------
    // custom diag info filled in with different components.
    // this is displayed in diag panel, and logged in startplay/midplay/endplay
    function _fireShouldUpdateVideoDiagInfo() {
        _eventSource.fire(Playback$shouldUpdateVideoDiagInfo, { videoDiagInfo: _videoDiagInfo });
    }
    _self.getVideoDiagInfo = function getVideoDiagInfo() {
        _fireShouldUpdateVideoDiagInfo();
        return _videoDiagInfo;
    };
    _self.setVideoDiagInfo = function setVideoDiagInfo(k, v) {
        _videoDiagInfo[k] = v;
    };

    // --------------------------------------------------------------------------------
    // -- playback components that are required to be ready before starting the playback
    // -- also create components that will be required for initialization
    // --------------------------------------------------------------------------------
    Playback$openPlaybacks.push(_self);
    _self.httpPlayback = new HttpPlayback(_self);
    _self.mediaHttp = new MediaHttp(_self);
    _self.bandwidthMeter = _bandwidthMeterFactory(config.bandwidthMeterType);

    _self.diagnostics = new PlayerDiagnostics(_self);
    _self.playbackInfoPanel = new PlaybackInfoPanel(_self);
    _self.playbackStreamManager = new PlaybackStreamManager(_self);
    _self.playDataManager = new PlayDataManager(_self);
    _self.mediaStreamFilter = new MediaStreamFilter(_self);

    if (config.enableHistorical) {
        _self.historical = new HistoricalBandwidth(_self);
    }

    function _bandwidthMeterFactory(type) {
        if (type === 'sliding_window') {
            return new SlidingWindowBandwidthMeter(_self);
        }
        return new BandwidthMeter(_self);
    }

    Playback$componentsWhenCreated.forEach(function (loadComponent) {
        loadComponent(_self);
    });

    addLoadMethodsToPlayback(this);
}

Playback.prototype = {
    getAudioStreamList: function () {
        return this.audioTrack.value.streams;
    },

    getVideoStreamList: function () {
        return this.videoTrack.value.streams;
    },

    createFilteredVideoStreamList: function () {
        var playback = this;
        return playback.getVideoStreamList().filter(function (stream) {
            return !playback.mediaStreamFilter.shouldDisallowStream(stream);
        });
    },

    getRelativeTime: function () {
        var loadTime = this.loadTime;
        if(!isNumber(loadTime)){
            loadTime = this.createTime;
        }
        // we might go from STATE_NOTLOADED -> CLOSING -> CLOSED and never have load time
        debug$assert(isUInt(loadTime) || !this.state || (this.state.value != Playback$STATE_LOADING && this.state.value != Playback$STATE_NORMAL));
        return clock$getTime() - loadTime;
    },

    importMilestones: function importMilestones(milestones) {
        var loadTime = this.loadTime,
            self = this;
        log.trace('importing milestones', milestones);
        enumerateOwnProperties(milestones, function(k, v) {
            self.milestones[k] = v - loadTime;
        });
    },
    normalizeKeyStatuses: function(list){
         var loadTime = this.loadTime,
            updatedList = {};
        enumerateOwnProperties(list, function(k, entries) {
            updatedList[k] = entries.map(function(v){
                return (v - loadTime);
            });
        });
        return updatedList;
    },
    getAbsoluteStartTime: function getAbsoluteStartTime() {
        var startTime,
            uiPlayStartTime = this.playbackParams['uiPlayStartTime'];

        if (isNumber(uiPlayStartTime)) {
            startTime = uiPlayStartTime;
        } else if (this.loadTime) {
            startTime = this.loadTime + clock$getPreciseAppEpoch();
        } else {
            startTime = this.createTime + clock$getPreciseAppEpoch(); //if load is not called or an exception occurs before.
        }
        debug$assert(isUInt(startTime));
        return startTime;
    },
    // calculates the delta from absolute time when user initiated the playback.
    // if uiPlayStartTime was not passed by UI, use the player.loadTime
    calculatePlayDelay: function calculatePlayDelay() {
        return Date$now() - this.getAbsoluteStartTime();
    },
    isTrailer: function(){
        return this.uiLabel === 'trailer';
    },
    isBillboard: function(){
        return (this.uiLabel) && (this.uiLabel.indexOf('billboard') >= 0);
    }
     
};



// -- player/addLoadMethodsToPlayback.js

/**
* Decorates a playback object with methods needed
* to prepare the player for video playback.
*/
function addLoadMethodsToPlayback(playback) {
    var log = new playback.log.CategoryLog('Playback'),
        done,
        initialAudioBitrates,
        initialVideoBitrates,
        initialAudioStream,
        postAuthorize,
        initialVideoStream,
        _cachedAudioStream,
        _cachedVideoStream;

    playback.load = function load(postAuth) {
        this.load = BADOP;
        postAuthorize = postAuth;

        if (playback.state.value != Playback$STATE_NOTLOADED) {
            // we might be closed, without ever being loaded
            return;
        }

        log.info('Playback loading', playback);

        playback.notifyLoading();

        // STEP 1: make sure all async components are loaded
        loadAsync(function (result) {
            if (result.success) {
                playback.createCoreObjects1();
            } else {
                processFatalError(result.errorCode || ErrorCodes.INIT_ASYNCCOMPONENT, result);
            }
        });
    };
    // Step 1.1: Create first set of core objects
    playback.createCoreObjects1 = function createCoreObjects1() {
        try {
            var accountKey = playback.accountKey;
            // TODO: should this load async?
            var account = accountKey ? account$get(accountKey) : account$getLatest();

            playback.accountKey = account.accountKey;
            playback.account = account;

            switch (config.heuristicsAlgorithm) {
                case 'random':
                    playback.heuristics = new PlaybackHeuristicsRandom(playback);
                    break;
                case 'fixed':
                    playback.heuristics = new PlaybackHeuristicsFixed(playback);
                    break;
                case 'bb':
                    playback.heuristics = new BufferBasedBitrateRestriction(playback);
                    break;
                default:
                    playback.heuristics = new PlaybackHeuristics(playback);
            }

            playback.nccpPlayback = new NccpPlayback(playback);
            playback.nccpLogging = new NccpLogging(playback);

            
            if(config.captureUnhandledExceptions){
                playback.exceptionHandler = new ExceptionHandler(playback, nccpLogBatcher.flush, log);
            }
            playback.validateInputs();
        } catch (e) {
            processFatalError(ErrorCodes.INIT_CORE_OBJECTS1, {
                errorSubCode: ErrorSubCodes.EXCEPTION,
                errorDetails: exceptionToString(e)
            });
        }
    };

    // STEP 2: check the inputs
    playback.validateInputs = function validateInputs() {
        // if there is a pending error, now it's a good time to actually close with it
        if (playback.fatalError) {
            playback.closeWithError(playback.fatalError);
            return;
        }

        // * valid movieId
        if (!isPositiveInt(playback.movieId)) {
            processFatalError(ErrorCodes.INIT_BADMOVIEID);
            return;
        }

        playback.checkSessionLock();
    };

    // STEP 3.1: check if we have session lock, we should not start playback without one
    playback.checkSessionLock = function checkSessionLock() {
        var result = storageLock.sessionLockResult;
        if (result) {
            if (result.success) {
                playback.closeOtherPlaybacks();
            } else {
                processFatalError(ErrorCodes.INIT_SESSION_LOCK, result);
            }
        } else {
            debug$assert(!config.enforceSingleSession);
            // if there is no sessionLockResult, then just ignore it
            playback.acquirePlaybackLock();
        }
    };

    // STEP 3.2: close other playbacks in this tab
    playback.closeOtherPlaybacks = function closeOtherPlaybacks() {
        if (config.closeOtherPlaybacks) {
            // before we load, close all open playbacks
            Playback$closeOpenPlaybacks(function() {
                playback.acquirePlaybackLock();
            }, playback);
        } else {
            playback.acquirePlaybackLock();
        }
    };

    // STEP 3.3: try to get the playback lock, we should not start playback without one
    playback.acquirePlaybackLock = function acquirePlaybackLock() {
        if (playback.state.value != Playback$STATE_LOADING)
            return;

        if (config.enforceSinglePlayback && (!playback.isTrailer()) && (!playback.isBillboard())) {
            storageLock.acquire(Playback$LOCKNAME, function(result) {
                if (result.success) {
                    playback.lockToken = result.lockToken;
                    playback.sendPersistedPlaydata();
                } else {
                    processFatalError(ErrorCodes.INIT_PLAYBACK_LOCK);
                }
            });
        } else {
            playback.sendPersistedPlaydata();
        }
    };

    // STEP 4: allow the playDataManager to send persisted playdata early (before auth) if it has to
    playback.sendPersistedPlaydata = function sendPersistedPlaydata() {
        if (playback.state.value != Playback$STATE_LOADING)
            return;

        playback.notifyMilestone('ic');
        playback.playDataManager.sendPersistedPlaydataEarly(function(result) {
            if (result.error) {
                log.error('Error sending persisted playdata', ErrorSubCodes$errorResultToLogFields(result));
            }
            // error or not, keep going
            playback.authorize();
        });
    };

    // STEP 5: get authorization response from NCCP which has tracks and streams
    playback.authorize = function authorize() {
        if (playback.state.value != Playback$STATE_LOADING)
            return;

        log.info('Authorizing', playback);
        var ats = clock$getTime();
        playback.notifyMilestone('ats');
        playback.nccpPlayback.authorize(function(result) {
            if (playback.state.value != Playback$STATE_LOADING)
                return;

            playback.notifyMilestone('at');
            var manifestData = playback.manifestData;
            playback.importMilestones({
                'pr_ats': (manifestData && isDefined(manifestData.requestStartTimePrepare)) ? manifestData.requestStartTimePrepare : ats,
                'pr_at': (manifestData && isDefined(manifestData.requestEndTimePrepare)) ? manifestData.requestEndTimePrepare : clock$getTime()
            });

            if (!result.success) {
                // use special messages depending on which NCCP method failed
                switch (result.method) {
                    case 'register':
                        processFatalError(ErrorCodes.NCCP_AUTHORIZE_REGISTER, result);
                        return;
                    case 'authenticationrenewal':
                        processFatalError(ErrorCodes.NCCP_AUTHORIZE_AUTHRENEW, result);
                        return;
                    default:
                        processFatalError(ErrorCodes.NCCP_AUTHORIZE, result);
                        return;
                }
            }


            if (playback.isTrailer() && config.prepareCadmium && videoPreparer && config.consumePreCachedStreams) {
                var context = {
                    log: log,
                    prefix: config.prepItemsStorePrefix,
                    isTest: config.environmentIsTest,
                    storage: storage
                };

                if (!manifestData) {
                    log.error('manifest data not available when uiLabel is trailer');
                    setupStreamsAndCdn();
                } else {
                    playback.notifyMilestone('pfs');
                    function initializeCachedStreams(result) {
                        playback.prefetchSummary = result.summary;
                        _cachedAudioStream = result.streams[0];
                        _cachedVideoStream = result.streams[1];
                    }

                    function handleErrorInLoadingPrefetchedStreams(result) {
                        var summary = result && result.summary;
                        log.error('error loading streams from cache', summary || result);
                        playback.prefetchSummary = summary;
                    }

                    videoPreparer.getPrefetchedStreams(manifestData, context)
                        .then(initializeCachedStreams)
                        .catch(handleErrorInLoadingPrefetchedStreams)
                        .then(function() {
                            playback.notifyMilestone('pf');
                            setupStreamsAndCdn();
                        });
                }
            } else {
                setupStreamsAndCdn();
            }


            function setupStreamsAndCdn() {
                var streamCdnList;

                try {
                    initialAudioBitrates = config.initialAudioBitrates,
                    initialVideoBitrates = config.initialVideoBitrates;
                    if (_cachedAudioStream) {
                        initialAudioBitrates = [_cachedAudioStream.bitrate];
                    }
                    if (_cachedVideoStream) {
                        initialVideoBitrates = [_cachedVideoStream.bitrate];
                    }


                    // pick initial streams as the first choice of configured initial bitrates
                    initialAudioBitrates = playback.getAudioStreamList().toBitrates(initialAudioBitrates);
                    initialVideoBitrates = playback.getVideoStreamList().toBitrates(initialVideoBitrates);

                    initialAudioStream = playback.getAudioStreamList().closestTo(initialAudioBitrates[0] || 0);
                    initialVideoStream = playback.getVideoStreamList().closestTo(initialVideoBitrates[0] || 0);

                    // stream CDN-s are the CDN-s that have urls for audio and video streams
                    streamCdnList = [];
                    function addCdnToStreamCdnList(stream) {
                        enumerateOwnProperties(stream.downloadUrls, function(cdnId, url) {
                            if (isUrl(url)) {
                                playback.cdnList.forEach(function (cdn) {
                                    if (cdn.id === cdnId) {
                                        Array$pushIfDoesntContain(streamCdnList, cdn);
                                    }
                                });
                            }
                        });
                    };
                    map.call(playback.getAudioStreamList(), addCdnToStreamCdnList);
                    map.call(playback.getVideoStreamList(), addCdnToStreamCdnList);
                    sort.call(streamCdnList, function (a, b) {
                        return a.rank - b.rank;
                    });

                    // primary cdn is always the first on the list (one with lowest rank)
                    playback.primaryCdn = streamCdnList[0];
                    playback.streamCdnList = streamCdnList;

                    var streamLocationGroups = {};
                    streamCdnList.forEach(function(cdn) {
                        var locationId = cdn.location.id;
                        if (!streamLocationGroups[locationId]) {
                            streamLocationGroups[locationId] = [];
                        }

                        streamLocationGroups[locationId].push(cdn);
                    });
                    var streamLocationList = [];
                    enumerateOwnProperties(streamLocationGroups, function(locationId, cdnList) {
                        var location = cdnList[0].location;
                        location.cdnList = cdnList;
                        streamLocationList.push(location);
                    });
                    playback.streamLocationList = streamLocationList.sort(function(a, b) {
                        return a.rank - b.rank;
                    });

                    if (playback.primaryCdn != playback.cdnList[0]) {
                        log.error('Primary CDN does not have downloadUrls for a/v streams', {
                            'CdnId': playback.cdnList[0].id
                        });
                    }
                } catch (e) {
                    // exception here is most likely caused by faulty auth response or
                    // bug in parseNccpAuthorizationResponse
                    log.error('Exception while picking initial streams', e);
                }

                // Make sure we have the minimum to start the playback with
                //  * a valid primary CDN,
                //  * valid audio stream, with a valid download URL for primary CDN
                //  * valid video stream, with a valid download URL for primary CDN
                if (initialAudioStream &&
                    initialVideoStream &&
                    streamCdnList.length) {
                    playback.processPostAuthorize();
                } else {
                    processFatalError(ErrorCodes.NCCP_AUTHORIZE_VERIFY);
                }
            }
        });
    };

    // Step 6: postAuthorize custom step, if there is one
    /** memberOf {Playback} */
    playback.processPostAuthorize = function processPostAuthorize() {
        if (postAuthorize) {
            log.info('Processing post-authorize', playback);
            postAuthorize(playback, function(result) {
                if (result.success) {
                    playback.downloadInitialStreamHeaders();
                } else {
                    processFatalError(ErrorCodes.INIT_POSTAUTHORIZE, result);
                }
            });
        } else {
            playback.downloadInitialStreamHeaders();
        }
    };

    // Step 7: Download some stream headers
    /** memberOf {Playback} */
    playback.downloadInitialStreamHeaders = function downloadInitialStreamHeaders() {
        if (playback.state.value != Playback$STATE_LOADING)
            return;

        log.info('Filtered initial stream headers', playback, { 'Audio': initialAudioBitrates.join('|'), 'Video': initialVideoBitrates.join('|') });
        playback.notifyMilestone('shs');

        // process force Track Selection if applicible
        var matches;
        if (config.forceAudioTrack) {
            matches = playback.audioTrackList.filter(function(track) {
                return track.bcp47 == config.forceAudioTrack || track.trackId == config.forceAudioTrack;
            });
            if (matches && matches.length) {
                playback.audioTrack.set(matches[0]);
            }
        }

        if (config.forceTimedTextTrack) {
            matches = playback.timedTextTrackList.filter(function(track) {
                return track ? (track.bcp47 == config.forceTimedTextTrack || track.trackId == config.forceTimedTextTrack) : config.forceTimedTextTrack.toLowerCase() == 'none';
            });
            if (matches && matches.length) {
                playback.timedTextTrack.set(matches[0]);
            }
        }

        // Download multiple stream headers,
        // Wait for all headers download to complete...
        // ... or, if timeout elapses, a single audio and a single video should suffice
        var audioStreamList = playback.getAudioStreamList(),
            videoStreamList = playback.getVideoStreamList(),
            audioHeader = audioStreamList[0],
            videoHeader = videoStreamList[0];

        if (playback.isTrailer()) { 
            if (_cachedAudioStream) { // if this is ever tested again, then update the useFilteredInitialBitratesOnly logic
                audioHeader = initialAudioStream;
            }
            if (_cachedVideoStream) {
                videoHeader = initialVideoStream;
            }
        }
        var headersToDownload = [audioHeader, videoHeader];
        if (config.useFilteredInitialBitratesOnly) {
            headersToDownload = [];
        }
        var headerDownloadsInProgress = 0,
            headerDownloadTimeoutEllapsed = false,
            lastDownloadFailureResult;

        // When initialiazing trailers or billboards, we will only download the lowest audio bitrate.
        // Therefore, we don't need to download additional audio header.
        if(!playback.isTrailer() && !playback.isBillboard()) {
            // fill the list with streams we want to download
            initialAudioBitrates.forEach(function(bitrate) {
                var stream = audioStreamList.closestTo(bitrate);
                if (!(headersToDownload.indexOf(stream) >= 0)) {
                    headersToDownload.push(stream);
                }
            });
        }

        initialVideoBitrates.forEach(function(bitrate) {
            var stream = videoStreamList.closestTo(bitrate);
            if (!(headersToDownload.indexOf(stream) >= 0)) {
                headersToDownload.push(stream);
            }
        });

        
        var logdata = headersToDownload.map(function(h) {
            return h ? (h.type + ':' + h.bitrate) : ''
        });

        log.info('Downloading initial stream headers', playback, logdata.join('|'));

        function dumpDownloadResults(asError) {
            var result = {};
            headersToDownload.forEach(function(header) {
                if(!header.downloadResult){
                    return;
                }
                var downloadResult = {'success': header.downloadResult.success};
                if (header.downloadResult.errorSubCode) {
                    downloadResult['errorSubCode'] = header.downloadResult.errorSubCode;
                }
                if (header.downloadResult.errorExternalCode) {
                    downloadResult['errorExternalCode'] = header.downloadResult.errorExternalCode;
                }
                if (header.downloadResult.errorDetails) {
                    downloadResult['errorDetails'] = header.downloadResult.errorDetails;
                }
                if (header.downloadResult.errorHttpCode) {
                    downloadResult['errorHttpCode'] = header.downloadResult.errorHttpCode;
                }
                if (header.downloadResult.url) {
                    downloadResult['url'] = header.downloadResult.url;
                }
                result[header.contentProfile + ':' + header.bitrate] = {
                    'urls': header.downloadUrls,
                    'result': downloadResult
                };
            });
            if (asError) {
                log.error('Header download results', stringifyJsonPretty(result));
            } else if (DEBUG || DEV) {
                log.trace('Header download results', stringifyJsonPretty(result));
            }
        }

        function assessHeaderDownloadState() {
            // This condition only applies to normal mode.
            // In trailer mode, we should proceed as long as we have one audio & video header
            if ( ( !playback.isTrailer() && !playback.isBillboard() ) && headerDownloadsInProgress > 0 && !headerDownloadTimeoutEllapsed) {
                // if we have pending downloads
                // and timeout didn't yet elapsed, wait
                return;
            }

            // pick lowest streams with header
            var audioStream = audioStreamList.firstAbove(0, true);
            var videoStream = videoStreamList.firstAbove(0, true);

            if (audioStream && videoStream) {
                // we have at least one of each header, we are done!
                initialAudioStream = audioStream;
                initialVideoStream = videoStream;
                assessHeaderDownloadState = NOOP;
                dumpDownloadResults(false);
                playback.populatePlayback();
            } else {
                // we don't have any usable header combination
                // and if there are no more donwloads in progress
                // or we got 420 from the server (proxy error)
                // this is a fatal error, end playback
                if ((lastDownloadFailureResult && lastDownloadFailureResult.errorSubCode === ErrorSubCodes.HTTP_PROXY) || headerDownloadsInProgress <= 0) {
                    assessHeaderDownloadState = NOOP;
                    dumpDownloadResults(true);
                    processFatalError(ErrorCodes.INIT_HEADER_MEDIA, lastDownloadFailureResult);
                }
            }
        }

        headerDownloadsInProgress = headersToDownload.length;
        headersToDownload.forEach(function(header) {
            log.trace('Downloading header', {
                'Type': header.type,
                'Bitrate': header.bitrate
            });
            header.downloadHeader((function(result) {
                header.downloadResult = result;
                if (!result.success) {
                    lastDownloadFailureResult = result;
                }
                headerDownloadsInProgress--;
                assessHeaderDownloadState();
            }));
        });

        setTimeout(function () {
            headerDownloadsInProgress > 0 && log.debug("Not all initial headers downloaded within the deadline (" + config.initialHeaderDownloadTimeout + " ms)");
            headerDownloadTimeoutEllapsed = true;
            assessHeaderDownloadState();
        }, config.initialHeaderDownloadTimeout);
    };

    // Step 8: Use initial audio and initial video stream as primary (we should have header for these by now),
    // and pick a good CDN (based on observed download failures), and determine video size
    /** memberOf {Playback} */
    playback.populatePlayback = function populatePlayback() {
        try {
            if (playback.state.value != Playback$STATE_LOADING)
                return;

            playback.notifyMilestone('sh');

            log.trace('Initializing primary streams and MediaBuffer');

            if(!config.useASE){
                // we can't switch audio, so pick whatever we think is best based on how fast we were able to download headers
                playback.audioStream.set(playback.primaryAudioStream = playback.heuristics.getAudioRecommendation(true));

                // for video, start with initial... we can switch up later
                playback.videoStream.set(playback.primaryVideoStream = initialVideoStream);
            }

            // primary streams must exist and have headers
            debug$assert(playback.primaryAudioStream && playback.primaryAudioStream.header && playback.primaryVideoStream && playback.primaryVideoStream.header);

            // create the media buffer, which will tie downloader and presenter together
            playback.mediaBuffer = new MediaBuffer(playback);
            // use audio or video track duration (whichever is longer)
            var audioChunks = playback.mediaBuffer.audioChunks;
            var videoChunks = playback.mediaBuffer.videoChunks;
            var audioEndTime = audioChunks.last.endTime;
            var videoEndTime = videoChunks.last.endTime;
            playback.duration = Math$max(audioEndTime, videoEndTime);
            playback.maxSeekablePosition = Math$min(audioEndTime, videoEndTime);


            // log a warning if there is a big discrepancy between audio and video streams
            if (Math$abs(audioEndTime - videoEndTime) > Math$min(audioChunks[0].duration, videoChunks[0].duration)) {
                log.error('Large audio and video duration gap', {
                    'AudioMS': audioEndTime,
                    'VideoMS': videoEndTime,
                    'MovieId': playback.movieId,
                    'AudioDlId': playback.primaryAudioStream.downloadableId,
                    'VideoDlId': playback.primaryVideoStream.downloadableId
                });
            }

            // video pixel size is the one that matches the stream with largest area (highest pixel count).
            var videoSize = { width: 1, height: 1 };
            playback.getVideoStreamList().forEach(function(s) {
                if (videoSize.width * videoSize.height < s.width * s.height) {
                    videoSize.width = s.width;
                    videoSize.height = s.height;
                }
            });
            playback.videoSize = videoSize;

            var bookmarkTime = parseInt10(config.bookmarkByMovieId[playback.movieId]);
            if (isInt(bookmarkTime)) {
                log.info('Overriding bookmark', { 'From': playback.bookmarkTime, 'To': bookmarkTime });
                playback.bookmarkTime = bookmarkTime;
            } else {
                // now that we know the duration, let's see if we should ignore the bookmark
                bookmarkTime = playback.bookmarkTime;
                if (bookmarkTime && bookmarkTime < config$bookmarkToMilliseconds(config.bookmarkIgnoreBeginning, playback.duration)) {
                    log.trace('Ignoring bookmark because it\'s to close to beginning');
                    playback.bookmarkTime = 0;
                }
                if (bookmarkTime && bookmarkTime > (playback.duration - config$bookmarkToMilliseconds(config.bookmarkIgnoreEnd, playback.duration))) {
                    log.trace('Ignoring bookmark because it\'s to close to end');
                    playback.bookmarkTime = 0;
                }
            }

            playback.createWorkedObjects();
        } catch (e) {
            processFatalError(ErrorCodes.INIT_CORE_OBJECTS2, {
                errorSubCode: ErrorSubCodes.EXCEPTION,
                errorDetails: exceptionToString(e)
            });
        }
    };

    // Step 9: Create core worked objects (this starts downloads and playback)
    /** memberOf {Playback} */
    playback.createWorkedObjects = function createWorkedObjects() {
        try {
            // now create the main worker objects...
            // Note: downloader and time tracker should be created after presenter, because presenter will change the playback.mediaTime

            // presenter to play the media...
            playback.mediaPresenter = new MediaPresenter(playback);

            if (playback.isTrailer()) {
                if (_cachedAudioStream) {
                    var chunks = playback.mediaBuffer.audioChunks;
                    populateMediaFromCache(chunks, initialAudioStream, _cachedAudioStream);
                }
                if (_cachedVideoStream) {
                    var chunks = playback.mediaBuffer.videoChunks;
                    populateMediaFromCache(chunks, initialVideoStream, _cachedVideoStream);
                }
            }
            // downloader to fetch the media (CDN Selection happens here.)...
            playback.mediaDownloader = createDownloader(playback);

            // timed text...
            playback.timedTextManager = new TimedTextManager(playback);

            // render the timed text
            if (config.renderTimedText) {
                playback.timedTextPresenter = new TimedTextPresenter(playback);
            }

            // play time tracker for reporting and diagnostics
            playback.playTimeTracker = new PlayTimeTracker(playback);

            // monitor for long pauses OR suspended execution, and induce playback error
            playback.inactivityMonitor = new InactivityMonitor(playback);

            Playback$componentsWhenLoaded.forEach(function(loadComponent) {
                loadComponent(playback);
            });

            // and finally tell the playback that we are done
            playback.notifyLoaded();


        } catch (e) {
            processFatalError(ErrorCodes.INIT_CORE_OBJECTS3, {
                errorSubCode: ErrorSubCodes.EXCEPTION,
                errorDetails: exceptionToString(e)
            });
        }
    };
    function populateMediaFromCache(chunks, stream, _cachedStream) {
        if (!chunks || !chunks.length) {
            log.warn('chunks not available in mediabuffer', _cachedStream.type);
            return;
        }
        if (!_cachedStream || !_cachedStream.chunksFromCache) {
            log.warn('chunks not available in cached stream', _cachedStream.type);
            return;
        }

        try {
            chunks.forEach(function(chunk, i) {
                var cachedChunk = _cachedStream.chunksFromCache[i],
                    media = cachedChunk && cachedChunk['media'];
                if (media && isString(media)) { 
                    log.info('chunk served from cache', chunk.logFields);
                    var content = base64$decode(media)['buffer'];
                    chunk.media = {
                        arrayBuffer: content,
                        length: content.byteLength,
                        stream: stream,
                        cdn: cachedChunk['cdn'] // TODO capture the cdn info in cached chunk download
                    }
                }else{
                    log.warn('chunk not in cache', chunk.logFields);
                }
            })
        } catch (e) {
            log.error('error reading cached chunks', e);
        }
    }
    function createDownloader(playback) {
        if (config.connectionStrategy === 'parallel') {
            return new ParallelMediaDownloader(playback);
        }
        return new MediaDownloader(playback);
    }

    /**
    * @param {number} errorCode
    * @param {Object|string|number=} errorResult
    */
    function processFatalError(errorCode, errorResult) {
        if (done) return; done = true;
        playback.closeWithError(new PlayerError(errorCode, errorResult));
    }
}



// -- player/Playback-busy.js
/**
* Helper method for initializing playback.busy property.
*/
function Playback$initBusy(playback) {
    var GRACE_PERIOD = 199,
        UPDATE_INTERVAL = 100;

    var _busy = playback.busy,
        _lastNonBusy  = 0,
        _busySince,
        _earliestEta,
        _lastProgressBackwardsTime,
        _updateBusyInterval;

    playback.state.addListener(function () {
        _startOrStopUpdateBusyTimer();
        _updateBusy();
    }, ORDERPROPERTY$late);

    playback.presentingState.addListener(function (args) {
        if (args.oldValue != PresentingState$WAITING || args.newValue != PresentingState$WAITING) {
            _lastNonBusy = clock$getTime();
        }
        _startOrStopUpdateBusyTimer();
    });
    playback.bufferingState.addListener(function () {
        _startOrStopUpdateBusyTimer();
    });
    _startUpdatingBusy();

    function _isBusy() {
        return playback.state.value == Playback$STATE_LOADING ||
                (playback.state.value == Playback$STATE_NORMAL && playback.presentingState.value == PresentingState$WAITING);
    };

    function _startOrStopUpdateBusyTimer() {
        if (_isBusy()) {
            _startUpdatingBusy();
        } else {
            _stopUpdatingBusy();
        }
    };

    function _updateBusy() {
        var now = clock$getTime(),
            oldValue = _busy.value,
            oldProgress = oldValue ? oldValue.progress : 0,
            eta,
            isBusy = playback.state.value == Playback$STATE_LOADING || (_isBusy() && (now - _lastNonBusy > GRACE_PERIOD)),
            isStalled,
            progress,
            progressRollback;

        if (isBusy && playback.state.value == Playback$STATE_NORMAL) {
            // why are we busy? any ETA for becoming non-busy?
            if (playback.bufferingState.value == BufferingState$STALLED) {
                // network is stalled
                progress = oldProgress;
                isStalled = true;
            } else {
                // if buffering is in progress, then we can have a (more or less) reliable progress
                eta = now + (playback.mediaDownloader.howLongToNormalState() || 0);
                _busySince = _busySince || now;
                _earliestEta = _earliestEta || _busySince + config.minBufferingTimeInMilliseconds+1;
                if (isNumber(eta)) {
                    eta = Math$max(eta, _earliestEta);
                    var maxProgress = playback.mediaDownloader.getMaxProgress();
                    progress = Math$round(Number$clamp((now - _busySince) / (eta - _busySince), 0,maxProgress) * 1000) / 1000;
                }
            }

            // heuristics changes its mind about progress quite a bit... 
            // make the "progress" indicator not look silly my moving backwards
            if (progress < oldProgress) {
                // progress moved backwards

                // if the jump is small, stick to the current number
                if (oldProgress - progress < config.progressBackwardsMinPercent / 100) {
                    progress = oldProgress;
                    _lastProgressBackwardsTime = undefined;
                } else {
                    // did we observe progress moving backwards before?
                    if (_lastProgressBackwardsTime) {
                        if (now - _lastProgressBackwardsTime > config.progressBackwardsGraceTimeMilliseconds) {
                            // if it's above threashold, reset the timestamp and allow it to jump backwards
                            progressRollback = true;
                            _lastProgressBackwardsTime = undefined;
                        } else {
                            // if it's bellow threashold, don't let it go backwards
                            progress = oldProgress;
                        }
                    } else {
                        // if it didn't, just remember current time and don't let it go backwards
                        _lastProgressBackwardsTime = now;
                        progress = oldProgress;
                    }
                }
            }

        } else {
            _busySince = undefined;
            _earliestEta = undefined;
            _lastProgressBackwardsTime = undefined;
        }

        var newValue = isBusy ? { stalled: isStalled, progress: progress, progressRollback: progressRollback } : null;

        // Should we update the progress? We don't want to flood listners with meaningless updates.
        if (
                ! newValue    ||  /* beginning of buffering */
                ! _busy       ||  /* ... */
                ! _busy.value ||  /* ... */
                (isNumber(newValue.progress) && !isNumber(_busy.value.progress)) ||  /* For the first update, busy progress will be NAN so need to update */
                (isNumber(newValue.progress) && isNumber(_busy.value.progress) && Math$abs(newValue.progress - _busy.value.progress) > 0.01) || /* Only update on whole % point changes */
                (newValue.stalled !== oldValue.stalled) /* Update if stalled value changed */
        ) {
            _busy.set(newValue);
        }
    };

    function _startUpdatingBusy() {
        if (!_updateBusyInterval) {
            _updateBusyInterval = setInterval(_updateBusy, UPDATE_INTERVAL);
        }
    };

    function _stopUpdatingBusy() {
        if (_updateBusyInterval) {
            clearInterval(_updateBusyInterval);
            _updateBusyInterval = undefined;
            dispatch(_updateBusy);
        }
    };
};


// -- player/Playback-common.js


/**
* @param {Object=} except
*/
function Playback$closeOpenPlaybacks(callback, except) {
    var openPlayback = Playback$openPlaybacks[0];
    if (openPlayback == except) {
        openPlayback = Playback$openPlaybacks[1];
    }
    if (openPlayback) {
        openPlayback.close(function () {
            Playback$closeOpenPlaybacks(callback, except);
        });
    } else {
        callback && callback(SUCCESS);
    }
}

/**
* @param {function(Playback)} loadComponent 
* 
* Takes a function which creates a component. The function takes playback as an argument.
*/
function Playback$registerComponent(whenToLoad, loadComponent) {
    switch (whenToLoad) {
        case Playback$COMPONENT_WHEN_CREATED:
            Playback$componentsWhenCreated.push(loadComponent);
            return;
        case Playback$COMPONENT_WHEN_LOADED:
            Playback$componentsWhenLoaded.push(loadComponent);
            return;
    }
    debug$assert(false);
}

var Playback$_index = 0;

// while a playback is open, it will be in this list
var Playback$openPlaybacks = [];

var Playback$componentsWhenCreated = [],
    Playback$componentsWhenLoaded = [];

var Playback$COMPONENT_WHEN_CREATED = 1,
    Playback$COMPONENT_WHEN_LOADED = 3;

var Playback$firstPlaybackLog,
    Playback$mostRecentPlaybackLog;

// we want to always have an xid, even before playback is created
// so generate the xid for first playabck in advance

// first playback will pick this up and clear it
var Playback$firstPlaybackXid = clock$createId(),
    // this one will always exist and be valid
    Playback$mostRecentPlaybackXid = Playback$firstPlaybackXid;

var Playback$throttledMediaTimeChanged = 1,
    Playback$closing = 2,
    Playback$bufferUnderrun = 3,
    Playback$repositioning = 4,
    Playback$repositioned = 5,
    Playback$playbackstart = 6,
    Playback$authorized = 7,
    Playback$licensed = 8,
    Playback$closed = 9,
    Playback$decoderUnderrun = 10,
    Playback$timedTextTrackListChanged = 11,
    Playback$shouldUpdateVideoDiagInfo = 12,
    Playback$tryRecoverFromStall = 13,
    Playback$trickPlayFramesChanged = 14,
    Playback$licenseAdded = 15,
    Playback$subtitleError = 16,
    HttpPlayback$downloadstarted = 21,
    HttpPlayback$downloadcomplete = 22,
    MediaBuffer$changed = 30,
    MediaBuffer$trackchanged = 31,
    BandwidthMeter$aggregateUpdated = 41,
    MediaPresenter$needlicense = 51,
    // TODO move this to Playback$ events
    MediaPresenter$paused = 52,
    MediaPresenter$currentTimeChanged = 53,
    MediaPresenter$seeked = 54;

var Playback$BUFFER_UNDERRUN_CAUSE_NETWORK = 'network',
    Playback$BUFFER_UNDERRUN_CAUSE_MEDIA = 'media';

var Playback$REPOSITION_CAUSE_INITIAL = 1,
    Playback$REPOSITION_CAUSE_SEEK = 2,
    Playback$REPOSITION_CAUSE_TRACK_CHANGED = 3;

var Playback$STATE_NOTLOADED = 0,
    Playback$STATE_LOADING = 1,
    Playback$STATE_NORMAL = 2,
    Playback$STATE_CLOSING = 3,
    Playback$STATE_CLOSED = 4;

var BufferingState$NORMAL = 1, // have enough data to start uninterrupted playback, and downloading as necessary
    BufferingState$BUFFERING = 2, // downloading, not enough data to start uninterrupted playback
    BufferingState$STALLED = 3; // unable to download (trying with a cooldown), not enough data to start uninterrupted playback

var PresentingState$WAITING = 1, // presenter is waiting for either buffering or some internal processing
    PresentingState$PLAYING = 2, // presenter is playing, the current time is actually progressing
    PresentingState$PAUSED = 3, // presenter is paused, it can start playback near instantaneously
    PresentingState$ENDED = 4; // presenter is done playing all the media, and is paused at the last frame

var Playback$LOCKNAME = 'playback';


// -- player/createPlayback.js
function createPlayback(accountKey, movieId, playbackParams) {
    var idProvider = new DefaultIdProvider();//di.resolve('idProvider');

    if (config.useASE) {
        return new PlaybackASE(accountKey, movieId, playbackParams, idProvider);
    }
    return new Playback(accountKey, movieId, playbackParams, idProvider);
}



// -- player/TrackingLog.js
/**
 * Send all the playback open and outcome (start?error?abort?) logs in simple way for tracking.
 */
Playback$registerComponent(Playback$COMPONENT_WHEN_CREATED, function loadTrackingLog(playback) {
    
    var _url = config.trackingLogUrl;
    if (!config.trackingLogEnabled || !_url) {
        return;
    }

    var _stallDelayId,
        _loadTime,
        _stallKeyPoints = config.trackingLogStallKeyPoints.slice(),
        _common = 'xid=' + playback.xid + '&pbi=' + playback.index + '&uiLabel=' + (playback.uiLabel || '');

    playback.state.addListener(_onPlaybackStateChanged);
    playback.addEventListener(Playback$playbackstart, _onPlaybackStart);
    playback.addEventListener(Playback$closing, _onPlaybackClosing);
    globalEvents.addListener(globalEvents$beforeunload, _onBeforeUnload, ORDERPROPERTY$early);

    // 'openplay' is sent immidiately when we start loading a playback
    // 'startplay' resembled NCCP startplay, and is sent when playback starts or fails to start, it can have outcome='success/error/abort/unload'
    // 'startstall' is sent if playback is still loading at every config.trackingLogStallKeyPoints

    function _onPlaybackStateChanged(args) {
        if (args.newValue >= Playback$STATE_LOADING) {
            playback.state.removeListener(_onPlaybackStateChanged);
            _sendTrackingLog('type=openplay&sev=info&locstor=' + escape(_getLocalStorageInfo()));
            _loadTime = clock$getTime();
            _waitForNextStall();
        }
    };

    function _onPlaybackStart() {
        _startDone('type=startplay&sev=info&outcome=success');
    };

    function _onPlaybackClosing() {
        var fatalError = playback.fatalError;
        if (fatalError) {
            var s = 'type=startplay&sev=error&outcome=error';
            var data = {};
            NccpLogging$_addPlayerErrorFields(data, fatalError);
            enumerateOwnProperties(data, function(k, v) {
                s += '&' + escape(k) + '=' + escape(v || '');
            });
            _startDone(s);
        } else {
            _startDone('type=startplay&sev=info&outcome=abort');
        }
    };

    function _waitForNextStall() {
        var keyTime = _stallKeyPoints.shift();
        if (keyTime > 0) {
            var delay = Math$max(keyTime - (clock$getTime() - _loadTime), 0);
            _stallDelayId = setTimeout(function() {
                _sendTrackingLog('type=startstall&sev=info&kt=' + keyTime);
                _waitForNextStall();
            }, delay);
        }
    };

    function _onBeforeUnload() {
        _startDone('type=startplay&sev=info&outcome=unload');
    };

    function _startDone(part) {
        // run only once
        _startDone = NOOP;

        // augment with load timings
        part += '&initstart=' + loadAsync$startTime +
            '&initend=' + loadAsync$endTime;

        // send the tracking
        _sendTrackingLog(part);

        // and unwire all events
        clearTimeout(_stallDelayId);
        playback.removeEventListener(Playback$playbackstart, _onPlaybackStart);
        playback.removeEventListener(Playback$closing, _onPlaybackClosing);
        globalEvents.removeListener(globalEvents$beforeunload, _onBeforeUnload);
    };

    function _getLocalStorageInfo() {
        // temprary code to track # of playbacks that are able to work with local storage (it's not full)
        var result;
        try {
            var key = 'player$test';
            var v = '' + clock$getEpoch();
            localStorage['setItem'](key, v);
            var v2 = localStorage['getItem'](key);
            localStorage['removeItem'](key);
            result = (v == v2) ? 'success' : 'mism';
        } catch (e) {
            result = 'ex: ' + e;
        }
        return result;
    };

    function _sendTrackingLog(data) {
        var payload = _common +
            '&soffms=' + playback.getRelativeTime() +
            '&' + data;
        if (playback.milestones && Object['keys'](playback.milestones).length)
            payload += '&' + objectToQueryString(mixIn({}, playback.milestones, {
                prefix: 'sm_'
            }));
        trackingLog(payload, _url);
    }

});


// -- player/PlaybackInfoPanel.js
/**
* @constructor
*/
function PlaybackInfoPanel(playback) {
    var _updateThrottle = new Throttle(1000),
        _element = createElement('DIV', 'position:absolute;left:10px;top:10px;right:10px;bottom:10px', undefined, { 'class': 'player-info' }),
        _textarea = createElement('TEXTAREA', 'position:absolute;resize:none;box-sizing:border-box;width:100%;height:100%;padding:10px;background-color:rgba(0,0,0,0.4);color:#fff;font-size:12px;font-family:Arial;overflow:auto'),
        _controls = createElement('DIV', 'position:absolute;top:2px;right:2px'),
        _visible,
        _playbackProperties = [
            playback.mediaTime,
            playback.cdn,
            playback.presentedAudio,
            playback.presentedVideo,
            playback.audioStream,
            playback.videoStream,
            playback.activeTimedTextTrack,
            playback.state,
            playback.bufferingState,
            playback.presentingState,
            playback.volume,
            playback.muted
        ],
        _playbackEvents = [
            MediaBuffer$changed,
            BandwidthMeter$aggregateUpdated
        ],
        _customGroup = {},
        _intervalId,
        _currentDroppedFrames,
        _totalDroppedFrames;

    this.setCustom = _setCustom;

    var _playbackState = {};
    _playbackState[Playback$STATE_NOTLOADED] = 'Not Loaded';
    _playbackState[Playback$STATE_LOADING] = 'Loading';
    _playbackState[Playback$STATE_NORMAL] = 'Normal';
    _playbackState[Playback$STATE_CLOSING] = 'Closing';
    _playbackState[Playback$STATE_CLOSED] = 'Closed';

    var _bufferingState = {};
    _bufferingState[BufferingState$NORMAL] = 'Normal';
    _bufferingState[BufferingState$BUFFERING] = 'Pre-buffering';
    _bufferingState[BufferingState$STALLED] = 'Network stalled';

    var _presentingState = {};
    _presentingState[PresentingState$WAITING] = 'Waiting for decoder';
    _presentingState[PresentingState$PLAYING] = 'Playing';
    _presentingState[PresentingState$PAUSED] = 'Paused';
    _presentingState[PresentingState$ENDED] = 'Media ended';

    _textarea.setAttribute('readonly', 'readonly');
    _element.appendChild(_textarea);
    _element.appendChild(_controls);

    function _setCustom(label, data) {
        _customGroup[label] = data;
    }

    function _show() {
        if (!_visible) {
            _intervalId = setInterval(_onInterval, 1000);
            playback.rootElement.appendChild(_element);
            var i = _playbackProperties.length;
            while (i--) {
                _playbackProperties[i].addListener(_onPropertyChanged);
            }
            i = _playbackEvents.length;
            while (i--) {
                playback.addEventListener(_playbackEvents[i], _onPropertyChanged);
            }
            _visible = true;
        }
        _update();
    };

    function _hide() {
        if (_visible) {
            clearInterval(_intervalId);
            _currentDroppedFrames = undefined;
            _totalDroppedFrames = undefined;
            playback.rootElement.removeChild(_element);
            var i = _playbackProperties.length;
            while (i--) {
                _playbackProperties[i].removeListener(_onPropertyChanged);
            }
            i = _playbackEvents.length;
            while (i--) {
                playback.removeEventListener(_playbackEvents[i], _onPropertyChanged);
            }
            _updateThrottle.schedule();
            _visible = false;
        }
    };

    function _toggle() {
        _visible ? _hide() : _show();
    };

    function _getGroups() {
        var mediaBuffer = playback.mediaBuffer;
        var groups = [];
        var o;

        groups.push({
            'Version': VERSION,
            'Esn': (device ? device.esn : 'UNKNOWN'),
            'UserAgent': navigator.userAgent
        });

        try {
            groups.push({
                'MovieId': playback.movieId,
                'TrackingId': playback.trackingId,
                'Xid': playback.xid + ' (' + Playback$openPlaybacks.map(function (p) { return p.xid }).join(', ') + ')',
                'Position': Number$formatMillisecond(playback.mediaTime.value),
                'Duration': Number$formatMillisecond(playback.duration),
                'Volume': Math$round(playback.volume.value * 100) + '%' + (playback.muted.value ? ' (Muted)' : '')
            });
        }
        catch (e) {
        }

        try {
            var howLongToNormalState = playback.mediaDownloader ? playback.mediaDownloader.howLongToNormalState() : undefined;
            groups.push({
                'Player state': _playbackState[playback.state.value],
                'Buffering state': _bufferingState[playback.bufferingState.value] + (isNumber(howLongToNormalState) ? ', ETA:' + Number$formatMillisecond(howLongToNormalState) : ''),
                'Rendering state': _presentingState[playback.presentingState.value]
            });
        }
        catch (e) {
        }

        try {
            var totalBytes = mediaBuffer.getTotalBytes();
            var maxBufferSizeBytes = config.maxBufferSizeBytes;
            var presentedAudio = playback.presentedAudio.value;
            var presentedAudioStream = presentedAudio && presentedAudio.stream;
            var presentedVideo = playback.presentedVideo.value;
            var presentedVideoStream = presentedVideo && presentedVideo.stream;
            var cdn = playback.cdn.value;
            var playingVmaf = presentedVideoStream ? presentedVideoStream.vmaf : '';
            var bufferingVmaf = playback.videoStream.value ? playback.videoStream.value.vmaf : '';
            groups.push({
                'Playing bitrate (a/v)': (presentedAudioStream && presentedVideoStream) ? presentedAudioStream.bitrate + ' / ' + presentedVideoStream.bitrate + ' ( ' + presentedVideoStream.header.diagInfo + ' )' : '?',
                'Playing/Buffering vmaf' : playingVmaf + '/' + bufferingVmaf,
                'Buffering bitrate (a/v)': playback.audioStream.value.bitrate + ' / ' + playback.videoStream.value.bitrate,
                'Buffer size in Bytes (a/v)': mediaBuffer.getAudioBufferBytes() + ' / ' + mediaBuffer.getVideoBufferBytes(),
                'Buffer size in Bytes': totalBytes + (maxBufferSizeBytes ? ' (' + (totalBytes * 100 / maxBufferSizeBytes).toFixed(0) + '% of max)' : ''),
                'Buffer size in Seconds (a/v)': Number$formatMillisecond(mediaBuffer.getAudioBufferLength()) + ' / ' + Number$formatMillisecond(mediaBuffer.getVideoBufferLength()),
                'Will Rebuffer': playback.heuristics.isRebufferForecasted(),
                'Current CDN': cdn.name + ', Id: ' + cdn.id
            });
        }
        catch (e) {
        }

        try {
            var audioStream = playback.presentedAudio.value.stream,
                audioStreamHeader = audioStream.header,
                audioTrack = audioStream.track,
                videoStream = playback.presentedVideo.value.stream,
                videoStreamHeader = videoStream.header,
                timedTextTrack = playback.activeTimedTextTrack.value;

            groups.push({
                'Audio Track': audioTrack.bcp47 + ', Id: ' + audioTrack.trackId + ', Channels: ' + audioTrack.channels + ', Codec: ' + (audioStreamHeader && audioStreamHeader.codec),
                'Video Track': 'Codec: ' + (videoStreamHeader && videoStreamHeader.codec),
                'Timed Text Track': timedTextTrack ? timedTextTrack.bcp47 + ', Profile: ' + timedTextTrack.nccpProfile + ', Id: ' + timedTextTrack.trackId : 'none'
            });
        }
        catch (e) {
        }

        try {
            groups.push({
                'Framerate': playback.videoStream.value.header.framerate.toFixed(3),
                'Current Dropped Frames': isNumber(_currentDroppedFrames) ? _currentDroppedFrames : '',
                'Total Frames': playback.mediaPresenter.getFrameCount(),
                'Total Dropped Frames': playback.mediaPresenter.getDroppedFrameCount(),
                'Total Corrupted Frames': playback.mediaPresenter.getCorruptedFrameCount(),
                'Total Frame Delay': playback.mediaPresenter.getFrameDelayCount(),
                'Main Thread stall/sec': mainThreadMonitor ? mainThreadMonitor.getHistory().join(' ') : 'DISABLED',
                'VideoDiag': makeCsv(playback.getVideoDiagInfo())
            });
        }
        catch (e) {
        }

        try {
            if (playback.mediaBuffer) {
                if (config.useASE) {
                    groups.push({
                        'Throughput': playback.throughput + ' kbps'
                    });
                } else {
                    groups.push({
                        'Latency': playback.bandwidthMeter.getLatency() + ' ms',
                        'Throughput': (playback.bandwidthMeter.getThroughput() * BPMStoKBPS).toFixed(0) + ' KBPS',
                        'Bandwidth (normalized)': playback.bandwidthMeter.calculateNormalizedBandwidth() + ' KBPS',
                        'Max Sustainable Video Bitrate': playback.bandwidthMeter.calculateSustainableVideoBitrate() + ' KBPS'
                    });
                }
            }
        }
        catch (e) {
        }

        try {
            enumerateOwnProperties(_customGroup, function (k, v) {
                o = o || {};
                o[k] = JSON.stringify(v);
            });
            o && groups.push(o);
        }
        catch (e) {
        }

        return groups;
    };

    function _update() {
        // don't update if part of the console is selected, so user can copy-paste without loosing selection
        if (_textarea['selectionStart'] != _textarea['selectionEnd'])
            return;

        var groups = _getGroups();

        var s = '';

        groups.forEach(function (g) {
            s = s ? s + '\n' : '';
            enumerateOwnProperties(g, function (k, v) {
                s += k + ': ' + g[k] + '\n';
            });
        });

        _textarea['style']['fontSize'] = Number$clamp(Math$floor(_element.clientHeight / 60), 8, 18) + 'px';
        _textarea.value = s;
    };

    function _onInterval() {
        if (playback.mediaPresenter){
            var totalDroppedFrames = playback.mediaPresenter.getDroppedFrameCount();
            _currentDroppedFrames = totalDroppedFrames - _totalDroppedFrames;
            _totalDroppedFrames = totalDroppedFrames;

            _onPropertyChanged();
        }
    }

    function _onPropertyChanged() {
        _updateThrottle.schedule(_update);
    };

    function _onkeydown(event) {
        if (event.ctrlKey && event.altKey && event.shiftKey && (event.keyCode == 68 || event.keyCode == 81)) {
            _toggle();
        }
    };

    var _closeElement = createElement('BUTTON', null, 'X');
    _closeElement.addEventListener('click', _hide, false);
    _controls.appendChild(_closeElement);

    globalEvents.addListener(globalEvents$keydown, _onkeydown);
    playback.addEventListener(Playback$closing, function () {
        globalEvents.removeListener(globalEvents$keydown, _onkeydown);
        _hide();
    });

    mixIn(this,
    /** @lends {PlaybackInfoPanel.prototype} */
    {
        toggle: _toggle,
        show: _show,
        hide: _hide,
        getGroups: _getGroups
    });
};



// -- player/PlaybackStreamManager.js
/**
* @constructor
*/
function PlaybackStreamManager(playback) {
    var CONTROL_HEIGHT = 180;

    var _element = createElement('DIV', 'position:absolute;left:0;top:50%;right:0;bottom:0;text-align:center;color:#040;font-size:11px;font-family:monospace', undefined, { 'class': 'player-streams' }),
        _controls = createElement('DIV', 'display:inline-block;background-color:rgba(255,255,255,0.86);border:3px solid #fff;padding:5px;margin-top:' + (-CONTROL_HEIGHT / 2) + 'px'),
        _buttons = createElement('DIV', 'width:100%;text-align:center'),
        _audioSelectElement = _createSelectElement('Audio Bitrate'),
        _videoSelectElement = _createSelectElement('Video Bitrate'),
        _cdnSelectElement = _createSelectElement('CDN'),
        _visible,
        _overrideBitrateFilter = {};

    _element.appendChild(_controls);
    _controls.appendChild(_buttons);

    function _show() {
        if (!_visible) {
            _reloadContent();
            playback.rootElement.appendChild(_element);
            _visible = true;
        }
    };

    function _hide() {
        if (_visible) {
            playback.rootElement.removeChild(_element);
            _visible = false;
        }
    };

    function _toggle() {
        _visible ? _hide() : _show();
    };

    function _apply() {
        _overrideBitrateFilter = {};
        var options = _videoSelectElement.options;
        var i = options.length;
        while (i--) {
            var option = options[i];
            if (option.selected) {
                _overrideBitrateFilter[option.value] = 1;
            }
        }
        playback.createFilteredVideoStreamList = _createFilteredVideoStreamListOverride;
        playback.mediaBuffer.discardVideoMediaBasedOnFilter();
        if (config.useASE) {
            // Clear jobs in the Cadmium job queue and in progress
            if (config.abortInProgressDownload){
                playback.mediaDownloader.clearInProgressDownloads();
            }
            _updateASE();
        }

        var cdnList = playback.cdnList;
        if (cdnList) {
            var newCdnId = _cdnSelectElement.value;
            var newCdn = cdnList.filter(function (cdn) {
                return cdn.id == newCdnId;
            })[0];
            if (newCdn && newCdn != playback.cdn.value) {
                newCdn.cdnsel = { 'testreason': 'streammanager', 'selreason': 'userselection' };
                playback.cdn.set(newCdn);
            }
        }

        _hide();
    };

    function _updateASE() {
        // Notify ASE session about the change
        var filteredVideoStreamList = playback.createFilteredVideoStreamList();
        var fullVideoStreamList = playback.getVideoStreamList();
        var profileList = [];
        fullVideoStreamList.forEach(function(stream){
            if (profileList.indexOf(stream.contentProfile) == -1){
                profileList.push(stream.contentProfile);
            }
        });

        var minBitRate = null,
            maxBitRate = null;
        filteredVideoStreamList.forEach(function(stream){
            if ( minBitRate === null ) {
                minBitRate = stream.bitrate;
                maxBitRate = stream.bitrate;
            } else if ( maxBitRate < stream.bitrate ) {
                maxBitRate = stream.bitrate;
            } else if ( minBitRate > stream.bitrate ) {
                minBitRate = stream.bitrate;
            }
        });
        var filters = [];
        profileList.forEach(function(profile){
            var filter = {};
            filter["ranges"] = [];
            if (!filter["profile"]) {
                filter["profile"] = profile;
            }
            if ( minBitRate && maxBitRate ){
                filter["ranges"].push( {"min": minBitRate, "max": maxBitRate} );
                filters.push(filter);
            }
        });
        playback.streamingSession.setVideoBitrateRanges(filters);
        playback.mediaBuffer.reset();
        playback.streamingSession.seek(playback.mediaTime.value);
    }

    function _reset() {
        // simply delete, so the method on prototype takes over
        delete playback.createFilteredVideoStreamList;
        playback.mediaBuffer.discardVideoMediaBasedOnFilter();
        if (config.useASE) {
            // Clear jobs in the Cadmium job queue and in progress
            if (config.abortInProgressDownload){
                playback.mediaDownloader.clearInProgressDownloads();
            }
            _updateASE();
        }
        _hide();
    };

    // this function is set on the playback when we want to override the list
    function _createFilteredVideoStreamListOverride() {
        var streams = playback.getVideoStreamList().filter(function (stream) {
            return _overrideBitrateFilter[stream.bitrate];
        });
        if (!streams.length) {
            streams.push(playback.primaryVideoStream);
        }
        return streams;
    };

    function _reloadContent() {
        var audioTrack = playback.audioTrack.value,
            videoTrack = playback.videoTrack.value,
            cdnList = playback.cdnList;

        if (audioTrack) {
            cdnList = cdnList.slice();
            cdnList.sort(function (a, b) { return a.rank - b.rank; });
            _setOptions(_audioSelectElement, audioTrack.streams.map(function (stream) {
                return {
                    value: stream.bitrate,
                    caption: stream.bitrate,
                    selected: (stream == playback.audioStream.value)
                };
            }));
        }

        if (videoTrack) {
            _setOptions(_videoSelectElement, videoTrack.streams.map(function (stream) {
                var disallowed = playback.mediaStreamFilter.shouldDisallowStream(stream);
                var bitrate = stream.bitrate;
                var s = bitrate;
                if (disallowed) {
                    s += ' (' + disallowed.join('|') + ')';
                }
                return {
                    value: bitrate,
                    caption: s,
                    // do the right thing, based on whether we have active override
                    selected: (playback.createFilteredVideoStreamList != _createFilteredVideoStreamListOverride) ? !disallowed : _overrideBitrateFilter[bitrate]
                };
            }));
            _videoSelectElement['removeAttribute']('disabled');
        }

        if (cdnList) {
            _setOptions(_cdnSelectElement, cdnList.map(function (cdn) {
                return {
                    value: cdn.id,
                    caption: '[' + cdn.id + '] ' + cdn.name,
                    selected: (cdn == playback.cdn.value)
                };
            }));
            _cdnSelectElement['removeAttribute']('disabled');
        }
    };

    function _reloadContentIfVisible() {
        if (_visible) {
            _reloadContent();
        }
    };

    function _createSelectElement(title) {
        var divElement = createElement('DIV', 'display:inline-block;vertical-align:top;margin:5px;'),
            titleElement = createElement('DIV', undefined, title),
            selectElement = createElement('select', 'width:120px;height:' + CONTROL_HEIGHT + 'px', undefined, { 'disabled': 'disabled', 'multiple': 'multiple' });

        divElement.appendChild(titleElement);
        divElement.appendChild(selectElement);

        _controls.appendChild(divElement);

        return selectElement;
    };

    function _setOptions(selectElement, options) {
        selectElement.innerHTML = '';
        options.forEach(function (o) {
            var attributes = { 'title': o.caption };
            o.selected && (attributes['selected'] = 'selected');
            var optionElement = createElement('option', undefined, o.caption, attributes);
            optionElement.value = o.value;
            selectElement.appendChild(optionElement);
        });
    };

    function _onkeydown(event) {
        if (event.ctrlKey && event.altKey && event.shiftKey && event.keyCode == 83) {
            _toggle();
        }
    };

    var _applyElement = createElement('BUTTON', undefined, 'Override');
    _applyElement.addEventListener('click', _apply, false);
    _buttons.appendChild(_applyElement);

    var _cancelElement = createElement('BUTTON', undefined, 'Reset');
    _cancelElement.addEventListener('click', _reset, false);
    _buttons.appendChild(_cancelElement);

    globalEvents.addListener(globalEvents$keydown, _onkeydown);
    playback.addEventListener(Playback$closing, function () {
        globalEvents.removeListener(globalEvents$keydown, _onkeydown);
    });

    playback.cdn.addListener(_reloadContentIfVisible);
    playback.audioTrack.addListener(_reloadContentIfVisible);
    playback.videoTrack.addListener(_reloadContentIfVisible);

    mixIn(this,
    /** @lends {PlaybackStreamManager.prototype} */
    {
        toggle: _toggle,
        show: _show,
        hide: _hide
    });
};



// -- player/PlayerDiagnostics.js
/**
* @constructor
*/
function PlayerDiagnostics(playback) {
    var _bandwidthMeter = playback.bandwidthMeter,
        _panels = [],
        _modelGetters = {},
        _eventSource = new EventSource(),
        _dirtyPanels = {},
        _fireUpdateEventsIsDispatched = false,
        _taskId = 1;

    // --------------------------------------------------------------------------------
    // -- initialization & public api

    _wireDownloadEvents();

    return {
        register: _register,
        notifyUpdated: _notifyUpdated,
        getModel: _getModel,
        addEventListener: _addEventListener,
        removeEventListener: _removeEventListener
    };

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _wireDownloadEvents() {
        if (DEBUG) {
            http.addEventListener(http$downloadstarted, _httpOnDownloadStarted);

            playback.addEventListener(BandwidthMeter$aggregateUpdated, function () {
                if (playback.mediaBuffer) {
                    _eventSource.fire('bandwidthupdated', {
                        'bandwidth': _bandwidthMeter.calculateSustainableVideoBitrate() + playback.audioStream.value.bitrate
                    }, true);
                }
            });

            playback.addEventListener(Playback$closed, function () {
                http.removeEventListener(http$downloadstarted, _httpOnDownloadStarted);
            });
        }
    };

    function _httpOnDownloadStarted(response) {
        var tag = {
            'taskId': _taskId++,
            'caption': response.request.diagCaption || 'dl',
            'startTime': response.measurements.requestTime
        };
        _eventSource.fire('taskstart', tag, true);

        response.addCallback(function (r2) {
            debug$assert(response === r2);
            tag['endTime'] = response.measurements.responseEndTime || clock$getTime();
            if (response.errorSubCode) {
                tag['error'] = response.errorSubCode;
            }
            _eventSource.fire('taskend', tag, true);
        });
    };

    function _fireUpdateEvents() {
        _fireUpdateEventsIsDispatched = false;
        var i = _panels.length;
        var panelName;
        while (i--) {
            panelName = _panels[i];
            if (_dirtyPanels[panelName]) {
                _dirtyPanels[panelName] = false;
                _eventSource.fire(panelName + 'changed', { 'getModel': _modelGetters[panelName] });
            }
        }
    };

    function _register(panelName, getModel) {
        debug$assert(!(_panels.indexOf(panelName) >= 0), 'panel already registered');
        _modelGetters[panelName] = getModel;
        _panels.push(panelName);
    };

    function _notifyUpdated(panelName) {
        _dirtyPanels[panelName] = true;
        if (!_fireUpdateEventsIsDispatched) {
            _fireUpdateEventsIsDispatched = true;
            dispatch(_fireUpdateEvents);
        }
    };

    function _getModel(panelName) {
        var getModel = _modelGetters[panelName];
        return getModel ? getModel() : undefined;
    };

    function _addEventListener(panelName, handler) {
        _eventSource.addListener(panelName, handler);
        // if a listener is added after panel was registered, make sure to update it
        if (_modelGetters[panelName]) {
            _notifyUpdated(panelName);
        }
    };

    function _removeEventListener(panelName, handler) {
        _eventSource.removeListener(panelName, handler);
    };
};


// -- player/CadmiumMediaStream.js
/**
* @constructor
*/
function CadmiumMediaStream(playback, track, type, downloadableId, bitrate, vmaf, size, downloadUrls, contentProfile) {
    var _self = this,
        _log = new playback.log.CategoryLog('CadmiumMediaStream'),
        _actualHeaderSize,
        _logFields = { 'Type': type, 'Bitrate': bitrate, 'DownloadableId': downloadableId },
        _cachedStream;

    // --------------------------------------------------------------------------------
    // -- public

    mixIn(_self,
    /** @lends {CadmiumMediaStream.prototype} */
    {
        track: track,
        type: type,
        downloadableId: downloadableId,
        bitrate: bitrate,
        vmaf: vmaf,
        contentProfile: contentProfile,
        size: size,
        downloadUrls: downloadUrls,
        header: null,
        setWidthAndHeight: _setWidthAndHeight,

        estimateHeaderSize: _estimateHeaderSize,
        downloadHeader: Function$makeMulticast(_downloadHeader),

        logFields: _logFields,
        toJSON: function(){ return _logFields; },
        isUsable: _isUsable
    });

    function _setWidthAndHeight(width, height){
        if (isDefined(width) || isDefined(height)) { // set only for video streams
            _self.width = width;
            _self.height = height;
            _logFields['Resolution'] = (_self.width || '') + ':' + (_self.height || '');
        }
    }
    // --------------------------------------------------------------------------------
    // -- private implementation
    function _isUsable(){
        var available = false,
            usableStream,
            idx;
        if (type === CadmiumMediaStream$VIDEO) {
            usableStream = playback.createFilteredVideoStreamList();
        } else if (type === CadmiumMediaStream$AUDIO) {
            usableStream = playback.getAudioStreamList();
        }
        idx = usableStream.indexOf(this);
        if(idx !== -1){
                available = true;
        }
        return available;
    }

    function _createHeader(boxes) {
        DEBUG && _log.debug('Header boxes', boxes.join('\n'), _logFields);
        var ftypBox = firstWithType(boxes, 'ftyp');
        // make sure this is a piff dash stream
        if (!(ftypBox.compatibleBrands.indexOf('dash') >= 0)) {
            throw new Error('ftyp is not dash compatable');
        }

        // create the init segment (this typically is the moov box, but can be overriden to include more boxes)
        var initSegment = CadmiumMediaStream$_getInitSegment(boxes);

        // since we are going to keep a reference to moov box, parse one from initSegement,
        // so we don't keep reference to original header bytes which include large sidx
        var moovBox = firstWithType(parseMp4(initSegment), 'moov');
        debug$assert(moovBox.type === 'moov');

        // HDR Content can have two video layers implemented as two separate trak boxes.
        var sampleEntryBoxes = [];
        var trakBoxes = moovBox.children.filter(function(box) { return box.type === "trak"; });
        for (var i = 0; i < trakBoxes.length; i++) {
            
            var sampleEntryBox = trakBoxes[i].getDescendant('mdia/minf/stbl/stsd/' + [
                Box$CODEC_MP4A,
                Box$CODEC_ENCA,
                Box$CODEC_EC3,
                Box$CODEC_AVC1,
                Box$CODEC_ENCV,
                Box$CODEC_HEVC,
                Box$CODEC_HEV1,
                Box$CODEC_DVHE                 
             ].join('|'));

            _applyWorkarounds(moovBox, sampleEntryBox);  
            sampleEntryBoxes.push(sampleEntryBox);    
        }
 
        sampleEntryBox = sampleEntryBoxes[0];
        // DEBUG: used for getting MOOV for repros
        //log.info(
        //    'WGET -O' + type + '_' + bitrate + '_moov.' + CadmiumMediaStream$switchType(type, 'isma', 'ismv') +
        //    ' "' + _self.downloadUrls[playback.cdnList[0].id].replace('?', '/range/' + moovBox.raw.byteOffset + '-' + (moovBox.raw.byteOffset + moovBox.raw.byteLength - 1) + '?') + '"');

        var sidxBox = firstWithType(boxes, 'sidx');

        // DEBUG: dump the base64 of headers
        // log.info('Stream header content', 'var headerBase64_' + type + '_' + bitrate + ' = \'' + base64$encode(new Uint8Array(sidxBox.raw.buffer, 0, sidxBox.raw.byteOffset + sidxBox.raw.byteLength)) + '\';');

        var sampleEntryBoxType = sampleEntryBox.type;
        var header = {
            stream: _self,
            // sample entry box type is our codec, it can be compared to BOX$CODEC_*
            codec: sampleEntryBoxType,
            drmProtected: (sampleEntryBoxType == Box$CODEC_ENCV || sampleEntryBoxType == Box$CODEC_ENCA),
            initSegment: initSegment,
            moovBox: moovBox
        };
        var desiredChunkDuration = 0;
        switch (_self.type) {
            case CadmiumMediaStream$AUDIO:
                debug$assert(sampleEntryBoxType == Box$CODEC_MP4A || sampleEntryBoxType == Box$CODEC_EC3 || sampleEntryBoxType == Box$CODEC_ENCA);
                desiredChunkDuration = config.audioChunkSizeMilliseconds;
                break;
            case CadmiumMediaStream$VIDEO:
                debug$assert(sampleEntryBoxType == Box$CODEC_HEVC || sampleEntryBoxType == Box$CODEC_HEV1 || sampleEntryBoxType == Box$CODEC_AVC1 || sampleEntryBoxType == Box$CODEC_ENCV);
                desiredChunkDuration = config.videoChunkSizeMilliseconds;

                // read framerate
                try {
                    var netflixVideoFrame = sampleEntryBox.getDescendant(Box$netflixVideoFrameType);
                    var framerate = netflixVideoFrame.numerator / netflixVideoFrame.denominator;
                    if (isNumber(framerate, 1)) {
                        header.framerate = framerate;
                    }
                }
                catch (e) {
                }

                // DVHE boxes do not have PASP descendants.
                if (sampleEntryBox.type !== Box$CODEC_DVHE)
                {
                    try {
                        // read width and height
                        var paspBox = sampleEntryBox.getDescendant('pasp');
                        var expectedWidth = sampleEntryBox.width;
                        var expectedHeight = sampleEntryBox.height;
                        if (paspBox.vSpacing < paspBox.hSpacing) {
                            expectedWidth = Math$floor(expectedWidth * paspBox.hSpacing / paspBox.vSpacing);
                        } else {
                            expectedHeight = Math$floor(expectedHeight * paspBox.vSpacing / paspBox.hSpacing);
                        }
                        if (expectedWidth != _self.width || expectedHeight != _self.height) {
                            _log.error('Stream resolution does not match', { 'Nccp': _self.width + 'x' + _self.height, 'Header': expectedWidth + 'x' + expectedHeight }, _logFields);
                        }
                        // show this in info panel
                        header.diagInfo = 'res: ' + sampleEntryBox.width + 'x' + sampleEntryBox.height + ', par: ' + paspBox.hSpacing + 'x' + paspBox.vSpacing;
                    } catch (e) {
                        header.diagInfo = "";
                    }
                }
                else {
                    header.diagInfo = "";
                }
                break;
        }
        header.chunkInfos = CadmiumMediaStream$_parseChunkInfos(_self, desiredChunkDuration, sidxBox);
        DEBUG && _log.debug('Parsed chunks',
            { 'Count': header.chunkInfos.length },
            _logFields,
            header.chunkInfos.map(function (chunk) { return '[#' + chunk.index + ' ' + Number$formatMillisecond(chunk.startTime) + ' ' + Number$formatMillisecond(chunk.duration) + ']'; }).join('\n')
        );
        return header;
    }

    function _downloadHeaderFromCdn(callback, cdn) {
        _log.trace('Downloading header', { 'Cdn': cdn.id }, _logFields);
        callback = callback || NOOP;

        if (playback.isTrailer() && config.prepareCadmium && videoPreparer && config.consumePreCachedStreams) {
            videoPreparer.getCachedData(playback.movieId, type).then(function(data) {
                _cachedStream = data;
                if (_cachedStream.bitrate == bitrate && _cachedStream.type == type && _cachedStream.header) {
                    _log.info('serve header from cache', {
                        type: type,
                        bitrate: bitrate
                    });
                    var content = CadmiumMediaStream$_parseHeaderBoxes(data.header);
                    processResponse({
                        success: true,
                        content: content
                    });
                } else {
                    makeRequest();
                }
            }).catch(makeRequest);
        } else {
            makeRequest();
        }
        // try to get the header for any CDN.
        function makeRequest(){
            var mediaRequest = {
                responseType: http$RESPONSETYPE_BINARY,
                parser: CadmiumMediaStream$_parseHeaderBoxes,
                url: _self.downloadUrls[cdn.id],
                cdn: cdn,
                track: track,
                stream: _self,
                offset: 0,
                length: _actualHeaderSize || _estimateHeaderSize(contentProfile),
                diagCaption: type + '-' + bitrate + '-hdr',
                cacheBuster: true
            };
            playback.httpPlayback.download(mediaRequest, processResponse);
        }
        
        function processResponse(response) {
            var callbackArgs;
            if (response.success) {
                try {
                    var boxes = response.content;
                    if (!_actualHeaderSize) {
                        // if we didn't know actual header size and underestimated it... retry
                        var netflixHeader = firstWithType(boxes, Box$netflixHeaderTypes);
                        _actualHeaderSize = netflixHeader.offsetToFirstSidx + netflixHeader.firstSidxSize;
                        if (_actualHeaderSize > 0 && !(_actualHeaderSize <= boxes.byteLength)) {
                            _log.warn('Header size underestimated, retrying', { 'Estimated': boxes.byteLength, 'Actual': _actualHeaderSize }, _logFields);
                            _downloadHeaderFromCdn(callback, cdn);
                            return;
                        }
                    }

                    var header = _createHeader(boxes);
                    if (header) {
                        debug$assert(header.chunkInfos.length >= 0);
                        _log.trace('Header parsed', { 'Chunks': header.chunkInfos.length }, _logFields);
                        _self.header = header;
                    }
                    if (config.useASE) {
                        if (response.parsed) {
                            SUCCESS.raw = response.raw;
                        } else {
                            SUCCESS.raw = response.content;
                        }
                        SUCCESS.raw = SUCCESS.raw.slice(0, _actualHeaderSize);
                    }
                    callbackArgs = SUCCESS;
                }
                catch (e) {
                    _log.error('Exception while parsing header', e, _logFields);
                    callbackArgs = {
                        success: false,
                        errorSubCode: ErrorSubCodes.HTTP_PARSE
                    };
                }
                callback(callbackArgs);
            } else {
                _log.error('Unable to download header', ErrorSubCodes$errorResultToLogFields(response), _logFields);
                callback(response);
            }
        }
    }

    function _downloadHeader(callback) {
        _self.headerDownloadAttempted = true;

        // download is an async process, and something might change the playback.primaryCdn
        // so we need to keep track of CDN-s we tried, instead of simple index iteration
        var attemptsPerCdn = {},
            cdnList = filter.call(playback.cdnList, function (cdn) { return isUrl(downloadUrls[cdn.id]); });

        function tryNextCdnOrCallback(result) {
            if (result.success) {
                // if we have a successfull result, we are done
                callback(result);
                return;
            }

            // otherwise, pick a CDN we haven't tried yet and try it
            var cdn, i;
            for (i = 0; i < cdnList.length; i++) {
                cdn = cdnList[i];
                if (!(attemptsPerCdn[cdn.id] > config.headerDownloadRetryCountBeforeCdnSwitch)) {
                    // found a CDN we haven't tried yet, break and use it
                    break;
                } else {
                    // don't use this CDN
                    cdn = null;
                }
            }

            // do we have a CDN we can try download from?
            if (cdn) {
                // mark it as attempted
                attemptsPerCdn[cdn.id] = (attemptsPerCdn[cdn.id] || 0) + 1;
                // and try to get the header from it
                _downloadHeaderFromCdn(tryNextCdnOrCallback, cdn);
            } else {
                // no more CDNs left, callback with a failure
                callback(result);
            }
        }

        tryNextCdnOrCallback({ success: false });
    }

    function _estimateHeaderSize(profile) {
        var headerSize = profile && _isHDRProfile(profile) 
            ? Math$ceil(CadmiumMediaStream$_DV_HEADER_CONSTANT_SIZE + playback.estimatedRuntime * CadmiumMediaStream$_DV_HEADER_SIZE_PER_MILLISECOND)
            : Math$ceil(CadmiumMediaStream$_HEADER_CONSTANT_SIZE + playback.estimatedRuntime * CadmiumMediaStream$_HEADER_SIZE_PER_MILLISECOND);

        return headerSize;
    }

    function _isHDRProfile(profile) {
        if (profile) {
            return videoProfiles$DV_no_HFR_4k_Set.indexOf(profile) > -1;
        }
    }

    function _applyWorkarounds(moovBox, sampleEntryBox) {
        var ignorePsshList = config.ignorePsshList;
        if (ignorePsshList.length) {
            moovBox.children.forEach(function (box) {
                if (box.type == 'pssh' && ignorePsshList.indexOf(box.drmSystemId) >= 0) {
                    // overwrite the type with 'free' so the CDM ignores this box
                    box.raw && box.raw.set([102, 114, 101, 101], 4);
                }
            });
        }

        // apply [trex] woarkaround
        if (config.workaroundAudioKeyFrame) {
            if (type == CadmiumMediaStream$AUDIO) {
                var trex = moovBox.getDescendant('mvex/trex');

                if (trex.defaultSampleFlags.sampleIsDifferenceSample) {
                    _log.trace('Applying sampleIsDifferenceSample workaround', _logFields, { 'Box': 'trex' });
                    parseChunkMedia$overwriteSampleIsDifferenceSample(trex, false);
                }
            }
        }

        // apply [tenc] workarond
        if (config.workaroundTenc) {
            if (MediaElement$getDrmType() == DrmType$PLAYREADY) {
                if (sampleEntryBox.type == 'encv') {
                    // fix the byte order in sinf/schi/tenc box

                    function workaroundTenc() {
                        // we want to compare to the PSSH in the PRIMARY stream
                        // because that will be the one used for license challenge
                        var psshBox = playback.primaryVideoStream.header.moovBox.children.filter(function (box) {
                            return box.type == 'pssh' && box.drmSystemId == DrmSystemId$PLAYREADY;
                        })[0];

                        // assume the psshData to be UTF16 with a bom header, and ignore the first byte (they are always 0)
                        // TODO: find out what those 10 bytes are we skip
                        var kidInPssh;

                        try {
                            // find and extract the content of KID
                            // actual challenge starts from 10th byte, before that we have length and some other metadata
                            kidInPssh = base64$decode(MediaElement$extractFromPlayreadyMessage(psshBox.data.subarray(10, psshBox.data.length - 10), 'KID'));
                        }
                        catch (e) {
                            _log.error('Exception parsing KID in PSSH', e);
                        }

                        if (kidInPssh && kidInPssh.length == 16) {
                            var tencBoxes = sampleEntryBox.children.map(function (sinfBox) {
                                try {
                                    if (sinfBox.type == 'sinf') {
                                        return sinfBox.getDescendant('schi/tenc|' + Box$trackEncryptionType);
                                    }
                                } catch (e) {
                                    _log.error('Exception finding TENC box', e);
                                }
                            }).filter(isDefined);

                            tencBoxes.forEach(function (tencBox) {
                                var keyId = tencBox.keyId;
                                if (keyId && compareArrays(kidInPssh, keyId)) {
                                    // these should NOT match, if they do, we need to aplly workaround, otherwise assume streams are fixed
                                    // See http://en.wikipedia.org/wiki/Globally_unique_identifier#Binary_encoding for why only some bytes are swapped

                                    _log.trace('Applying KID byte order workaround', _logFields, { 'Box': tencBox.type });

                                    function swap(i, j) {
                                        var t = keyId[i];
                                        keyId[i] = keyId[j];
                                        keyId[j] = t;
                                    }

                                    swap(0, 3);
                                    swap(1, 2);
                                    swap(4, 5);
                                    swap(6, 7);

                                    // no need to write they keyId back, since it shares the same backing ArrayBuffer with the box raw content
                                    debug$assert(keyId['buffer'] && moovBox.raw['buffer'] && keyId['buffer'] === moovBox.raw['buffer']);
                                }
                            });

                        } else {
                            debug$assert(false);

                        }
                    }

                    // if we have primaryVideoStream, apply workaround
                    // otherwise wait for playback to load, when we will be guaranteed to have primaryVideoStream
                    if (playback.primaryVideoStream) {
                        workaroundTenc();
                    } else {
                        function onPlaybackStateChange(args) {
                            if (args.newValue == Playback$STATE_NORMAL) {
                                playback.state.removeListener(onPlaybackStateChange);
                                workaroundTenc();
                            }
                        }
                        playback.state.addListener(onPlaybackStateChange);
                    }
                }
            }
        }

        // encrypted audio workaround
        // Note: JScrambler had issue with regex in if statement
        if (_self.contentProfile.indexOf("-enc") >= 0) {
            if (sampleEntryBox.type === Box$CODEC_ENCA){
                var newType = /heaac/.test(_self.contentProfile) ? [0x6d, 0x70, 0x34, 0x61] : [0x65, 0x63, 0x2d, 0x33]; // 'mp4a' : 'ec-3'
                sampleEntryBox.raw.set(newType, 4); // change box type from 'enca' to 'mp4a'
            }

            var tencBoxes = sampleEntryBox.children.map(function (sinfBox) {
                try {
                    if (sinfBox.type == 'sinf') {
                        return sinfBox.getDescendant('schi/tenc|' + Box$trackEncryptionType);
                    }
                } catch (e) {
                    _log.error('Exception finding TENC box', e);
                }
            }).filter(isDefined);

            tencBoxes.forEach(function (tencBox) {
                var algorithmOffset = tencBox.size - tencBox.contentLength + 4; // version & flags (4 bytes)
                tencBox.raw.set([0, 0, 0], algorithmOffset); // overwrite defaultAlgorithm
            });
        }
    }
}

function CadmiumMediaStream$_parseHeaderBoxes(arrayBuffer) {
    var buffer = new Uint8Array(arrayBuffer);
    var boxes = parseMp4(buffer);
    boxes.byteLength = arrayBuffer.byteLength;
    return boxes;
}

function CadmiumMediaStream$_getInitSegment(boxes) {
    var i,
        a,
        box,
        initSegmentBoxTypeList = config.initSegmentBoxTypeList,
        initSegmentBoxList = [],
        boxListLength = initSegmentBoxTypeList.length,
        byteLength = 0,
        byteOffset = 0,
        initSegment;

    debug$assert(initSegmentBoxTypeList.indexOf('moov') >= 0, 'init segment must have a moov box');
    for (i = 0; i < boxListLength; i++) {
        a = firstWithType(boxes, initSegmentBoxTypeList[i]).raw;
        initSegmentBoxList.push(a);
        byteLength += a.length;
    }
    debug$assert(byteLength > 0);

    initSegment = new Uint8Array(byteLength);
    for (i = 0; i < boxListLength; i++) {
        a = initSegmentBoxList[i];
        initSegment.set(a, byteOffset, a.length);
        byteOffset += a.length;
    }
    debug$assert(byteOffset === byteLength);

    return initSegment;
}

function CadmiumMediaStream$_parseChunkInfos(stream, desiredChunkDuration, sidxBox) {
    var chunkInfo,
        previousChunkInfo,
        chunkInfos = [],
        timeScale = sidxBox.timeScale,
        references = sidxBox.references,
        referencesLength = references.length,
        desiredReferenceDuration = Math$round(desiredChunkDuration * timeScale / MILLISECONDS_PER_SECOND),
        reference,
        rawSidx = sidxBox.raw,
        referenceOffset = rawSidx.byteOffset + rawSidx.byteLength + sidxBox.firstOffset,
        referenceStartTime = 0, // Ideally this should start from sidxBox.earliestPresentationTime, but that value populated wrong in our encodes (as if 5/17/2013)
        nextReferenceOffset,
        nextReferenceStartTime,
        previousChunkDuration,
        chunkIndex = 0,
        chunkDuration,
        chunkOffset = referenceOffset,
        chunkStartTime = referenceStartTime;

    for (var i = 0; i < referencesLength; i++) {
        reference = references[i];
        nextReferenceStartTime = referenceStartTime + reference.duration;
        nextReferenceOffset = referenceOffset + reference.size;

        chunkDuration = nextReferenceStartTime - chunkStartTime;
        if (i < referencesLength - 1 && Math$abs(chunkDuration - desiredReferenceDuration) > Math$abs(chunkDuration + references[i + 1].duration - desiredReferenceDuration)) {
            // including next reference will put us closer to desiredReferenceDuration
            // don't create the chunk
        } else {
            // create the chunk
            chunkInfo = {
                index: chunkIndex++,
                stream: stream,
                offset: chunkOffset,
                length: nextReferenceOffset - chunkOffset,
                startTime: Math$floor(chunkStartTime * MILLISECONDS_PER_SECOND / timeScale),
                duration: Math$floor((nextReferenceStartTime - chunkStartTime) * MILLISECONDS_PER_SECOND / timeScale),
                all: chunkInfos,
                next: null,
                previous: null
            };
            chunkInfo.logFields = {
                'Type': chunkInfo.stream.type,
                'Bitrate': chunkInfo.stream.bitrate,
                'ChunkNum': chunkInfo.index,
                'StartTime': Number$formatMillisecond(chunkInfo.startTime),
                'Duration': Number$formatMillisecond(chunkInfo.duration)
            };
            if (previousChunkInfo) {
                chunkInfo.previous = previousChunkInfo;
                previousChunkInfo.next = chunkInfo;
                // workaround timeScale rounding errors by make sure chunks align by millisecond precision
                debug$assert(Math$abs(previousChunkInfo.duration - (chunkInfo.startTime - previousChunkInfo.startTime)) <= 1, 'Chunks should be continious.');
                previousChunkInfo.duration = chunkInfo.startTime - previousChunkInfo.startTime;
            }
            chunkInfos.push(chunkInfo);
            previousChunkInfo = chunkInfo;

            chunkStartTime = nextReferenceStartTime;
            chunkOffset = nextReferenceOffset;
        }

        referenceOffset = nextReferenceOffset;
        referenceStartTime = nextReferenceStartTime;
    }
    return chunkInfos;
}

var CadmiumMediaStream$AUDIO = 'audio',
    CadmiumMediaStream$VIDEO = 'video',
    CadmiumMediaStream$TIMEDTEXT = 'timedtext',
    CadmiumMediaStream$TRICKPLAY = 'trickplay';

/**
* @param {*=} timedText
* @param {*=} trickplay
*/
function CadmiumMediaStream$switchType(type, audio, video, timedText, trickplay) {
    if (type == CadmiumMediaStream$AUDIO) {
        return audio;
    } else if (type == CadmiumMediaStream$VIDEO) {
        return video;
    } else if (type == CadmiumMediaStream$TIMEDTEXT) {
        return timedText;
    } else if (type == CadmiumMediaStream$TRICKPLAY) {
        return trickplay;
    }
}

// Header format: [ftyp] [netflix header] [moov] [sidx]
var CadmiumMediaStream$_HEADER_CONSTANT_SIZE = 256 /* ftyp and nflx header */ + 2000  /* moov box */ + 36 /* sidx metadata*/;
var CadmiumMediaStream$_HEADER_SIZE_PER_MILLISECOND = 12 / 2000; /* each fragment is 12 bytes in sidx, and each fragment is 2000 ms */
var CadmiumMediaStream$_DV_HEADER_CONSTANT_SIZE = 265 /* ftyp and nflx header */ + 2605  /* moov box */ + 48 /* sidx metadata*/;
var CadmiumMediaStream$_DV_HEADER_SIZE_PER_MILLISECOND = 13 / 2000; /* each fragment is 12 bytes in sidx, and each fragment is 2000 ms */

// helper functions for stream list,
// Since we cannot extend arrays in JavaScript, these are mixed in to the stream array

var CadmiumMediaStreams$methods = (
/** @lends {Array.prototype} */
{
    /**
    * @param {number} bitrate
    * @param {boolean=} mustHaveHeader
    */
    closestTo: function CadmiumMediaStreams_closestTo(bitrate, mustHaveHeader) {
        var streams = this;
        if (mustHaveHeader) {
            streams = streams.filter(CadmiumMediaStreams$hasHeaderFilter);
        }
        return streams.reduce(function (bestMatch, stream) {
            return (bestMatch && Math$abs(bestMatch.bitrate - bitrate) < Math$abs(stream.bitrate - bitrate)) ? bestMatch : stream;
        });
    },

    firstAbove: function CadmiumMediaStreams_firstAbove(bitrate, mustHaveHeader) {
        var streams = this;
        if (mustHaveHeader) {
            streams = streams.filter(CadmiumMediaStreams$hasHeaderFilter);
        }
        return streams.reduce(function (bestMatch, stream) {
            return (stream.bitrate > bitrate && stream.bitrate < bestMatch.bitrate) ? stream : bestMatch;
        }, streams[streams.length - 1]);
    },

    firstBelow: function CadmiumMediaStreams_firstBellow(bitrate, mustHaveHeader) {
        var streams = this;
        if (mustHaveHeader) {
            streams = streams.filter(CadmiumMediaStreams$hasHeaderFilter);
        }
        return streams.reduce(function (bestMatch, stream) {
            return (stream.bitrate < bitrate && stream.bitrate > bestMatch.bitrate) ? stream : bestMatch;
        }, streams[0]);
    },

    toBitrates: function CadmiumMediaStreams_toBitrates(filter) {
        var bitrates = this.map(function (stream) { return stream.bitrate; });
        if (isArray(filter)) {
            bitrates = filterBitrates(bitrates, filter);
        }
        return bitrates;
    }
});

function CadmiumMediaStreams$addMethodsToArray(streamArray) {
    return mixIn(streamArray, CadmiumMediaStreams$methods);
}

function CadmiumMediaStreams$hasHeaderFilter(stream) {
    return !!stream.header;
}

function CadmiumMediaStreams$doesNotHaveHeaderFilter(stream) {
    return !stream.header;
}

function CadmiumMediaStream$getAvailableBitrates(streamArray) {
    return streamArray.map(function(ms) { return ms.bitrate; });
}
function CadmiumMediaStream$getMaxHeight(streamArray) {
    return Array$max(streamArray.map(function(ms) { return ms.height; }));
}




// -- player/MediaBuffer.js
/**
* @constructor
*/

function MediaBuffer(playback) {
    var _log = new playback.log.CategoryLog('MediaBuffer'),
        _self = this,
        _diagnostics = playback.diagnostics,
        _audioChunks = MediaBuffer$_createChunks(playback.primaryAudioStream, MAX_MEDIA_TIME),
        _primaryVideoStream = playback.primaryVideoStream,
        _heuristics = playback.heuristics,

        // since the renderer is audio master, make sure we have more audio than video
        // if we don't do this, the VIDEO never gets to "ended" state
        // tolerate a single extra frame (we see this a lot, VIDEO works fine with it, and we don't want to chop off ~4 seconds if we can avoid doing so)
        _videoChunks = MediaBuffer$_createChunks(playback.primaryVideoStream, config.clipLongVideo ? (_audioChunks.last.endTime + Math$floor(1000 / (_primaryVideoStream.header.framerate || 60))) : undefined),
        _allChunks = _audioChunks['concat'](_videoChunks),
        _backBufferSize = config.backBufferSizeMilliseconds,
        _maxBufferSize = config.maxBufferSizeMilliseconds,
        _maxBufferBytes = config.maxBufferSizeBytes,
        _backToFrontBufferRatio = config.backToFrontBufferRatioPercent / 100,
        _maxForwardBufferSize = _maxBufferSize - _backBufferSize,
        _useParallel = config.connectionStrategy === 'parallel',
        _isVideoFunc = function(job){ return job.mediaRequest.mediaType === ASEMediaStream$VIDEO; },
        _bufferFullGetterThrottle = new GetterThrottle(_isBufferFull, 1000), // isBufferFull is expensive so only call at most every second.
        _compactThrottle = new Throttle(500);

    // --------------------------------------------------------------------------------
    // -- initialization & internal api

    var primaryVideoStreamChunkInfos = playback.primaryVideoStream.header.chunkInfos;
    if (primaryVideoStreamChunkInfos.length != _videoChunks.length) {
        var lastChunkInfo = primaryVideoStreamChunkInfos[primaryVideoStreamChunkInfos.length - 1];
        _log.error('Clipping video chunks to be less than audio', {
            'FromEndTime': Number$formatMillisecond(lastChunkInfo.startTime + lastChunkInfo.duration),
            'ToEndTime': Number$formatMillisecond(_videoChunks.last.endTime),
            'AudioEndTime': Number$formatMillisecond(_audioChunks.last.endTime)
        });
    }

    if (!(_backBufferSize >= 0) || !(_maxBufferSize > _audioChunks.first.duration) || !(_maxBufferSize >= 2 * _backBufferSize)) {
        // some sanity config check
        throw new Error('bad buffer size');
    }

    playback.audioTrack.addListener(function (args) {
        if(config.useASE && playback.streamingSession){
            if (args.reset) {
                _log.trace("ASE previously rejected the audio track switch, resetted!");
                return;
            }
            var newtracks = {
                audioTrackId: args.newValue.trackId,
                toJSON: function(){ return args.newValue.logFields; }
            };
            if (!playback.streamingSession.switchTracks(newtracks)) {
                _log.trace("ASE rejected the audio track switch");
                //reset it back to the old value
                playback.audioTrack.set(args.oldValue, {reset: true});
            } else {
                _log.trace("ASE accepted the audio track switch");
                _disgardMedia(args.newValue, _audioChunks);
            }
        } else {
            _disgardMedia(args.newValue, _audioChunks);
        }
    });
    playback.videoTrack.addListener(function (args) { _disgardMedia(args.newValue, _videoChunks); });

    playback.addEventListener(Playback$closed, _onPlaybackClosed);

    if (DEBUG) {
        // diagnostic panel
        _diagnostics.register('buffer', function () {
            return {
                'audio': MediaBuffer$_visualizeChunks(_audioChunks, playback.mediaTime.value),
                'video': MediaBuffer$_visualizeChunks(_videoChunks, playback.mediaTime.value)
            };
        });
        playback.addEventListener(Playback$throttledMediaTimeChanged, function () { _diagnostics.notifyUpdated('buffer'); });
    }

    // internal api

    mixIn(this, /** @lends {MediaBuffer.prototype} */ {
        audioChunks: _audioChunks,
        videoChunks: _videoChunks,

        getNextAudioChunkThatNeedsMedia: _getNextAudioChunkThatNeedsMedia,

        getNextVideoChunkThatNeedsMedia: _getNextVideoChunkThatNeedsMedia,

        getNextChunkToDownload: _getNextChunkToDownload,

        tryMakeRoom: _maxBufferBytes ? _tryMakeRoom : RETURN_TRUE,

        notifyChunksDownloaded: _notifyChunksDownloaded,

        notifyAppendedToDecoder: _notifyAppendedToDecoder,

        notifyDroppedByDecoder: _notifyDroppedByDecoder,

        notifyDroppedAllByDecoder: _notifyDroppedAllByDecoder,

        discardVideoMediaBasedOnFilter: _discardVideoMediaBasedOnFilter,

        discardVideoMediaBasedOnFilterWithoutRebuffer: _discardVideoMediaBasedOnFilterWithoutRebuffer,

        getBufferedTime: _getBufferedTime,

        getBufferLength: _getBufferLength,

        getNormalizedBufferLength: _getNormalizedBufferLength,

        getAudioBufferLength: _getAudioBufferLength,

        getAudioBufferBytes: _getAudioBufferBytes,

        getVideoBufferLength: _getVideoBufferLength,

        getVideoBufferBytes: _getVideoBufferBytes,

        getBufferOccupancyList: _getBufferOccupancyList,

        getTotalBytes: _getTotalBytes,

        getHasVideoUpToMediaTime: _getHasVideoUpToMediaTime,

        getLogFields: _getLogFields,

        isBufferFull: _bufferFullGetterThrottle.get,

        compact: _compactThrottle.schedule.bind(null, _compact),

        pruneASERequests: _pruneASERequests,

        reset: _reset,

        hasEnoughBufferToStoreNextJob: _hasEnoughBufferToStoreNextJob
    });

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _reset(){
        var chunk;

        //reset audio chunks
        chunk = _audioChunks.first;
        while (chunk){
            if (chunk.media) {
                _dropMedia(chunk, 'seek');
                chunk.inDecoder = undefined;
            }
            chunk = chunk.next;
        }

        chunk = _videoChunks.first;
        while (chunk){
            if (chunk.media) {
                _dropMedia(chunk, 'seek');
                chunk.inDecoder = undefined;
            }
            chunk = chunk.next;
        }
    }

    /**
    * get the next chunk that we need to download
    * this method considers MILLISECOND limits on buffers, but not the size limits
    * because the MediaDownloader is expected to ask MediaBuffer to make room before downloading
    */
    function _getNextChunkToDownload() {
        var mediaTime = playback.mediaTime.value;

        var audioChunk = _getNextAudioChunkThatNeedsMedia();
        var videoChunk = _getNextVideoChunkThatNeedsMedia();

        if (audioChunk) {
            if (audioChunk.startTime - mediaTime > _maxForwardBufferSize) {
                audioChunk = null;
            }
        }

        if (videoChunk) {
            if (videoChunk.startTime - mediaTime > _maxForwardBufferSize) {
                videoChunk = null;
            }
        }

        if (videoChunk) {
            if (audioChunk) {
                if (videoChunk.startTime <= audioChunk.startTime && audioChunk.startTime > mediaTime) {
                    // we want video, if we have less video than audio BUT we do have SOME audio
                    return videoChunk;
                }
            } else {
                // we also want video, if there is no more audio that we need
                return videoChunk;
            }
        }

        return audioChunk;
    }

    /**
    * Free up enough room to download the given chunk. If includeInProgressChunks
    * is true then chunks that are downloading or about to be are treated as
    * if they have already landed when checking for available space. This prevents
    * overshooting the buffer's byte limit.
    * returns true if we are able to free up enough room
    */
    function _tryMakeRoom(chunkInfo, includeInProgressChunks) {
        debug$assertPositiveInt(_maxBufferBytes);

        var requestedSize = chunkInfo.length;
        var availableSize = _maxBufferBytes - _getTotalBytes(includeInProgressChunks);
        if (availableSize > requestedSize) {
            // there is room in the buffer, we are done
            return true;
        }

        // let's try to free up space
        var mediaTime = playback.mediaTime.value;
        var audioChunk;
        var videoChunk;
        var upToMediaTime;

        // drop media from the back buffers
        // up to the desired [backBufferSize]
        upToMediaTime = mediaTime - _backBufferSize;
        audioChunk = _audioChunks.first;
        videoChunk = _videoChunks.first;
        while (audioChunk || videoChunk) {
            // stop dropping media once we reach the chunk that covers upToMediaTime
            if (audioChunk && audioChunk.endTime >= upToMediaTime) {
                audioChunk = undefined;
            }
            if (videoChunk && videoChunk.endTime >= upToMediaTime) {
                videoChunk = undefined;
            }

            // pick what to drop, audio or video (whichever ends earlier)
            if (audioChunk && (!videoChunk || audioChunk.endTime < videoChunk.endTime)) {
                // drop audio
                availableSize += _dropMedia(audioChunk, 'bb');
                audioChunk = audioChunk.next;
            } else if (videoChunk) {
                // drop video
                availableSize += _dropMedia(videoChunk, 'bb');
                videoChunk = videoChunk.next;
            }

            if (availableSize > requestedSize) {
                return true;
            }
        }

        // drop from future buffers
        // start dropping from end, up the chunkInfo
        // we should not drop chunks before the one we are making a room for
        audioChunk = _audioChunks.last;
        videoChunk = _videoChunks.last;
        while (audioChunk || videoChunk) {
            // stop at the "up to" chunk
            if (audioChunk && audioChunk.startTime <= chunkInfo.startTime) {
                audioChunk = undefined;
            }
            if (videoChunk && videoChunk.startTime <= chunkInfo.startTime) {
                videoChunk = undefined;
            }

            // pick what to drop, audio or video (whichever starts later)
            if (audioChunk && (!videoChunk || audioChunk.startTime > videoChunk.startTime)) {
                // drop audio
                availableSize += _dropMedia(audioChunk, 'bf');
                audioChunk = audioChunk.previous;
            } else if (videoChunk) {
                // drop video
                availableSize += _dropMedia(videoChunk, 'bf');
                videoChunk = videoChunk.previous;
            }

            if (availableSize > requestedSize) {
                return true;
            }
        }

        // drop more media from the back buffers
        // this time keep dropping past [backBufferSize] up to [backToFrontBufferRatio]% of front buffer
        // Note: we shouldn't hit this case, unless we are playing very high bitrate on a device with very little memory
        upToMediaTime = mediaTime - _backToFrontBufferRatio * (chunkInfo.startTime - mediaTime);
        audioChunk = _audioChunks.first;
        videoChunk = _videoChunks.first;
        while (audioChunk || videoChunk) {
            // stop dropping media once we reach the chunk that covers upToMediaTime
            if (audioChunk && audioChunk.endTime >= upToMediaTime) {
                audioChunk = undefined;
            }
            if (videoChunk && videoChunk.endTime >= upToMediaTime) {
                videoChunk = undefined;
            }

            // pick what to drop, audio or video (whichever ends earler)
            if (audioChunk && (!videoChunk || audioChunk.endTime < videoChunk.endTime)) {
                // drop audio
                availableSize += _dropMedia(audioChunk, 'bbr');
                audioChunk = audioChunk.next;
            } else if (videoChunk) {
                // drop video
                availableSize += _dropMedia(videoChunk, 'bbr');
                videoChunk = videoChunk.next;
            }

            if (availableSize > requestedSize) {
                return true;
            }
        }
    }


    /**
    * Drop media from chunk and return space that was made available
    */
    function _dropMedia(chunk, reason) {
        var media = chunk.media;
        chunk.media = null;
        chunk.mediaRequest = undefined;
        chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
        media && DEBUG && _log.debug('Dropped chunk', chunk, { 'Reason': reason }, _getLogFields());
        return media ? media.length : 0;
    }

    /**
    * The MediaDownloader calls into this to let the buffer know that new media is available.
    * @param {Array.<Object>} chunks list of chunks that is included in this request
    * @param {Array.<Object>} infos list of chunkInfos
    * @param {CadmiumMediaStream} stream CadmiumMediaStream that the chunk belongs to
    * @param {Object} arrayBuffer
    * @param {Object} cdn
    * @param {Object} downloadMeasurements
    * @param {Object=} ASEMediaRequest (optional) the ASE MediaRequest that is associate with this function, only applicable for JSASE
    */
    function _notifyChunksDownloaded(chunks, infos, stream, arrayBuffer, cdn, downloadMeasurements, ASEMediaRequest) {
        function decryptAndSetMedia(chunk, stream, chunkBuffer, cdn, downloadMeasurements, ASEMediaRequest) {
            return _decryptMedia(chunk, stream, chunkBuffer, cdn)
            .then(function () {
                _setMedia(chunk, stream, chunkBuffer, cdn, ASEMediaRequest, downloadMeasurements);
            });
        }

        var decryptAndSetMediaResults = [];

        var offset = 0;
        for (var i = 0; i < chunks.length; i++) {
            var chunk = chunks[i],
                info = infos[i];
            if ((stream.type == CadmiumMediaStream$AUDIO && stream.track != playback.audioTrack.value) || (stream.type == CadmiumMediaStream$VIDEO && stream.track != playback.videoTrack.value)) {
                _log.trace('Rejecting received chunk because it doesn\'t match most recent track', chunk, stream);
                return;
            }
            if (chunk.media && chunk.media.stream.bitrate >= stream.bitrate) {
                // Stream might become unavailable when user manually set it unavailable.
                // If that is the case, we should continue and replace the chunk.media.
                // Otherwise (if the stream is still available), that is an error.
                if(chunk.media.stream.isUsable()){
                    //If the stream is still usable, we should simply return and ignore this chunk
                    chunk.setDownloading(MediaBuffer$CHUNK_DOWNLOADED);
                    _log.warn('Rejecting received chunk because it is lower bitrate than existing chunk', chunk, stream);
                    return;
                } else {
                    //If the stream is no longer usable, clean up the media instead
                    chunk.media = null;
                    if (config.useASE) {
                        chunk.mediaRequest = undefined;
                    }
                }
            }

            // copy the array buffer if there's more than one chunk
            var chunkBuffer = chunks.length > 1 ? new Uint8Array(new Uint8Array(arrayBuffer.buffer, offset, info.length)) : arrayBuffer;

            offset += info.length;

            if (stream.decryptionKey) {
                var result = decryptAndSetMedia(chunk, stream, chunkBuffer, cdn, downloadMeasurements, ASEMediaRequest);
                decryptAndSetMediaResults.push(result);                
            } else {
                _setMedia(chunk, stream, chunkBuffer, cdn, ASEMediaRequest, downloadMeasurements);
            }
        }

        // Note: the chunk might get compacted right after download, this happens if the
        // user seeks back while download is in progress, and download finishes after the seek
        // and by the time chunk arrives it's already to far in future, and gets compacted

        Promise.all(decryptAndSetMediaResults)
        .then(function () {
            _bufferUpdated();
        })
        .catch(function (e) {
            _log.error('decryptAndSetMedia failed: ', e);
            playback.closeWithError(new PlayerError(ErrorCodes.DECRYPT_AUDIO));
        });
    }

    function _decryptMedia(chunk, stream, chunkBuffer, cdn) {
        function getDecryptKey(stream) {
            return new Promise(function (resolve, reject) {
                if (stream.decryptionKeyRaw) {
                    resolve(stream.decryptionKeyRaw);
                } else {
                    var key = base64$decode(stream.decryptionKey);
                    window['netflix']['crypto']['importKey']('raw', key, {'name': "AES-CTR"}, false, ["encrypt", "decrypt"])
                        .then(function (result) {
                            stream.decryptionKeyRaw = result;
                            resolve(result);
                        })
                        .catch(function (e) {
                            _log.error("Unable to import AES-CTR key");
                            reject(e);
                        });
                }
            });
        }

        function decrypt(chunk, stream, chunkBuffer, decryptionKey) {
            function decryptChunk(moofBox, mdatBox, stream) {
                function decryptSample(algorithm, key, data) {
                    return window['netflix']['crypto']['decrypt'](algorithm, key, data)
                        .then(function (result) {
                            data.set(new Uint8Array(result));
                        });
                }

                try {
                    var trafBox = moofBox.getDescendant('traf');
                    var saizBox = trafBox.getDescendant('saiz');
                    var sencBox = trafBox.getDescendant('A2394F52-5A9B-4F14-A244-6C427C648DF4');
                    var trunBox = trafBox.getDescendant('trun');

                    var numberOfSamples = trunBox.samples.length;
                    var ivOffset = 0;
                    var sampleOffset = 0;

                    var samples = [];
                    for (var i = 0; i < numberOfSamples; i++) {
                        var ivSize = saizBox.sampleInfoSizes[i] || saizBox.sampleInfoSizes[0] || 8; // defaultSize = 8
                        
                        var iv = new Uint8Array(16);
                        iv.set(sencBox.auxData.subarray(ivOffset, ivOffset + ivSize));
                        ivOffset += ivSize;

                        var sampleSize = trunBox.samples[i].size;
                        var sampleData = mdatBox.data.subarray(sampleOffset, sampleOffset + sampleSize);
                        sampleOffset += sampleSize;
                        
                        var length = (iv.length - ivSize) * BYTEtoBITS;
                        var algorithm = {'name': "AES-CTR", 'counter': iv, 'length': length};
                        var result = decryptSample(algorithm, stream.decryptionKeyRaw, sampleData);
                        samples.push(result);
                    }

                    return Promise.all(samples);
                } catch (e) {
                    return Promise.reject(e);
                }
            }

            try {
                var boxes = parseMp4(chunkBuffer);

                var chunks = [];
                for (var i = 0; i < boxes.length; ) {
                    var moofBox = boxes[i++];
                    var mdatBox = boxes[i++];

                    var result = decryptChunk(moofBox, mdatBox, stream);
                    chunks.push(result);
                }           

                return Promise.all(chunks);
            } catch (e) {
                return Promise.reject(e);
            }
        }

        return getDecryptKey(stream)
        .then(function (decryptionKey) {
            return decrypt(chunk, stream, chunkBuffer, decryptionKey);
        });
    }

    function _setMedia(chunk, stream, chunkBuffer, cdn, ASEMediaRequest, downloadMeasurements) {
        chunk.media = {
            stream: stream,
            arrayBuffer: chunkBuffer,
            length: chunkBuffer.length,
            cdn: cdn
        };
        chunk.setDownloading(MediaBuffer$CHUNK_DOWNLOADED);
        if(config.useASE && ASEMediaRequest){
            chunk.mediaRequest = ASEMediaRequest;
            ASEMediaRequest.appendCompleted = true;
        }
        _self.compact();
        CadmiumMediaStream$switchType(stream.type, playback.downloadedAudio, playback.downloadedVideo).set({
            chunk: chunk,
            stream: stream,
            cdn: cdn,
            downloadMeasurements: downloadMeasurements
        });

        _log.trace('Received chunk', chunk, { 'CdnId': cdn.id }, _getLogFields());
    }

    function _notifyAppendedToDecoder(chunk) {
        chunk.inDecoder = true;
        if (config.disgardMediaOnAppend) {
            var media = chunk.media;
            debug$assert(media);
            if (media) {
                media.arrayBuffer = null;
            }
        }
    }

    function _notifyDroppedByDecoder(chunk) {
        chunk.inDecoder = undefined;
        if (config.disgardMediaOnAppend && !config.useASE) {
            _dropMedia(chunk, 'dbd');
        }
    }

    function _notifyDroppedAllByDecoder() {
        var i = _allChunks.length,
            chunk,
            media;

        while (i--) {
            chunk = _allChunks[i];
            chunk.inDecoder = undefined;
            media = chunk.media;
            if (media && !media.arrayBuffer) {
                _dropMedia(chunk, 'ab');
            }
        }
    }

    function _getBufferLength() {
        return Math$min(_getAudioBufferLength(), _getVideoBufferLength());
    }


    function _getBufferedTime() {
        var mediaTime = playback.mediaTime.value,
            upToAudio = MediaBuffer$_getLastChunkWithMedia(mediaTime, _audioChunks),
            upToVideo = MediaBuffer$_getLastChunkWithMedia(mediaTime, _videoChunks),
            bufferedTime;

        if (upToAudio && upToVideo) {
            bufferedTime = Math$min(upToAudio.endTime, upToVideo.endTime);
        }

        return coalesce(bufferedTime, mediaTime);
    };
    // Get the normalized buffer level in range from  [0,1] were zero is empty buffer and 1 is full.
    // Base it on bytes or time depending on the type of buffer limiting we are using.
    function _getNormalizedBufferLength() {
        // Byte limited buffer
        if (_maxBufferBytes) {
             return config.maxBufferSizeBytes
                ? Number$clamp((_getAudioBufferBytes() + _getVideoBufferBytes()) / config.maxBufferSizeBytes, 0, 1)
                : 0;
        }

        // Time limited buffer;
        return Number$clamp(_getBufferLength() / config.maxBufferSizeMilliseconds, 0, 1);
    }

    function _getNextAudioChunkThatNeedsMedia() {
        if (!_useParallel) {
            return _getNextChunkThatNeedsMedia(_audioChunks);
        } else {
            return _getNextIdleChunkThatNeedsMedia(_audioChunks);
        }
    }

    function _getNextVideoChunkThatNeedsMedia() {
        if (!_useParallel) {
            return _getNextChunkThatNeedsMedia(_videoChunks);
        } else {
            return _getNextIdleChunkThatNeedsMedia(_videoChunks);
        }
    }

    function _getAudioBufferLength() {
        var mediaTime = playback.mediaTime.value,
            upTo = MediaBuffer$_getLastChunkWithMedia(mediaTime, _audioChunks);
        return upTo ? Math$max(0, upTo.endTime - mediaTime) : 0;
    }

    function _getAudioBufferBytes() {
        return MediaBuffer$_getBufferBytes(playback.mediaTime.value, _audioChunks);
    }

    function _getVideoBufferLength() {
        var mediaTime = playback.mediaTime.value,
            upTo = MediaBuffer$_getLastChunkWithMedia(mediaTime, _videoChunks);
        return upTo ? Math$max(0, upTo.endTime - mediaTime) : 0;
    }

    function _getVideoBufferBytes() {
        return MediaBuffer$_getBufferBytes(playback.mediaTime.value, _videoChunks);
    }

    function _getTotalBytes(includeInProgress) {
        var i = _allChunks.length,
            chunk,
            media,
            totalBytes = 0,
            videoChunkInfos = playback.videoStream.value.header.chunkInfos,
            audioChunkInfos = playback.audioStream.value.header.chunkInfos;

        while (i--) {
            chunk = _allChunks[i];
            media = chunk.media;

            if (media) {
                totalBytes += media.length;
            } else if (includeInProgress && (chunk.downloading & MediaBuffer$CHUNK_INPROGRESS)) {
                if (chunk.type === CadmiumMediaStream$VIDEO) {
                    totalBytes += videoChunkInfos[chunk.index].length;
                } else if (chunk.type == CadmiumMediaStream$AUDIO) {
                    totalBytes += audioChunkInfos[chunk.index].length;
                }
            }
        }
        return totalBytes;
    }

    /**
     * Return a list of MediaRequest indices to identify all MediaBuffer chunks that currently have media
     *
     * @param {Object} chunks -- linked list of chunks
     * @returns {Array}
     */
    function _getBufferOccupancyList(chunks) {
        var chunk = chunks.first,
            requestList = [];

        while (chunk) {
            if (chunk.media && chunk.mediaRequest) {
                requestList.push(chunk.mediaRequest.getRequestId());
            }
            chunk = chunk.next;
        }

        DEBUG && _log.debug('The buffer currently has ' + requestList.length + ' chunks');
        return requestList;
    }

    function _getHasVideoUpToMediaTime() {
        var mediaTime = playback.mediaTime.value,
            upTo = MediaBuffer$_getLastChunkWithMedia(mediaTime, _videoChunks);
        return upTo ? upTo.endTime : mediaTime;
    }

    function _getLogFields() {
        return {
            'AudioBufferLength': Number$formatMillisecond(_getAudioBufferLength()),
            'VideoBufferLength': Number$formatMillisecond(_getVideoBufferLength())
        };
    }

    function _haveDownloadedRemainingMedia() {
        var audioChunksNeedMedia = _getNextAudioChunkThatNeedsMedia(),
            videoChunksNeedMedia = _getNextVideoChunkThatNeedsMedia();

        return !(audioChunksNeedMedia || videoChunksNeedMedia);
    }

    /**
    * Buffer fullness can occur when 1) we've hit max allowed buffer level,
    * or 2) there are no more chunks left in the timeline to buffer, i.e.,
    * PTS is near the end of the video.  Note this method might be more
    * aptly named, isBufferFullish() since we have some fudge factor
    * for the fact that we may not quite be exactly at max buffer (we could be
    * up to one chunk's worth of seconds shy of it), yet still want to consider
    * that a full buffer.
    */
    function _isBufferFull() {
        return _getNormalizedBufferLength() >= 0.9 || _haveDownloadedRemainingMedia();
    }

    /**
    * MediaDownloadWorkerASE uses this function to see whether
    * the MediaBuffer has enough room to store a Job once it is downloaded.
    * If yes, MediaDownloadWorkerASE will go ahead and start dispatch the job;
    * Otherwise, MediaDownloadWorkerASE will hold on to the Job until there is enough space freed up.
    * @param {{chunk: Object, recommendation: Object, mediaRequest: {mediaType: number} }} job
    */
    function _hasEnoughBufferToStoreNextJob(job) {
        var mediaTime = playback.mediaTime.value,
            chunkToBeDownloaded = job.chunk;

        if (chunkToBeDownloaded) {
            if (chunkToBeDownloaded.startTime - mediaTime > _maxForwardBufferSize) {
                return false;
            }
        }
        return true;
    }

    /**
     * Free up media from chunks that are drop eligible.
     * @param chunks The linked list of chunks to inspect for drop eligibility.
     * @param droppedChunks The count of dropped chunks.
     * @private
     */
    function _compactChunks(chunks, droppedChunks) {
        var mediaTime = playback.mediaTime.value,
            firstChunkWithMedia,
            lastChunkWithMedia,
            chunk = chunks.first,
            droppedChunkCount = droppedChunks.count,
            duration = 0;

        // 1) Free up media from the eligible chunks from the timeline that reside before the back buffer.
        while (chunk) {
            if (chunk.media) {
                firstChunkWithMedia = firstChunkWithMedia || chunk;
                if (chunk.endTime < (mediaTime -  _backBufferSize)) {
                    droppedChunkCount++;
                    _dropMedia(chunk, 'msb');
                } else {
                    lastChunkWithMedia = chunk;
                    duration += chunk.duration;
                }
            }
            chunk = chunk.next;
        }
        firstChunkWithMedia = chunk;

        // 2) Free up media that is ahead of the forward buffer. We might be in this situation if the user
        // has done a backward seek.
        var latest = _furthestMediaTimeAllowedInBuffer(firstChunkWithMedia);
        var latestChunkIndex = chunks.getForTime(latest).index;
        while (lastChunkWithMedia && (duration > _maxBufferSize && lastChunkWithMedia.index > latestChunkIndex))  {
            if (lastChunkWithMedia.media) {
                droppedChunkCount++;
                duration -= lastChunkWithMedia.duration;
                _dropMedia(lastChunkWithMedia, 'msf');

            }
            lastChunkWithMedia = lastChunkWithMedia.previous;
        }
        droppedChunks.count = droppedChunkCount;
    }
    /**
     * Free up memory until we are below the byte buffer limit.
     * @param droppedChunks an object that keeps a count of dropped chunks.
     * returns true if we are able to free up enough room
     */
    function _compactByteBuffer(droppedChunks) {
        if (!_maxBufferBytes) {
            return;
        }

        var availableSize = _maxBufferBytes - _getTotalBytes(false);
        if (availableSize > 0) {
            // there is room in the buffer, we are done
            return true;
        }

        // let's try to free up space
        var mediaTime = playback.mediaTime.value;
        var audioChunk;
        var videoChunk;
        var upToMediaTime;

        // drop media from the back buffers
        // up to the desired [backBufferSize]
        upToMediaTime = mediaTime - _backBufferSize;
        audioChunk = _audioChunks.first;
        videoChunk = _videoChunks.first;
        while (audioChunk || videoChunk) {
            // stop dropping media once we reach the chunk that covers upToMediaTime
            if (audioChunk && audioChunk.endTime >= upToMediaTime || audioChunk.downloading !== MediaBuffer$CHUNK_DOWNLOADED) {
                audioChunk = undefined;
            }
            if (videoChunk && videoChunk.endTime >= upToMediaTime || videoChunk.downloading !== MediaBuffer$CHUNK_DOWNLOADED) {
                videoChunk = undefined;
            }

            // pick what to drop, audio or video (whichever ends earlier)
            if (audioChunk && (!videoChunk || audioChunk.endTime < videoChunk.endTime)) {
                // drop audio
                droppedChunks.count++;
                availableSize += _dropMedia(audioChunk, 'bb');
                audioChunk = audioChunk.next;
            } else if (videoChunk) {
                // drop video
                droppedChunks.count++;
                availableSize += _dropMedia(videoChunk, 'bb');
                videoChunk = videoChunk.next;
            }

            if (availableSize > 0) {
                return true;
            }
        }

        // drop from future buffers
        // start dropping from end, up the chunkInfo
        // we should not drop chunks before the one we are making a room for
        audioChunk = _audioChunks.last;
        videoChunk = _videoChunks.last;
        while (audioChunk || videoChunk) {
            // stop at the "up to" chunk
            if (audioChunk && audioChunk.startTime <= mediaTime || audioChunk.downloading !== MediaBuffer$CHUNK_DOWNLOADED) {
                audioChunk = undefined;
            }
            if (videoChunk && videoChunk.startTime <= mediaTime || videoChunk.downloading !== MediaBuffer$CHUNK_DOWNLOADED) {
                videoChunk = undefined;
            }

            // pick what to drop, audio or video (whichever starts later)
            if (audioChunk && (!videoChunk || audioChunk.startTime > videoChunk.startTime)) {
                // drop audio
                droppedChunks.count++;
                availableSize += _dropMedia(audioChunk, 'bf');
                audioChunk = audioChunk.previous;
            } else if (videoChunk) {
                // drop video
                droppedChunks.count++;
                availableSize += _dropMedia(videoChunk, 'bf');
                videoChunk = videoChunk.previous;
            }

            if (availableSize > 0) {
                return true;
            }
        }
    }

    function _furthestMediaTimeAllowedInBuffer(firstChunkWithMedia){
        return (firstChunkWithMedia ? firstChunkWithMedia.endTime : playback.mediaTime.value) + _maxBufferSize;
    }

    /**
     * Free up chunks that are outside time or byte based buffer limits.
     * Prune requests based on resulting media time line for ASE.
     * @private
     */
    function _compact() {
        DEBUG && _log.trace("Calling Compact().");
        var droppedRequests = { count: 0};
        _compactChunks(_audioChunks, droppedRequests);
        _compactChunks(_videoChunks, droppedRequests);
        _compactByteBuffer(droppedRequests);

        // tell the ASE session to update the pipeline bookkeeping
        if (config.useASE && playback.streamingSession && config.pruneRequestsFromNative &&
            (droppedRequests.count > 0)) {
            _pruneASERequests();
        }
    }

    function _pruneASERequests() {
        var indices = {};
            indices[ASEMediaStream$AUDIO] = _getBufferOccupancyList(_audioChunks);
            indices[ASEMediaStream$VIDEO] = _getBufferOccupancyList(_videoChunks);

            //!!! - don't use playback.mediaPresenter.getElementTime(), cause during the seek, ElementTime is not updated until the seek is completed
        playback.streamingSession.pruneRequestsBasedOnNative(indices, playback.mediaTime.value);
    }

    // Get the next chunk that needs media and is not already being processed.
    function _getNextIdleChunkThatNeedsMedia(chunks) {
        for (var chunk = chunks.getForTime(playback.mediaTime.value); chunk && (chunk.media || chunk.downloading !== MediaBuffer$CHUNK_WAITING); chunk = chunk.next) { };
        return chunk;
    }

    function _getNextChunkThatNeedsMedia(chunks) {
        for (var chunk = chunks.getForTime(playback.mediaTime.value) ; chunk && chunk.media; chunk = chunk.next) { };
        return chunk;
    }

    function _bufferUpdated() {
        playback.fireEvent(MediaBuffer$changed);
        _diagnostics.notifyUpdated('buffer');
    }

    function _disgardMedia(track, chunks) {
        // wipe all the media that isn't for this track
        _log.trace('Disgarding media due to a track change');
        var chunk = chunks.first;
        while (chunk) {
            if (chunk.media && chunk.media.stream.track != track) {
                _dropMedia(chunk, 'tc');
            }
            chunk = chunk.next;
        }
        playback.fireEvent(MediaBuffer$trackchanged);
        _bufferUpdated();
    }

    function _discardVideoMediaBasedOnFilter() {
        var streams = playback.createFilteredVideoStreamList();
        var chunk = _videoChunks.first;
        var newStreamingPts;
        var dropped;

        while (chunk) {
            if (chunk.media && !chunk.inDecoder && streams.indexOf(chunk.media.stream) < 0) {
                if ( config.useASE && chunk.startTime >= playback.mediaTime.value){
                    if (!newStreamingPts){
                        newStreamingPts = chunk.startTime;
                    }
                }
                _dropMedia(chunk, 'sf');
                dropped = true;
            }
            chunk = chunk.next;
        }
        if (dropped) {
            _log.trace('Discarding media based on stream filters');
            if (config.useASE){
                if(config.pruneRequestsFromNative){
                    if (config.abortInProgressDownload){
                        //clear the in progress ones, since we need to immediately re-download the next chunks
                        playback.mediaDownloader.clearInProgressDownloads(_isVideoFunc, _isVideoFunc);
                    }
                    _pruneASERequests();
                } else {
                    var vp = playback.streamingSession._pipelines[playback.streamingManager.MEDIA_VIDEO];
                    vp.setStreamingPts(newStreamingPts);
                    vp.recalculateCompleteBuffer(playback.mediaTime);
                }
            }
            _bufferUpdated();
        }
    }

    function _discardVideoMediaBasedOnFilterWithoutRebuffer() {
        var streams = playback.createFilteredVideoStreamList(),
        chunk = _videoChunks.first,
        dropped,
        decoderChunkIndex,
        decoderChunkIndexPlus;

        var minimumSafeBufferLevel = _heuristics.getMinimumSafeBufferLevel();
        minimumSafeBufferLevel = Math$max(minimumSafeBufferLevel, 8008);


        var newStreamingPts;

        while (chunk) {
            if (chunk.media) {
                if (chunk.inDecoder) {
                    decoderChunkIndex = chunk.index;
                    var additionalChunks = minimumSafeBufferLevel / chunk.duration;
                    decoderChunkIndexPlus = decoderChunkIndex + additionalChunks;
                }

                // drop media for all chunks not in the filtered video stream list, and those needed to avoid rebuffer
                if (!(chunk.index >= decoderChunkIndex && chunk.index <= decoderChunkIndexPlus) && streams.indexOf(chunk.media.stream) < 0) {
                    if ( config.useASE && chunk.startTime >= playback.mediaTime.value){
                        if (!newStreamingPts){
                            newStreamingPts = chunk.startTime;
                        }
                    }
                    _dropMedia(chunk, 'sf');
                    dropped = true;
                }
            }
            chunk = chunk.next;
        }
        if (dropped) {
            _log.trace('Discarding media based on stream filters');
            if (config.useASE){
                if(config.pruneRequestsFromNative){
                    if (config.abortInProgressDownload){
                        //clear the in progress ones, since we need to immediately re-download the next chunks
                        playback.mediaDownloader.clearInProgressDownloads(_isVideoFunc, _isVideoFunc);
                    }
                    _pruneASERequests();
                } else {
                    if (newStreamingPts){
                        var vp = playback.streamingSession._pipelines[playback.streamingManager.MEDIA_VIDEO];
                        vp.setStreamingPts(newStreamingPts);
                        vp.recalculateCompleteBuffer(playback.mediaTime);
                    }
                }
            }
            _bufferUpdated();
        }
    }

    function _onPlaybackClosed() {
        // be safe, and drop all the media
        // Shouldn't need to do this, but if there is a memory leak anywhere in the player
        // this is by far biggest memory hog
        var chunk;
        chunk = _audioChunks.first;
        while (chunk) {
            chunk.media = null;
            chunk.mediaRequest = null;
            chunk = chunk.next;
        }
        chunk = _videoChunks.first;
        while (chunk) {
            chunk.media = null;
            chunk.mediaRequest = null;
            chunk = chunk.next;
        }
    }
}

// calculates buffer length in media time
function MediaBuffer$_getLastChunkWithMedia(time, chunks) {
    var chunk = chunks.getForTime(time);
    if (chunk.media) {
        while (chunk.next && chunk.next.media) chunk = chunk.next;
        return chunk;
    }
}

function MediaBuffer$_getFirstChunkWithMedia(time, chunks) {
    var chunk = chunks.getForTime(time);
    if (chunk.media) {
        while (chunk.previous && chunk.previous.media) chunk = chunk.previous;
        return chunk;
    }
}

// calculates buffer length in bytes
function MediaBuffer$_getBufferBytes(time, chunks) {
    var chunk = chunks.getForTime(time);
    var byteCount = 0;
    if (chunk && chunk.media) {
        // interpolate first chunk (this is how logging spec wants it)
        byteCount += Math$floor(Number$clamp((chunk.endTime - time) / chunk.duration, 0, 1) * chunk.media.length);
        chunk = chunk.next;
    }
    while (chunk && chunk.media) {
        byteCount += chunk.media.length;
        chunk = chunk.next;
    }
    return byteCount;
}


function MediaBuffer$_createChunks(stream, clipEnd) {
    var chunkInfos = stream.header.chunkInfos;
    var chunkInfo;
    var chunks = [];
    var chunk;
    var lastChunk;
    var length = chunkInfos.length;
    if (length <= 0) {
        throw new Error('few chunks');
    }
    for (var i = 0; i < length; i++) {
        chunkInfo = chunkInfos[i];
        var startTime = chunkInfo.startTime,
            duration = chunkInfo.duration,
            endTime = startTime + duration;
        if (endTime > clipEnd) {
            break;
        }
        chunk = {
            type: stream.type,
            index: i,
            startTime: startTime,
            duration: duration,
            endTime: endTime,
            downloading: MediaBuffer$CHUNK_WAITING,
            media: null,
            all: chunks,
            previous: null,
            next: null,
            setDownloading: function setDownloading(value) {
                debug$assert(!(this.media && value === MediaBuffer$CHUNK_WAITING));
                this.downloading = value;
            }
        };
        chunk.logFields = {
            'Type': chunk.type,
            'Chunk index': chunk.index,
            'StartTime': Number$formatMillisecond(chunk.startTime),
            'EndTime': Number$formatMillisecond(chunk.endTime)
        };
        if (lastChunk) {
            lastChunk.next = chunk;
            chunk.previous = lastChunk;
        }
        lastChunk = chunk;
        chunks.push(chunk);
    }
    chunks.getForTime = MediaBuffer$_chunks_getForTime;
    chunks.first = chunks[0];
    chunks.last = lastChunk;
    // store an approximate time-to-index scale, which we can use for quicker lookups
    chunks._timeToIndexScale = chunks.length >= 2 ? (chunks.length - 1) / (chunks.last.startTime - chunks.first.startTime) : 1;
    return chunks;
}

function MediaBuffer$_chunks_getForTime(time) {
    // approximate index of the chunk we need by using time-to-index scale
    var chunk = this[Number$clamp(Math$floor(time * this._timeToIndexScale), 0, this.length - 1)];
    // go left until this chunk starts before the time
    for (; chunk.startTime > time && chunk.previous; chunk = chunk.previous) { };
    // go right until this chunk ends after time
    for (; chunk.endTime < time && chunk.next; chunk = chunk.next) { };
    debug$assert(chunk == this.first || chunk.startTime <= time);
    debug$assert(chunk == this.last || chunk.endTime >= time);
    return chunk;
}

function MediaBuffer$_visualizeChunks(chunks, time) {
    var chunk;
    var result = [];

    var playingChunk = chunks.getForTime(time);
    for (var i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        result.push({
            'index': chunk.index,
            'startTime': chunk.startTime,
            'endTime': chunk.endTime,
            'hasMedia': !!chunk.media,
            'inDecoder': !!chunk.inDecoder,
            'playing': (chunk == playingChunk),
            'bitrate': chunk.media ? chunk.media.stream.bitrate : 0,
            'downloading_state' : chunk.downloading
        });
    }

    return result;
}

// Bit flag based enum set. Each one should be a unique
// power of two.
var MediaBuffer$CHUNK_WAITING = 1;
var MediaBuffer$CHUNK_ONDECK = 2;
var MediaBuffer$CHUNK_DOWNLOADING = 4;
var MediaBuffer$CHUNK_DOWNLOADED = 8;
var MediaBuffer$CHUNK_INPROGRESS = MediaBuffer$CHUNK_ONDECK | MediaBuffer$CHUNK_DOWNLOADING;

// ASE media types, use when the ASE Enums are not available.
var ASEMediaStream$AUDIO = 0,
    ASEMediaStream$VIDEO = 1;



// -- player/selectCdn.js
function selectCdn(playback, testReason, callback) {
    // downloads 8 bytes from each CDN (so we can verify that it's a MOOF box), and recommends a CDN to use
    // recomendation is evaluated as follows:
    //   * cdn with lowest rank that we got a response from
    //   * unless the next in line CDN had much smaller latency
    var httpPlayback = playback.httpPlayback,
        cdnList = playback.cdnList,
        audioStream = playback.audioStream.value,
        videoStream = playback.videoStream.value,
        mediaBuffer = playback.mediaBuffer,
        audioChunk = mediaBuffer.getNextAudioChunkThatNeedsMedia(),
        videoChunk = mediaBuffer.getNextAudioChunkThatNeedsMedia(),
        cdn,
        results = {},
        outstandingRequests = 0,
        timeoutElapsed,
        audioPingRequest,
        videoPingRequest;

    for (var i = 0; i < cdnList.length; i++) {
        cdn = cdnList[i];
        audioPingRequest = selectCdn$_constructPingRequest(cdn, audioStream, audioChunk);
        videoPingRequest = selectCdn$_constructPingRequest(cdn, videoStream, videoChunk);
        if (audioPingRequest && videoPingRequest) {
            outstandingRequests += 2;
            httpPlayback.download(audioPingRequest, onDownloadComplete);
            httpPlayback.download(videoPingRequest, onDownloadComplete);
        }
    }

    setTimeout(function () {
        timeoutElapsed = true;
        assessResults();
    }, config.selectCdnTimeoutMilliseconds);

    function onDownloadComplete(response) {
        if (response.success) {
            var request = response.request;
            results[request.stream.type + '$' + request.cdn.id] = response.measurements;
        }
        outstandingRequests--;
        assessResults();
    };

    function assessResults() {
        if (outstandingRequests > 0 && !timeoutElapsed) {
            return;
        }

        // let's try to select a CDN
        var cdn,
            minLatency,
            latency,
            audioMeasurements,
            videoMeasurements,
            respondedCdns = [],
            i;

        for (i = 0; i < cdnList.length; i++) {
            cdn = cdnList[i];
            audioMeasurements = results[CadmiumMediaStream$AUDIO + '$' + cdn.id];
            videoMeasurements = results[CadmiumMediaStream$VIDEO + '$' + cdn.id];
            if (audioMeasurements && videoMeasurements) {
                latency = Math$max(audioMeasurements.responseStartTime - audioMeasurements.requestTime, videoMeasurements.responseStartTime - videoMeasurements.requestTime);
                respondedCdns.push({
                    cdn: cdn,
                    latency: latency
                });
                minLatency = minLatency === undefined ? latency : Math$min(latency, minLatency);
            }
        }

        i = respondedCdns.length;

        if (i) {
            // some of the CDN-s have responded

            // prefer lower ranking CDN-s, if the latency difference is small...
            // ...to do that, throw away all the CDN-s that have longer latency than min+selectCdnSignificantLatency
            var entry;
            while (i-- && respondedCdns.length > 1) {
                entry = respondedCdns[i];
                if (entry.latency > minLatency + config.selectCdnSignificantLatency) {
                    respondedCdns.splice(i, 1);
                }
            }

            // return remaining CDN with lowest rank
            complete(respondedCdns[0].cdn);

        } else {
            // we have no responses...

            // if there are no more outstandingRequests, then respond with an error
            if (outstandingRequests <= 0) {
                // complete with error
                complete();
            }
        }
    };

    /**
    * @param {Object=} selectedCdn
    */
    function complete(selectedCdn) {
        if (selectedCdn) {
            selectedCdn.cdnsel = { 'testreason': testReason, 'selreason': 'relativelatency' };
        }

        assessResults = NOOP;
        complete = NOOP;
        callback({
            success: !!selectedCdn,
            selectedCdn: selectedCdn
        });
    };
};

function selectCdn$_constructPingRequest(cdn, stream, chunk) {
    var url = stream.downloadUrls[cdn.id];
    // does this CDN have this downloadable?
    if (url) {
        return {
            responseType: http$RESPONSETYPE_BINARY,
            url: stream.downloadUrls[cdn.id],
            parser: selectCdn$_verifyResponse,
            offset: stream.header.chunkInfos[chunk ? chunk.index : 0].offset,
            length: 8,
            cdn: cdn,
            track: stream.track,
            stream: stream,
            diagCaption: stream.type + '-' + stream.bitrate + '-ping',
            cacheBuster: true
        };
    }
};


function selectCdn$_verifyResponse(arrayBuffer) {
    // must be a moof box
    var buffer = new Uint8Array(arrayBuffer);
    var dis = new DataStream(buffer);

    var size = dis.readUInt();
    if (size < 8 || size > selectCdn$MAX_MOOF_SIZE) {
        throw new Error('cdnping-badsize');
    }

    var type = dis.readChars(4);
    if (type != 'moof') {
        throw new Error('cdnping-badtype');
    }

    return true;
};

// a very very very large MOOF, it just can't be bigger than this
var selectCdn$MAX_MOOF_SIZE = 1000000;


// -- player/selectCdnBasedOnBandwidth.js
function selectCdnBasedOnBandwidth(playback, testReason, callback) {
    // download a chunk from every location until one has bandwidth > config.selectCdnBandwidthThresholdKbps
    // if no location meets that bandwidth requirement then choose the one with the highest weighted bandwidth
    var log = new playback.log.CategoryLog('CdnSelBw'),
        httpPlayback = playback.httpPlayback,
        heuristics = playback.heuristics,
        bandwidthMeter = playback.bandwidthMeter,
        streamLocationList = playback.streamLocationList,
        mediaBuffer = playback.mediaBuffer,
        results = {};

    // start testing first cdn at first location
    var testConfig = {
        locationIndex: 0,
        cdnIndex: 0
    };

    var chunkToDownload = mediaBuffer.getNextChunkToDownload();
    if (chunkToDownload) {
        testLocation(testConfig, chunkToDownload);
    } else {
        callback({
            success: true,
            selectedCdn: playback.cdn.value || playback.primaryCdn
        });
    }

    return {
        howLongToComplete: howLongToComplete
    };

    function testLocation(testConfig, chunkToDownload) {
        debug$assert(chunkToDownload);

        var location = streamLocationList[testConfig.locationIndex];
        var cdnsAtLocation = location.cdnList;

        var streamToDownload;
        if (chunkToDownload.type == CadmiumMediaStream$VIDEO) {
            // pick a bitrate based on heuristics
            var recommendation = playback.bufferingState.value == BufferingState$NORMAL ? heuristics.getBufferingRecommendation() : heuristics.getPrebufferingRecommendation();
            streamToDownload = recommendation.videoStream;
            if (!streamToDownload.header) {
                // if recommended stream doesn't have a header, fallback to primary
                streamToDownload = playback.primaryVideoStream;
            }
        } else {
            debug$assert(chunkToDownload.type == CadmiumMediaStream$AUDIO);
            streamToDownload = playback.audioStream.value;
        } 

        debug$assert(streamToDownload && streamToDownload.header);

        for (var i = 0; i < cdnsAtLocation.length; i++) {
            var cdn = cdnsAtLocation[i];
            if (testConfig.cdnIndex === i) {
                var videoBufferLength = playback.mediaBuffer.getVideoBufferLength();
                var mediaRequest = MediaDownloader$createRequest(chunkToDownload, streamToDownload, cdn, config.bandwidthTestBytesPerCdn, videoBufferLength);
                log.trace('CDN Selection: Downloading', { 'CdnId': cdn.id }, chunkToDownload, streamToDownload, {
                    'Count': mediaRequest.chunks.length,
                    'Offset': mediaRequest.offset,
                    'Length': mediaRequest.length
                });
                httpPlayback.download(mediaRequest, onChunkComplete);
            } else {
                var pingRequest = selectCdn$_constructPingRequest(cdn, streamToDownload, chunkToDownload);
                log.trace('CDN Selection: Pinging', { 'CdnId': cdn.id }, chunkToDownload, streamToDownload);
                httpPlayback.download(pingRequest, onPingComplete);
            }
        }
    };

    function onChunkComplete(response) {
        var request = response.request;
        var requestChunk = {};
        var requestChunksLength = 0;
        if (response.success) {
            requestChunk = request.chunks[0];
            requestChunksLength  = request.chunks.length;
        }
        DEBUG && log.trace(String$format("CDN Selection: onChunkComplete, success = {0}, requestChunksLength = {1}, requestChunk index = {2}",response.success, requestChunksLength, requestChunk.index));
        if (response.success) {
            mediaBuffer.notifyChunksDownloaded(request.chunks, request.infos, request.stream, response.content, request.cdn, response.measurements);
        } else if (request.chunks) {
            request.chunks.forEach(function(chunk) {
                _resetChunk(chunk);
            });
        }

        updateResults(response);

        assessLocation();
    };
    function _resetChunk(chunk) {
        chunk.media = null;
        chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
    }
    function onPingComplete(response) {
        updateResults(response);
    };

    function updateResults(response) {
        var cdn = response.request.cdn;
        var cdnId = cdn.id;
        var locationId = cdn.location.id;

        if (response.success) {
            if (!results[locationId]) {
                results[locationId] = {};
            }

            results[locationId][cdnId] = { cdn: cdn, measurements: response.measurements };
        } else {
            if (results[locationId] && results[locationId][cdnId]) {
                delete results[locationId][cdnId];  // remove previous result
            }
        }
    };

    function assessLocation() {
        var bandwidth = getBandwidth(testConfig.locationIndex, testConfig.cdnIndex);
        if (bandwidth > config.selectCdnBandwidthThresholdKbps) {
            var cdn = streamLocationList[testConfig.locationIndex].cdnList[testConfig.cdnIndex];
            cdn.cdnsel = { 'testreason': testReason, 'selreason': 'fastselection', 'fastselthreshold': config.selectCdnBandwidthThresholdKbps };
            callback({
                success: true,
                selectedCdn: cdn
            });
        } else {
            var chunkToDownload = mediaBuffer.getNextChunkToDownload();
            if (chunkToDownload && updateTestConfig(testConfig, results)) {
                // test next server/location
                testLocation(testConfig, chunkToDownload);
            } else {
                var cdn = selectCdnBasedOnResults(results);
                callback({
                    success: !!cdn,
                    selectedCdn: cdn
                });
            }
        }
    };

    function updateTestConfig(testConfig, results) {
        // was download successful, which is marked by the presence of measurements
        var locationId = getLocationId(testConfig),
            cdnId = getCdnId(testConfig);
        var measurements = results[locationId] && results[locationId][cdnId];
        if (measurements) {
            // download succeeded, go to the next location
            return goToNextLocation(testConfig);
        } else {
            // download failed, go to another server at the same location if there is one
            return goToNextServerAtLocation(testConfig) || goToNextLocation(testConfig);
        }
    };

    function getLocationId(testConfig) {
        return streamLocationList[testConfig.locationIndex].id;
    };

    function getCdnId(testConfig) {
        return streamLocationList[testConfig.locationIndex].cdnList[testConfig.cdnIndex].id;
    };

    function goToNextLocation(testConfig) {
        if (testConfig.locationIndex < streamLocationList.length - 1) {
            testConfig.locationIndex++;
            testConfig.cdnIndex = 0;
            return true;
        }
    };

    function goToNextServerAtLocation(testConfig) {
        if (testConfig.cdnIndex < streamLocationList[testConfig.locationIndex].cdnList.length - 1) {
            testConfig.cdnIndex++;
            return true;
        }
    };

    function getBandwidth(locationIndex, cdnIndex) {
        var location = streamLocationList[locationIndex];
        var locationId = location.id;
        var cdnId = location.cdnList[cdnIndex].id;
        if (results[locationId] && results[locationId][cdnId]) {
            var measurements = results[locationId][cdnId].measurements;
            return calculateBandwidth(measurements);
        }
    };

    function calculateBandwidth(measurements) {
        if (measurements) {
            // use total time to evaluate bandwidth since transfer time might be zero
            var totalTime = measurements.responseEndTime - measurements.requestTime;
            var bandwidth = BPMStoKBPS * measurements.contentLength / totalTime;
            return bandwidth;
        }
    };

    function selectCdnBasedOnResults(results) {
        var cdn;
        var cdnWeightedBandwidth = 0;

        // search for results at every location
        enumerateOwnProperties(results, function (locationId, cdns) {
            if (cdns) {
                // search for result at every cdn at that location
                enumerateOwnProperties(cdns, function (cdnId, result) {
                    var bandwidth = calculateBandwidth(result.measurements);
                    var weigthedBandwidth = bandwidth * result.cdn.location.weight;

                    // find the cdn with the highest weighted bandwidth
                    if (weigthedBandwidth > cdnWeightedBandwidth) {
                        cdnWeightedBandwidth = weigthedBandwidth;
                        cdn = result.cdn;
                    }
                });
            }
        });

        if (cdn) {
            cdn.cdnsel = { 'testreason': testReason, 'selreason': 'maxweightedbw' };
        }

        return cdn;
    };

    function howLongToComplete() {
        // rough estimate
        // TODO: this logic might be obsolete if we change how we do progress
        var singleTestTime = bandwidthMeter.calculateDownloadTime(config.bandwidthTestBytesPerCdn);
        var testEta = singleTestTime * (streamLocationList.length - testConfig.locationIndex);
        return testEta;
    };
}


// -- player/selectCdnBasedOnCarrera.js
/**
 * If historical information is available, use Carrera to choose a video bitrate for CDN selection downloads.
 * If data is missing for one or more CDNs, fall back to Heuristics.
 *
 * @param {Playback} playback The main video playback object
 * @param {string} testReason Why are we performing CDN selection
 * @param {CarreraBitrateSelector} carrera Carrera implementation to pick starting bitrate
 * @param {Array} streams List of available video streams
 * @param {Function} callback Function to call when CDN selection has completed
 */
function selectCdnBasedOnCarrera(playback, testReason, carrera, streams, callback) {
    // download a chunk from every location until one has bandwidth > config.selectCdnBandwidthThresholdKbps
    // if no location meets that bandwidth requirement then choose the one with the highest weighted bandwidth
    var log = new playback.log.CategoryLog('CdnSelCarrera'),
        httpPlayback = playback.httpPlayback,
        heuristics = playback.heuristics,
        bandwidthMeter = playback.bandwidthMeter,
        streamLocationList = playback.streamLocationList,
        mediaBuffer = playback.mediaBuffer,
        usingCarrera = [],
        results = {};

    // start testing first cdn at first location
    var testConfig = {
        locationIndex: 0,
        cdnIndex: 0
    };

    var chunkToDownload = mediaBuffer.getNextChunkToDownload();
    if (chunkToDownload) {
        testLocation(testConfig, chunkToDownload);
    } else {
        callback({
            success: true,
            selectedCdn: playback.cdn.value || playback.primaryCdn,
            usingCarrera: usingCarrera.indexOf(playback.cdn.value) > -1
        });
    }

    return {
        howLongToComplete: howLongToComplete
    };


    function testLocation(testConfig, chunkToDownload) {
        debug$assert(chunkToDownload);
        var location = streamLocationList[testConfig.locationIndex],
            cdnsAtLocation = location.cdnList,
            vbitrate,
            recommendation;

        var streamToDownload;
        if (chunkToDownload.type == CadmiumMediaStream$AUDIO) {
            debug$assert(chunkToDownload.type == CadmiumMediaStream$AUDIO);
            streamToDownload = playback.audioStream.value;
        }

        for (var i = 0; i < cdnsAtLocation.length; i++) {
            var cdn = cdnsAtLocation[i];

            if (chunkToDownload.type == CadmiumMediaStream$VIDEO) {
                vbitrate = carrera.getInitialBitrate(cdn.location.id);
                if (vbitrate) {
                    streamToDownload = streams.firstBelow(vbitrate + 1, true);
                    usingCarrera.push(cdn.location.id);
                } else {
                    // fall back to Heuristics if Carrera didn't return anything (no historical data)
                    recommendation =  heuristics.getPrebufferingRecommendation(true);
                    streamToDownload = recommendation.videoStream;
                    if (!streamToDownload.header) {
                        // if recommended stream doesn't have a header, fallback to primary
                        streamToDownload = playback.primaryVideoStream;
                    }
                }
            }

            debug$assert(streamToDownload && streamToDownload.header);

            if (testConfig.cdnIndex === i) {
                var videoBufferLength = playback.mediaBuffer.getVideoBufferLength();
                var mediaRequest = MediaDownloader$createRequest(chunkToDownload, streamToDownload, cdn, config.bandwidthTestBytesPerCdn, videoBufferLength);
                log.trace('Downloading', { 'CdnId': cdn.id }, chunkToDownload, streamToDownload, {
                    'Count': mediaRequest.chunks.length,
                    'Offset': mediaRequest.offset,
                    'Length': mediaRequest.length
                });
                httpPlayback.download(mediaRequest, onChunkComplete);
            } else {
                var pingRequest = selectCdn$_constructPingRequest(cdn, streamToDownload, chunkToDownload);
                log.trace('Pinging', { 'CdnId': cdn.id }, chunkToDownload, streamToDownload);
                httpPlayback.download(pingRequest, onPingComplete);
            }
        }
    }

    function onChunkComplete(response) {
        var request = response.request;

        if (response.success) {
            mediaBuffer.notifyChunksDownloaded(request.chunks, request.infos, request.stream, response.content, request.cdn, response.measurements);
        } else if (request.chunks) {
            request.chunks.forEach(function(chunk) {
                _resetChunk(chunk);
            });
        }

        updateResults(response);

        assessLocation();
    }

    function _resetChunk(chunk) {
        chunk.media = null;
        chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
    }

    function onPingComplete(response) {
        updateResults(response);
    }

    function updateResults(response) {
        var cdn = response.request.cdn;
        var cdnId = cdn.id;
        var locationId = cdn.location.id;

        if (response.success) {
            if (!results[locationId]) {
                results[locationId] = {};
            }

            results[locationId][cdnId] = { cdn: cdn, measurements: response.measurements,  };
        } else {
            if (results[locationId] && results[locationId][cdnId]) {
                delete results[locationId][cdnId];  // remove previous result
            }
        }
    }

    function assessLocation() {
        var bandwidth = getBandwidth(testConfig.locationIndex, testConfig.cdnIndex);
        if (bandwidth > config.selectCdnBandwidthThresholdKbps) {
            var cdn = streamLocationList[testConfig.locationIndex].cdnList[testConfig.cdnIndex];
            cdn.cdnsel = { 'testreason': testReason, 'selreason': 'fastselection', 'fastselthreshold': config.selectCdnBandwidthThresholdKbps };
            callback({
                success: true,
                selectedCdn: cdn,
                usingCarrera: usingCarrera.indexOf(playback.cdn.value) > -1
            });
        } else {
            var chunkToDownload = mediaBuffer.getNextChunkToDownload();
            if (chunkToDownload && updateTestConfig(testConfig, results)) {
                // test next server/location
                testLocation(testConfig, chunkToDownload);
            } else {
                var cdn = selectCdnBasedOnResults(results);
                callback({
                    success: !!cdn,
                    selectedCdn: cdn,
                    usingCarrera: usingCarrera.indexOf(playback.cdn.value) > -1
                });
            }
        }
    }

    function updateTestConfig(testConfig, results) {
        // was download successful, which is marked by the presence of measurements
        var locationId = getLocationId(testConfig),
            cdnId = getCdnId(testConfig);
        var measurements = results[locationId] && results[locationId][cdnId];
        if (measurements) {
            // download succeeded, go to the next location
            return goToNextLocation(testConfig);
        } else {
            // download failed, go to another server at the same location if there is one
            return goToNextServerAtLocation(testConfig) || goToNextLocation(testConfig);
        }
    }

    function getLocationId(testConfig) {
        return streamLocationList[testConfig.locationIndex].id;
    }

    function getCdnId(testConfig) {
        return streamLocationList[testConfig.locationIndex].cdnList[testConfig.cdnIndex].id;
    }

    function goToNextLocation(testConfig) {
        if (testConfig.locationIndex < streamLocationList.length - 1) {
            testConfig.locationIndex++;
            testConfig.cdnIndex = 0;
            return true;
        }
    }

    function goToNextServerAtLocation(testConfig) {
        if (testConfig.cdnIndex < streamLocationList[testConfig.locationIndex].cdnList.length - 1) {
            testConfig.cdnIndex++;
            return true;
        }
    }

    function getBandwidth(locationIndex, cdnIndex) {
        var location = streamLocationList[locationIndex];
        var locationId = location.id;
        var cdnId = location.cdnList[cdnIndex].id;
        if (results[locationId] && results[locationId][cdnId]) {
            var measurements = results[locationId][cdnId].measurements;
            return calculateBandwidth(measurements);
        }
    }

    function calculateBandwidth(measurements) {
        if (measurements) {
            // use total time to evaluate bandwidth since transfer time might be zero
            var totalTime = measurements.responseEndTime - measurements.requestTime;
            var bandwidth = BPMStoKBPS * measurements.contentLength / totalTime;
            return bandwidth;
        }
    }

    function selectCdnBasedOnResults(results) {
        var cdn;
        var cdnWeightedBandwidth = 0;

        // search for results at every location
        enumerateOwnProperties(results, function (locationId, cdns) {
            if (cdns) {
                // search for result at every cdn at that location
                enumerateOwnProperties(cdns, function (cdnId, result) {
                    var bandwidth = calculateBandwidth(result.measurements);
                    var weigthedBandwidth = bandwidth * result.cdn.location.weight;

                    // find the cdn with the highest weighted bandwidth
                    if (weigthedBandwidth > cdnWeightedBandwidth) {
                        cdnWeightedBandwidth = weigthedBandwidth;
                        cdn = result.cdn;
                    }
                });
            }
        });

        if (cdn) {
            cdn.cdnsel = { 'testreason': testReason, 'selreason': 'maxweightedbw' };
        }

        return cdn;
    }

    function howLongToComplete() {
        // rough estimate
        // TODO: this logic might be obsolete if we change how we do progress
        var singleTestTime = bandwidthMeter.calculateDownloadTime(config.bandwidthTestBytesPerCdn);
        var testEta = singleTestTime * (streamLocationList.length - testConfig.locationIndex);
        return testEta;
    }
}


// -- player/MediaDownloader.js
/**
* @constructor
*/
function MediaDownloader(playback) {
    var _log = new playback.log.CategoryLog('MediaDownloader'),
        _httpPlayback = playback.httpPlayback,
        _heuristics = playback.heuristics,
        _bandwidthMeter = playback.bandwidthMeter,
        _mediaBuffer = playback.mediaBuffer,
        _repositionUpdate = new Throttle(500),
        _activeTask,
        _activeHeaderDownload,
        _activeCooldown,
        _failedDownloadRetryWaits = config.failedDownloadRetryWaits,
        _failedDownloadRetryIndex = 0,
        _thisDownloadExpectedLatency,
        _thisDownloadExpectedTransferTime,
        _futureDownloadsEta,
        _firstPrebufferComplete,
        _performCdnTestReason = 'startup';

    debug$assert(_httpPlayback);
    debug$assert(_heuristics);
    debug$assert(_bandwidthMeter);
    debug$assert(_mediaBuffer);

    _init();

    this.howLongToNormalState = _howLongToNormalState;

    this.getCurrentStateName = NOOP;
    this.getMaxProgress = function _getMaxProgress() {
        return 0.99;
    };
    // --------------------------------------------------------------------------------
    // -- private implementation

    function _init() {
        //-- start updating and listenting to media playback progress
        dispatch(_update);
        playback.addEventListener(Playback$throttledMediaTimeChanged, function () {
            // do not update inline of a media time change
            // do so we handle [throttledMediaTimeChanged] followed with [repositioned] properly
            dispatch(_update);
        });

        playback.addEventListener(Playback$bufferUnderrun, function (args) {
            // presenter run out of buffer... 
            if (args.cause == Playback$BUFFER_UNDERRUN_CAUSE_NETWORK) {
                // if it was because downloader didn't keep up, go into buffering state
                playback.bufferingState.set(BufferingState$BUFFERING);
            }
            dispatch(_update);
        });
        playback.addEventListener(Playback$repositioned, function () {
            // presenter repositioned...
            // do we need to enter buffering mode?
            var recommendation;
            if (playback.audioStream.value.header && playback.videoStream.value.header) {
                // if we switch tracks, we won't have headers to run heuristics
                recommendation = _heuristics.getPrebufferingRecommendation();
            }
            if (recommendation && recommendation.needMoreAudioMilliseconds <= 0 && recommendation.needMoreVideoMilliseconds <= 0) {
                _log.trace('Repositioned without rebuffer', _mediaBuffer);
            } else {
                _log.trace('Repositioned, buffering', _mediaBuffer);
                playback.bufferingState.set(BufferingState$BUFFERING);
            }

            // don't abort current update to often
            _repositionUpdate.schedule(_onUpdteDueToReposition);
        });
        http.addEventListener(http$onlinechanged, _update);
        playback.addEventListener(Playback$closing, _onClosing);
    }

    function _onClosing() {
        http.removeEventListener(http$onlinechanged, _update);
        if (_activeTask && _activeTask.response) {
            _activeTask.response.abort();
        }
    }

    function _onUpdteDueToReposition() {
        // abort active download, unless it's the one that we would want to download anyways
        var chunkToDownload = _mediaBuffer.getNextChunkToDownload();
        if (_activeTask && _activeTask.response && chunkToDownload != _activeTask.chunk) {
            _activeTask.response.abort();
        }
        _update();
    }

    function _howLongToNormalState() {
        var eta;
        if (playback.bufferingState.value == BufferingState$BUFFERING && _activeTask) {
            var thisDownloadEta;
            try {
                // estimate as follows
                // [ (a) ..this download latency.. ][ (b) ..this download transfer..][ (c) ...all the other downloads estimated transfer time...]
                if (_activeTask.type == MediaDownloader$TASK_CHUNKDOWNLOAD) {
                    var response = _activeTask.response;
                    var measurements = response.measurements;
                    if (isNumber(measurements.responseStartTime)) {
                        // download is connected (past latency) and is downloading
                        // so we are at the (b) stage, interpolate the time based on bytes
                        var transferredBytes = measurements.contentLength || 0,
                            totalBytes = response.request.length;
                        thisDownloadEta = (1 - transferredBytes / totalBytes) * _thisDownloadExpectedTransferTime;
                    } else {
                        // download didn't connect yet, so we are at the latency stage
                        // interpolate the real time, but never go above 0
                        var elapsed = clock$getTime() - measurements.requestTime;
                        thisDownloadEta = Math$max(_thisDownloadExpectedLatency - elapsed, 0) + _thisDownloadExpectedTransferTime;
                    }
                }
            }
            catch (e) {
                debug$assert(false, '' + e);
            }
            eta = (thisDownloadEta || 0) + (_futureDownloadsEta || 0);
            
            // if current task has it's own ETA, take max (say when CDN selection takes longer)
            var taskEta = _activeTask.howLongToComplete && _activeTask.howLongToComplete();
            if (taskEta) {
                eta = Math$max(taskEta, eta);
            }
        }
        return eta;
    }

    function _update() {
        if (playback.state.value != Playback$STATE_NORMAL || playback.presentingState.value == PresentingState$ENDED)
            return;

        // Check if media download URLs are still good.
        if (playback.manifestWillExpireOn && playback.manifestWillExpireOn <= clock$getTime()) {
            // Media URLs are expired, we can't start new downloads
            if (playback.bufferingState.value != BufferingState$NORMAL) {
                // if we are in buffering state... we can never actually buffer
                // so induce a playback failure
                playback.closeWithError(new PlayerError(ErrorCodes.AUTHORIZATION_EXPIRED));
            }
            // otherwise, just don't do anything
            return;
        }

        if (playback.bufferingState.value == BufferingState$BUFFERING) {
            if (!http$isOnLine()) {
                playback.bufferingState.set(BufferingState$STALLED);
            }
        }

        if (playback.bufferingState.value == BufferingState$STALLED) {
            if (http$isOnLine()) {
                playback.bufferingState.set(BufferingState$BUFFERING);
            }
        }

        // make sure the current audio and video streams have headers
        // missing headers are most likely caused by track changes
        if (!playback.audioStream.value.header) {
            _downloadHeader(playback.audioStream.value);
            // exit, since we can't do much without a header
            return;
        }

        if (!playback.videoStream.value.header) {
            _downloadHeader(playback.videoStream.value);
            // exit, since we can't do much without a header
            return;
        }

        if ( _performCdnTestReason) {
            // if we don't have a CDN selected, select one
            // Note: this happens if header downloads had failures, and Playback.load didn't pick a CDN
            _startSelectCdnTask(_performCdnTestReason);

            _performCdnTestReason = undefined;

            return;
        }

        // Do we have anything we need to download?
        var chunkToDownload = _mediaBuffer.getNextChunkToDownload();

        // get a recommendation from heuristics
        var recommendation;
        if (playback.bufferingState.value != BufferingState$NORMAL) {
            // we are "pre-buffering"...
            
            // try to exit buffering mode based on recommendation from heuristics
            recommendation = _heuristics.getPrebufferingRecommendation();
            if (recommendation.needMoreAudioMilliseconds <= 0 && recommendation.needMoreVideoMilliseconds <= 0) {
                _exitBufferingState('Heuristics');
            }

            // also, we have to exit buffering mode if buffer is full
            if (!chunkToDownload) {
                _exitBufferingState('Full');
            }
        }

        // don't download if there is an active task
        if (_activeTask)
            return;

        // also don't start the download if there is an active header download for a higher bitrate stream
        // Note: we do this for higher bitrate streams, so we switch up to it once we get the header
        if (_activeHeaderDownload &&
            _activeHeaderDownload.stream.type == CadmiumMediaStream$VIDEO &&
            _activeHeaderDownload.stream.bitrate > playback.videoStream.value.bitrate) {
            return;
        }

        if (chunkToDownload) {
            // run heuristics for non-buffering (playing) mode only if we have something to download
            if (playback.bufferingState.value == BufferingState$NORMAL) {
                recommendation = _heuristics.getBufferingRecommendation();
            }

            // if we need to download a chunk, do so
            var chunkIndex = chunkToDownload.index,
            stream;

            if (chunkToDownload.type == CadmiumMediaStream$VIDEO) {
                // if we need more video, update the video stream based on recommendation from heuristics
                stream = recommendation.videoStream;

                // does this stream have the chunk we need?
                if (!(stream.header && stream.header.chunkInfos[chunkIndex])) {
                    _log.warn('Stream is missing header or has less chunks than primary, falling back to primary', { 'BitrateOld': stream.bitrate, 'BitrateNew': playback.primaryVideoStream.bitrate });
                    stream = playback.primaryVideoStream;
                }

                if (stream != playback.videoStream.value) {
                    _log.trace('Stream switch', { 'BitraetOld': playback.videoStream.value.bitrate, 'BitrateNew': stream.bitrate });
                    playback.videoStream.set(stream);
                }
            } else if (chunkToDownload.type == CadmiumMediaStream$AUDIO) {
                stream = playback.audioStream.value;
            } else {
                debug$assert(false);
                return;
            }

            var chunkInfo = stream.header.chunkInfos[chunkIndex];
            // before we download, ask the buffer to free up room for this download
            if (!_mediaBuffer.tryMakeRoom(chunkInfo)) {
                // no room, can't download
                
                // in case we don't have the minimum for the decoder, as a drastic measure resort to downloading the lowest bitrate
                // even if it puts us above max buffer size
                if (stream.type == CadmiumMediaStream$AUDIO && _mediaBuffer.getAudioBufferLength() < config.minDecoderBufferMilliseconds) {
                    _log.trace('Ignoring max buffer bytes', chunkToDownload, stream);
                } else if (stream.type == CadmiumMediaStream$VIDEO && _mediaBuffer.getVideoBufferLength() < config.minDecoderBufferMilliseconds) {
                    stream = playback.getVideoStreamList().firstAbove(0, true);
                    chunkInfo = stream.header.chunkInfos[chunkIndex];
                    _log.trace('Ignoring max buffer bytes, and reverting to lowest video stream', chunkToDownload, stream);

                } else {
                    // make sure to exit buffering state, and we are done here
                    _exitBufferingState('NoRoom');
                    chunkInfo = undefined;
                }
            }

            if (chunkInfo) {
                if (playback.bufferingState.value == BufferingState$BUFFERING && recommendation) {
                    _futureDownloadsEta = _getEstimatedDownloadTime(
                        playback.mediaTime.value,
                        chunkToDownload,
                        recommendation.needMoreAudioMilliseconds,
                        recommendation.needMoreVideoMilliseconds);
                    _thisDownloadExpectedLatency = _bandwidthMeter.getLatency();
                    _thisDownloadExpectedTransferTime = Math$max(_bandwidthMeter.calculateDownloadTime(chunkInfo.length) - _thisDownloadExpectedLatency, 1);
                } else {
                    _futureDownloadsEta = undefined;
                    _thisDownloadExpectedLatency = undefined;
                    _thisDownloadExpectedTransferTime = undefined;
                }

                // before we actually download the chunk, let's see if we been failing downloads...
                if (_failedDownloadRetryIndex > config.selectCdnDownloadRetryCountBeforeCdnSwitch) {
                    // if we were, kick of CDN seleciton instead... and return (no media downloaded)
                    _startSelectCdnTask('dlfail');
                    return;
                }

                var cdn = playback.cdn.value;
                var videoBufferLength = playback.mediaBuffer.getVideoBufferLength();
                var mediaRequest = MediaDownloader$createRequest(chunkToDownload, stream, cdn, undefined, videoBufferLength);

                // TODO: used for getting MOOV for repros, delete this at one point
                //log.info(
                //    'WGET -O' + stream.type + '_' + stream.bitrate + '_chunk_' + (chunkToDownload.index <= 9 ? '00' : chunkToDownload.index <= 99 ? '0' : '') + chunkToDownload.index + '.' + CadmiumMediaStream$switchType(stream.type, 'isma', 'ismv') +
                //    ' "' + stream.downloadUrls[cdn.id].replace('?', '/range/' + chunkInfo.offset + '-' + (chunkInfo.offset + chunkInfo.length - 1) + '?') + '"');

                _log.trace('Downloading chunk', chunkToDownload, stream, {
                    'Offset': mediaRequest.offset,
                    'Length': mediaRequest.length
                });

                chunkToDownload.setDownloading(MediaBuffer$CHUNK_DOWNLOADING);
                CadmiumMediaStream$switchType(stream.type, playback.downloadingAudio, playback.downloadingVideo).set({
                    chunk: chunkToDownload,
                    stream: stream,
                    cdn: cdn
                });

                // kick off the download
                _activeTask = {
                    type: MediaDownloader$TASK_CHUNKDOWNLOAD,
                    stream: stream,
                    chunk: chunkToDownload,
                    response: _httpPlayback.download(mediaRequest, _onTaskComplete)
                };
            }
        }

        // Get a video header if heuristics recommends we do so
        if (!_activeHeaderDownload && recommendation && recommendation.getHeaderFor) {
            _downloadHeader(recommendation.getHeaderFor);
        }
    }

    function _exitBufferingState(causeForLog) {
        if (playback.bufferingState.value != BufferingState$NORMAL) {
            _log.trace('Buffering complete', { 'Cause': causeForLog }, _mediaBuffer);
            playback.bufferingState.set(BufferingState$NORMAL);
            if (!_firstPrebufferComplete) {
                _firstPrebufferComplete = true;
                playback.notifyMilestone('pb');
            }
        }
    }

    function _startSelectCdnTask(testReason) {
        _log.trace('Selecting a CDN');
        _activeTask = { type: MediaDownloader$TASK_CDNSELECTION };
        switch (config.selectCdnType) {
            case 'bandwidth':
                var r = selectCdnBasedOnBandwidth(playback, testReason, _onTaskComplete);
                _activeTask.howLongToComplete = r && r.howLongToComplete;
                break;
            default:
                selectCdn(playback, testReason, _onTaskComplete);
                break;
        }
    }

    function _downloadHeader(stream) {
        if (_activeHeaderDownload && _activeHeaderDownload.stream == stream) {
            // already downloading that stream
            return;
        }
        if (stream.headerDownloadAttempted) {
            // we already attempted to download that stream, and most likely failed... or timedout
            // TODO: should we retry?
            return;
        }
        _log.trace('Downloading header', stream);
        var headerDownload = {
            stream: stream,
            startedOn: clock$getTime()
        };
        _activeHeaderDownload = headerDownload;

        function onHeaderDownloadComplete() {
            // wrap up the download
            if (_activeHeaderDownload == headerDownload) {
                _activeHeaderDownload = null;
            }
            headerDownload = null;
            _update();
        };
        stream.downloadHeader(onHeaderDownloadComplete);
        setTimeout(onHeaderDownloadComplete, config.headerDownloadTimeout);
    }

    function _onTaskComplete(result) {
        debug$assertNotNull(_activeTask);
        var task = _activeTask;
        _activeTask = null;
        if (playback.state.value != Playback$STATE_NORMAL) {
            return;
        }
        if (task.type != MediaDownloader$TASK_COOLDOWN) {
            if (result.success) {
                _failedDownloadRetryIndex = 0;
                if (task.type == MediaDownloader$TASK_CHUNKDOWNLOAD) {
                    // we downloaded a chunk
                    var request = result.request;
                    if (playback.bufferingState.value == BufferingState$STALLED) {
                        playback.bufferingState.set(BufferingState$BUFFERING);
                    }
                    _mediaBuffer.notifyChunksDownloaded(request.chunks, request.infos, request.stream, result.content, request.cdn, result.measurements);
                } else {
                    // we performed a CDN selection, use the result
                    playback.cdn.set(result.selectedCdn);
                }
            }
            else {
                // we failed to download a chunk or perform a CDN selection, kick off a cooldown
                if (result.errorSubCode != ErrorSubCodes.HTTP_ABORT) {
                    // kick off a cooldown
                    _activeTask = { type: MediaDownloader$TASK_COOLDOWN };
                    setTimeout(_onTaskComplete, _failedDownloadRetryWaits[_failedDownloadRetryIndex]);
                    if ((++_failedDownloadRetryIndex) >= _failedDownloadRetryWaits.length) {
                        if (playback.bufferingState.value == BufferingState$BUFFERING) {
                            playback.bufferingState.set(BufferingState$STALLED);
                        }
                        _failedDownloadRetryIndex = _failedDownloadRetryWaits.length - 1;
                    }
                }
            }
        }
        _update();
    }

    function _onCooldownElapsed() {
        _activeCooldown = null;
        _update();
    }

    function _getEstimatedDownloadTime(mediaTime, chunkToDownload, audioMilliseconds, videoMilliseconds) {
        // gets how long will it take to download given ammount of audio and video
        // excluding the chunkToDownload download time
        var audioChunk = _mediaBuffer.getNextAudioChunkThatNeedsMedia(),
            videoChunk = _mediaBuffer.getNextVideoChunkThatNeedsMedia(),
            audioChunkInfos = playback.audioStream.value.header.chunkInfos,
            videoChunkInfos = playback.videoStream.value.header.chunkInfos,
            downloadTime = 0;

        while (audioMilliseconds > 0 && audioChunk) {
            if (!audioChunk.media && audioChunk != chunkToDownload) {
                downloadTime += _bandwidthMeter.calculateDownloadTime(audioChunkInfos[audioChunk.index].length);
            }
            audioMilliseconds -= audioChunk.duration;
            audioChunk = audioChunk.next;
        }

        while (videoMilliseconds > 0 && videoChunk) {
            if (!videoChunk.media && videoChunk != chunkToDownload) {
                downloadTime += _bandwidthMeter.calculateDownloadTime(videoChunkInfos[videoChunk.index].length);
            }
            videoMilliseconds -= videoChunk.duration;
            videoChunk = videoChunk.next;
        }

        return downloadTime;
    }
};

/**
 * @param {number=} minimumNumberOfBytes
 * @param {number=} videoBufferLength
 */
function MediaDownloader$createRequest(nextChunkToDownload, stream, cdn, minimumNumberOfBytes, videoBufferLength) {
    var chunkInfos = stream.header.chunkInfos,
        offset = chunkInfos[nextChunkToDownload.index].offset,
        length = 0;

    // initialize chunks to download with first chunk, add if necessary
    var chunks = [],
        infos = [];

    do {
        var info = chunkInfos[nextChunkToDownload.index];
        length += info.length;
        chunks.push(nextChunkToDownload);
        infos.push(info);

        nextChunkToDownload = nextChunkToDownload.next;
    } while (length < minimumNumberOfBytes && nextChunkToDownload);

    var connectionTimeoutMs = config.connectTimeoutMilliseconds;
    // if using variable timeout and we were given the current buffer level
    // then compute new timeout value to add to request
    // only compute for devices with buffers based on time not on byte limitations
    if (isDefined(videoBufferLength) && config.useVariableConnectTimeout && !config.maxBufferSizeBytes) {
        // this equation gives a timeout lower than 8 seconds when buffer is under 8 second
        // at 16 seconds of buffer, we reach the default value of 8-second timeout
        // after that the timeout grows more slowly, reaching 17 second when the buffer is full (240 seconds)
        connectionTimeoutMs = Math.max(config.minConnectTimeoutMilliseconds,
                                Math.min(videoBufferLength/config.connectTimeoutBufferDiscount,
                                            config.connectTimeoutMilliseconds + config.connectTimeoutoutUpperLimitMultiplier*(videoBufferLength/config.maxBufferSizeMilliseconds)));
    }
    return {
        responseType: http$RESPONSETYPE_BINARY,
        parser: MediaDownloader$parseChunkMedia,
        url: stream.downloadUrls[cdn.id],
        offset: offset,
        length: length,
        cdn: cdn,
        track: stream.track,
        stream: stream,
        chunks: chunks,
        infos: infos,
        diagCaption: stream.type + '-' + stream.bitrate + '-' + chunks.map(function (chunk) { return chunk.index; }).join('+'),
        cacheBuster: true,
        connectTimeoutMilliseconds: connectionTimeoutMs
    };
};



var MediaDownloader$TASK_CHUNKDOWNLOAD = 1,
    MediaDownloader$TASK_COOLDOWN = 2,
    MediaDownloader$TASK_CDNSELECTION = 3;


// -- player/CpuProbe.js
Playback$registerComponent(Playback$COMPONENT_WHEN_CREATED, function loadCpuProbe(playback) {

    playback.addEventListener(HttpPlayback$downloadstarted, onDownloadStarted);

    function onDownloadStarted(response) {
        // try to do this after we send a reasonably sized request, so it's done in parallel to network being busy
        var request = response.request;
        if (request && (request.length > 4000)) {
            playback.removeEventListener(HttpPlayback$downloadstarted, onDownloadStarted);
            dispatch(function () {
                var executionCount = 2000;

                var startTime = performance.now(),
                    previousTime = startTime,
                    timeDeltas = [];

                for (var i = 0; i < executionCount; i++) {
                    var atanCount = 10;
                    while (atanCount--) {
                        // store result, so compiler doesn't skip this line
                        playback.temp = Math.atan2(atanCount, atanCount);
                    }

                    var now = performance.now();
                    timeDeltas.push(now - previousTime);
                    previousTime = now;
                }

                var totalTime = previousTime - startTime;
                var averageTime = totalTime / executionCount;

                // detect all the context switches
                var outliers = [];
                for (var i = 0; i < timeDeltas.length; i++) {
                    // threshold is 5 times average
                    if (timeDeltas[i] > (5 * averageTime)) {
                        outliers.push(i);
                    }
                }

                // add up all the context switch time
                var contextSwitchTime = outliers.reduce(function(previousValue, currentValue) {
                    return previousValue + timeDeltas[currentValue];
                }, 0);

                // adjust totalTime, by subtracting contextSwitchTime
                totalTime -= contextSwitchTime;
                executionCount -= outliers.length;

                if (totalTime != 0 ) {
                    // cpuSpeed is a function of how many operations / second can be executed
                    var cpuSpeed = executionCount / totalTime;

                    playback.cpuSpeed = (Math.round(cpuSpeed));
                }

            });
        }
    };
});



// -- player/DeviceCapabilities.js
/**
 * Select profiles the device is capable of streaming based on it's capabilities.
 * @param {Object} allProfiles all available profiles
 * @param {string} type the media type of the profiles, 'audio', or 'video'
 */
function DeviceCapabilities$SelectProfiles(allProfiles, type) {
    var filteredProfiles,
        videoProfilesMap = {},
        audioProfilesMap = {},
        DV_Codec = 'dvhe.01000000';

    debug$assert(type === 'video' || type === 'audio');

    // H264 support
    videoProfilesMap[videoProfile$H264_BPL30] = 'avc1.42E01E';
    videoProfilesMap[videoProfile$H264_MPL30] = 'avc1.4D401E';
    videoProfilesMap[videoProfile$H264_MPL31] = 'avc1.4D401F';
    videoProfilesMap[videoProfile$H264_MPL40] = 'avc1.4D4028';

    // HEVC support (H265)
    videoProfilesMap[videoProfile$HEVC_MAIN_MPL30] = 'hev1.1.6.L90.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN_MPL31] = 'hev1.1.6.L93.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN_MPL40] = 'hev1.1.6.L120.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN_MPL41] = 'hev1.1.6.L123.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN_MPL50] = 'hev1.1.6.L150.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN_MPL51] = 'hev1.1.6.L153.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN10_MPL30] = 'hev1.2.6.L90.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN10_MPL31] = 'hev1.2.6.L93.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN10_MPL40] = 'hev1.2.6.L120.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN10_MPL41] = 'hev1.2.6.L123.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN10_MPL50] = 'hev1.2.6.L150.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN10_MPL51] = 'hev1.2.6.L153.B0';

    // HEVC Temporal layer support
    videoProfilesMap[videoProfile$HEVC_MAIN_MPL30_31_tl] = 'hev1.1.6.L90.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN_MPL31_40_tl] = 'hev1.1.6.L93.B0';    
    videoProfilesMap[videoProfile$HEVC_MAIN_MPL40_41_tl] = 'hev1.1.6.L120.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN_MPL50_51_tl] = 'hev1.1.6.L150.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN10_MPL30_31_tl] = 'hev1.2.6.L90.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN10_MPL31_40_tl] = 'hev1.2.6.L93.B0';    
    videoProfilesMap[videoProfile$HEVC_MAIN10_MPL40_41_tl] = 'hev1.2.6.L120.B0';
    videoProfilesMap[videoProfile$HEVC_MAIN10_MPL50_51_tl] = 'hev1.2.6.L150.B0';

    // Dolby Vision Support
    videoProfilesMap[videoProfile$DV_MAIN10_MPL30] = DV_Codec;
    videoProfilesMap[videoProfile$DV_MAIN10_MPL31] = DV_Codec;
    videoProfilesMap[videoProfile$DV_MAIN10_MPL40] = DV_Codec;
    videoProfilesMap[videoProfile$DV_MAIN10_MPL41] = DV_Codec;
    videoProfilesMap[videoProfile$DV_MAIN10_MPL50] = DV_Codec;
    videoProfilesMap[videoProfile$DV_MAIN10_MPL51] = DV_Codec;

    // Audio support
    audioProfilesMap[audioProfile$HEAAC] = 'mp4a.40.2';
    audioProfilesMap[audioProfile$DDPLUS] =  'ec-3';
    audioProfilesMap[audioProfile$HEAAC_DRM] = 'mp4a.40.5';

    filteredProfiles = allProfiles.filter(function(profile) {
        var map = type === 'video' ? videoProfilesMap : audioProfilesMap;
        var typeString = String$format('{0}/mp4;codecs="{1}"',type,videoProfilesMap[profile]);
        var result = MediaSource.isTypeSupported(typeString);
        return result;
    });
    return filteredProfiles;
}

/**
* Don't filter any profiles;
*/
function DeviceCapabilities$AllProfiles(allProfiles) {
    return allProfiles;
}

function DeviceCapabilities$SelectSourceBufferType(type) {
    var filteredTypes;
    var typeStringTemplate = '{0}/mp4;codecs="{1}"';
    var videoSourceBufferTypes = [
        'avc1.640028',      // H264
        'hev1.2.6.L153.B0', // H265
        'dvhe.01000000'     // Dolby Vision
    ];

    var audioSourceBufferTypes = [
        'mp4a.40.2',    // AAC
        'ec-3'          // Dolby Digial Plus
    ];

    var bufferedTypes = type === 'video' ? videoSourceBufferTypes : audioSourceBufferTypes;
    filteredTypes = bufferedTypes.filter(function(mediaType){
        var typeString = String$format('{0}/mp4;codecs="{1}"',type,mediaType);
        return MediaSource.isTypeSupported(typeString);
    });
    return String$format(typeStringTemplate,type,filteredTypes.join(', '));
}

/**
*  supports HD
*/
function DeviceCapabilities$canDecode264() {
    return MediaSource.isTypeSupported(MEDIA_TYPE_VIDEO_H264);
}

/**
*  supports UltraHD
*/
function DeviceCapabilities$canDecode265() {
    return MediaSource.isTypeSupported(MEDIA_TYPE_VIDEO_H265);    
}

/**
*  supports DV_HDR
*/
function DeviceCapabilities$canDecodeDV() {
    return MediaSource.isTypeSupported(MEDIA_TYPE_VIDEO_DV);        
}

/**
*  supports UHDA_HDR
*/
function DeviceCapabilities$canDecodeUHDA_HDR() {
    return false;
}


function DeviceCapabilities$supportsHD() {

    return DeviceCapabilities$canDecode264() && Array$isASubsetOf(videoProfiles$HDSet.concat(videoProfiles$SDSet), config.videoProfiles);
} 

function DeviceCapabilities$supportsUltraHD() {
    return DeviceCapabilities$canDecode265() &&
    (Array$isASubsetOf(videoProfiles$UHDSet, config.videoProfiles) ||  Array$isASubsetOf(videoProfiles$UHD_Main10Set, config.videoProfiles));

} 
function DeviceCapabilities$supportsDV_HDR() {
    return DeviceCapabilities$canDecodeDV() &&  Array$isASubsetOf(videoProfiles$DV_no_HFR_4k_Set, config.videoProfiles);
}


function DeviceCapabilities$supports3D() {
    return false;
} 

function DeviceCapabilities$supportsUHDA_HDR() {
    return false;
} 
function DeviceCapabilities$isCastTV() {
    return DEVICE_CATEGORY === 'casttv';
}


    // >>>>>>>>>>>>>>>> BEGIN PARALLEL <<<<<<<<<<<<<<<<

// -- player/ParallelMediaDownloader.js
/**
* @constructor
*/
function ParallelMediaDownloader(playback) {
    var _log = new playback.log.CategoryLog('ParallelMediaDownloader'),
        _httpPlayback = playback.httpPlayback,
        _heuristics = playback.heuristics,
        _bandwidthMeter = playback.bandwidthMeter,
        _mediaBuffer = playback.mediaBuffer,
        _maxConcurrentDownloads = config.maxParallelConnections,
        _downloaderStateFactory,
        _currentDownloaderState,
        _updateMonitorTimeMs = config.parallelDownloaderUpdateFrequencyMs,
        _updateMonitorId,
        _updateThrottle = new Throttle(config.parallelDownloaderUpdateThrottleFrequencyMs),
        _downloaderContext = {
            mediaDownloader: this,
            downloadJobManager: {},
            failureMonitor: new DownloadFailureMonitor(config.selectCdnDownloadRetryCountBeforeCdnSwitch)
        },
        checkForSafeBufferLevel = _checkForSafeBufferLevel;

    playback.downloaderContext = _downloaderContext;
    _downloaderContext.downloadJobManager = _createDownloadManager(config.parallelDownloadManagerType);
    _downloaderContext.cdnTestReason = 'startup';

    debug$assert(_httpPlayback);
    debug$assert(_heuristics);
    debug$assert(_bandwidthMeter);
    debug$assert(_mediaBuffer);
    _init();

    // Public API
    this.changeDownloaderState = _changeDownloaderState;
    this.howLongToNormalState = _howLongToNormalState;

    /**
    * Clear download jobs that are either planned or in progress (by aborted the download). A shouldAbort function
    * can be optionally passed in which will on abort any in progress jobs that pass whatever test the function specifies. 
    * Note this only applies to inProgress jobs, waiting jobs are unconditionally cleared.
    * 
    * @param {Function} shouldAbortFunction() a function that should return true if a job should be excluded.
    */
    this.clearInProgressDownloads = _clearInProgressDownloads;

    this.getCurrentStateName = _getCurrentStateName;

    this.getMaxProgress = _getMaxProgress;

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _getCurrentStateName() {
        return _currentDownloaderState && _currentDownloaderState.getName() || 'null';
    }

    function _getMaxProgress() {
        return _currentDownloaderState.getMaxProgress();
    }
    function _init() {
        _downloaderStateFactory = new DownloaderStateFactory(playback, _downloaderContext);

        if (config.initialBitrateSelectionAlgorithm == 'carrera') {
            DEBUG && _log.trace('Initial Bitrate Selection Algorithm is Carrera.');
            _changeDownloaderState(_downloaderStateFactory.initBitrateSelectionState, "using carrera for initial playback.");
        } else {
            _changeDownloaderState(_downloaderStateFactory.cdnSelectionState, "select first CDN before playback.");
        }

        _updateMonitorId = setInterval(_update, _updateMonitorTimeMs);

        var jobCompletionHandler = function _jobCompletedHandler() {
            _update();
        };
        _downloaderContext.downloadJobManager.addEventListener(DownloadJobManager$JobCompleted, jobCompletionHandler);

        playback.addEventListener(Playback$closing, function () {
            clearInterval(_updateMonitorId);
            _updateThrottle.dispose();
            http.removeEventListener(http$onlinechanged, _httpOnlineChanged);
            _downloaderContext.downloadJobManager.removeEventListener(DownloadJobManager$JobCompleted, jobCompletionHandler);
            _downloaderContext.downloadJobManager.abortJobs();
        });

        //-- start updating and listening to media playback progress
        _update();

        playback.addEventListener(Playback$throttledMediaTimeChanged, function () {
            // do not update inline of a media time change
            // do so we handle [throttledMediaTimeChanged] followed with [repositioned] properly
            _update();
        });

        playback.addEventListener(Playback$bufferUnderrun, function (args) {
            // presenter ran out of buffer... 
            if (args.cause == Playback$BUFFER_UNDERRUN_CAUSE_NETWORK) {
                // if it was because downloader didn't keep up, go into buffering state
                _downloaderContext.downloadJobManager.setActiveWorkers(1);
                checkForSafeBufferLevel = _checkForSafeBufferLevel;
                _currentDownloaderState.onBufferUnderrun();
                _update();
            }
        });

        playback.addEventListener(Playback$repositioned, function () {
            _currentDownloaderState.onSeek();
            _update();
        });

        playback.addEventListener(Playback$tryRecoverFromStall, function() {
            _currentDownloaderState.tryRecoverFromStall();
        });

        http.addEventListener(http$onlinechanged, _httpOnlineChanged);
    }
    function _httpOnlineChanged() {
        if (http$isOnLine()) {
            _currentDownloaderState && _currentDownloaderState.tryRecoverFromStall();
        }
    }
    function _clearInProgressDownloads(shouldAbortFunction) {
        _downloaderContext.downloadJobManager.clearJobs();
        _downloaderContext.downloadJobManager.abortJobs(shouldAbortFunction);
    }
    function _createDownloadManager(type) {
        if (type === "subchunk") {
            return new SubChunkDownloadJobManager(_maxConcurrentDownloads, _maxConcurrentDownloads, playback);
        }
        return new DownloadJobManager(_maxConcurrentDownloads, 1, playback);
    }
    // Change to a new media downloader state.
    function _changeDownloaderState(newState, reason) {
        try {
           _log.trace(
                String$format("transitioning from {0} to {1}, reason: {2}",
                    _currentDownloaderState && _currentDownloaderState.getName() || 'null',
                    newState.getName(),
                    reason
                )
            );
            debug$assert(newState);
            if (_currentDownloaderState) {
                _currentDownloaderState.exitState();
            }
            _currentDownloaderState = newState;
            _currentDownloaderState.enterState();
            _update();            
        }
        catch (e) {
            _log.error("There was an error changing downloader state, e: ", e);
        }

    }

    function _howLongToNormalState() {
        return _currentDownloaderState.howLongToNormalState();
    }

    function _update() {
        _updateThrottle.schedule(_innerUpdate);
    }
    // The main update function.
    function _innerUpdate() {
        if (playback.state.value == Playback$STATE_NORMAL) {
            checkForSafeBufferLevel();
            _currentDownloaderState.update();
        }
    }

    function _checkForSafeBufferLevel() {
        var safeBufferLevel = config.parallelSafeBufferThreshhold;
        if (_mediaBuffer.getNormalizedBufferLength() > safeBufferLevel) {
            _downloaderContext.downloadJobManager.setActiveWorkers(_maxConcurrentDownloads);
            checkForSafeBufferLevel = NOOP;
        }
    }
};




// -- player/ParallelMediaDownloaderStates.js
/**
* @constructor
* @param {Object} playback the top level playback object
*/
function BaseState(playback) {
    var _context = playback.downloaderContext,
        _activeHeaderDownload,
        _downloadJobManager = _context.downloadJobManager,
        _mediaDownloader = _context.mediaDownloader,
        _stateFactory = _context.downloaderStateFactory,
        _startBufferingTime;

    //----------------- Public API
    this.getName = function() {
         return 'BaseState';
    };

    // Designed to be used by derived classes with call().
    this.init = function _init() {
        this.log = new playback.log.CategoryLog(this.getName());
    };
    this.init();

    this.getMaxProgress = function _getMaxProgress() {
        return 0.99;
    };

    this.enterState = NOOP;

    this.exitState = NOOP;

    this.update = NOOP;

    this.tryRecoverFromStall = NOOP;

    this.onBufferUnderrun = function _onBufferUnderun() {
        playback.bufferingState.set(BufferingState$BUFFERING);
        _mediaDownloader.changeDownloaderState(_stateFactory.rebufferingState, "buffer underrun");
    };

    this.onSeek = function _onSeek() {
        _mediaDownloader.changeDownloaderState(_stateFactory.seekingState, "user seek");
    };

    this.getActiveHeaderDownload = function _getActiveHeaderDownload() {
        return _activeHeaderDownload;
    };

    this.howLongToNormalState = function _howLongToNormalState() {
       // This should never be called.
       return 0;
    };

    /**
    * Transition to CDN selection state if CDN failure condition met.
    * @return {boolean} returns true if selecting CDNs due to failure, false otherwise.
    */
    this.selectCDNOnRetryFailure = function _selectCDNOnRetryFailure() {
        if (_context.failureMonitor.shouldPerformCDNSelect(playback.cdn.value)) {
            _context.cdnTestReason = 'dlfail';
            _context.failedDownloadRetryIndex = 0;
            _mediaDownloader.changeDownloaderState(_stateFactory.cdnSelectionState, "download failures");
            return true;
        }
        return false;
    };

    //----------- Worker Methods
    this.downloadRecommendedChunk = function _downloadRecommendedChunk(chunkToDownload, recommendation) {
        _downloadJobManager.enqueue({
            chunk: chunkToDownload, recommendation: recommendation
        });
    };

    this.downloadHeader = function _downloadHeader(stream) {
        if (_activeHeaderDownload && _activeHeaderDownload.stream == stream) {
            // already downloading that stream
            return;
        }
        if (stream.headerDownloadAttempted) {
            // we already attempted to download that stream, and most likely failed... or timedout
            // TODO: should we retry?
            return;
        }
        this.log.trace('Downloading header', stream);

        var headerDownload = {
            stream: stream,
            startedOn: clock$getTime()
        };
        _activeHeaderDownload = headerDownload;

        function _onHeaderDownloadComplete() {
            // wrap up the download
            if (_activeHeaderDownload == headerDownload) {
                _activeHeaderDownload = null;
            }
            headerDownload = null;
        }

        stream.downloadHeader(_onHeaderDownloadComplete);
        setTimeout(_onHeaderDownloadComplete, config.headerDownloadTimeout);
    };

    // Using the chunk to be downloaded and the recommended stream to download 
    // from heuristics return the chunk info.
    this.getChunkInfoForChunk = function _getChunkInfoForChunk(chunkToDownload, recommendation) {
        if (chunkToDownload.type === CadmiumMediaStream$VIDEO) {
            // if we need more video, update the video stream based on recommendation from heuristics
            var stream = recommendation.videoStream;
        } else if (chunkToDownload.type == CadmiumMediaStream$AUDIO) {
            stream = playback.audioStream.value;
        } else {
            debug$assert(false);
            return undefined;
        }

        // return chunkInfo.
        return stream.header.chunkInfos[chunkToDownload.index];
    };

    this.calculateTimeToNormalFromElapsed = function _calculateTimeToNormalFromElapsed() {
        var delta = clock$getTime() - _context.startBufferingTime;

        return config.maxBufferingTimeInMilliseconds - delta;
    };

    this.resetStartOfBufferingTime = function _resetStartOfBufferingTime() {
        _context.startBufferingTime = clock$getTime();
    };
}

/**
* @constructor
* @extends BaseState
*/
function PlayingState(playback) {
    var _base = new BaseState(playback),
        _context = playback.downloaderContext,
        _heuristics = playback.heuristics,
        _mediaBuffer = playback.mediaBuffer,
        _downloadJobManager = _context.downloadJobManager,
        _checkAbortDownloadThrottle = new Throttle(1000);

    mixIn(this, _base);

    _context.cdnTestReason = "startup";

    //----------------- Public API
    this.getName = function() {
         return 'PlayingState';
    };

    this.enterState = function enterState() {
        _context.failureMonitor.clearFailures();
        playback.bufferingState.set(BufferingState$NORMAL);

        _context.downloadJobManager.setEnabled(true);
    };

    // update()
    this.update = function update() {
        // Check if we should continue processing based on playback states
        if (playback.state.value != Playback$STATE_NORMAL || playback.presentingState.value == PresentingState$ENDED)
            return;

        // Heuristics may inform us that we need to abort downloads on occasion,
        // we need to poll it periodically to detect this.
        _checkAbortDownloadThrottle.schedule(abortDownloadsIfNeeded);

        // Check if media download URLs are still good.
        if (playback.manifestWillExpireOn && playback.manifestWillExpireOn <= clock$getTime()) {
            // Media URLs are expired, we can't start new downloads
            if (playback.bufferingState.value != BufferingState$NORMAL) {
                // if we are in buffering state... we can never actually buffer
                // so induce a playback failure
                playback.closeWithError(new PlayerError(ErrorCodes.AUTHORIZATION_EXPIRED));
            }
            // otherwise, just don't do anything
            return;
        }

        // make sure the current audio and video streams have headers
        // missing headers are most likely caused by track changes
        if (!playback.audioStream.value.header) {
            this.downloadHeader(playback.audioStream.value);
            // exit, since we can't do much without a header
            return;
        }

        if (!playback.videoStream.value.header) {
            this.downloadHeader(playback.videoStream.value);
            // exit, since we can't do much without a header
            return;
        }

        if (this.selectCDNOnRetryFailure()) {
            return;
        }

        // Do we have anything we need to download?
        var chunkToDownload = _mediaBuffer.getNextChunkToDownload();

        var activeHeaderDownload = this.getActiveHeaderDownload();
        
        // also don't start the download if there is an active header download for a higher bitrate stream
        // Note: we do this for higher bitrate streams, so we switch up to it once we get the header
        if (activeHeaderDownload &&
            activeHeaderDownload.stream.type == CadmiumMediaStream$VIDEO &&
            activeHeaderDownload.stream.bitrate > playback.videoStream.value.bitrate) {
            return;
        }
        if (chunkToDownload && _context.downloadJobManager.needsWork()) {
            var recommendation = _heuristics.getBufferingRecommendation();
            var chunkInfo = this.getChunkInfoForChunk(chunkToDownload, recommendation);

            if (_mediaBuffer.tryMakeRoom(chunkInfo,true)) {
                if (playback.bufferingState.value == BufferingState$NORMAL) {
                    this.downloadRecommendedChunk(chunkToDownload, recommendation);
                }
            }
            // Get a video header if heuristics recommends we do so
            if (!activeHeaderDownload && recommendation && recommendation.getHeaderFor) {
                this.downloadHeader(recommendation.getHeaderFor);
            }
        }
    };

    function abortDownloadsIfNeeded() {
        if (_heuristics.shouldAbortDownloads()) {
            _downloadJobManager.clearJobs();
            _downloadJobManager.abortJobs();
        }
    }
}

/**
* @constructor
* @extends BaseState
*/
function BufferingState(playback) {
    var _base = new BaseState(playback),
        _context = playback.downloaderContext,
        _mediaDownloader = _context.mediaDownloader,
        _downloadJobManager = _context.downloadJobManager,
        _mediaBuffer = playback.mediaBuffer,
        _mediaPresenter = playback.mediaPresenter,
        _bandwidthMeter = playback.bandwidthMeter,
        _firstPrebufferComplete,
        _stateFactory = _context.downloaderStateFactory,
        _heuristics = playback.heuristics,
        _futureDownloadsEta = MAX_MEDIA_TIME, // prevents us from over promising
        _self = this;

    mixIn(this, _base);
    //----------------- Public API
    this.howLongToNormalState = function() {
        if (config.maxBufferingTimeInMilliseconds) {
            return this.calculateTimeToNormalFromElapsed();
        }
        return _calculateTimeToNormalFromDownloads();
    }

    this.getName = function() {
         return 'BufferingState';
    };

    this.enterState = function enterState() {
        playback.bufferingState.set(BufferingState$BUFFERING);
        _context.downloadJobManager.setEnabled(true);
    };

    // update()
    this.update = function update() {
        // Handle cases where the network (usually wifi) becomes unavailable.
        if (!http$isOnLine()) {
            playback.bufferingState.set(BufferingState$STALLED);
        }
        else if (playback.bufferingState.value == BufferingState$STALLED) {
            playback.bufferingState.set(BufferingState$BUFFERING);
        }
        // make sure the current audio and video streams have headers
        // missing headers are most likely caused by track changes
        if (!playback.audioStream.value.header) {
            this.downloadHeader(playback.audioStream.value);
            // exit, since we can't do much without a header
            return;
        }

        if (!playback.videoStream.value.header) {
            this.downloadHeader(playback.videoStream.value);
            // exit, since we can't do much without a header
            return;
        }

        if (this.selectCDNOnRetryFailure()) {
            return;
        }

        // Do we have anything we need to download?
        var chunkToDownload = _mediaBuffer.getNextChunkToDownload();

        // try to exit buffering mode based on recommendation from heuristics
        var recommendation = _heuristics.getPrebufferingRecommendation();

        // We cannot exit if the decoder does not have enough media.
        if (_mediaPresenter.decoderHasEnoughData()) {
            if (recommendation.needMoreAudioMilliseconds <= 0 && recommendation.needMoreVideoMilliseconds <= 0) {
                _exitBufferingState('Heuristics');
                return;
            }

            if (config.maxBufferingTimeInMilliseconds && this.calculateTimeToNormalFromElapsed() <= 0) {
                _exitBufferingState('maxBufferingTime');
                return;
            }

            // also, we have to exit buffering mode if buffer is full
            if (!chunkToDownload && _mediaBuffer.isBufferFull()) {
                _exitBufferingState('Full');
                return;
            }
        }

        _futureDownloadsEta = _getEstimatedDownloadTime(
                  chunkToDownload,
                  recommendation.needMoreAudioMilliseconds,
                  recommendation.needMoreVideoMilliseconds
        );

        var activeHeaderDownload = this.getActiveHeaderDownload();
        // also don't start the download if there is an active header download for a higher bitrate stream
        // Note: we do this for higher bitrate streams, so we switch up to it once we get the header
        if (activeHeaderDownload &&
            activeHeaderDownload.stream.type == CadmiumMediaStream$VIDEO &&
            activeHeaderDownload.stream.bitrate > playback.videoStream.value.bitrate) {
            return;
        }

        if (chunkToDownload && _context.downloadJobManager.needsWork()) {
            if (!recommendation.videoStream.header) {
                this.downloadHeader(recommendation.videoStream);
                return;
            }
            var chunkInfo = this.getChunkInfoForChunk(chunkToDownload, recommendation);

            if (_mediaBuffer.tryMakeRoom(chunkInfo, true)) {
            this.downloadRecommendedChunk(chunkToDownload, recommendation);
            }
        }

        // Get a video header if heuristics recommends we do so
        if (!activeHeaderDownload && recommendation && recommendation.getHeaderFor) {
            _self.downloadHeader(recommendation.getHeaderFor);
        }
    };

    //----------------- Private Implementation

    function _calculateTimeToNormalFromDownloads() {
        return _futureDownloadsEta;
    }

    function _exitBufferingState(causeForLog) {
        _self.log.trace("in _exitBufferingState()");
        if (playback.bufferingState.value != BufferingState$NORMAL) {
            _self.log.trace('Buffering complete', { 'Cause': causeForLog }, _mediaBuffer);
            if (!_firstPrebufferComplete) {
                _firstPrebufferComplete = true;
                playback.notifyMilestone('pb');
            }
        }
        _mediaDownloader.changeDownloaderState(_stateFactory.playingState, "exiting buffering: "+causeForLog);
    }

    function _getEstimatedDownloadTime(chunkToDownload, audioMilliseconds, videoMilliseconds) {
        // gets how long will it take to download given amount of audio and video
        // excluding the chunkToDownload download time
        var audioChunk = _mediaBuffer.getNextAudioChunkThatNeedsMedia(true),
            videoChunk = _mediaBuffer.getNextVideoChunkThatNeedsMedia(true),
            audioChunkInfos = playback.audioStream.value.header.chunkInfos,
            videoChunkInfos = playback.videoStream.value.header.chunkInfos,
            downloadTime = 0;

        while (audioMilliseconds > 0 && audioChunk) {
            if (!audioChunk.media && audioChunk != chunkToDownload) {
                downloadTime += _bandwidthMeter.calculateDownloadTime(audioChunkInfos[audioChunk.index].length);
            }
            audioMilliseconds -= audioChunk.duration;
            audioChunk = audioChunk.next;
        }

        while (videoMilliseconds > 0 && videoChunk) {
            if (!videoChunk.media && videoChunk != chunkToDownload) {
                downloadTime += _bandwidthMeter.calculateDownloadTime(videoChunkInfos[videoChunk.index].length);
            }
            videoMilliseconds -= videoChunk.duration;
            videoChunk = videoChunk.next;
        }

        return downloadTime;
    }
}

/**
* @constructor
* @extends BaseState
*/
function SeekingState(playback) {
    var _base = new BaseState(playback),
        _self = this,
        _context = playback.downloaderContext,
        _mediaDownloader = _context.mediaDownloader,
        _downloadJobManager = _context.downloadJobManager,
        _heuristics = playback.heuristics,
        _mediaBuffer = playback.mediaBuffer,
        _stateFactory = _context.downloaderStateFactory;

    mixIn(this, _base);

    //----------------- Public API
    this.getName = function() {
        return 'SeekingState';
    };

    this.enterState = function enterState() {
        _downloadJobManager.clearJobs();
        _downloadJobManager.abortJobs();
    };

    this.update = function update() {
        // presenter repositioned...
        // do we need to enter buffering mode?
        var recommendation;
        if (playback.audioStream.value.header && playback.videoStream.value.header) {
            // if we switch tracks, we won't have headers to run heuristics
            recommendation = _heuristics.getPrebufferingRecommendation();
        }

        if (recommendation &&
            recommendation.needMoreAudioMilliseconds <= 0 &&
            recommendation.needMoreVideoMilliseconds <= 0 &&
            playback.bufferingState.value !== BufferingState$STALLED) {
            this.log.trace('Repositioned without rebuffer', _mediaBuffer);
            _mediaDownloader.changeDownloaderState(_stateFactory.playingState, "no buffering required during seek.");
        } else {
            this.log.trace('Repositioned, buffering', _mediaBuffer);
            _self.resetStartOfBufferingTime();             
            _mediaDownloader.changeDownloaderState(_stateFactory.bufferingState,"buffering required during seek.");
        }
    };
}

/**
* @constructor
* @extends BaseState
*/
function RebufferingState(playback) {
    var _base = new BaseState(playback),
        _self = this,
        _context = playback.downloaderContext,
        _mediaDownloader = _context.mediaDownloader,
        _downloadJobManager = _context.downloadJobManager,
        _stateFactory = _context.downloaderStateFactory;

    mixIn(this, _base);

    //----------------- Public API
    this.getName = function () {
        return 'RebufferingState';
    };

    this.enterState = function enterState() {
        _downloadJobManager.clearJobs();
        _downloadJobManager.abortJobs();
    };

    this.update = function update() {
        _context.cdnTestReason = "buffer underrun";
        _mediaDownloader.changeDownloaderState(_stateFactory.cdnSelectionState, "CDN selection due to rebuffer.");
    };
}

/**
* @constructor
* @extends BaseState
*/
function CDNSelectionState(playback) {
    var _base = new BaseState(playback),
        _context = playback.downloaderContext,
        _downloadJobManager = _context.downloadJobManager,
        _activeTask,
        _userSeekedDuringCDNSelection,
        _failedCDNSelectBackoffs = config.failedDownloadRetryWaits,
        _failedCDNSelectCount = 0,
        _cooldownThrottle = new Throttle(1),
        _self = this;

    if (config.initialBitrateSelectionAlgorithm === 'carrera') {
        _self.carrera = new CarreraBitrateSelector(playback);
        _self.streams = _createStreamList();
    }

    mixIn(this, _base);
    //----------------- Public API
    this.getName = function() {
         return 'CDNSelectionState';
    };

    this.howLongToNormalState = function _howLongToNormalState() {
        var eta = _downloadJobManager.getTotalDownloadTimeOfJobs() || 0;
        if (_activeTask) {
            var taskEta = _activeTask.howLongToComplete && _activeTask.howLongToComplete();
            if (taskEta) {
                eta = Math$max(taskEta, eta);
            }
        }
        
        return Math$max(eta, this.calculateTimeToNormalFromElapsed());
    };

    this.enterState = function enterState() {
        _cooldownThrottle.setCooldown(1);
        _failedCDNSelectCount = 0;
        _context.failureMonitor.clearFailures();
        _userSeekedDuringCDNSelection = false;
        _self.resetStartOfBufferingTime();
    };

    this.exitState = function exitState() {
        _cooldownThrottle.dispose();
        _activeTask = null;
    };

    this.tryRecoverFromStall = function _tryRecoverFromStall() {
        playback.bufferingState.value == BufferingState$STALLED &&
        http$isOnLine() &&
        _cooldownThrottle.scheduleImmediate(_simpleUpdate);
    };

    this.update = config.useCDNExponentialBackoff ? _exponentialBackoffUpdate : _simpleUpdate;

    function _exponentialBackoffUpdate() {
        DEBUG && _self.log.trace("calling _exponentialBackoffUpdate");
        if (http$isOnLine()) {
            if (config.asynchronousCDNSelection || _cooldownThrottle.getCooldown() > 1)   {
                _cooldownThrottle.schedule(_simpleUpdate);
            }
            else {
                _simpleUpdate();
            }

        } else {
            this.checkForStall();
        }
    }

    this.onSeek = function onSeek() {
        _userSeekedDuringCDNSelection = true;
    };

    this.checkForStall = function () {
        if (playback.bufferingState.value == BufferingState$BUFFERING) {
            playback.bufferingState.set(BufferingState$STALLED);
        }
    };
    // this.getMaxProgress = function _getMaxProgress() {
    //     return 0.50;
    // };
    //----------------- Private Implementation
    function _simpleUpdate() {
        DEBUG && _self.log.trace('in CDNSelectionState._simpleUpdate(), _activeTask = '+_activeTask);
         if (!_activeTask) {
             _activeTask = { type: MediaDownloader$TASK_CDNSELECTION };
             _startSelectCdnTask(_context.cdnTestReason);
         }
     }

    function _startSelectCdnTask(testReason) {
        _self.log.trace('Selecting a CDN');
        var r;

        // only allow Carrera at start up
        if (testReason === 'startup' && config.initialBitrateSelectionAlgorithm === 'carrera') {
            r = selectCdnBasedOnCarrera(playback, testReason, _self.carrera, _self.streams, _onCdnSelectionCompleteCarrera);
            if (_activeTask) {
                _activeTask.howLongToComplete = r && r.howLongToComplete;
            }
        } else {
            switch (config.selectCdnType) {
                case 'bandwidth':
                    r = selectCdnBasedOnBandwidth(playback, testReason, _onCdnSelectionComplete);
                    if (_activeTask) {
                        _activeTask.howLongToComplete = r && r.howLongToComplete;
                    }
                    break;
                default:
                    selectCdn(playback, testReason, _onCdnSelectionComplete);
                    break;
            }
        }
    }

    function _onCdnSelectionComplete (result) {
        if (result.success) {
            playback.cdn.set(result.selectedCdn);
            _self.log.trace("cdn selected: ", { 'name': result.selectedCdn.name });
            _context.cdnTestReason = undefined;
            if (!_userSeekedDuringCDNSelection) {
                if (playback.bufferingState.value == BufferingState$BUFFERING || playback.bufferingState.value == BufferingState$STALLED) {
                    _context.mediaDownloader.changeDownloaderState(_context.downloaderStateFactory.bufferingState, "underrun, buffer media before resume.");
                } else {
                    _context.mediaDownloader.changeDownloaderState(_context.downloaderStateFactory.playingState, "buffer has media, resume playback");
                }
            }
        } else {
            _self.log.trace("cdn selection failed!");
            _self.checkForStall();
            if (playback.bufferingState.value == BufferingState$STALLED) {
                // if we've failed to select a CDN and we're buffering try again using exponential backoff.
                _cooldownThrottle.setCooldown(_failedCDNSelectBackoffs[_failedCDNSelectCount]);
                _failedCDNSelectCount = _failedCDNSelectCount < _failedCDNSelectBackoffs.length - 1 ? _failedCDNSelectCount + 1 : _failedCDNSelectBackoffs.length - 1;
            }
            _activeTask = null;
        }

        if (_userSeekedDuringCDNSelection) {
            _context.mediaDownloader.changeDownloaderState(_context.downloaderStateFactory.seekingState, "user seek");
        }
    }

    function _onCdnSelectionCompleteCarrera (result) {
        if (result.success) {
            playback.cdn.set(result.selectedCdn);
            _self.log.trace("cdn selected: ", { 'name': result.selectedCdn.name });
            _context.cdnTestReason = undefined;
            _context.usingCarrera = result.usingCarrera;
        } else {
            _self.checkForStall();
            if (playback.bufferingState.value == BufferingState$STALLED) {
                // if we've failed to select a CDN and we're buffering try again using exponential backoff.
                _cooldownThrottle.setCooldown(_failedCDNSelectBackoffs[_failedCDNSelectCount]);
                _failedCDNSelectCount = _failedCDNSelectCount < _failedCDNSelectBackoffs.length - 1 ? _failedCDNSelectCount + 1 : _failedCDNSelectBackoffs.length - 1;
            }
            _activeTask = null;
        }

        if (_userSeekedDuringCDNSelection) {
            _context.mediaDownloader.changeDownloaderState(_context.downloaderStateFactory.seekingState, "user seek");
        }
    }

    function _createStreamList() {
        var streams = playback.createFilteredVideoStreamList(),
            streamsLength = streams.length;
        CadmiumMediaStreams$addMethodsToArray(streams);
        for (var i = 0; i < streamsLength; i++) {
            streams[i].lower = streams[i - 1];
            streams[i].higher = streams[i + 1];
        }
        return streams;
    }
}

/**
 * @constructor
 * @extends CDNSelectionState
 *
 * Initial state when Carrera is enabled.
 * It combines CDN selection and prebuffering (if needed).
 * Transitions straight to Playing State when enough audio/video is downloaded.
 */
function InitBitrateSelectionState(playback) {
    var _cdnBase = new CDNSelectionState(playback),
        _context = playback.downloaderContext,
        _mediaDownloader = _context.mediaDownloader,
        _mediaBuffer = playback.mediaBuffer,
        _mediaPresenter = playback.mediaPresenter,
        _bandwidthMeter = playback.bandwidthMeter,
        _heuristics = playback.heuristics,
        _stateFactory = _context.downloaderStateFactory,
        _firstPrebufferComplete,
        _futureDownloadsEta,
        _useHeuristics = false,
        _vbitrate,
        _self = this;

    // only set to true once we have successfully used historical data to pick a video bitrate
    _context.usingCarrera = false;

    mixIn(this, _cdnBase);
    //----------------- Public API
    this.getName = function() {
        return 'InitBitrateSelectionState';
    };

    this.exitState = function exitState() {
        playback.usingCarrera = _context.usingCarrera;
        playback.carreraStats = _self.carrera.getExpBandwidthObject();
    };

    this.update = function update() {
        if (!playback.cdn.value) {
            _cdnBase.update.apply(_self);
        } else {
            _bufferingUpdate();

        }
    };

    //----------------- Private Implementation
    function _bufferingUpdate() {
        // make sure the current audio and video streams have headers
        // missing headers are most likely caused by track changes
        if (!playback.audioStream.value.header) {
            _self.downloadHeader(playback.audioStream.value);
            // exit, since we can't do much without a header
            return;
        }

        if (!playback.videoStream.value.header) {
            _self.downloadHeader(playback.videoStream.value);
            // exit, since we can't do much without a header
            return;
        }

        if (_self.selectCDNOnRetryFailure()) {
            return;
        }

        // if we are using Carrera, exit after 2 chunks of video
        // check that we have enough audio and 2 chunks of video for Carrera
        var needMoreAudioMilliseconds =
            (_mediaBuffer.getAudioBufferLength() >= config.audioChunkSizeMilliseconds) ?
                0 : (config.audioChunkSizeMilliseconds - _mediaBuffer.getAudioBufferLength());
        var needMoreVideoMilliseconds =
            (_mediaBuffer.getVideoBufferLength() >= config.carreraMediaMillisecondsToDownload) ?
                0 : ( config.carreraMediaMillisecondsToDownload - _mediaBuffer.getVideoBufferLength());

        if (_context.usingCarrera) {
            if (needMoreVideoMilliseconds === 0 && needMoreAudioMilliseconds === 0 && _mediaPresenter.decoderHasEnoughData()) {
                _exitBufferingState('Carrera');
                return;
            }
        }

        // We need to download more video before starting playback
        // If CDN selection only got audio, we need to try using Carrera now, for the first video chunk
        if (!_vbitrate && !_useHeuristics) {
            _vbitrate = _self.carrera.getInitialBitrate(playback.cdn.value.location.id);
        }
        // Historical had no data for Carrera, switch to heuristics
        _useHeuristics = !_vbitrate;

        // Do we have anything we need to download?
        var chunkToDownload = _mediaBuffer.getNextChunkToDownload();
        var recommendation;

        // fall-back
        if (_useHeuristics) {
            recommendation = _heuristics.getPrebufferingRecommendation(true);

            // prebuffering check for default code path
            if (recommendation.needMoreVideoMilliseconds <=0 && recommendation.needMoreAudioMilliseconds <=0 && _mediaPresenter.decoderHasEnoughData()) {
                _exitBufferingState('Heuristics');
                return;
            }
        } else {
            _context.usingCarrera = true;
            var streamToDownload = _self.streams.firstBelow(_vbitrate + 1, true),
                betterVideoStream = _self.streams.firstAbove(_vbitrate + 1, false);

            recommendation = {
                videoStream: streamToDownload,
                getHeaderFor: betterVideoStream,
                needMoreAudioMilliseconds: needMoreAudioMilliseconds,
                needMoreVideoMilliseconds: needMoreVideoMilliseconds
            };
        }

        _futureDownloadsEta = _getEstimatedDownloadTime(
            chunkToDownload,
            recommendation.needMoreAudioMilliseconds,
            recommendation.needMoreVideoMilliseconds
        );

        if (chunkToDownload && _context.downloadJobManager.needsWork()) {
            var chunkInfo = _self.getChunkInfoForChunk(chunkToDownload, recommendation);
            if (_mediaBuffer.tryMakeRoom(chunkInfo, true)) {
                _self.downloadRecommendedChunk(chunkToDownload, recommendation);
            }
        }
    }

    function _exitBufferingState(causeForLog) {
        _self.log.trace("in _exitBufferingState()");
        if (playback.bufferingState.value != BufferingState$NORMAL) {
            _self.log.trace('Buffering complete', { 'Cause': causeForLog }, _mediaBuffer);
            if (!_firstPrebufferComplete) {
                _firstPrebufferComplete = true;
                playback.notifyMilestone('pb');
            }
        }
        _mediaDownloader.changeDownloaderState(_stateFactory.playingState, "exiting buffering: " + causeForLog);
    }

    function _getEstimatedDownloadTime(chunkToDownload, audioMilliseconds, videoMilliseconds) {
        // gets how long will it take to download given ammount of audio and video
        // excluding the chunkToDownload download time
        var audioChunk = _mediaBuffer.getNextAudioChunkThatNeedsMedia(true),
            videoChunk = _mediaBuffer.getNextVideoChunkThatNeedsMedia(true),
            audioChunkInfos = playback.audioStream.value.header.chunkInfos,
            videoChunkInfos = playback.videoStream.value.header.chunkInfos,
            downloadTime = 0;

        while (audioMilliseconds > 0 && audioChunk) {
            if (!audioChunk.media && audioChunk != chunkToDownload) {
                downloadTime += _bandwidthMeter.calculateDownloadTime(audioChunkInfos[audioChunk.index].length);
            }
            audioMilliseconds -= audioChunk.duration;
            audioChunk = audioChunk.next;
        }

        while (videoMilliseconds > 0 && videoChunk) {
            if (!videoChunk.media && videoChunk != chunkToDownload) {
                downloadTime += _bandwidthMeter.calculateDownloadTime(videoChunkInfos[videoChunk.index].length);
            }
            videoMilliseconds -= videoChunk.duration;
            videoChunk = videoChunk.next;
        }

        return downloadTime;
    }
}

/**
* Factory for downloader States, adds log capability.
* @constructor
*/
function DownloaderStateFactory(playback, context) {
    context.downloaderStateFactory = this;
    this.playingState = register(PlayingState);
    this.seekingState = register(SeekingState);
    this.rebufferingState = register(RebufferingState);
    this.cdnSelectionState = register(CDNSelectionState);
    this.bufferingState = register(BufferingState);
    this.initBitrateSelectionState = register(InitBitrateSelectionState);

    function register(stateConstructor) {
        var state = new stateConstructor(playback);
        state.init.call(state);
        return state;
    }
}



// -- player/MediaDownloadWorker.js
/**
* @constructor
*/
function MediaDownloadWorker(jobQueue, playback, active, id) {
    var _log = new playback.log.CategoryLog('MediaDownloadWorker'),
        _mediaBuffer = playback.mediaBuffer,
        _mediaHttp = playback.mediaHttp,
        _isActive = active,
        _bandwidthMeter = playback.bandwidthMeter,
        _currentJob, // the currently job being downloaded, if any.
        _activeTask,
        _self = this,
        _context = playback.downloaderContext,
        _eventSource = new EventSource();
        this.addEventListener = _eventSource.addListener;

    _context.failedDownloadRetryWaits = config.failedDownloadRetryWaits;
    _context.failedDownloadRetryIndex = 0;

    jobQueue.addEventListener(DownloadJobManager$JobAdded, function (continueHint) {
        if (!_activeTask && _isActive) {
            continueHint.handled = true;
            _update();
        }
    });
    debug$assert(_mediaHttp);
    debug$assert(_bandwidthMeter);
    debug$assert(_mediaBuffer);

    // --------------------------------------------------------------------------------
    // -- Public API
    this.isEnabled = function _isEnabled() {
        return _isActive;
    };

    this.setEnabled = function _setEnabled(isEnabled) {
        _isActive = isEnabled;
    };

    this.shutdown = function _shutdown() {
        this.setEnabled(false);
    };
    this.getCurrentJob = function _getCurrentJob() {
        return _currentJob;
    };

    this.abortJob = function abortJob(shouldAbortFunction) {

        if (_activeTask && _activeTask.response && _currentJob) {
            var shouldAbort = shouldAbortFunction ? shouldAbortFunction(_currentJob) : true;
            if (shouldAbort) {
                DEBUG && shouldAbortFunction && shouldAbortFunction(_currentJob) && _log.debug("excluded job's bitrate: "+ _currentJob.recommendation.videoStream.bitrate);
                _currentJob.chunk.media = null;
                _currentJob.chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
                _log.trace("Aborted download of chunk:", _currentJob.chunk.index);
                _activeTask.response.abort();
                _activeTask = null;
                _currentJob = null;
            }
        }
    };

    // --------------------------------------------------------------------------------
    // -- private implementation
    function _update() {
        if (!_activeTask  && _isActive) {
            _currentJob = jobQueue.dequeue();
            if (_currentJob) {
                _downloadJob(_currentJob);
            }
        }
    }
    function _resetChunk(chunk) {
        if (chunk) {
            chunk.media = null;
            chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
        }
    }
    function _downloadJob(job) {
        var chunkToDownload = job.chunk,
            recommendation = job.recommendation;

        // if we need to download a chunk, do so
        var chunkIndex = chunkToDownload.index,
        stream;

        if (chunkToDownload.type === CadmiumMediaStream$VIDEO) {
            // if we need more video, update the video stream based on recommendation from heuristics
            stream = recommendation.videoStream;

            // does this stream have the chunk we need?
            if (!(stream.header && stream.header.chunkInfos[chunkIndex])) {
                _log.warn('Stream is missing header or has less chunks than primary, falling back to primary', { 'BitrateOld': stream.bitrate, 'BitrateNew': playback.primaryVideoStream.bitrate });
                stream = playback.primaryVideoStream;
            }

            if (stream != playback.videoStream.value) {
                _log.trace('Stream switch', { 'BitrateOld': playback.videoStream.value.bitrate, 'BitrateNew': stream.bitrate, 'Chunk Index': chunkIndex});
                playback.videoStream.set(stream, {chunkStartTime: stream.header.chunkInfos[chunkIndex].startTime,
                                                  streamTput: -1,
                                                  networkMonitorTput: -1});
            }
        } else if (chunkToDownload.type == CadmiumMediaStream$AUDIO) {
            stream = playback.audioStream.value;
        } else {
            debug$assert(false);
            return;
        }

        var chunkInfo = stream.header.chunkInfos[chunkIndex];


        if (chunkInfo) {
            var cdn = playback.cdn.value;
            var mediaRequest = MediaDownloadWorker$createRequest(chunkToDownload, stream, cdn);

            DEBUG && _log.trace('Downloading chunk', chunkToDownload, stream, {
                'Offset': mediaRequest.offset,
                'Length': mediaRequest.length
            });

            chunkToDownload.setDownloading(MediaBuffer$CHUNK_DOWNLOADING);
            CadmiumMediaStream$switchType(stream.type, playback.downloadingAudio, playback.downloadingVideo).set({
                chunk: chunkToDownload,
                stream: stream,
                cdn: cdn
            });

            // kick off the download
            var newTask = {
                type: MediaDownloadWorker$TASK_CHUNKDOWNLOAD,
                stream: stream,
                chunk: chunkToDownload

            };
            _activeTask = newTask;
            newTask.response = _mediaHttp.download(mediaRequest, _onTaskComplete);
            job.response = newTask.response;
        }

        function _onTaskComplete(result) {
            _taskCompleteHandler(result);
            _eventSource.fire(MediaDownloadWorker$JobCompleted);
            _currentJob = null;
            if (_activeTask) {
                _activeTask = null;
            }
        }

        function _taskCompleteHandler(result) {
            var request;

            if (playback.state.value != Playback$STATE_NORMAL) {
                return;
            }
            if (result && result.success) {
                _context.failedDownloadRetryIndex = 0;

                // we downloaded a chunk
                 request = result.request;
                _mediaBuffer.notifyChunksDownloaded(request.chunks, request.infos, request.stream, result.content, request.cdn, result.measurements);
            } else {

                // we failed to download a chunk
                _currentJob && _resetChunk(_currentJob.chunk);
                if (!result || result.errorSubCode != ErrorSubCodes.HTTP_ABORT) {
                    if (result && result.errorSubCode == ErrorSubCodes.HTTP_PROXY) {
                        playback.closeWithError(new PlayerError(ErrorCodes.MEDIA_DOWNLOAD, result.errorSubCode));
                    } else {
                        if (result) {
                            request = result.request;
                            _context.failureMonitor.updateFailures(request.cdn, request.chunks[0], request.stream);
                        }
                        if ((++_context.failedDownloadRetryIndex) >= _context.failedDownloadRetryWaits.length) {
                            _context.failedDownloadRetryIndex = _context.failedDownloadRetryWaits.length - 1;
                        }
                    }
                }
            }
            // After processing check to see if there is more work.
            dispatch(_update);
        }
    }
}
/**
* @param {number=} minimumNumberOfBytes
*/
function MediaDownloadWorker$createRequest(nextChunkToDownload, stream, cdn, minimumNumberOfBytes) {
    var chunkInfos = stream.header.chunkInfos,
        offset = chunkInfos[nextChunkToDownload.index].offset,
        length = 0;

    // initialize chunks to download with first chunk, add if necessary
    var chunks = [],
        infos = [];

    do {
        var info = chunkInfos[nextChunkToDownload.index];
        length += info.length;
        chunks.push(nextChunkToDownload);
        infos.push(info);

        nextChunkToDownload = nextChunkToDownload.next;
    } while (length < minimumNumberOfBytes && nextChunkToDownload);

    return {
        responseType: http$RESPONSETYPE_BINARY,
        parser: MediaDownloader$parseChunkMedia,
        url: stream.downloadUrls[cdn.id],
        offset: offset,
        length: length,
        cdn: cdn,
        track: stream.track,
        stream: stream,
        chunks: chunks,
        infos: infos,
        diagCaption: stream.type + '-' + stream.bitrate + '-' + chunks.map(function (chunk) { return chunk.index; }).join('+'),
        cacheBuster: true
    };
};


var MediaDownloadWorker$TASK_CHUNKDOWNLOAD = 1,
    MediaDownloadWorker$TASK_COOLDOWN = 2,
    MediaDownloadWorker$TASK_CDNSELECTION = 3;

var MediaDownloadWorker$JobCompleted = 1;



// -- player/DownloadJobManager.js
/**
 * @constructor
 */
function DownloadJobManager(numWorkers, numActiveWorkers, playback) {
    var _workers = [],
        _bandwidthMeter = playback.bandwidthMeter,
        _self = this;
    
    var _innerQueue = new buckets.Queue();
    var _eventSource = new EventSource();
    this.addEventListener = _eventSource.addListener;
    this.removeEventListener = _eventSource.removeListener;

    this.enqueue = function _enqueue(elem) {
        var result = _innerQueue.enqueue(elem);
        elem.chunk.setDownloading(MediaBuffer$CHUNK_ONDECK);
        _eventSource.shortCircuitFire(DownloadJobManager$JobAdded);
        return result;
    };

    this.dequeue = function _dequeue() {
        return _innerQueue.dequeue();
    };

    this.peek = function _peek() {
        return _innerQueue.peek();
    };

    this.size = function _size() {
        return _innerQueue.size();
    };

    this.contains = function _contains(elem, equalsFunction) {
        return _innerQueue.contains(elem, equalsFunction);
    };

    this.forEach = function _forEach(callback) {
        return _innerQueue.forEach(callback);
    };

    this.setEnabled = function _setEnabled(isEnabled) {
        _workers.forEach(function(worker) {
            worker.setEnabled(isEnabled);
        });
    };

    // Get the total download time of jobs in progress.
    this.getTotalDownloadTimeOfJobs = function _getTotalDownloadTimeOfJobs() {
        var totalBytes = 0;
        _workers.forEach(function(worker) {
            var job = worker.getCurrentJob();
            if (job && job.chunk.downloading === MediaBuffer$CHUNK_DOWNLOADING) {
                var chunk = job.chunk;
                var recommendation = job.recommendation;
                var stream = chunk.type === CadmiumMediaStream$VIDEO ? recommendation.videoStream : playback.audioStream.value;;
                var response = job.response;
                if (response) {
                    var measurements = job.response.measurements;
                    if (isNumber(measurements.responseStartTime)) {
                        var transferredBytes = measurements.contentLength || 0;
                        totalBytes += Math$max(response.request.length - transferredBytes, 0);
                    } else {
                        var chunkInfo = stream.header.chunkInfos[chunk.index];
                        totalBytes += chunkInfo.length;
                    }
                }
            }
        });
        totalBytes = totalBytes || 0;
        return _bandwidthMeter.calculateDownloadTime(totalBytes);

    };

    // Abort jobs that are more than numActiveWorkers distant from comparison chunks.
    this.abortDistantChunkDownloads = function abortDistantChunkDownloads(comparisonChunk) {
        if (!comparisonChunk) {
            return;
        }

        _workers.forEach(function (worker) {
            var job = worker.getCurrentJob();

            if (!job) {
                return;
            }

            // We want to abort jobs in progress unless the jobs are a within a few chunks ahead
            // of the comparison chunk.
            if ((job.chunk.index < comparisonChunk.index) || (job.chunk.index - comparisonChunk.index) >= numActiveWorkers) {
                worker.abortJob();
            }
        });
    };

    // Abort all jobs in progress.
    this.abortJobs = function abortJobs(shouldAbortFunction) {
        _workers.forEach(function(worker) {
            worker.abortJob(shouldAbortFunction);
        });
    };

    // Set the maximum number of active workers
    this.setActiveWorkers = function setActiveWorkers(n) {
        var maxWorkers = _workers.length;
        var newActiveWorkerCount = Number$clamp(n, 0, maxWorkers);

        for (var i = 0; i < maxWorkers; i++) {
            _workers[i].setEnabled(i < newActiveWorkerCount);
        }
    };

    // Clear the job queue of jobs.
    this.clearJobs = function clearJobs() {
        _innerQueue.forEach(function(job) {
            job.chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
        });
        _innerQueue.clear();
    };

    this.needsWork = function _needsWork() {
        return _innerQueue.size() < 2;
    };

    // initialize the workers
    for (var i = 0; i < numWorkers; i++) {
        var worker = new MediaDownloadWorker(_self, playback, i < numActiveWorkers, (i + 1));

        worker.addEventListener(MediaDownloadWorker$JobCompleted, function jobCompleted() {
            _eventSource.fire(DownloadJobManager$JobCompleted);
        });
        _workers.push(worker);
    }
}

var DownloadJobManager$JobAdded = 1;
var DownloadJobManager$JobCompleted = 2;


// -- player/SubChunkPlanner.js
/**
* @constructor
*/
function SubChunkPlanner(idealSubchunkSize) {
    var _self = this;

    this.idealSubchunkSize = idealSubchunkSize || SIXTY_FOUR_KB;
    this.computeSubChunkJobs = _computeSubChunkJobs;

    function _computeSubChunkJobs(chunkSpec, chunkToDownload, nWorkers) {
        var subchunkJobs = [];
        var startRange, endRange;

        if (nWorkers === 1 || chunkSpec.length <= _self.idealSubchunkSize) {
            subchunkJobs.push({
                offset: chunkSpec.offset,
                length: chunkSpec.length,
                endRange: chunkSpec.offset + chunkSpec.length,
                parentChunk: chunkToDownload
            });
        }
        else {
            // 1. Divide chunk by number of workers to get the right ideal chunk size multiple. This will be our subchunk length, except
            // for the last (remainder) subchunk which will be a partial.
            var numIdeals = Math.floor(chunkSpec.length / _self.idealSubchunkSize),
                fullSubChunkLength = Math.floor(numIdeals / nWorkers) * _self.idealSubchunkSize || _self.idealSubchunkSize,
                numFullSubchunks = Math.floor(chunkSpec.length / fullSubChunkLength);

                numFullSubchunks = numFullSubchunks > 0 ? numFullSubchunks - 1 : 0;
            var remainderLength = chunkSpec.length - fullSubChunkLength * numFullSubchunks;

            // 2. Build the download plans for the full sub chunks.
            for (var i = 0; i < numFullSubchunks; i++) {
                startRange = chunkSpec.offset + i * fullSubChunkLength;
                endRange = startRange + fullSubChunkLength - 1;

                subchunkJobs.push({
                    offset: startRange,
                    length: fullSubChunkLength,
                    endRange: endRange,
                    parentChunk: chunkToDownload
                });
            };

            // 3. Add the remainder chunk if any.
            if (remainderLength > 0) {
                startRange = chunkSpec.offset + numFullSubchunks * fullSubChunkLength;
                subchunkJobs.push({
                    offset: startRange,
                    length: remainderLength,
                    endRange: startRange + remainderLength,
                    parentChunk: chunkToDownload
                });
            }
            else {
                subchunkJobs[subchunkJobs.length - 1].endRange += 1;
            }
        }
        var length = subchunkJobs.length;
        for (var i = 0; i < length; i++) {
            var parentChunk = subchunkJobs[i].parentChunk;
            subchunkJobs[i].index = i + 1;
            subchunkJobs[i].logFields = { 'name': String$format("{0}_{1} - {2}/{3}", parentChunk.type, parentChunk.index, i + 1, length) };

        }
        //_verifySubChunkJobs(chunkToDownload,subchunkJobs);
        return subchunkJobs;
    }

}




// -- player/SubchunkDownloadJobManager.js
/**
 * @constructor
 */
function SubChunkDownloadJobManager(numWorkers, numActiveWorkers, playback) {
    var _log = new playback.log.CategoryLog('SubChunkDownloadJobManager'),
        _workers = [],
        _bandwidthMeter = playback.bandwidthMeter,
        _self = this,
        _mediaBuffer = playback.mediaBuffer,
        _numActiveWorkers = numActiveWorkers,
        _subChunkPlanner = new SubChunkPlanner(config.subchunkLength);

    // Hash table of chunks whose subchunks are downloading
    var _chunksInProgress = {};

    // Queue of subchunks jobs waiting for workers.
    var _subChunksJobQueue = new buckets.Queue();

    // Chunk waiting to be planned.
    var _chunkJobOnDeck;

    var _eventSource = new EventSource();
    this.addEventListener = _eventSource.addListener;
    this.removeEventListener = _eventSource.removeListener;

    // Public API
    this.enqueue = function _enqueue(chunkJob) {
        chunkJob.chunk.setDownloading(MediaBuffer$CHUNK_ONDECK);
        _processChunkJob(chunkJob);
    };

    function _processChunkJob(chunkJob) {
        if (!chunkJob) {
            return;
        }
        var chunkToDownload = chunkJob.chunk,
             recommendation = chunkJob.recommendation;

        // Plan subchunks
        var stream = chunkToDownload.type === CadmiumMediaStream$VIDEO ?
            recommendation.videoStream : chunkToDownload.type === CadmiumMediaStream$AUDIO ?
                playback.audioStream.value : debug$assert(false);

        debug$assert(stream.header);

        DEBUG && _log.debug("enqueing and subchunking chunk: ", chunkToDownload);
        var chunkInfo = stream.header.chunkInfos[chunkToDownload.index];
        chunkToDownload.content = new Uint8Array(chunkInfo.length);

        chunkToDownload.subChunkJobs = _subChunkPlanner.computeSubChunkJobs(chunkInfo, chunkToDownload, _numActiveWorkers);
        DEBUG && _verifySubChunkJobs(chunkInfo, chunkToDownload.subChunkJobs);

        chunkToDownload.subChunkJobs.forEach(function (job) {
            job.cdn = playback.cdn.value;
            job.stream = stream;
            _subChunksJobQueue.enqueue(job);
            _eventSource.shortCircuitFire(SubChunkDownloadJobManager$SubChunkJobAdded);
        });
    }

    function _verifySubChunkJobs(chunkInfo, subchunkJobs) {
        var subchunksLength = 0;
        var firstSubChunk;
        var lastSubChunk;
        subchunkJobs.forEach(function (job) {
            if (!firstSubChunk || job.offset < firstSubChunk.offset) {
                firstSubChunk = job;
            }
        });

        subchunkJobs.forEach(function(job) {
            subchunksLength += job.length;
        });

        subchunkJobs.forEach(function (job) {
            if (!lastSubChunk || job.offset > lastSubChunk.offset) {
                lastSubChunk = job;
            }
        });

        debug$assert(chunkInfo.length === subchunksLength);
        debug$assert(chunkInfo.offset === firstSubChunk.offset);
        debug$assert((chunkInfo.offset + chunkInfo.length) === lastSubChunk.endRange);
    }
    this.needsWork = function _needsWork() {
        // Don't allow the workers to get too far ahead on the timeline.
        return Object.keys(_chunksInProgress).length < config.maxChunksInProgressForSubchunking && _subChunksJobQueue.size() <= _numActiveWorkers;
    };

    /**
    * Attempts to dequeue a sub chunk job for download.
    */
    this.dequeue = function _dequeue() {
        var subChunkJob = _subChunksJobQueue.dequeue();
        if (!subChunkJob) {
            return null;
        }
        subChunkJob.cdn = playback.cdn.value;

        var chunk = subChunkJob.parentChunk;

        if (!_chunksInProgress[_getKey(chunk)]) { // We're starting on a new chunk.
            chunk.request = MediaDownloadWorker$createRequest(chunk, subChunkJob.stream, subChunkJob.cdn);
            CadmiumMediaStream$switchType(subChunkJob.stream.type, playback.downloadingAudio, playback.downloadingVideo).set({
                chunk: chunk,
                stream: subChunkJob.stream,
                cdn: subChunkJob.cdn
            });
            DEBUG && _log.trace('Downloading subchunk for: ', chunk, subChunkJob.stream);
            _chunksInProgress[_getKey(chunk)] = chunk;
            chunk.setDownloading(MediaBuffer$CHUNK_DOWNLOADING);

            // if we need to download a chunk, do so
            var chunkIndex = chunk.index,
                stream;
                //chunkInfo = stream.header.chunkInfos[chunkIndex];

            if (chunk.type === CadmiumMediaStream$VIDEO) {
                // if we need more video, update the video stream based on recommendation from heuristics
                stream = subChunkJob.stream;

                // does this stream have the chunk we need?
                if (!(stream.header && stream.header.chunkInfos[chunkIndex])) {
                    _log.warn('Stream is missing header or has less chunks than primary, falling back to primary', { 'BitrateOld': stream.bitrate, 'BitrateNew': playback.primaryVideoStream.bitrate });
                    stream = playback.primaryVideoStream;
                }

                if (stream != playback.videoStream.value) {
                    _log.trace('Stream switch', { 'BitrateOld': playback.videoStream.value.bitrate, 'BitrateNew': stream.bitrate });
                    playback.videoStream.set(stream);
                }
            } else if (chunk.type !== CadmiumMediaStream$AUDIO) {
                debug$assert(false);
                throw new Error("unexpected chunk type.");
            }
        }
        return subChunkJob;
    };

    this.peek = function _peek() {
        return _subChunksJobQueue.peek();
    };

    this.size = function _size() {
        return _subChunksJobQueue.size();
    };

    this.contains = function _contains(elem, equalsFunction) {
        return _subChunksJobQueue.contains(elem, equalsFunction);
    };

    this.forEach = function _forEach(callback) {
        return _subChunksJobQueue.forEach(callback);
    };

    this.setEnabled = function _setEnabled(isEnabled) {
        _workers.forEach(function(worker) {
            worker.setEnabled(isEnabled);
        });
    };

    // Get the total download time of jobs in progress.
    this.getTotalDownloadTimeOfJobs = function _getTotalDownloadTimeOfJobs() {
        var totalBytes = 0;
        _workers.forEach(function(worker) {
            var job = worker.getCurrentJob();
            if (job) {
                var response = job.response;
                if (response) {
                    var measurements = response.measurements;
                    if (isNumber(measurements.responseStartTime)) {
                        var transferredBytes = measurements.contentLength || 0;
                        totalBytes += Math$max(response.request.length - transferredBytes, 0);
                    } else {
                        totalBytes += job.length;
                    }
                }
            }
        });
        totalBytes = totalBytes || 0;
        return _bandwidthMeter.calculateDownloadTime(totalBytes);
    };

    // Abort jobs that are more than numActiveWorkers distant from comparison chunks.
    this.abortDistantChunkDownloads = function abortDistantChunkDownloads(comparisonChunk) {
        if (!comparisonChunk) {
            return;
        }
        _workers.forEach(function (worker) {
            var job = worker.getCurrentJob();

            if (!job) {
                return;
            }

            // We want to abort jobs in progress unless the jobs are a within a few chunks ahead
            // of the comparison chunk.
            if ((job.chunk.index < comparisonChunk.index) || (job.chunk.index - comparisonChunk.index) >= _numActiveWorkers) {
                worker.abortJob();
            }
        });
    };

    // Abort all jobs in progress.
    this.abortJobs = function abortJobs() {
        Object.keys(_chunksInProgress).forEach(function(key) {
            var chunk = _chunksInProgress[key];
            _resetChunk(chunk);
            delete _chunksInProgress[key];
        });
        _workers.forEach(function(worker) {
            worker.abortJob();
        });
    };

    function _resetChunk(chunk) {
        if (chunk) {
            chunk.media = null;
            chunk.setDownloading(MediaBuffer$CHUNK_WAITING);
            chunk.subChunkJobs = null;
        }
    }
    // Set the maximum number of active workers
    this.setActiveWorkers = function setActiveWorkers(n) {
        var maxWorkers = _workers.length;
        var newActiveWorkerCount = Number$clamp(n, 0, maxWorkers);

        for (var i = 0; i < maxWorkers; i++) {
            _workers[i].setEnabled(i < newActiveWorkerCount);
        }
    };

    // Clear the job queue of jobs.
    this.clearJobs = function clearJobs() {
        if (_chunkJobOnDeck) {
            _resetChunk(_chunkJobOnDeck.chunk);
            _chunkJobOnDeck = null;
        }
        _subChunksJobQueue.forEach(function(job) {
            job && _resetChunk(job.parentChunk);
        });
        _subChunksJobQueue.clear();
    };

    // initialize the workers
    for (var i = 0; i < numWorkers; i++) {
        var worker = new SubChunkDownloadWorker(_self, playback, i < _numActiveWorkers, (i + 1));

        worker.addEventListener(SubChunkDownloadWorker$JobCompleted, function jobCompleted(subChunkJob) {
            _onSubChunkJobCompleted(subChunkJob);
        });
        _workers.push(worker);
    }

    //------------ Private Implementation
    function _getKey(chunk) {
        return chunk.type + "_" + chunk.index;
    }

    function _onSubChunkJobCompleted(subChunkJob) {
        // if downloads were aborted, the job will be null
        if (!subChunkJob) {
            return;
        }

        // Copy the subchunk response content into the parent chunk’s content array buffer
        var chunk = subChunkJob.parentChunk,
            parseSuccessful,
            context = playback.downloaderContext;

        if (subChunkJob.response.success) {
            if (_isChunkComplete(chunk)) {

                chunk.subChunkJobs.forEach(function(job) {
                    chunk.content.set(job.response.content, job.offset - chunk.request.offset);
                });
                try {
                    chunk.content = SubChunkDownloadJobManager$parseChunkMedia(chunk.content);
                    parseSuccessful = true;
                } 
                catch (ex) {
                    _resetChunk(chunk);
                    context.failureMonitor.updateFailures(subChunkJob.cdn, chunk, subChunkJob.stream);
                    _log.warn('Exception parsing response', ex, chunk);
                }
                delete _chunksInProgress[_getKey(chunk)];
                if (parseSuccessful) {
                    DEBUG && _log.debug("chunk was fully assembled: ", chunk);
                    _mediaBuffer.notifyChunksDownloaded([chunk], chunk.request.infos, subChunkJob.stream, chunk.content, subChunkJob.cdn, _computeDownloadMeasurements(chunk));
                }
                chunk.subChunkJobs = null;
                chunk.content = null;
                var nextJobToProcess = _chunkJobOnDeck;
                _chunkJobOnDeck = null;
                _processChunkJob(nextJobToProcess);
                _eventSource.fire(DownloadJobManager$JobCompleted);
            }
        } else {
            subChunkJob.response = null;
            
            if (context.failureMonitor.shouldPerformCDNSelect(subChunkJob.cdn)) {
                _self.setEnabled(false);
            }
            _subChunksJobQueue.enqueue(subChunkJob);
            _eventSource.shortCircuitFire(SubChunkDownloadJobManager$SubChunkJobAdded);
        }

        function _isChunkComplete(chunk) {
            if (chunk.subChunkJobs) {
                var length = chunk.subChunkJobs.length;
                for (var i = 0; i < length; i++) {
                    var subchunk = chunk.subChunkJobs[i];
                    if (!subchunk.response || !subchunk.response.success) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }
    }

    function _computeDownloadMeasurements(chunk) {
        var measurements = {};
        var jobs = chunk.subChunkJobs;
        if (chunk.subChunkJobs) {
            measurements.requestTime = Array$min(jobs, function (job) { return job.response.measurements.requestTime; });
            measurements.responseStartTime = Array$min(jobs, function (job) { return job.response.measurements.responseStartTime; });
            measurements.responseEndTime = Array$max(jobs, function (job) { return job.response.measurements.responseEndTime; });
            measurements.contentLength = chunk.content.length;
        }

        return measurements;
    }
}

var SubChunkDownloadJobManager$SubChunkJobAdded = 1;
var SubChunkDownloadJobManager$SubChunkJobCompleted = 2;




// -- player/SubChunkDownloadWorker.js
/**
* @constructor
*/
function SubChunkDownloadWorker(jobQueue, playback, active, id) {
    var _log = new playback.log.CategoryLog('SubChunkDownloadWorker'),
        _mediaBuffer = playback.mediaBuffer,
        _mediaHttp = playback.mediaHttp,
        _isActive = active,
        _currentJob, // the currently job being downloaded, if any.
        _activeTask,
        _context = playback.downloaderContext,
        _eventSource = new EventSource();
        this.addEventListener = _eventSource.addListener;

    _context.failedDownloadRetryWaits = config.failedDownloadRetryWaits;
    _context.failedDownloadRetryIndex = 0;

    jobQueue.addEventListener(SubChunkDownloadJobManager$SubChunkJobAdded, function (continueHint) {
        if (!_currentJob && _isActive) {
            continueHint.handled = true;
            _update();
        }
    });
    debug$assert(_mediaHttp);
    debug$assert(_mediaBuffer);

    // --------------------------------------------------------------------------------
    // -- Public API
    this.isEnabled = function _isEnabled() {
        return _isActive;
    };

    this.setEnabled = function _setEnabled(isEnabled) {
        if (_isActive != isEnabled) {
            _isActive = isEnabled;

            // If waking up, check the queue for work.
            _isActive && _update();
        }
    };

    this.shutdown = function _shutdown() {
        this.setEnabled(false);
    };
    this.getCurrentJob = function _getCurrentJob() {
        return _currentJob;
    };

    this.isBusy = function _isBusy() {
        return _currentJob;
    };

    this.abortJob = function abortJob() {
        if (_activeTask && _activeTask.response) {
            _log.trace("Aborted download of chunk:", _currentJob);
            _activeTask.response.abort();
            _activeTask = null;
            _currentJob = null;
        }
    };

    // --------------------------------------------------------------------------------
    // -- private implementation
    function _update() {
        if (!_currentJob && _isActive) {
            _currentJob = jobQueue.dequeue();
            if (_currentJob) {
                    _downloadJob(_currentJob);
                }
            }
        }

    function _downloadJob(job) {
        var mediaRequest = SubChunkDownloadWorker$createRequest(job);

        // kick off the download
        var newTask = {
            type: SubChunkDownloadWorker$TASK_SUBCHUNKDOWNLOAD,
            stream: job.stream,
            subchunkJob: job

        };
        _activeTask = newTask;
        DEBUG && _log.debug(String$format("worker {0}, Downloading subchunk",id),job);
        newTask.response = _mediaHttp.download(mediaRequest, _onTaskComplete);
        job.response = newTask.response;

        function _onTaskComplete(result) {
            DEBUG && _log.debug(String$format("Subchunk downloading complete by worker {0} for subchunk", id), job);
            _taskCompleteHandler(result);
            _eventSource.fire(SubChunkDownloadWorker$JobCompleted,_currentJob);
            _currentJob = null;
            if (_activeTask && _activeTask.type != MediaDownloadWorker$TASK_COOLDOWN) {
                _activeTask = null;
            }
        };

        function _taskCompleteHandler(result) {
            dispatch(_update);

            var task = _activeTask;

            if (!task || playback.state.value != Playback$STATE_NORMAL) {
                return;
            }
            if (task.type != MediaDownloadWorker$TASK_COOLDOWN) {
                if (result && result.success) {
                    _context.failedDownloadRetryIndex = 0;
                    debug$assert(task.type == MediaDownloadWorker$TASK_CHUNKDOWNLOAD);
                } else {

                    // we failed to download a chunk
                    if (!result || result.errorSubCode != ErrorSubCodes.HTTP_ABORT) {
                        _context.failureMonitor.updateFailures(job.cdn, job.parentChunk, job.stream);
                        if ((++_context.failedDownloadRetryIndex) >= _context.failedDownloadRetryWaits.length) {
                            _context.failedDownloadRetryIndex = _context.failedDownloadRetryWaits.length - 1;
                        }
                    }
                }
            } 
        }
    };
}

function SubChunkDownloadWorker$createRequest(subChunkJob) {
    var stream = subChunkJob.stream;
    return {
        responseType: http$RESPONSETYPE_BINARY,
        parser: SubChunkDownloadWorker$parseSubChunkMedia,
        url: stream.downloadUrls[subChunkJob.cdn.id],
        offset: subChunkJob.offset,
        length: subChunkJob.length,
        chunks: [subChunkJob.parentChunk],
        cdn: subChunkJob.cdn,
        track: stream.track,
        stream: stream,
        diagCaption: stream.type + '-' + stream.bitrate + '-' + subChunkJob.parentChunk.index + "- sub." + subChunkJob.index,
        cacheBuster: true
    };
};

function SubChunkDownloadWorker$parseSubChunkMedia(content) {
    return new Uint8Array(content);
}

var SubChunkDownloadWorker$TASK_SUBCHUNKDOWNLOAD = 1,
    SubChunkDownloadWorker$TASK_COOLDOWN = 2;

var SubChunkDownloadWorker$JobCompleted = 1;


// -- heuristics/SlidingWindowBandwidthMeter.js
/**
 * @constructor
 * Sliding Window Bandwidth Meter has a different design philosophy as compared
 * to previous bandwidth meters. Instead of just measuring the bandwidth of downloads (corrected
 * for latency), this meter measures the throughput this app is able to capture for media downloads.
 * It achieves this by using a sliding window of time with fixed duration, for example 30 seconds, and looks 
 * at all the media downloads successfully completed during that time, accounting for fractional downloads sitting
 * on the booundary. This technique more accurately measures bandwidth since it accounts
 * for download failures, gaps between downloads and multiple connections.
 *
 * In the main, the throughput calculation becomes equal to the total bytes of all downloads, whole and fractional,
 * within window divided by 30 seconds. In the example below the failed download of chunk 3 is easily accounted for
 * as well as the simultaneous downloads of  multiple connections.
 *
 *      30                                        0
 *      |-----------------------------------------|
 *    __|_________   _____________  ______________|
 *   |_____1______| |_____4_______||_______6______|
 *      |     ___________   __________            |
 *      |    |_3-failed__| |____3_____|           |  Time --->
 *      |  __________   __________                | 
 *      | |____2_____| |_____5___|                |
 *      |                                         |
 *      -------------------------------------------
 *                  Sliding Window
 */ 
function SlidingWindowBandwidthMeter(playback) {
    var _log = new playback.log.CategoryLog('SlidingWindowBandwidthMeter'),
        _mediaBuffer,
        _sustainableBitrateMeter,
        _measurements = [],
        _throughput = 1000 * KBPStoBPMS, // BytesPerMillisecond
        _throughput60 = 0, // throughput in the first 60 seconds
        _totalBytes = 0,
        _windowDurationMs = config.slidingWindowWidthMilliseconds,
        _lastupdateTime = clock$getTime(),
        _newDownloadsToProcess,
        _frequencyOfSlidingWindowCalcMs = 250,
        _maxMeasurements = 100,
        _latestCDN,
        _bandwidthReportCounter = 0,
        _bandwidthReportMax = Math$round(1000 / _frequencyOfSlidingWindowCalcMs),
        _latestRequestTime,
        _currentTimer,
        _reportedTotalTimeMs,
        _throughput60samples = 0;

    DEBUG && _log.debug('Starting SlidingWindowBandwidthMeter');
    playback.addEventListener(HttpPlayback$downloadcomplete, _onDownloadComplete);

    /**
    * Returns the measured throughput in bytes per millisecond.
    * @returns {number}
    */
    this.getThroughput = function () { return _throughput; };

    /**
    * Returns the measured throughput in Kbps.
    * @returns {number}
    */
    this.getThroughputKbps = function() { return Math$floor(_throughput * BPMStoKBPS); };

    /**
    * Returns the measured throughput after 60 seconds of playback in Kbps.
    * @returns {number}
    */
    this.getThroughput60 = function () { return Math$floor(_throughput60 * BPMStoKBPS); };

    /**
    * Returns the total bytes in window.
    * @returns {number}
    */
    this.getTotalBytes = function () { return _totalBytes; };

    /**
    * Returns the total duration over which the throughput was measured in milliseconds.
    * @return {number}
    */
    this.getTotalTime = function () { return _reportedTotalTimeMs; };

    /**
    * Returns the CDN from whence the last download came.
    * @returns {Object}
    */
    this.getLatestCDN = function () { return _latestCDN; };

    /**
    * Returns the time of the last request in milliseconds since the epoch.
    * (Epoch = 1 January 1970 00:00:00 UTC).
    * @returns {number}
    */
    this.getLatestRequestTime = function () { return _latestRequestTime; };

    /** 
    * Calculate the amount of time in milliseconds that a certain number of bytes would take given the
    * current throughput.
    *
    * @param sizeInBytes the number of bytes to use to calculate the download time for.
    * @returns {number}
    */
    this.calculateDownloadTime = _calculateDownloadTime;

    /**
    * Calculate the highest sustainable video rate (in KBPS) given the current throughput.
    * @returns {number}
    */
    this.calculateSustainableVideoBitrate = _calculateSustainableVideoBitrate;

    //------- Deprecated
    /**
    * Provides the throughput in Kbps.
    *
    * @deprecated Use getThroughputKbps().
    */
    this.calculateNormalizedBandwidth = _calculateNormalizedBandwidth;

    // getTransferTime and getLatency are deprecated, and all its usages will eventually be replaced by getTotalTime. Trying
    // to sift apart latency and transfer time in the browser is unreliable due to anti-virus programs.
    /**
    * @deprecated Use getTotalTime().
    */
    this.getTransferTime = function () { return _reportedTotalTimeMs; };

    /**
    * DO NOT USE. Always returns zero, since latency measurement is unreliable on browsers.
    * 
    * @deprecated
    */
    this.getLatency = function () { return 0; };

    //--- Event Handlers
    playback.addEventListener(Playback$closing, function () {
        _currentTimer && clearInterval(_currentTimer);
    });

    // Throughput calculation heartbeat.
    _currentTimer = setInterval(_updateSlidingWindowAggregateBandwidth, _frequencyOfSlidingWindowCalcMs);

    // Throughput in the first 60 seconds.
    var _throughput60Timer = new RecurringTimer(1000, _getThroughput60);
    _throughput60Timer.setTimer();

    //------------------------------------------------------------------------------------
    // Private Implementation.
    function _onDownloadComplete(response) {
        var measurements = response.measurements;
        var request = response.request;
        if (request.cdn) {
            _latestCDN = request.cdn.location.id;
        }
        _latestRequestTime = measurements.requestTime;
        if (response.success && measurements.contentLength > BandwidthMeter$smallContentLength && response.type == http$RESPONSETYPE_BINARY) {
            var predictedDownloadTime = _calculateDownloadTime(measurements.contentLength);
            var actualDownloadTime = measurements.responseEndTime - measurements.requestTime;
            DEBUG && _log.debug('Download complete', {
                'Length': measurements.contentLength,
                'Accuracy': (predictedDownloadTime / actualDownloadTime).toFixed(2),
                'PredictedTime': Number$formatMillisecond(predictedDownloadTime),
                'ActualTime': Number$formatMillisecond(actualDownloadTime)
            });

            _measurements.push(measurements);
            while (_measurements.length > _maxMeasurements) {
                _measurements.shift();
            }

            // Only signal new downloads if the buffer is full and we're not 
            // updating based on time passing.
            _newDownloadsToProcess = _mediaBuffer && _mediaBuffer.isBufferFull();

            _updateCalcDuringStartup();
        }
    }

    // In order to get to accuracy quickly during playback startup 
    // we want to calculate the bandwidth with each download for 
    // the first ten.
    function _updateCalcDuringStartup() {
        if (_measurements.length <= 10) {
            _updateSlidingWindowAggregateBandwidth();
        } else {
            _updateCalcDuringStartup = NOOP;
        }
    }

    function isInRange(value, lower, upper) {
        return value >= lower && value <= upper;
    }

    // Calculate the bandwidth based on a sliding window approach.
    function _updateSlidingWindowAggregateBandwidth() {
        if (playback.state.value == Playback$STATE_NORMAL || playback.state.value == Playback$STATE_LOADING) {
            _calculateSlidingWindowAggregateBandwidth();
        }
    }

    function _calculateSlidingWindowAggregateBandwidth() {
        var prevUpdateTime = _lastupdateTime,
            isBufferFull,
            updateDelta;

        _lastupdateTime = clock$getTime();
        updateDelta = _lastupdateTime - prevUpdateTime;

        _mediaBuffer = _mediaBuffer || playback.mediaBuffer;
        isBufferFull = _mediaBuffer && _mediaBuffer.isBufferFull();

        // if the buffer is not full or new downloads have come in, update the throughput calcs.
        if (!isBufferFull || _newDownloadsToProcess) {
            // Every second we fire an update event to signal clients
            // to the latest bandwidth measurement. This provides clients with backwards compatibility
            // with the regular bandwidth meter which fired the event after every download.
            // In the future clients should simply request the throughput at whatever frequency
            // they deem necessary since this meter's throughput measurement is no longer solely
            // tied to download completion events.
            if (++_bandwidthReportCounter >= _bandwidthReportMax) {
                _bandwidthReportCounter = 0;
                playback.fireEvent(BandwidthMeter$aggregateUpdated);
            }
            if (_measurements.length > 0) {
                var lastMinusFirst = _measurements[_measurements.length - 1].responseEndTime - _measurements[0].requestTime,
                    _actualWindowDurationMs = Math$min(_windowDurationMs, lastMinusFirst),
                    chunksInWindow = 0,
                    windowEndTime = clock$getTime();

                // As long as the actual window time is about equal to the window Duration use endTime - windowDuration as the 
                // start time, else use the time of the first request to avoid filtering out early downloads
                var windowStartTime = _actualWindowDurationMs >= _windowDurationMs
                    ? windowEndTime - _windowDurationMs
                    : _measurements[0].requestTime;

                // We never want the sliding window to be greater than the configuration duration.
                windowStartTime = (windowEndTime - windowStartTime) <= config.slidingWindowWidthMilliseconds
                    ? windowStartTime
                    : windowEndTime - config.slidingWindowWidthMilliseconds;

                _totalBytes = 0;

                // 1) Find full and partial chunks and calculate total bytes for them.
                _measurements.forEach(function(measurement) {
                    var chunkDownloadTime = measurement.responseEndTime - measurement.requestTime,
                        fractionInWindow = 0;

                    if (chunkDownloadTime <= 0 ||
                            measurement.responseEndTime < windowStartTime ||
                            measurement.requestTime > windowEndTime
                    ) {
                        return;
                    }

                    if (measurement.requestTime >= windowStartTime && measurement.responseEndTime <= windowEndTime) {
                        fractionInWindow = 1;
                    } else if (isInRange(measurement.responseEndTime, windowStartTime, windowEndTime)) {
                        fractionInWindow = (measurement.responseEndTime - windowStartTime) / chunkDownloadTime;
                    } else if (isInRange(measurement.requestTime, windowStartTime, windowEndTime)) {
                        fractionInWindow = (windowEndTime - measurement.requestTime) / chunkDownloadTime;
                    }
                    chunksInWindow++;
                    _totalBytes += measurement.contentLength * fractionInWindow;
                });
                _totalBytes = Math$floor(_totalBytes);

                // 2) Divide by the sliding window duration to calculate the throughput.
                //_throughput = Math$floor(_totalBytes / _actualWindowDurationMs); // in bytes per ms;
                _throughput = Math$floor(Math$max(8, _totalBytes / _actualWindowDurationMs)); // in bytes per ms;

                _reportedTotalTimeMs = _actualWindowDurationMs;
                _newDownloadsToProcess = false;
            }

        } else if (isBufferFull) { 
            // If the buffer is full just keep shifting the measurements forward in time as if they recently occurred,
            // otherwise they'll fall out of window and lower our reported throughput.
            _timeShiftMeasurements(updateDelta);
        }
    }

    function _timeShiftMeasurements(delta) {
        _measurements.forEach(function (measurement) {
            measurement.requestTime += delta;
            measurement.responseStartTime += delta;
            measurement.responseEndTime += delta;
        });
    }

    // Returns the milliseconds needed to download sizeInBytes.
    function _calculateDownloadTime(sizeInBytes) {
        return Math$floor(sizeInBytes / _throughput); 
    }
    
    function _calculateSustainableVideoBitrate() {
        debug$assert(playback.mediaBuffer);
        _sustainableBitrateMeter = _sustainableBitrateMeter || new SustainableBitrateMeter(playback.mediaBuffer, playback.primaryAudioStream);
        var bitrate = _sustainableBitrateMeter.calculateSustainableVideoBitrate(_throughput, 0);
        return bitrate;
    }

    function _calculateNormalizedBandwidth() {
        return this.getThroughputKbps();
    }

    function _getThroughput60() {
        if (_throughput60samples > 60) {
            _throughput60Timer.clearTimer();
        } else {
            _throughput60 = (_throughput60 * _throughput60samples + _throughput)/(_throughput60samples + 1);
            _throughput60samples += 1;
        }
    }
}






// -- heuristics/DownloadFailureMonitor.js
/**
* @constructor
*/
function DownloadFailureMonitor(failureThreshhold) {
    var _self = this,
        _failureThreshold = failureThreshhold,
        _failureMap = {};

    this.updateFailures = _updateFailures;

    this.clearFailures = _clearFailures;

    this.shouldPerformCDNSelect = _shouldPerformCDNSelect;

    //--------------------------------------
    // Private implementation
    function _updateFailures(cdn, chunk, stream) {
        debug$assert(chunk && stream);

        var id = stream.type + "_" + chunk.index,
            key = cdn.name + "_" + id;
        _failureMap[key] = _failureMap[key] ? _failureMap[key] + 1 : 1; 
    }

    function _clearFailures() {
        _failureMap = {};
    }

    function _shouldPerformCDNSelect(cdn) {
        return Object.keys(_failureMap)
            .some(function (key) {
                var val = _failureMap[key];
                return key.indexOf(cdn.name) > -1 && val > _failureThreshold;
            });
    }
}


    // >>>>>>>>>>>>>>>> END PARALLEL <<<<<<<<<<<<<<<<

// -- player/parseChunkMedia.js
function MediaDownloader$parseChunkMedia(content) {
    return parseChunkMedia(new Uint8Array(content));
};

function SubChunkDownloadJobManager$parseChunkMedia(content) {
    return parseChunkMedia(content);
}

function parseChunkMedia(content) {
    // verify that downloaded data is MOOF/MDAT pairs
    var buffer = content,
        boxes = parseMp4(buffer),
        box,
        tfhd,
        saio,
        auxDataBox;

    for (var i = 0; i < boxes.length; i += 2) {
        box = boxes[i];
        if (!(box.type == 'moof' && boxes[i + 1].type == 'mdat')) {
            throw new Error('data is not moof-mdat box pairs');
        }
        if (config.workaroundSaio) {
            // HACK: workaround MP-823
            if (box.type == 'moof') {
                saio = box.getDescendant('traf/saio');
                auxDataBox = box.getDescendant('traf/' + Box$sampleEncryptionType);
                if (saio && auxDataBox) {
                    var sampleInfoOffset = auxDataBox.auxData.byteOffset - box.raw.byteOffset;
                    if (saio.sampleInfoOffsets[0] != sampleInfoOffset) {
                        DEBUG && log.debug('Repairing bad SAIO');
                        parseChunkMedia$overwriteSampleInfoOffset(saio, sampleInfoOffset);
                    }
                }
            }
        }
        if (config.workaroundAudioKeyFrame) {
            // HACK: workaround tfhd 
            if (box.type == 'moof') {
                tfhd = box.getDescendant('traf/tfhd');
                var defaultSampleFlags = tfhd.defaultSampleFlags;
                if (defaultSampleFlags && defaultSampleFlags.sampleIsDifferenceSample) {
                    DEBUG && log.debug('Applying sampleIsDifferenceSample workaround', { 'Box': 'tfhd' });
                    parseChunkMedia$overwriteSampleIsDifferenceSample(tfhd, false);
                }
            }
        }
    }
    return buffer;
}

function parseChunkMedia$overwriteSampleInfoOffset(saio, sampleInfoOffset) {
    // mimics saio reading logic in mp4 parser
    var stream = new DataStream(saio.raw);
    stream.seek(saio.size - saio.contentLength);
    var version = stream.readNumber(1);
    var flags = stream.readNumber(3);                        
    if (flags & 0x01) {
        stream.readUInt();
        stream.readUInt();
    }
    var fieldSize = version >= 1 ? 8 : 4;
    stream.readUInt();
    stream.writeNumber(sampleInfoOffset, fieldSize);
}

function parseChunkMedia$overwriteSampleIsDifferenceSample(box, b) {
    // find were flags are and overwrite the stream.
    // mimics tfhd and trex reading logic in mp4 parser
    var stream = new DataStream(box.raw);
    stream.seek(box.size - box.contentLength);
    var version = stream.readNumber(1);
    var flags = stream.readNumber(3);       
    stream.readUInt();
    var flagBytes;
    switch(box.type) {
        case 'tfhd':
            if (flags & 0x01) stream.readULong();
            if (flags & 0x02) stream.readUInt();
            if (flags & 0x08) stream.readUInt();
            if (flags & 0x10) stream.readUInt();
            if (flags & 0x20) {
                flagBytes = stream.readArray(2);
            }
            break;
        case 'trex':
            stream.readUInt();
            stream.readUInt();
            stream.readUInt();        
            flagBytes = stream.readArray(2);
            break;
    }
    debug$assert(flagBytes);
    if (flagBytes) {
        flagBytes[1] = b ? (flagBytes[1] | 1) : (flagBytes[1] & 0xFE);
    }
}


// -- player/TimedTextTrack.js
/**
 * @constructor
 */
function TimedTextTrack(playback, trackId, downloadableId, downloadUrls, bcp47, displayName, trackType, nccpTrackType, nccpProfile, midx, isNone, isForced, decryptionKey) {
    var _log = new playback.log.CategoryLog('TimedTextTrack'),
        _state = TimedTextTrack$STATE_NOT_LOADED,
        _logFields = {
            'Bcp47': bcp47,
            'TrackId': trackId,
            'DownloadableId': downloadableId
        },
        _getEntriesDelegate = Function$makeMulticast(_retreiveEntries),
        _isImageBased = nccpProfile && (nccpProfile == timedTextProfile$NFLX_CMISC || nccpProfile == timedTextProfile$NFLX_CMISC_ENC),
        _imageSubtitleManager,
        _currentCdnId,
        _entries;
    // --------------------------------------------------------------------------------
    // -- internal api

    var _self = {
        type: CadmiumMediaStream$TIMEDTEXT,
        trackId: trackId,
        trackType: trackType,
        nccpTrackType: nccpTrackType,
        nccpProfile: nccpProfile,
        downloadableId: downloadableId,
        bcp47: bcp47,
        displayName: displayName,
        getEntries: _getEntries,
        getState: function() { return _state;},
        logFields: _logFields,
        isImageBased: _isImageBased,
        getImageSubtitleManager: function getImageSubtitleManager() {
            return _imageSubtitleManager
        },
        getSubtitlesList: _getSubtitlesList,
        isNone: function() {
            return isNone;
        },
        isForced: function() {
            return isForced;
        }
    };
    return _self;

    // --------------------------------------------------------------------------------
    // -- private implementation


    function _getEntries(callback) {
        _getEntriesDelegate(function(result) {
            callback(result);
        });
    }

    function _retreiveEntries(callback) {
        _state = TimedTextTrack$STATE_LOADING;

        if (playback.state.value != Playback$STATE_LOADING) {
            doDownload();
        } else {
            // wait for normal state
            playback.state.addListener(onPlaybackStateChanged);
        }

        function onPlaybackStateChanged() {
            playback.state.removeListener(onPlaybackStateChanged);
            // if next state isn't loading, then playback errored our or was closed
            doDownload();
        };

        function _getLogFields(s){
            var logFields = mixIn({
                'currentPts': playback.mediaPresenter.getElementTime(),
            },s);
            delete logFields['imageData'];
            return logFields;
        }
        function doDownload() {
            if (playback.state.value == Playback$STATE_NORMAL) {
                if (_isImageBased) {
                    _initializeImageSubtitleManager(function(result) {
                        if (result.success) {
                            // TODO loggin for midx properties
                            _log.info('Loaded image subtitle manager');
                        } else {
                            _log.error('Unable to load image subtitles manager', result); // capture actual error
                            _state = TimedTextTrack$STATE_LOAD_FAILED;
                            _getEntriesDelegate = Function$makeMulticast(_retreiveEntries);
                        }
                        callback(result);
                    });
                } else {
                    _downloadEntries(function(result) {
                        if (result.success) {
                            _log.trace('Entries parsed', {
                                'Length': result.entries.length
                            }, _logFields);
                            _self.cdn = result.cdn;
                            _state = TimedTextTrack$STATE_LOADED;
                        } else {
                            _log.error('Unable to retreive timed text track', ErrorSubCodes$errorResultToLogFields(result), _logFields, {'url': result.url});
                            _state = TimedTextTrack$STATE_LOAD_FAILED;
                            // reset the delegate, so next time we are asked for entries, we retry the downloads
                            _getEntriesDelegate = Function$makeMulticast(_retreiveEntries);
                        }
                        callback(result);
                    });
                }
            } else {
                callback({});
            }
        }
    }

    function _downloadEntries(callback) {
        // downloadUrls can either be a cdnId -> URL map, or a fixed url, or actual list of parsed entries
        // first check for a fixed URL
        if (isString(downloadUrls)) {
            _downloadFromCdn(downloadUrls, undefined, callback);
            return;
        }
        // if it's actual array of entries, we are done
        if (isArray(downloadUrls)) {
            callback({
                success: true,
                entries: downloadUrls,
                track: _self
            });
            return;
        }

        // download is an async process, and something might change the playback.primaryCdn
        // so we need to keep track of CDN-s we tried, instead of simple index iteration
        var attemptsPerCdn = {};
        var currentCdnId, 
            currentUrl;

        function tryNextCdnOrCallback(result) {
            var errorLogFields = {},
                willRetry,
                status;
            if (result.success) {
                // if we have a successfull result, we are done
                callback(result);
                return;
            } else if (!result.initialRequest) {
                errorLogFields = _getLogFields(currentCdnId, currentUrl, 'text');
                errorLogFields['errorstring'] = result.reason;
                if(currentCdnId && attemptsPerCdn[currentCdnId] <= config.timedTextDownloadRetryCountBeforeCdnSwitch){
                    willRetry = true;
                    status = 'retry with current cdn';
                }
            }

            // otherwise, pick a CDN we haven't tried yet and try it
            var cdn, url, i;
            for (i = 0; i < playback.cdnList.length; i++) {
                cdn = playback.cdnList[i];
                url = downloadUrls[cdn.id];
                if (!(attemptsPerCdn[cdn.id] > config.timedTextDownloadRetryCountBeforeCdnSwitch) && url) {
                    // found a CDN we haven't tried yet, break and use it
                    break;
                } else {
                    // don't use this CDN
                    cdn = null;
                }
            }

            // do we have a CDN we can try download from?
            if (cdn && url) {
                // mark it as attempted
                if(currentCdnId !== cdn.id){
                    status = 'retry with next cdn';
                    willRetry = true;
                }
                currentCdnId = cdn.id;
                currentUrl = url;
                attemptsPerCdn[cdn.id] = (attemptsPerCdn[cdn.id] || 0) + 1;
                // and try it
                _downloadFromCdn(url, cdn, tryNextCdnOrCallback);
            } else {
                // no more CDNs left, we are done
                willRetry = false;
                status ='all cdns tried';
                callback(result);
            }
            if (!result.success && !result.initialRequest) {
                _fireErrorEvent(errorLogFields, willRetry, status);
            }
        };

        tryNextCdnOrCallback({
            success: false,
            initialRequest: true
        });
    }

    function _downloadFromCdn(url, cdn, callback) {
        function parseContent(content) {
            var videoSize = playback.videoSize;
            debug$assert(videoSize);
            parseDfxpXml(
                content,
                videoSize.width / videoSize.height,
                config.timedTextStyleDefaults,
                config.timedTextStyleOverrides,
                function(result) {
                    if (result.success) {
                        var entries = result.entries;
                        var timedTextTimeOverride = config.timedTextTimeOverride;

                        if (timedTextTimeOverride) {
                            // override the times
                            var time = 0;
                            entries.forEach(function(entry) {
                                entry['startTime'] = time;
                                entry['endTime'] = (time += timedTextTimeOverride);
                            });
                        }
                        _entries = entries;
                        callback({
                            success: true,
                            entries: entries,
                            cdn: cdn,
                            track: _self
                        });
                    } else {
                        result.url = mediaRequest.url;
                        result.reason = 'parseerror';
                        result.track = _self;
                        callback(result);
                    }
                });
        }

        function decryptContent(content) {
            var algorithm = {'name': 'AES-CBC'};
            return window['netflix']['crypto']['importKey']('raw', base64$decode(decryptionKey), algorithm, false, ["encrypt", "decrypt"])
            .then(function (key) {
                var iv = new Uint8Array(content, 0, 16);
                algorithm = {'name': 'AES-CBC', 'iv': iv};
                var data = new Uint8Array(content, 16);
                return window['netflix']['crypto']['decrypt'](algorithm, key, data)
                .then(function (content) {
                    content = new Uint8Array(content);
                    content = utf8$getString(content);
                    return content;
                });
            });
        }

        _log.trace('Downloading', cdn && {
            'cdn': cdn.id
        }, _logFields);
        var mediaRequest = {
            responseType: decryptionKey ? http$RESPONSETYPE_BINARY : http$RESPONSETYPE_TEXT,
            url: url,
            track: _self,
            cdn: cdn,
            diagCaption: 'tt-' + bcp47
        };

        playback.httpPlayback.download(mediaRequest, function(response) {
            if (response.success) {
                if(decryptionKey) {
                    decryptContent(response.content)
                    .then(function (content) {
                        parseContent(content);
                    })
                    .catch(function (e) {
                        response.success = false;
                        response.reason = 'decrypt failed';
                        response.track = _self;
                        callback(response);
                    });
                } else {
                    parseContent(response.content);
                }
            } else {
                response.reason = 'downloadfailed';
                response.url = mediaRequest.url;
                response.track = _self;
                callback(response);
            }
        });
    }

    function _initializeImageSubtitleManager(callback){
        var options = {
            autostart: false,
            profile: nccpProfile,
            midxOffset: midx.offset,
            midxSize: midx.length,
            pts: playback.mediaTime.value || 0,
            bufferSize: config.imageSubsMaxBuffer,
            crypto: window['netflix']['crypto'],
            key: decryptionKey && base64$decode(decryptionKey)
        };
        var logger = new playback.log.CategoryLog('TimedTextTrack');
        logger.warn = logger.trace.bind(logger);
        logger.info = logger.debug.bind(logger);
        var platform = {
            getPts: function() {
                return playback.mediaPresenter.getElementTime();
            },
            logger: logger,
            request: _requestFunction,
            isDebug: DEBUG
        };
        
        var cdnIds = Object.keys(downloadUrls),
            cdnIndex = 0,
            attemptsPerCdn = {};

        function loadMidx(cdnId) {
            if (!isDefined(cdnId)) { //in case nccp resp does not contain the cdnId in downloadUrl
                callback({
                    success: false,
                    'msg': 'cdnId is not defined for image subs downloadUrl'
                });
                _fireErrorEvent(_getLogFields('', '', 'image'), false, 'cdnId is undefined');
                return;
            }
            
            midx.url = downloadUrls[_currentCdnId];
            options.url = midx.url;
            attemptsPerCdn[cdnId] = (attemptsPerCdn[cdnId] || 0) + 1;

            var subtitleManager = new SubtitleManager(platform, options);
            subtitleManager.on('ready', function() {
                _imageSubtitleManager = subtitleManager;
                callback({
                    success: true,
                    track: _self
                });
            });
            subtitleManager.on('error', function(err) {
                var result = {
                    'success': false
                };
                for (var x in err) {
                    result[x] = err[x];
                }
               
                var errorLogFields = _getLogFields(_currentCdnId, midx.url, 'image');
                errorLogFields['details'] = {
                    'midxoffset': midx.offset,
                    'midxsize': midx.length,
                };
                errorLogFields['errorstring'] = result['errorString'];


                if (attemptsPerCdn[cdnId] <= config.timedTextDownloadRetryCountBeforeCdnSwitch) {
                    _fireErrorEvent(errorLogFields, true, 'retry with current cdn');
                    loadMidx(_currentCdnId)
                } else {
                    _currentCdnId = cdnIds[cdnIndex++];
                    if (_currentCdnId) {
                        _fireErrorEvent(errorLogFields, true, 'retry with next cdn');
                        loadMidx(_currentCdnId);
                    } else {
                        _fireErrorEvent(errorLogFields, false, 'all cdns tried');
                        callback({
                            success: false,
                            'msg': 'all cdns failed for image subs',
                            track: _self
                        });
                    }
                }
            });
        }
        _currentCdnId = cdnIds[cdnIndex++];
        loadMidx(_currentCdnId);
    }

    function _requestFunction(options, callback) {
        _log.trace('Downloading', options);
        var mediaRequest = {
            url: options.url,
            offset: options.offset,
            length: options.size,
            responseType: http$RESPONSETYPE_BINARY,
            headers: {},
            cdn: _getCdnFromCdnId(_currentCdnId)
        };

        playback.httpPlayback.download(mediaRequest, function(response) {
            _log.trace('imgsub: request status ' + response.success);
            if (response.success) {
                callback(null, new Uint8Array(response.content))
            } else {
                callback({
                    'errorSubCode': response.errorSubCode,
                    'errorExternalCode':  response.errorExternalCode
                });
            }
        })
    }

    function _getCdnFromCdnId(id){
        // memoization TODO
        if(playback.cdnList){
            return playback.cdnList.filter(function(cdn){
                return cdn.id == id;
            })[0];
        }
    }

    function _getLogFields(cdnId, url, subtitletype) {
        var result = {};
        try {
            result = {
                'currentCdnId': cdnId,
                'url': url,
                'profile': nccpProfile,
                'dlid': downloadableId,
                'subtitletype': subtitletype,
                'bcp47': bcp47,
                'cdnCount': Object.keys(downloadUrls).length
            };
        } catch (e) {
            _log.warn('Error accummulating data', e);
        }
        return result;
    }

    function _fireErrorEvent(fields, willRetry, status) {
        fields['willRetry'] = willRetry;
        fields['status'] = status;
        playback.fireEvent(Playback$subtitleError, fields);
        _log.warn('subtitleerror event', fields);
    }
    // TODO Optimize this using binary search. this will be used in each range for midplay and endplay.
    function _getSubtitlesList(start, end) {
        var subtitles;
        try {
            if (_isImageBased) {
                subtitles = _imageSubtitleManager ? _imageSubtitleManager.getSubtitlesList(start, end) : undefined;
            } else {
                if (_entries) {
                    subtitles = _entries.filter(function(e) {
                        var entryStartTime = e['startTime'],
                            entryEndTime = e['endTime'];
                        return (entryStartTime >= start && entryStartTime <= end) || (entryStartTime <= start && start <= entryEndTime)
                    });
                } // else entries were not initialized
            }
        } catch (e) {
            _log.error('error in getSubtitles', e, {
                'start': start,
                'end': end,
                'isImageBased': _isImageBased
            });
        }
        return subtitles;
    }
};

var TimedTextTrack$NEGLIGIBLE_TIME = 10;

var TimedTextTrack$STATE_NOT_LOADED = 0,
    TimedTextTrack$STATE_LOADING = 1,
    TimedTextTrack$STATE_LOADED = 2,
    TimedTextTrack$STATE_LOAD_FAILED = 3;



// -- player/TimedTextManager.js
/**
* @constructor
*
* Figures out which timed text entries should be active now, 
* and sets playback.timedText
*/
function TimedTextManager(playback) {
    var _log = new playback.log.CategoryLog('TimedTextManager'),
        _self = this,
        _stateEntries = {},
        _entries,
        _timedTextTimer = new TimedTextTimer(),
        _nEntriesDisplayed = 0,
        _sumOfDelays = 0,
        _oldTrack,
        _eventSource = new EventSource(),
        _imageSubtitleManager,
        _getCurrentPts = playback.mediaPresenter.getElementTime,
        _utils = utils, // nf-utils
        _subtitleTracker = new SubtitleTracker(new playback.log.CategoryLog('SubtitleTracker'), config.enableSubtitleTrackerLogging, {
            mixIn: _utils.mixIn,
            debugAssert: debug$assert
        }),
        _currentlyShowing = Object['create'](null),
        _closing = false,
        _retryCount = 0,
        _retryTimer;
         
    this.averageSubtitleDelay = null;
    _self.addEventListener = _eventSource.addListener;
    _self.removeEventListener = _eventSource.removeListener;
    _self.fireEvent = _eventSource.fire;
    // --------------------------------------------------------------------------------
    // -- internal api

    this.addCustomTrack = _addCustomTrack;
    this.getSubtitleQoeScore = function(pts) {
        return _subtitleTracker.getScore(pts);
    };
    this.getSubtitleQoe = function(pts){
        return _subtitleTracker.getSubtitleQoe(pts);
    };

    // --------------------------------------------------------------------------------
    // -- private implementation

    // special kind of entries for when file isn't downloaded
    _stateEntries[TimedTextTrack$STATE_LOADING] = { loading: true };
    _stateEntries[TimedTextTrack$STATE_LOAD_FAILED] = { failed: true };

    playback.timedTextTrack.addListener(_timeTextTrackChanged);
    playback.addEventListener(Playback$playbackstart, _timeTextTrackChanged);
    playback.presentingState.addListener(_sync);
    playback.addEventListener(Playback$throttledMediaTimeChanged, _sync);

    playback.addEventListener(Playback$repositioned, function(args) {
        _subtitleTracker.seekBegin(_getCurrentPts());
    });

    playback.addEventListener(MediaPresenter$seeked, function(args) {
        var subtitle = playback.timedText.value,
            currentSubs = [];
        if (subtitle && isDefined(subtitle['id'])) {
            currentSubs.push(subtitle['id']);
        }
        var currentTrack = playback.timedTextTrack.value;
        // Special handling for the track that means subtitles off

        if (currentTrack && currentTrack.isNone() && (!currentTrack.isForced()) ) {
            currentTrack = undefined;
        }
        if(_imageSubtitleManager){
            currentSubs = Object['keys'](_currentlyShowing);
        }
        _subtitleTracker.seekComplete(_getCurrentPts(), currentTrack, currentSubs);
    });
    
    // keep track here, because onActiveEntry update can cause duplicates.
    playback.timedText.addListener(function(args) {
        var subtitle = args.newValue;
        if (subtitle && isDefined(subtitle['id'])) {
            _subtitleTracker.updateWithSubtitle(subtitle['id']); //capture the ids
            if (DEBUG) {
                _log.debug('timed text changed qoe, pts:' + playback.mediaPresenter.getElementTime() + ': ' + subtitle['id']);
            }
        }
    });

    playback.addEventListener(Playback$closing, function timedTextManager_handleClosing() {
        _entries = undefined;
        _clearImageSubtitleManager();
        _timedTextTimer.stop();
        _updateActiveEntry();
        _closing = true;
        _resetRetryControl();
    });

    _timedTextTimer.getMediaTime = _getCurrentPts;
    _timedTextTimer.onactiveentryupdated = _updateActiveEntry;

    function _sync() {
        _timedTextTimer.start();
        if (playback.presentingState.value != PresentingState$PLAYING) {
            _timedTextTimer.stop();
        }
    }

    function _timeTextTrackChanged() {
        var currentPts = _getCurrentPts();
        _resetRetryControl(); //explicit change for timed text track. we can clear the timer.
        if (_oldTrack) {
            _log.info('Deactivating', _oldTrack);
            _subtitleTracker.deActivating(_getCurrentPts(), _oldTrack);
        }
        playback.activeTimedTextTrack.set(null);
        _timedTextTimer.setEntries(_entries = undefined);
        _clearImageSubtitleManager();
        
        var newTrack = playback.timedTextTrack.value;
        // Special handling for the track that means subtitles off
        if (newTrack && (newTrack.isNone()) && (!newTrack.isForced())) {
            newTrack = undefined;
        }
        _subtitleTracker.activating(_getCurrentPts(), newTrack);
        if (newTrack) {
            _log.info('Activating', newTrack);
             newTrack.getEntries(_getEntriesCallback);    
        }
        _oldTrack = newTrack;
        _updateActiveEntry();
    }
    function _resetRetryControl(){
       _retryCount = 0; 
       clearTimeout(_retryTimer);
    }
    function _getEntriesCallback(result) {
        if(_closing){
            return;
        }
        var track = result.track,
            willRetry;

        if (track == playback.timedTextTrack.value) {
            if(track.isImageBased){
                if(result.success){
                    _resetRetryControl();
                    _imageSubtitleManager = track.getImageSubtitleManager();
                    _manageImageSubtitleEventHandlers('addListener');
                    _log.info('Activated', track);
                    playback.activeTimedTextTrack.set(track);
                    // dispatch since the UI is yet to bind event handlers.
                    dispatch(function() {
                        _imageSubtitleManager.updatePts(_getCurrentPts());
                    });
                }else{
                    willRetry = !!(_retryCount < config.maxRetriesTimedTextDownload);
                    if (willRetry) {
                        _retryTimer = setTimeout(retryTrackInitialization.bind(null, track), config.timedTextRetryInterval);
                    }
                    _log.error('Failed to activate img subtitle, retry=' + willRetry, result, track);
                }
            }else{
                var newEntries = result.entries;
                if (newEntries) {
                    _resetRetryControl();
                    _timedTextTimer.setEntries(_entries = newEntries);
                    _log.info('Activated', track);
                    playback.activeTimedTextTrack.set(track);
                } else {
                    willRetry = !!(_retryCount < config.maxRetriesTimedTextDownload);
                    if (willRetry) {
                        _retryTimer = setTimeout(retryTrackInitialization.bind(null, track), config.timedTextRetryInterval);
                    }
                    _log.error('Failed to activate, retry=' + willRetry, ErrorSubCodes$errorResultToLogFields(result), track);
                }
                _updateActiveEntry();
            }
        }
    }

    function retryTrackInitialization(track){
        _retryCount++;
        track.getEntries(_getEntriesCallback);
    }

    function _updateActiveEntry() {
        var activeEntry;

        if (playback.state.value == Playback$STATE_NORMAL && playback.presentingState.value != PresentingState$WAITING) {
            if (_entries) {
                activeEntry = _timedTextTimer.getActiveEntry();
            } else {
                // if we don't have the entries loaded, set it to one of the special entries
                // which indicate 'loading' or 'failed'
                if (playback.timedTextTrack.value) {
                    // if we don't have the entries loaded, set it to one of the special entries
                    // which indicate 'loading' or 'failed'
                    activeEntry = _stateEntries[playback.timedTextTrack.value.getState()];
                }
            }
        }
        if (activeEntry && isDefined(activeEntry['startTime'])) { //startTime can be zero though rare.
            _nEntriesDisplayed++;
            _sumOfDelays += (_timedTextTimer.getMediaTime() - activeEntry['startTime']); // add in the current delay
            _self.averageSubtitleDelay = Math$ceil(_sumOfDelays / (_nEntriesDisplayed + 0.0));
        }

        playback.timedText.set(activeEntry);
    }

    function _addCustomTrack(urlOrEntries, name) {
        var trackId = 'custom' + (++TimedTextManager$customTimedTextCounter);
        var track = new TimedTextTrack(
            playback,
            trackId,
            '1',
            urlOrEntries,
            'xx',
            name || trackId,
            TrackType$PRIMARY,
            'primary',
            'custom',
            {},
            false,
            false,
            undefined
        );
        playback.timedTextTrackList.push(track);
        playback.audioTrackList.forEach(function (audioTrack) {
            Array$pushIfDoesntContain(audioTrack.timedTextTrackList, track);
        });
        playback.fireEvent(Playback$timedTextTrackListChanged);
        return track;
    }

    function _clearImageSubtitleManager() {
        if (_imageSubtitleManager) {
            _imageSubtitleManager.stop();
            _manageImageSubtitleEventHandlers('removeListener');
        }
        _imageSubtitleManager = undefined;
    }

    function _showHandler(s) {
        _self.fireEvent(TimedTextManager$showsubtitle, s);
        if (s && s['id']) {
            _subtitleTracker.updateWithSubtitle(s['id']);
            if (DEBUG) {
                _log.debug('timed text changed qoe, pts:' + playback.mediaPresenter.getElementTime() + ': ' + s['id']);
            }
            _currentlyShowing[s['id']] = 1;
        }
        _log.trace('showsubtitle', _getSubtitleLogFields(s));
    }

    function _removeHandler(s) {
        _self.fireEvent(TimedTextManager$removesubtitle, s);
        if (s && s['id']) {
            delete _currentlyShowing[s['id']];
        }
        _log.trace('removesubtitle', _getSubtitleLogFields(s));
    }

    function _getSubtitleLogFields(s) {
        return {
            'currentPts': _getCurrentPts(),
            'displayTime': s['displayTime'],
            'duration': s['duration'],
            'id': s['id'],
            'originX': s['originX'],
            'originY': s['originY'],
            'sizeX': s['sizeX'],
            'sizeY': s['sizeY'],
            'rootContainerExtentX': s['rootContainerExtentX'],
            'rootContainerExtentY': s['rootContainerExtentY']
        }
    }

    function _updateImageSubtitleManagerPts() { 
        _imageSubtitleManager.updatePts(_getCurrentPts());
    }

    function _pauseImageSubtitleManager(){
        _imageSubtitleManager.pause();
    }

    function _manageImageSubtitleEventHandlers(methodName) {
        _imageSubtitleManager[methodName]('showsubtitle', _showHandler);
        _imageSubtitleManager[methodName]('removesubtitle', _removeHandler);
        if(methodName == 'addListener'){
            playback.addEventListener(MediaPresenter$currentTimeChanged,_updateImageSubtitleManagerPts);
            playback.addEventListener(MediaPresenter$paused, _pauseImageSubtitleManager);
        }else{
            playback.removeEventListener(MediaPresenter$currentTimeChanged,_updateImageSubtitleManagerPts);
            playback.removeEventListener(MediaPresenter$paused, _pauseImageSubtitleManager);
        }
        // add playback pause/resume event handler for subtitle manager pause/resume TODO
    }
};

var TimedTextManager$customTimedTextCounter = 0,
    TimedTextManager$showsubtitle = 'showsubtitle',
    TimedTextManager$removesubtitle = 'removesubtitle';



// -- player/TimedTextPresenter.js
/**
* @constructor
*
* Renders playback.timedText as HTML.
*/
function TimedTextPresenter(playback) {
    var _rootElement = playback.rootElement,
        _timedTextHtmlPresenter = new TimedTextHtmlPresenter(config.timedTextFontFamilyMapping);
        
    var videoSize = playback.videoSize;
    debug$assert(videoSize.width / videoSize.height > 0.1);
    _timedTextHtmlPresenter.setAspect(videoSize.width / videoSize.height);
    _rootElement.appendChild(_timedTextHtmlPresenter.getElement());

    playback.timedText.addListener(_onTimedTextChanged);
    playback.addEventListener(Playback$closing, _onClosing);
    globalEvents.addListener(globalEvents$resize, _onResize);

    this.setTimedTextBounds = _timedTextHtmlPresenter.setTimedTextBounds;

    function _onClosing() {
        globalEvents.removeListener(globalEvents$resize, _onResize);
        _rootElement.removeChild(_timedTextHtmlPresenter.getElement());
    }

    function _onTimedTextChanged(args) {
        var videoSize = playback.videoSize;
        _timedTextHtmlPresenter.setEntry(args.newValue);
    }

    function _onResize() {
        _timedTextHtmlPresenter.render();
    }
};



// -- player/TimedTextCustomTrack.js
Playback$registerComponent(Playback$COMPONENT_WHEN_LOADED, function loadTimedTextCustomTrack(playback) {

    var _log = new playback.log.CategoryLog('TimedTextCustomTrack');

    if (config.customDfxpUrl) {
        // if there is a custom track, load it
        _log.info('Loading url', { 'Url': config.customDfxpUrl });
        var track = playback.timedTextManager.addCustomTrack(config.customDfxpUrl, 'custom');
        playback.timedTextTrack.set(track);
    }

    globalEvents.addListener(globalEvents$keydown, onkeydown);

    playback.addEventListener(Playback$closing, function () {
        globalEvents.removeListener(globalEvents$keydown, onkeydown);
    });

    function onkeydown(event) {
        if (event.ctrlKey && event.altKey && event.shiftKey && event.keyCode == 84) {
            var el = createElement('INPUT', undefined, undefined, { 'type': 'file' });
            el.addEventListener('change', function () {
                var f = el.files[0];
                if (f) {
                    var fileName = f['name'];
                    _log.info('Loading file', { 'FileName': fileName });
                    var reader = new FileReader();
                    reader.readAsText(f);
                    reader.addEventListener('load', function () {
                        var videoSize = playback.videoSize;
                        parseDfxpXml(
                            reader.result,
                            videoSize.width / videoSize.height,
                            config.timedTextStyleDefaults,
                            config.timedTextStyleOverrides,
                            function (result) {
                                if (result.success) {
                                    var entries = result.entries;
                                    var track = track = playback.timedTextManager.addCustomTrack(entries, fileName);
                                    playback.timedTextTrack.set(track);
                                } else {
                                    _log.error('Inavlid custom DFXP');
                                }
                            });
                    });
                }
            });
            el.click();
        }
    };

});



// -- player/PlayTimeTracker.js
/**
* @constructor
*/
function PlayTimeTracker(playback) {
    var _log = new playback.log.CategoryLog('PlayTimeTracker'),
        _currentAudio,
        _currentVideo,
        _currentTimedText,
        _playedAudio = [],
        _playedVideo = [],
        _playedTimedText = [],
        _startTime = playback.mediaTime.value,
        _averageBitrates = {},
        _doneTrackingAbrDel = false,
        _abrs = {},
        _intrplayWaitTime = 0,
        _logPoints = config.abrdelLogPointsSeconds,
        _logPointsLen = _logPoints.length;

    // --------------------------------------------------------------------------------
    // -- initialization & public api

    _wireEvents();

    // Initialize structure to track average bitrates delivered
    _averageBitrates['abrdel'] = 0;
    while (_logPointsLen--) {
        _abrs['abrdel' + _logPoints[_logPointsLen]] = 0;
        _averageBitrates['abrdel' + _logPoints[_logPointsLen]] = 0;
    }

    
    mixIn(this, /** @lends {PlayTimeTracker.prototype} */ {
        getTotalPlayTime: _getTotalPlayTime,
        getAudioVideoPlayTimeByCdnAndDownloadableId: _getAudioVideoPlayTimeByCdnAndDownloadableId,
        getPlayTimeByDownloadableId: _getPlayTimeByDownloadableId,
        getAverageBitrateDelivered: _getAverageBitrateDelivered,
        getAverageVmafDelivered: _getAverageVmafDelivered,
        getAverageBitrateDeliveredAtTimes: _getAverageBitrateDeliveredAtTimes,
        addIntrplayWaitTimeMs: _addIntrplayWaitTimeMs,
        getIntrplayWaitTimeMs: _getIntrplayWaitTimeMs,
        hasVmaf: _hasVmaf
    });
    

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _addIntrplayWaitTimeMs(waitTime){
        _intrplayWaitTime += waitTime;
    }

    function _getIntrplayWaitTimeMs(){
        return _intrplayWaitTime;
    }
    
    // Assume video has vmaf is first video segment has vmaf score
    function _hasVmaf() {
        return !!(_playedVideo[0] && _playedVideo[0].stream && isDefined(_playedVideo[0].stream.vmaf));
    }

    // returns total time we spent playing in milliseconds
    function _getTotalPlayTime() {
        _sliceAll(playback.mediaTime.value);
        // use video for calculating total
        var totalPlayTime = 0;
        var i = _playedVideo.length;
        while (i--) {
            totalPlayTime += (_playedVideo[i].endTime - _playedVideo[i].startTime);
        }
        debug$assert(totalPlayTime === Math$floor(totalPlayTime), "Value of totalPlayTime is not an integer.");
        return parseInt(Math$floor(totalPlayTime));
    }

    function _getAudioVideoPlayTimeByCdnAndDownloadableId() {
        _sliceAll(playback.mediaTime.value);
        return {
            'audio': PlayTimeTracker$_aggregatePlayTime(_playedAudio, PlayTimeTracker$_downloadableIdAndCdnAggregateFunction),
            'video': PlayTimeTracker$_aggregatePlayTime(_playedVideo, PlayTimeTracker$_downloadableIdAndCdnAggregateFunction)            
        };
    }

    function _getPlayTimeByDownloadableId() {
        var playTimes = {
            'total': _getTotalPlayTime(),
            'audio': PlayTimeTracker$_aggregatePlayTime(_playedAudio, PlayTimeTracker$_downloadableIdAggregateFunction),
            'video': PlayTimeTracker$_aggregatePlayTime(_playedVideo, PlayTimeTracker$_downloadableIdAggregateFunction),
            'timedtext': PlayTimeTracker$_aggregatePlayTime(_playedTimedText, PlayTimeTracker$_downloadableIdAggregateFunction)
        };

        debug$assert(playTimes['audio'][0] && playTimes['video'][0]);

        return playTimes;
    }
    
    // Returns null and logs warning if a single video segment does not have a bitrate
    function _getAverageBitrateDelivered() {
        _sliceAll(playback.mediaTime.value);
        // use video for calculating total
        var videoSegments = PlayTimeTracker$_aggregatePlayTime(_playedVideo, PlayTimeTracker$_bitrateAggregateFunction);
        var averageBitrate;

        try {
            averageBitrate = PlayTimeTracker$_averageTimeWeightedMetricFromSegments(videoSegments);
        } catch (e) {
            _log.warn('Failed to calc average bitrate');
            return null;
        }

        _averageBitrates['abrdel'] = Math$round(averageBitrate);
        return _averageBitrates['abrdel'];
    }
    
    // Returns null and logs warning if a single video segment does not have a vmaf score
    function _getAverageVmafDelivered() {
        _sliceAll(playback.mediaTime.value);
        // use video for calculating total
        var videoSegments = PlayTimeTracker$_aggregatePlayTime(_playedVideo, PlayTimeTracker$_vmafAggregateFunction);
        var averageVmaf;

        try {
            averageVmaf = PlayTimeTracker$_averageTimeWeightedMetricFromSegments(videoSegments);
        } catch (e) {
            _log.warn('Failed to calc average vmaf');
            return null;
        }

        return Math$round(averageVmaf);
    }

    function _onRepositioning(args) {
        _sliceAll(args.oldMediaTime);
        _startTime = args.newMediaTime;
        _currentAudio = undefined;
        _currentVideo = undefined;
        if (_currentTimedText) {
            // for timed text, since it's one big chunk for whole movie
            // make it start from new position for tracking
            _currentTimedText.startTime = _startTime;
        }
        DEBUG && _log.debug('Reposition', { 'OldMediaTime': Number$formatMillisecond(args.oldMediaTime), 'NewMediaTime': Number$formatMillisecond(args.newMediaTime) });
    }

    function _onActiveTimedTextTrackChanged(args) {
        var mediaTime = playback.mediaTime.value;
        _pushCurrent(_currentTimedText, _playedTimedText, mediaTime);
        _currentTimedText = !args.newValue ? undefined : {
            cdn: args.newValue.cdn,
            track: args.newValue,
            startTime: playback.mediaTime.value,
            endTime: MAX_MEDIA_TIME
        };
    }

    function _sliceAll(upToMediaTime) {
        if (_currentAudio && _currentVideo) {
            // ignore media time progress past _currentXxxxx.endTime
            upToMediaTime = Math$min(upToMediaTime, _currentAudio.endTime);
            upToMediaTime = Math$min(upToMediaTime, _currentVideo.endTime);

            _pushCurrent(_currentAudio, _playedAudio, upToMediaTime);
            _currentAudio.startTime = upToMediaTime;

            _pushCurrent(_currentVideo, _playedVideo, upToMediaTime);
            _currentVideo.startTime = upToMediaTime;

            if (_currentTimedText) {
                _pushCurrent(_currentTimedText, _playedTimedText, upToMediaTime);
                _currentTimedText.startTime = upToMediaTime;
            }
            _startTime = upToMediaTime;

            DEBUG && _log.debug('Slice all', { 'MediaTime': Number$formatMillisecond(upToMediaTime) });
        }
    }

    function _changeCurrent(current, played, next) {
        if (current) {
            _pushCurrent(current, played, Math$min(current.endTime, playback.mediaTime.value));
        }

        if (next) {
            var chunk = next.chunk,
                stream = next.stream;

            return {
                cdn: next.cdn,
                track: stream.track,
                stream: stream,
                startTime: Math$max(chunk.startTime, _startTime),
                endTime: chunk.endTime
            };
        }
    }

    function _pushCurrent(current, played, upToMediaTime) {
        if (current && upToMediaTime >= current.startTime) {
            var entry = {
                cdn: current.cdn,
                track: current.track,
                stream: current.stream,
                startTime: current.startTime,
                endTime: upToMediaTime
            };

            var latestEntry = played[played.length - 1];
            if (latestEntry &&
                latestEntry.track == entry.track &&
                latestEntry.stream == entry.stream &&
                latestEntry.cdn == entry.cdn &&
                latestEntry.endTime == entry.startTime) {
                // combine with last entry
                latestEntry.endTime = entry.endTime;
            } else {
                // it's a new entry
                played.push(entry);
            }

            DEBUG && _log.debug('Played', {
                'DownloadableId': (entry.stream || entry.track).downloadableId,
                'Start': Number$formatMillisecond(entry.startTime),
                'Duration': Number$formatMillisecond(entry.endTime - entry.startTime)
            }, played.map(function (e) {
                return '[' + e.track.type +
                    (e.stream ? ' ' + e.stream.bitrate : '') +
                    (e.track.bcp47 ? ' ' + e.track.bcp47 : '') +
                    ' ' + Number$formatMillisecond(e.endTime - e.startTime) +
                    ' (' + Number$formatMillisecond(e.startTime) + ' to ' + Number$formatMillisecond(e.endTime) + ')' +
                    ']';
            }).join('\n'));
        }
    }

    // Return abrdel at different timepoints for putting in logblobs
    function _getAverageBitrateDeliveredAtTimes() {
        if (_doneTrackingAbrDel) {
            return _averageBitrates;
        } else {
            // Track the average video bitrate delivered: abdel, abrdel15, abrdel30, abrdel60, abrdel120
            var logPointsLen = _logPoints.length,
                totalDuration = _getTotalPlayTime();

            while (logPointsLen--) {
                var timepoint = _logPoints[logPointsLen];
                var key = 'abrdel' + timepoint;
                if (_abrs[key]==0 && totalDuration > timepoint * MILLISECONDS_PER_SECOND) {
                    var sum = 0,
                        playedLen = _playedVideo.length,
                        lastBitrate,
                        seg,
                        time = 0;

                    // Use all played segments to calculate total number of Kb delivered
                    for (var i=0; i<playedLen; i++) {
                        seg = _playedVideo[i];
                        sum = sum + seg.stream.bitrate * (seg.endTime - seg.startTime);
                        time = time + (seg.endTime - seg.startTime);
                        lastBitrate = seg.stream.bitrate;

                        // stop processing segments once we have gone past the logging point
                        if (time > timepoint * MILLISECONDS_PER_SECOND) {
                            break;
                        }
                    }
                    if (sum) {
                        // Calculate the average and adjust is the last played segment went past the logging timepoint
                        // E.g. If we have data for 16 seconds, but want abrdel15, remove the last second
                        var finalKey = 'abrdel' + timepoint;
                        _abrs[finalKey] = Math$round((sum - lastBitrate * (time - timepoint * MILLISECONDS_PER_SECOND))/(timepoint * MILLISECONDS_PER_SECOND));
                    }
                }
            }

            // Stop calculating abrdel after passing the last timepoint
            if (_abrs['abrdel' + _logPoints[_logPoints.length-1]] !== 0) {
                _doneTrackingAbrDel = true;
            }

            enumerateOwnProperties(_abrs, function(key, value) {
                _averageBitrates[key] = value == 0 ? _averageBitrates['abrdel'] : value;
            });
        }
        return _averageBitrates;
    }

    function _wireEvents() {
        playback.addEventListener(Playback$repositioning, _onRepositioning);
        playback.presentedAudio.addListener(function (args) { _currentAudio = _changeCurrent(_currentAudio, _playedAudio, args.newValue); });
        playback.presentedVideo.addListener(function (args) { _currentVideo = _changeCurrent(_currentVideo, _playedVideo, args.newValue); });
        playback.activeTimedTextTrack.addListener(_onActiveTimedTextTrackChanged);
    }
}

function PlayTimeTracker$_aggregatePlayTime(played, aggregateFunction) {
    var playTimes = [],
        playTime,
        key,
        map = {},
        entry,
        aggregate,
        l = played.length,
        i;
    for (i = 0; i < l; i++) {
        entry = played[i];
        aggregate = aggregateFunction(entry);
        key = aggregate.key;
        playTime = map[key];
        var duration = entry.endTime - entry.startTime;
        if (!playTime) {
            // none, create based ona aggregate (minus the key) and add it
            delete aggregate.key;
            playTime = aggregate;
            playTime['duration'] = duration;

            playTimes.push(playTime);
            map[key] = playTime;
        } else {
            playTime['duration'] += duration;
        }
    }
    return playTimes;
}

function PlayTimeTracker$_downloadableIdAggregateFunction(entry) {
    var downloadableId,
        bitrate,
        vmaf,
        stream = entry.stream;
    if (stream) {
        downloadableId = stream.downloadableId;
        bitrate = stream.bitrate;
        vmaf = stream.vmaf;
    } else {
        downloadableId = entry.track.downloadableId;
    }
    return {
        key: downloadableId + '$' + (bitrate || 0),
        'downloadableId': downloadableId,
        'bitrate': bitrate,
        'vmaf': vmaf
    };
}

function PlayTimeTracker$_downloadableIdAndCdnAggregateFunction(entry) {
    var aggregate = PlayTimeTracker$_downloadableIdAggregateFunction(entry);
    var cdnId = entry.cdn.id;
    aggregate.key += '$' + cdnId;
    aggregate['cdnId'] = cdnId;
    return aggregate;
}

function PlayTimeTracker$_bitrateAggregateFunction(entry) {
    var stream = entry.stream,
        bitrate = stream ? stream.bitrate : 0;

    return {
        key: bitrate,
        metric: bitrate
    };
}

function PlayTimeTracker$_vmafAggregateFunction(entry) {
    var stream = entry.stream,
        vmaf = stream ? stream.vmaf : 0;

    return {
        key: vmaf,
        metric: vmaf
    };
}

// Expects an array of objects with a metric and duration property
// Metric and duration should be set using the dot notation to be consistant for the closure compiler
function PlayTimeTracker$_averageTimeWeightedMetricFromSegments(segments) {
    var seg;
    var i;

    var totalPlayTime = 0;
    i = segments.length;
    while (i--) {
        seg = segments[i];
        if (isDefined(seg.duration) && isDefined(seg.metric)) {
            totalPlayTime += seg.duration;
        } else {
            throw new Error('invalid arguments');
        }
    }

    if (!totalPlayTime) {
        // if we didn't play anything, return 0
        return 0;
    }

    var average = 0;
    i = segments.length;
    while (i--) {
        seg = segments[i];
        average += seg.metric * seg.duration / totalPlayTime;
    }
    
    return average;
}


// -- player/InactivityMonitor.js
/**
 * @constructor
 *
 * Monitors Inactivity and causes playback close if the player is inactive for a long time.
 */
function InactivityMonitor(playback) {
    var pauseTimeoutLimitMilliseconds = config.pauseTimeoutLimitMilliseconds;
    
    if (playback.isTrailer() || playback.isBillboard() || !pauseTimeoutLimitMilliseconds) {
        return; // no monitoring required for these cases.
    }

    var pauseTimeoutMonitor = new TimeoutMonitor(pauseTimeoutLimitMilliseconds, playback.closeWithError.bind(playback, new PlayerError(ErrorCodes.PAUSE_TIMEOUT))),
        execSuspensionMonitor;

    function _startOrStopPauseTimeoutMonitor() {
        if (playback.state.value == Playback$STATE_NORMAL && (playback.presentingState.value == PresentingState$PAUSED || playback.presentingState.value == PresentingState$ENDED)) {
            pauseTimeoutMonitor.ensureTimer();
        } else {
            pauseTimeoutMonitor.stopTimer();
        }
    };
    playback.presentingState.addListener(_startOrStopPauseTimeoutMonitor);
    playback.state.addListener(_startOrStopPauseTimeoutMonitor);

    if (config.inactivityMonitorInterval) {
        var lastSeen = clock$getTime();
        execSuspensionMonitor = new RecurringTimer(config.inactivityMonitorInterval, function() {
            var _now = clock$getTime();
            if (_now - lastSeen > pauseTimeoutLimitMilliseconds) {
                playback.closeWithError(new PlayerError(ErrorCodes.INACTIVITY_TIMEOUT));
                execSuspensionMonitor.clearTimer();
            }
            lastSeen = _now;
        });
        execSuspensionMonitor.setTimer();
    }
    // Cleanup on Playback close.
    playback.addEventListener(Playback$closing, function() {
        pauseTimeoutMonitor.stopTimer();
        isDefined(execSuspensionMonitor) && execSuspensionMonitor.clearTimer();
    });

}


// -- player/TrickPlay.js
/**
* @constructor
*/
function TrickPlay(playback, id, height, width, pixelAspectHeight, pixelAspectWidth, size, urls) {
    var _self = this,
        _log = new playback.log.CategoryLog('TrickPlay'),
        _state = TrickPlay$STATE_NOT_LOADED,
        _logFields = {},
        _attemptsPerUrl = {},
        _retry = true,
        _data;

    // --------------------------------------------------------------------------------
    // -- public

    mixIn(_self,
        /** @lends {TrickPlay.prototype} */
        {
            type: CadmiumMediaStream$TRICKPLAY,
            id: id,
            download: _download,
            getFrame: _getFrame,
            getRetry: function () { return _retry; },
            getState: function() { return _state; },
            getStatus: _getStatus,
            logFields: _logFields,
            size: size
        });

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _getFrame(time) {
        if (_data) {
            var index = Math$floor(time / _data.header.timestampMultiplier);

            if (index >= 0 && index < _data.images.length) {
                return {
                    'image': _data.images[index],
                    'time': index * _data.header.timestampMultiplier,
                    'height': height,
                    'width': width,
                    'pixelAspectHeight': pixelAspectHeight,
                    'pixelAspectWidth': pixelAspectWidth
                };
            }
        }
    };

    function _getStatus() {
        switch (_state) {
            case TrickPlay$STATE_LOADED:
                return 'downloaded';
            case TrickPlay$STATE_LOADING:
                return 'loading';
            case TrickPlay$STATE_LOAD_FAILED:
                return 'downloadfailed';
            case TrickPlay$STATE_PARSE_FAILED:
                return 'parsefailed';
            default:
                return 'notstarted';
        }
    };

    function _download() {
        var url = _getUrl(urls);
        if (url) {
            _state = TrickPlay$STATE_LOADING;

            _downloadFromUrl(url);
        } else {
            _retry = false;
        }
    };

    function _getUrl(urls) {
        var ret;
        enumerateOwnProperties(urls, function (cdnId, url) {
            if (!ret) {
                var attempts = _attemptsPerUrl[url];
                if (!attempts) {
                    _attemptsPerUrl[url] = 1;
                    ret = {
                        url: url,
                        cdnId: cdnId
                    };
                } else if (attempts < (config.trickPlayDownloadRetryCount + 1)) {
                    _attemptsPerUrl[url]++;
                    ret = {
                        url: url,
                        cdnId: cdnId
                    };
                }
            }
        });
        return ret;
    };

    function _downloadFromUrl(url) {
        _log.trace('Downloading', url.url, _logFields);

        var mediaRequest = {
            responseType: http$RESPONSETYPE_BINARY,
            cdn: _getCdnFromCdnId(url.cdnId),
            url: url.url,
            track: _self
        };
        playback.httpPlayback.download(mediaRequest, function (response) {
            if (response.success) {
                try {
                    _data = parseTrickPlay(response.content);
                    _state = TrickPlay$STATE_LOADED;
                    _log.trace('TrickPlay parsed', { 'Images': _data.images.length }, _logFields);
                    playback.fireEvent(Playback$trickPlayFramesChanged);
                } catch (e) {
                    _state = TrickPlay$STATE_PARSE_FAILED;
                    _log.error('TrickPlay parse failed.', e);
                }
            } else {
                _state = TrickPlay$STATE_NOT_LOADED;
                _log.error('TrickPlay download failed.', ErrorSubCodes$errorResultToLogFields(response), _logFields);
            }
        });
    };

    function _getCdnFromCdnId(cdnId) {
        for (var i = 0; i < playback.cdnList.length; i++) {
            var cdn = playback.cdnList[i];
            if (cdn && cdn.id == cdnId) {
                return cdn;
            }
        }
    };
};

var TrickPlay$STATE_NOT_LOADED = 0,
    TrickPlay$STATE_LOADING = 1,
    TrickPlay$STATE_LOADED = 2,
    TrickPlay$STATE_LOAD_FAILED = 3,
    TrickPlay$STATE_PARSE_FAILED = 4;



// -- player/TrickPlayManager.js
Playback$registerComponent(Playback$COMPONENT_WHEN_LOADED, function loadTrickPlayManager(playback) {
    if (config.enableTrickPlay) {
        playback.trickPlayManager = new TrickPlayManager(playback);
    }
});

/**
* @constructor
*
* Figures out when to download trickplay
* and sets playback.trickPlay
*/
function TrickPlayManager(playback) {
    playback.trickplayStats = {};
    // --------------------------------------------------------------------------------
    // -- private implementation

    if (playback.trickPlayList && playback.trickPlayList.length > 0) {
        playback.trickPlay = _getHighResolutionTrickPlay();

        if (playback.trickPlay) {
            playback.addEventListener(Playback$playbackstart, function() {
                playback.addEventListener(MediaBuffer$changed, _attemptTrickPlayDownload);
            });
        }
    }

    function _attemptTrickPlayDownload() {
        var trickPlay = playback.trickPlay;
        var trickPlayState = trickPlay.getState();
        if (trickPlayState == TrickPlay$STATE_LOADING) {
            return;
        }

        if (trickPlayState == TrickPlay$STATE_LOADED || !trickPlay.getRetry()) {
            playback.removeEventListener(MediaBuffer$changed, _attemptTrickPlayDownload);
            return;
        }

        var trickPlayToDownload = _getTrickPlayToDownload();
        if (trickPlayToDownload) {
            playback.trickplayStats.offset = clock$getTime();
            playback.trickPlay = trickPlayToDownload;
            playback.trickPlay.download();
        }
    }

    function _getTrickPlayToDownload() {
        var checkHighResolutionTrickPlay = false;

        if (playback.playTimeTracker.getTotalPlayTime() < config.trickPlayHighResolutionThresholdMilliseconds) {
            checkHighResolutionTrickPlay = playback.videoStream.value.bitrate > config.trickPlayHighResolutionBitrateThreshold;
        }
        return _getSafeToDownloadTrickPlay(checkHighResolutionTrickPlay);
    }

    function _getSafeToDownloadTrickPlay(checkHighResolution) {
        if (checkHighResolution) {
            var highResulutionTrickPlay = _getHighResolutionTrickPlay();
            if (_getSafeToDownloadBufferBased(highResulutionTrickPlay.size)) {
                playback.trickplayStats.res = 'h';
                return highResulutionTrickPlay;
            }
        }

        var lowResolutionTrickPlay = _getLowResolutionTrickPlay();
        if (_getSafeToDownloadBufferBased(lowResolutionTrickPlay.size)) {
            playback.trickplayStats.res = 'l';
            return lowResolutionTrickPlay;
        }
    }

    function _getSafeToDownloadBufferBased(sizeInBytes) {
        var lowestBufferLevel = Math$min(playback.mediaBuffer.getVideoBufferLength(), playback.mediaBuffer.getAudioBufferLength());
        var downloadTime = playback.bandwidthMeter.calculateDownloadTime(sizeInBytes);
        downloadTime *= (1 + config.additionalDownloadSimulationParams[2] * 0.01);

        return downloadTime < lowestBufferLevel * config.trickplayBufferFactor;
    }

    function _getHighResolutionTrickPlay() {
        return playback.trickPlayList[playback.trickPlayList.length - 1];
    }

    function _getLowResolutionTrickPlay() {
        return playback.trickPlayList[0];
    }
}


// -- player/SecureStopManager.js
Playback$registerComponent(Playback$COMPONENT_WHEN_LOADED, function loadSecureStopManager(playback) {
    if (config.secureStopEnabled) {
        playback.secureStopManager = new SecureStopManager(playback);
    }
});
/**
 * @constructor SecureStopManager
 * @param {Object} playback
 * @param {string=} existingKeySessionId
 */
function SecureStopManager(playback, existingKeySessionId) {

    var _self = this,
        _state,
        _challenge,
        _keySessionId,
        _drmType,
        _prevSession,
        _log = new playback.log.CategoryLog('SSManager'),
        _eventSource = new EventSource();

    var _keyMessageExpiry = config.secureStopKeyMessageTimeoutMilliseconds,
        _keyAddedExpiry = config.secureStopKeyAddedTimeoutMilliseconds,
        _keyMessageExpiryTimer,
        _keyAddedExpiryTimer;

    var _waitForKeyMessage,
        _waitForServerResponse,
        _waitForKeyAdded,
        _waitForComplete;

    var _startTimestamp,
        _kmTimestamp,
        _srTimestamp,
        _milestones = {}; //ss_km, ss_sr, ss_ka

    function _init() {
        _log.trace('initializing');
        _waitForKeyMessage = SecureStopManager$getCustomPromise('keymessage');
        _waitForServerResponse = SecureStopManager$getCustomPromise('server_response');
        _waitForKeyAdded = SecureStopManager$getCustomPromise('keyadded');
        _waitForComplete = SecureStopManager$getCustomPromise('complete');

        _state = SecureStopManager$WAITING_FOR_KEY_MESSAGE;

        if (existingKeySessionId && config.secureStopFromPersistedKeySession) {
            if (MediaElement$getDrmType() == DrmType$PLAYREADY && !DeviceCapabilities$isCastTV()) {
                // for PlayReady use '*' to request all SecureStops in CDM
                // do not use during playback as it cause current playback to fail
                existingKeySessionId = base64$encode('*');
            }

            _prevSession = new SecureStopManager$createKeySession(playback, existingKeySessionId, _self);
            _keyMessageExpiry = config.secureStopPersistedKeyMessageTimeoutMilliseconds;

        }

        _keyMessageExpiryTimer = _expirePromise(_waitForKeyMessage, _keyMessageExpiry);

        _waitForComplete.promise['then'](_log.info.bind(_log, 'complete'));
        _startTimestamp = clock$getTime();
        _eventSource.fire(SecureStopManagerEvents$initiated);
    }

    function _isBeingProcessed() {
        return _state >= SecureStopManager$WAITING_FOR_KEY_MESSAGE && _state < SecureStopManager$COMPLETED;
    }

    function _isWaitingForKeyMessage() {
        return (_state === SecureStopManager$WAITING_FOR_KEY_MESSAGE);
    }

    function _updateWithKeyMessage(data) {
        DEBUG && _log.trace('Key message received', data);
        _kmTimestamp = clock$getTime();
        _milestones['ss_km'] = _kmTimestamp - _startTimestamp;

        if (!_isWaitingForKeyMessage()) {
            return; // In case the key message arrives after termination due to keyerror or videoelem error or timeout
        }
        _state = SecureStopManager$WAITING_FOR_SERVER_RESPONSE;
        _challenge = data.challenge;
        _keySessionId = data.keySessionId;
        _drmType = data.drmType;

        var drmChallenge = {},
            drmKey,
            encodedChallenge;

        if (_drmType == DrmType$WIDEVINE) {
            drmKey = DrmType$WIDEVINE + 'cef';
            encodedChallenge = base64$encode(data.challenge);
        } else if (_drmType == DrmType$FPS) {
            drmKey = DrmType$FPS;
            encodedChallenge = base64$encode(data.challenge);
        } else if (_drmType == DrmType$PLAYREADY) {
            drmKey = DrmType$PLAYREADY;

            // "native" signifies PlayReady 3.0 and distinguishes from
            // Netflix patched Play Read 2.5.
            drmKey += DeviceCapabilities$isCastTV() ? '' : 'native';
            encodedChallenge = data.challenge; // challenge is already base64 encoded
        }
        drmChallenge[drmKey + 'securestop'] = encodedChallenge;

        _waitForKeyMessage.resolve({
            success: true,
            data: drmChallenge
        });

        DEBUG && _log.debug('Key message challenge', encodedChallenge);

        clearTimeout(_keyMessageExpiryTimer);
        _keyMessageExpiryTimer = undefined;
    }
    function _updateWithServerResponse(result) {
        _srTimestamp = clock$getTime();
        _milestones['ss_sr'] = _srTimestamp - _kmTimestamp;

        var str = '',
            p = _waitForServerResponse;
        if (_state !== SecureStopManager$WAITING_FOR_SERVER_RESPONSE) {
            return; // this is an edge case where the termination occurred due to key error, while the request to the server was in flight
        }
        if (result.success) {
            if (_drmType == DrmType$WIDEVINE) {
                try {
                    str = parseStringNode(result['securestopack']['widevinecefsecureack']);
                    p.resolve({
                        success: true,
                        ack: base64$decode(str),
                        challenge: _challenge
                    });
                    _state = SecureStopManager$WAITING_FOR_KEY_ADDED;
                } catch (e) {
                    _terminate({
                        'ErrorCode': ErrorCodes.SECURE_STOP_NCCP_PARSE_PAYLOAD_ERROR,
                        'ErrorDetails': exceptionToString(e)
                    });
                }

            } else if (_drmType == DrmType$FPS) {
                p.resolve({
                    success: true,
                    ack: utf8$getBytes('acknowledged')
                });
                _state = SecureStopManager$WAITING_FOR_KEY_ADDED;
            } else if (_drmType == DrmType$PLAYREADY) {
                try {
                    if (!DeviceCapabilities$isCastTV()){
                        str = parseStringNode(result['securestopack']['playreadysecureack']);
                        p.resolve({
                            success: true,
                            ack: base64$decode(str),
                            challenge: _challenge
                        })
                    } else {
                         var secureStopAck = 'secure-stop-release';
                         p.resolve({
                           success: true,
                            ack: utf8Encode(secureStopAck)
                         });
                    }
                } catch (e) {
                    _terminate({
                        'ErrorCode': ErrorCodes.SECURE_STOP_NCCP_PARSE_PAYLOAD_ERROR,
                        'ErrorDetails': exceptionToString(e)
                    });
                }
            }
        } else {
            var errorCode,
                isIndexedDbError = result.errorSubCode && ([ErrorSubCodes.STORAGE_DELETE_ERROR, ErrorSubCodes.STORAGE_DELETE_TIMEOUT].indexOf(result.errorSubCode) >= 0);
            if (isIndexedDbError) {
                errorCode = ErrorCodes.SECURE_STOP_STORAGE_REMOVE_ERROR;
            } else {
                errorCode = ErrorCodes.SECURE_STOP_NCCP_ERROR;
            }
            _terminate({
                'ErrorCode': errorCode,
                'ErrorDetails': result.errorDetails || '',
                'ErrorSubCode': result.errorSubCode || ''
            });
        }

        if (_state == SecureStopManager$WAITING_FOR_KEY_ADDED) {
            _keyAddedExpiryTimer = _expirePromise(_waitForKeyAdded, _keyAddedExpiry);
        }
    }

    function _isWaitingForKeyAdded() {
        return (_state === SecureStopManager$WAITING_FOR_KEY_ADDED);
    }

    function _updateWithKeyAdded(attempts) {
        DEBUG && _log.trace('Keyadded received');
        _milestones['ss_ka'] = clock$getTime() - _srTimestamp;
        _state = SecureStopManager$COMPLETED;
        var status = {
            'success': true
        };
        if (isDefined(attempts)) {
            status['attempts'] = attempts;
        }
        mixIn(status, _milestones);
        _waitForComplete.resolve(status);
        clearTimeout(_keyAddedExpiryTimer);
        _keyAddedExpiryTimer = undefined;

    }

    function _terminate(result) {
        var status = {
            'success': false,
            'state': _state
        };
        mixIn(result, status);
        mixIn(result, _milestones);

        nccpLogBatcher.flush();

        // for preventing memory leak
        (_keyMessageExpiryTimer) && clearTimeout(_keyMessageExpiryTimer);
        (_keyAddedExpiryTimer) && clearTimeout(_keyAddedExpiryTimer);

        _waitForKeyMessage.resolve(result);
        _waitForServerResponse.resolve(result);
        _waitForKeyAdded.resolve(result);

        _waitForComplete.resolve(result);
        _state = SecureStopManager$COMPLETED;
        if (config.secureStopDisplayLogWindowOnError) {
            logDisplay.show();
        }
    }


    mixIn(_self, /** @lends {SecureStopManager.prototype} */ {
        init: _init,
        addEventListener: _eventSource.addListener,
        removeEventListener: _eventSource.removeListener,

        isBeingProcessed: _isBeingProcessed,

        waitForKeyMessage: function() {
            return _waitForKeyMessage.promise;
        },

        isWaitingForKeyMessage: _isWaitingForKeyMessage,

        updateWithKeyMessage: _updateWithKeyMessage,

        waitForServerResponse: function() {
            return _waitForServerResponse.promise;
        },
        updateWithServerResponse: _updateWithServerResponse,

        waitForKeyAdded: function() {
            return _waitForKeyAdded.promise;
        },
        isWaitingForKeyAdded: _isWaitingForKeyAdded,
        updateWithKeyAdded: _updateWithKeyAdded,

        waitForComplete: function() {
            return _waitForComplete.promise;
        },

        terminate: _terminate
    });


    function _expirePromise(p, expiry) {
        return setTimeout(function() {
            _terminate({
                'ErrorCode': ErrorCodes.SECURE_STOP_PROMISE_EXPIRED,
                'ErrorDetails': p.name + ' promise expired'
            });
        }, expiry);
    }
}



function SecureStopManager$getCustomPromise(name) {
    var p = {},
        promise = new Promise(function(res, rej) {
            p.resolve = res;
            p.reject = rej;
        });
    p.name = name;
    p.promise = promise;
    return p;
}

var SecureStopManagerEvents$initiated = 1;

var SecureStopManager$WAITING_FOR_KEY_MESSAGE = 1,
    SecureStopManager$WAITING_FOR_SERVER_RESPONSE = 2,
    SecureStopManager$WAITING_FOR_KEY_ADDED = 3,
    SecureStopManager$COMPLETED = 4;

function SecureStopManager$specialCaseForChrome(e) {
    var check = (/Chrome/.test(userAgent) && (e['systemCode'] == 1) && (e['errorCode'] && e['errorCode']['code'] == 1));
    if (check) {
        log.error('SSManager , ignoring keyerror')
    }
    return check;
}

/**
 * Creates a key session for the purposes of performing a secure stop.
 * @constructor
 */
function SecureStopManager$createKeySession(playback, existingKeySessionId, secureStopManager) {
    var EVENT_PREFIX = MediaElement$getEventPrefix(),
        _url,
        _mediaSource,
        _keySessionId = existingKeySessionId,
        _mediaKeys,
        _keySystemId = config.keySystemId,
        _drmType = MediaElement$getDrmType(),
        _keySession,
        _shouldAttachToDom = true,
        _log = new playback.log.CategoryLog('SSManagerPersisted'),
        _certificate,
        _attempts = 0,
        _pendingClose,
        _pendingTimer,
        _MAX_ATTEMPTS = config.secureStopPersistedKeySessionRetries;

    debug$assert(existingKeySessionId, "SecureStopManager$createKeySession should be called with a non-null existingSessionId");
    DEBUG && _log.trace('Previous EME key session', {
        'keySessionId': _keySessionId
    });

    secureStopManager.waitForComplete()['then'](_cleanUp);
    if (_keySessionId) {
        _initiatePersistentSecureStopRelease();
    }
    function _initiatePersistentSecureStopRelease() {
        try {
            if (_drmType === DrmType$PLAYREADY) {
                if (DeviceCapabilities$isCastTV()) {
                    var supportedConfigs = [{
                        'initDataTypes': ['cenc'],
                        'persistentState': "required",
                        'sessionTypes' :["temporary", "persistent-license"]
                    }];
                    navigator['requestMediaKeySystemAccess'](_keySystemId, supportedConfigs).
                    then(function (keySystemAccess) {
                        return keySystemAccess['createMediaKeys']();
                    }).
                    then(function (createdMediaKeys) {
                        _keySession = window['cast']['receiver']['eme']['KeySession']['createSession'](createdMediaKeys, 'persistent-release-message');
                        _keySession.load(existingKeySessionId).
                        then(function (loaded) {
                            if (!loaded) {
                                _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_KEY_SESSION_NOT_AVAILABLE, undefined, {'existingKeySessionId': existingKeySessionId});
                            } else {
                                _keySession.addEventListener('message', _onKeyMessage);
                                _keySession['remove']()
                                .catch(function (e) {
                                    _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_KEY_SESSION_NOT_AVAILABLE, e, {'existingKeySessionId': existingKeySessionId});
                                });
                            }
                        }).catch(function (e) {
                            _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_KEY_SESSION_NOT_AVAILABLE, e, {'existingKeySessionId': existingKeySessionId});
                        });
                        _manageEventHandlers(_keySession, 'addEventListener');
                    }).
                    catch(function (e) {
                        _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_CREATE_SESSION_WITH_KEY_RELEASE_FAILED, e);
                    })
                    
                } else {
                    _mediaKeys = new MediaKeys(_keySystemId);
                    var secureStopCdmData = formatPlayReadySecureStopCdmData(base64$encode('*'));  // always request all SecureStops
                    _keySession = _mediaKeys['createSession']('video/mp4', new Uint8Array(), secureStopCdmData);
                    _manageEventHandlers(_keySession, 'addEventListener');
                }
            } else {
                _log.error('Unsupported drm type ', _drmType);
                _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_DRM_NOT_SUPPORTED);
            }
        } catch (e) {
            _log.error('Exception on webkitSetMediaKeys', e);
            _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_PLAY_MSE_GENERATEKEYREQUEST, e);
        }
    }

    function recreateSession() {
        _attempts++;
        DEBUG && _log.trace('recreating session, attempt# ' + _attempts);
        try {
            _keySession = _mediaKeys['createSession']('keyrelease', _certificate);
            _manageEventHandlers(_keySession, 'addEventListener');
        } catch (e) {
            _log.error('create session error', e);
            _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_CREATE_SESSION_WITH_KEY_RELEASE_FAILED, e);
        }
    }

    function _onKeyMessage(ev) {
        var message = ev['message'];

        if (MediaElement$getDrmType() == DrmType$FPS) {
            SecureStopManager$matchSessionId(message, _keySessionId).
            then(function(matched) {
                DEBUG && _log.trace('found keysessionId: ' + matched);
                if (matched) {
                    _plistFound(message);
                } else {
                    DEBUG && _log.trace('sending ack, waiting for key added');
                    _addKey(utf8$getBytes('acknowledged'));
                    _pendingClose = true; // now wait for keyadded event
                    _pendingTimer = setTimeout(function() {
                        _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_PENDING_KEY_ADDED_EXPIRED)
                    }, config.secureStopPersistedKeyAddedTimeoutUnmatchedSession);
                }
            }).
            catch(function(e) {
                _log.error('exception on matching persisted keysessionId', e);
                _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_PLIST_PARSE_ERROR, e);
            });
        } else if (MediaElement$getDrmType() == DrmType$PLAYREADY) {
            
            var challenge;
            
            if (DeviceCapabilities$isCastTV()) {
                
                if (ev['messageType'] !== 'license-release') {
                    _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_UNEXPECTED_MESSAGE_TYPE, undefined, {'messageType': ev['messageType']});
                }
                
                challenge = base64$encode(new Uint8Array(ev['message']));
            } else {
                challenge = MediaElement$extractFromPlayreadyMessage(message, 'PlayReadyKeyMessage', 'Challenge');
            }

            if (!challenge || challenge.length < 4 || challenge.length % 4) {
                _log.error("SecureStop challenge is invalid: " + base64$encode(message));
            }

            secureStopManager.updateWithKeyMessage({
                success: true,
                challenge: challenge,
                drmType: MediaElement$getDrmType(),
                keySessionId: _keySessionId
            });

            secureStopManager.waitForServerResponse()['then'](function(result) {
                if (result.success) {
                    DEBUG && _log.trace('sending ack , server response success');
                    _addKey(result.ack);
                }
            });
        }
    }

    function _plistFound(message) {
        DEBUG && _log.trace('plist keysessionId matched, attempt# ' + _attempts);
        secureStopManager.updateWithKeyMessage({
            success: true,
            challenge: message,
            drmType: MediaElement$getDrmType(),
            keySessionId: _keySessionId
        });

        secureStopManager.waitForServerResponse()['then'](function(result) {
            if (result.success) {
                DEBUG && _log.trace('sending ack , server response success');
                _addKey(result.ack);
            }
        });

        _pendingClose = false;
    }

    function _addKey(data) {
        DEBUG && _log.debug('AddKey:', base64$encode(data));
        function keySessionUpdateErrorHandler(e) {
            _log.error('Exception calling keySession.update ', e);
            _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_PLAY_MSE_KEYSESSION_UPDATE, e);
        }
        try {
            if (_keySession) {
                if (DeviceCapabilities$isCastTV()) {
                    _log.trace("in _addKey for cast TV keySession Update");
                    _keySession['update'](data)['then'](_onKeyAdded)
                    .catch(keySessionUpdateErrorHandler);
                } else {
                    _keySession['update'](data)
                    .catch(keySessionUpdateErrorHandler);
                }
            }
        } catch (e) {
            _log.error('Exception calling keySession.update ', e);
            _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_PLAY_MSE_KEYSESSION_UPDATE, e);
        }
    }

    function _onKeyAdded() {
        DEBUG && _log.trace('key added event , isPendingClose ' + _pendingClose);
        if (_pendingClose) {
            _pendingClose = false;
            clearTimeout(_pendingTimer);
            _manageEventHandlers(_keySession, 'removeEventListener');
            _keySession.close();
            if (_attempts < _MAX_ATTEMPTS) {
                DEBUG && _log.trace('recreating session');
                recreateSession();
            } else {
                _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_MAX_ATTEMPTS_EXCEEDED);
            }
        } else {
            // this means we are done  
            secureStopManager.updateWithKeyAdded(_attempts);
            _keySession.close();
        }
    }

    function _onKeyError(e) {
        var o = MediaElement$getErrorResult(e, ErrorSubCodes$toMediaKeyErrorSubCode);
        _log.error('Received event: keyerror', o.logInfo);

        if (SecureStopManager$checkForNoMoreKeySessionsError(e)) {
            _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_NO_MORE_ERROR);
            return;
        }

        if (secureStopManager.isBeingProcessed()) {
            _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_KEY_ERROR, undefined, ErrorSubCodes$errorResultToLogFields(o.errorResult));
        }
    }

    function _onError(e) {
        var o = MediaElement$getErrorResult(e, ErrorSubCodes$toMediaErrorSubCode);
        _log.error('Video element event: error', o.logInfo);
        if (secureStopManager.isBeingProcessed()) {
            _terminateWithError(ErrorCodes.SECURE_STOP_PERSISTED_VIDEO_ERROR, undefined, ErrorSubCodes$errorResultToLogFields(o.errorResult));
        }
    }

    function _cleanUp() {
        if (isDefined(_url)) {
            URL.revokeObjectURL(_url);
        }

        // todo: Possible source of unhandled DOM exceptions.
        _keySession && _keySession.close();

        _mediaSource = null;
        _url = "";
    }

    /**
     * @param {number} errorCode
     * @param {Object|null|undefined=} e
     * @param {Object|null|undefined=} errorData
     */
    function _terminateWithError(errorCode, e, errorData) {
        var err = {
            'ErrorCode': errorCode
        };
        if (e) {
            err['ErrorDetails'] = exceptionToString(e);
        }
        if (errorData) {
            mixIn(err, errorData);
        }
        err['attempts'] = _attempts;
        secureStopManager.terminate(err);
    }

    /**
     * @param {Object} source
     * @param {string} action
     */
    function _manageEventHandlers(source, action) {
        source[action](EVENT_PREFIX + 'keyerror', _onKeyError);
        source[action](EVENT_PREFIX + 'keymessage', _onKeyMessage);
        source[action](EVENT_PREFIX + 'keyadded', _onKeyAdded);
    }

    /**
     * @param {string} encodedSessionId
     */
    function formatPlayReadySecureStopCdmData(encodedSessionId) {
        var PLAY_READY_METERING_CERT = 
            'Q0hBSQAAAAEAAAUMAAAAAAAAAAJDRVJUAAAAAQAAAfwAAAFsAAEAAQAAAFhr+y4Ydms5rTmj6bCCteW2' +
            'AAAAAAAAAAAAAAAJzZtwNxHterM9CAoJYOM3CF9Tj0d9KND413a+UtNzRTb/////AAAAAAAAAAAAAAAA' +
            'AAAAAAABAAoAAABU8vU0ozkqocBJMVIX2K4dugAAADZodHRwOi8vbnJkcC5uY2NwLm5ldGZsaXguY29t' +
            'L3Jtc2RrL3JpZ2h0c21hbmFnZXIuYXNteAAAAAABAAUAAAAMAAAAAAABAAYAAABcAAAAAQABAgAAAAAA' +
            'glDQ2GehCoNSsOaaB8zstNK0cCnf1+9gX8wM+2xwLlqJ1kyokCjt3F8P2NqXHM4mEU/G1T0HBBSI3j6X' +
            'pKqzgAAAAAEAAAACAAAABwAAAEgAAAAAAAAACE5ldGZsaXgAAAAAH1BsYXlSZWFkeSBNZXRlcmluZyBD' +
            'ZXJ0aWZpY2F0ZQAAAAAABjIwMjQ4AAAAAAEACAAAAJAAAQBAU73up7T8eJYVK4UHuKYgMQIRbo0yf27Y' +
            '5EPZRPmzkx1ZDMor7Prs77CAOU9S9k0RxpxPnqUwAKRPIVCe0aX2+AAAAgBb65FSx1oKG2r8AxQjio+U' +
            'rYGLhvA7KMlxJBbPXosAV/CJufnIdUMSA0DhxD2W3eRLh2vHukIL4VH9guUcEBXsQ0VSVAAAAAEAAAL8' +
            'AAACbAABAAEAAABYyTlnSi+jZfRvYL0rk9sVfwAAAAAAAAAAAAAABFNh3USSkWi88BlSM6PZ2gMuceJF' +
            'J9hzz0WzuCiwF9qv/////wAAAAAAAAAAAAAAAAAAAAAAAQAFAAAADAAAAAAAAQAGAAAAYAAAAAEAAQIA' +
            'AAAAAFvrkVLHWgobavwDFCOKj5StgYuG8DsoyXEkFs9eiwBX8Im5+ch1QxIDQOHEPZbd5EuHa8e6Qgvh' +
            'Uf2C5RwQFewAAAACAAAAAQAAAAwAAAAHAAABmAAAAAAAAACATWljcm9zb2Z0AAAAAAAAAAAAAAAAAAAA' +
            'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +
            'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAUGxheVJlYWR5IFNM' +
            'MCBNZXRlcmluZyBSb290IENBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +
            'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA' +
            'MS4wLjAuMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +
            'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +
            'AAAAAAAAAAAAAQAIAAAAkAABAECsAomwQgNY0bm6U6Au9JRvwjbNnRzmVkZi+kg7npnRQ2T+4LgyrePB' +
            'dBRQ3qb/jxXkn++4sOFa7vjRpFBzV0MMAAACAIZNYc/yJW5CLFaLPCgAHPs+FSdlhYS6BSG3mxgo2Tbe' +
            'HYJqj8Pm5/p6kNXKKUbx9kou+59dz/5+Q060QpP6xas=';

        var cdmData =
            "<PlayReadyCDMData type=\"SecureStop\">" +
            "<SecureStop version=\"1.0\" >" +
            "<SessionID encoding=\"base64encoded\">" + encodedSessionId + "</SessionID>" +
            "<ServerCert encoding=\"base64encoded\">" + PLAY_READY_METERING_CERT + "</ServerCert>" +
            "</SecureStop>" +
            "</PlayReadyCDMData>";

        return new Uint8Array(String$stringToArrayBuffer(cdmData));
    }    
}

function SecureStopManager$checkForNoMoreKeySessionsError(e) {
    try {
        var target = e['target'],
            error = e['target']['error'],
            code = error['code'],
            systemCode = error['systemCode'];

        if (MediaElement$getDrmType() == DrmType$FPS) {
            // [33, 109, 111, 114] === utf8$getBytes('!mor')
            if (code == 2 && systemCode == '560820082') {
                return true
            }
        } else if (MediaElement$getDrmType() == DrmType$PLAYREADY) {
            if (code == 1 && systemCode == -2147024637) { // 0x80070103 DRM_E_NOMORE
                return true;
            }
        }
    } catch (ex) {

    }
}

function SecureStopManager$matchSessionId(message, sessionId) {
    return new Promise(function(res, rej) {
        message = message; // || base64$decode(samplePlist); sample list matches with 7711664130424031767

        var xmlString = utf8$getString(message),
            spcSessionId;
        DEBUG && log.debug('SSManagerPersisted xml String is ', xmlString);
        xml2js(xmlString, function(spc) {
            spcSessionId = spc['object']['dict']['string'][xml$TEXT];
            DEBUG && log.trace ('SSManagerPersisted: matching session ID: in Disk  ' + sessionId + ' to SPC session ID ' + spcSessionId);
            res(spcSessionId == sessionId);
        })
    });
}


// -- player/ExceptionHandler.js
/**
 * @constructor
 * Binds to global event 'error' for uncaught exceptions.
 * Note that this can be extended to during playback handling too. lets see for startplay for now.
 */
function ExceptionHandler(playback, flushLogs, log) {
    try {
        var flushInterval;

        if (config.uncaughtExceptionFlushInterval) {
            flushInterval = setInterval(function() {
                flushLogs(); //must be called with no args here.
            }, config.uncaughtExceptionFlushInterval);
        }

        function handleErrorEvent(e) {
            var ex = e['error'] || e,
                str = exceptionToString(ex);
            log.error('uncaught exception', ex, str);
        }

        function cleanup() {
            window['removeEventListener']('error', handleErrorEvent);
            clearInterval(flushInterval);
            playback.removeEventListener(Playback$closing, cleanup);
            playback.removeEventListener(Playback$playbackstart, cleanup);
        }

        window['addEventListener']('error', handleErrorEvent);

        playback.addEventListener(Playback$closing, cleanup);
        playback.addEventListener(Playback$playbackstart, cleanup);

    } catch (e) {
        log.error('exception in exception handler ', e);
    }
}


// -- player/DummyEme.js
var dummyEmeSessionManager = {
    emeSessions: [],
    createSession: function(){}
};

loadAsync$register(ErrorCodes.INIT_COMPONENT_DUMMY_EME, function asyncLoadMsl(callback) {
	 
   if (!config.dummyEmeCount || !isPromiseBasedEmeSupported()) {
        callback(SUCCESS);
        return;
    }
    var base64 = require(88);

    var legacyClock = {
        getTime: clock$getTime,
        getEpoch: clock$getEpoch
    };
	
    var _log = new log.CategoryLog('DummyEme'),
        keySystemId = config.keySystemId,
        isDebug = DEBUG,
        maxCount = config.dummyEmeCount,
        performLicense = config.dummyEmePerformLicense,
        onError = function(err) {
            _log.error('error in dummy eme ', err);
        };

    var cert = 'CAUSwwUKvQIIAxIQ5US6QAvBDzfTtjb4tU/7QxiH8c+TBSKOAjCCAQoCggEBAObzvlu2hZRsapAPx4Aa4GUZj4/GjxgXUtBH4THSkM40x63wQeyVxlEEo1D/T1FkVM/S+tiKbJiIGaT0Yb5LTAHcJEhODB40TXlwPfcxBjJLfOkF3jP6wIlqbb6OPVkDi6KMTZ3EYL6BEFGfD1ag/LDsPxG6EZIn3k4S3ODcej6YSzG4TnGD0szj5m6uj/2azPZsWAlSNBRUejmP6Tiota7g5u6AWZz0MsgCiEvnxRHmTRee+LO6U4dswzF3Odr2XBPD/hIAtp0RX8JlcGazBS0GABMMo2qNfCiSiGdyl2xZJq4fq99LoVfCLNChkn1N2NIYLrStQHa35pgObvhwi7ECAwEAAToQdGVzdC5uZXRmbGl4LmNvbRKAA4TTLzJbDZaKfozb9vDv5qpW5A/DNL9gbnJJi/AIZB3QOW2veGmKT3xaKNQ4NSvo/EyfVlhc4ujd4QPrFgYztGLNrxeyRF0J8XzGOPsvv9Mc9uLHKfiZQuy21KZYWF7HNedJ4qpAe6gqZ6uq7Se7f2JbelzENX8rsTpppKvkgPRIKLspFwv0EJQLPWD1zjew2PjoGEwJYlKbSbHVcUNygplaGmPkUCBThDh7p/5Lx5ff2d/oPpIlFvhqntmfOfumt4i+ZL3fFaObvkjpQFVAajqmfipY0KAtiUYYJAJSbm2DnrqP7+DmO9hmRMm9uJkXC2MxbmeNtJHAHdbgKsqjLHDiqwk1JplFMoC9KNMp2pUNdX9TkcrtJoEDqIn3zX9p+itdt3a9mVFc7/ZL4xpraYdQvOwP5LmXj9galK3s+eQJ7bkX6cCi+2X+iBmCMx4R0XJ3/1gxiM5LiStibCnfInub1nNgJDojxFA3jH/IuUcblEf/5Y0s1SzokBnR8V0KbA==';
    var psshBoxes = [
        'AAAANHBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAABQIARIQAAAAAAPV9MUAAAAAAAAAAA==',
        'AAAANHBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAABQIARIQAAAAAAP1kscAAAAAAAAAAA==',
        'AAAANHBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAABQIARIQAAAAAAPWsFEAAAAAAAAAAA==',
        'AAAANHBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAABQIARIQAAAAAAP2bUEAAAAAAAAAAA==',
        'AAAANHBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAABQIARIQAAAAAAP1zWkAAAAAAAAAAA==',
        'AAAANHBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAABQIARIQAAAAADk+f2QAAAAAAAAAAA==',
        'AAAANHBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAABQIARIQAAAAAAPVITEAAAAAAAAAAA==',
        'AAAANHBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAABQIARIQAAAAAAPU93UAAAAAAAAAAA==',
        'AAAANHBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAABQIARIQAAAAAAPRb5kAAAAAAAAAAA==',
        'AAAANHBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAABQIARIQAAAAADk5lM4AAAAAAAAAAA=='
    ];
    var returnsPromise = function() {
            return new Promise(function(res, rej) {});
        },
        returnsResolvedPromise = function() {
            return Promise.resolve()
        },
        noop = function() {},
        getRequestContext = function(isDebug) {
            return {
                isDebug: isDebug,
                cert: cert
            };
        };
    function _createEme() {
        try {
            var emeSessions = dummyEmeSessionManager.emeSessions,
                index = emeSessions.length;
            if (index >= maxCount) {
                _log.trace('max count exceed for eme sessions', maxCount);
                return;
            }
            _log.trace('create dummy eme session ', {
                'count': emeSessions.length,
                'performLicense': performLicense
            });

        	var psshBox = base64.decode(psshBoxes[index]),
        		requests = new DrmRequests(_log, returnsPromise, returnsResolvedPromise, getRequestContext(isDebug));
            
            var emeContext = {
                isDebug: isDebug,
                isSecureStopEnabled: false,
                secureStopTimeouts: {
                    messageTimeout: 0,
                    changedTimeout: 0
                },
                requests: requests,
                promiseBased: true,
                onerror: onError,
                notifyLicenseRequest: noop,
                clock: legacyClock,
                playbackInitiated: false
            };

            var emeSession = new EmeSession(_log, 'cenc', undefined, emeContext);
            emeSessions.push(emeSession);
            var instanceCreation = emeSession.create(keySystemId);
            if (performLicense) {
                instanceCreation.then(function() {
                    emeSession.license(Enums.LICENSE_TYPE.LIMITED, psshBox, true);
                }).catch(onError);
            } else {
                instanceCreation.catch(onError);
            }
        } catch (e) {
            _log.error('error in creating dummy eme', e);
        }
    }
    
    dummyEmeSessionManager.createSession = _createEme;
    if (config.createDummySessionOnInit) {
        for (var i = 0; i < config.dummyEmeCount; i++) {
            setTimeout(_createEme, 100 * i);
        }
    }
    callback(SUCCESS);
});


// -- player/initCongestionService.js
var congestionService;
loadAsync$register(ErrorCodes.INIT_CONGESTION_SERVICE, function asyncLoadCongestionService(callback) {
	
	if (config.enableCongestionService) {
	    congestionService = new CongestionService({
	        apiEndpoint: config.congestionServiceApiEndpoint,
	        http: http,
	        clock: {getEpoch: clock$getEpoch},
	        minTtlSeconds: 60 * 10,
			log: new log.CategoryLog('Congestion')
	    });
		
	}
	
	callback(SUCCESS);
});


// -- config/ConfigService.js
/**
* Provides access to the Streaming Configuration Endpoint.
* Returns a configuration object with values that should be used to overide the default configuration.
* These overrides come from fast properities (that can be device specific), and A/B tests the user is allocated to.
* Authentication is required using Netflix cookies. The cookies are passed through this service implicitly via the http request. 
* Authentication is necessary to get the correct test allocations.
* ESN information is required to load the correct fast property configuration for the device.
*
* @constructor
* @param {*} log
* @param {{
	apiHost: (string|null),
	esnPrefix: string,
	esn: string,
	softwareVersion: string,
	languages: string,
	castShellVersion: string
}} playerInfo
*/
var ConfigService = function (log, playerInfo) {
    debug$assert(log);
	
	debug$assert(playerInfo);
	debug$assertValidString(playerInfo.apiHost, 'apiHost property is required');
	debug$assertValidString(playerInfo.esnPrefix, 'esnPrefix property is required');
	debug$assertValidString(playerInfo.esn, 'esn property is required');
	debug$assertValidString(playerInfo.softwareVersion, 'softwareVersion property is required');
    debug$assertValidString(playerInfo.castShellVersion, 'castShellVersion property is required');
	debug$assertValidString(playerInfo.languages, 'languages property is required');
	
	this.log = log;
	this.playerInfo = playerInfo;
}

/**
* Returns a promise that resolves with the configuration object.
* @param {string} configType should always be 'streaming'. Other types may be supported in the future.
* @return {Object} Promise that resolves with one argument of the following type
* {{success: boolean, config: Object}}
*/
ConfigService.prototype.getConfig = function (configType) {
    var self = this;
    self.log.trace('Downloading config data.');

	var params = {
		'v': '2.0',
		'output': 'json',
		'engine': 'html',
		'routing': 'reject',
		'device_type': self.playerInfo.esnPrefix,
		'certification_version': '0',
		'languages': self.playerInfo.languages,
		'country': 'US',
		'application_name': 'Cadmium', // Should this be Cadmium?
		'application_v': self.playerInfo.softwareVersion,
		'e': self.playerInfo.esn,
		'sdk_version': 'cast.cadmium.core',
		'nrdapp_version': 'n/a',
		'nrdlib_version': 'n/a',
		'mdxlib_version': 'n/a',
		'sw_version': self.playerInfo.castShellVersion,
		'dar': '16_9', // do we need this?
		'nrdp': 'true'
	};
	
	var queryString = objectToQueryString(params);

    var url = 'https://' + self.playerInfo.apiHost + '/apps/' + self.getConfigPath(configType) + '/config?' + queryString;
    return new Promise(function(resolve, reject) {

        function handleResponse(response) {
            try {
                if (response.success) {
					// Add error checking around this
					var content = new Uint8Array(response.content),
						data = String.fromCharCode.apply(null, content),
						json = JSON.parse(data);
					
                    return {
                        success: true,
                        config: json.config
                    };
                } else {
                    return {
                        success: false,
                        message: 'Unable to download the config. ' + response.errorDetails,
                        httpCode: response.errorHttpCode
                    };
                }
            } catch (e) {
                var exString = exceptionToString(e);
                self.log.error('Unable to download the config. Received an exception parsing response', {
                    'message': e.message,
                    'exception': exString,
                    'url': url
                });
                return {
                    success: false,
                    errorDetails: exString,
                    message: 'Unable to download the config. ' + e.message
                };
            }
        }

        function shouldRetry(err, attempt, maxAttempts) {
            if (attempt > maxAttempts) {
                self.log.error('Config download failed, retry limit exceeded, giving up', mixIn({
                        'Attempts': attempt - 1,
                        'MaxRetries': maxAttempts
                    },
                    err));
                return false;
            }
            return true;
        }

        function calculateRetryWait(attempt, maxAttempts) {
            var maxWait = Math.pow(2, Math.min(attempt - 1, maxAttempts)) * 1000;
            return randomInt(1000, maxWait);
        }

        function wait(ms) {
            return new Promise(function(resolve, reject) {
                setTimeout(function() {
                    resolve();
                }, ms);
            });
        }

        function retry(request, attempt, maxAttempts) {
            http.download(request, function(response) {
                var result = handleResponse(response);
                if (result.success) {
                    resolve(result);
                } else {
                    var waitTime;

                    self.log.warn('Config download failed, retrying', mixIn({
                        'Attempt': attempt,
                        'WaitTime': waitTime,
                        'MaxRetries': maxAttempts
                    }, result));

                    if (shouldRetry(result, attempt + 1, maxAttempts)) {
                        waitTime = calculateRetryWait(attempt, maxAttempts);
                        return wait(waitTime).then(function(result) {
                            return retry(request, attempt + 1, maxAttempts); // recurse
                        });
                    }

                    reject(result);
                }
            });
        }

        if (!http) {
            return Promise.reject({
                success: false,
                message: 'Unable to download Config. There was no HTTP object supplied'
            })
        }

        var request = {
            url: url,
            responseType: 3,
            withCredentials: true,
            diagCaption: 'config-download'
        };
        return retry(request, 1, 3);
    });
};

/**
* Returns the path for the endpoint based on the type of config to be loaded.
* Currently only supports one type.
*
* @private
* @param {string} configType should be always set to 'streaming'. May support other values in the future.
* @return {string}
*/
ConfigService.prototype.getConfigPath = function (configType) {
	// Only streaming is supported
	var applicationMap = {
		'streaming': 'streaming_nrdp_qoe_params'
	}
	return applicationMap[configType];
}


// -- player/CongestionService.js
/// <reference path="../http/http.d.ts"/>
var CongestionService = (function () {
    /**
    * Service for getting and caching congestion information from API.Next
    * This object should be created and stored as a singleton to take avantage
    * of it's internal caching.
    * Freshness of congestion information is based on a ttl returned from the API.
    *
    * Congestion information is used by the UI to show a message to users when
    * they are on a congested network. This info may also be used to configure
    * adaptive streaming in the future.
    *
    * @constructor
    */
    function CongestionService(config) {
        this.apiEndpoint = config.apiEndpoint;
        this.http = config.http;
        this.clock = config.clock;
        this.minTtlSeconds = config.minTtlSeconds;
        this.isRequestingCongestion = false;
        this.callbacks = [];
        this.log = config.log;
        if (config.congestionInfo) {
            this.setCongestionInfo(config.congestionInfo);
        }
        if (this.lastCongestionInfoIsStale()) {
            this.fetchCongestionInfo();
        }
        else {
            this.scheduleNextFetch();
        }
    }
    /**
    * Get the Congetion Information
    * Returns current congestionInfo sync or can be passed a callback function
    * that is called as soon as the current request finishes, or right alway
    * if one is not in progress.
    */
    CongestionService.prototype.getCongestion = function (callback) {
        callback = callback || function () { };
        var congestionInfo;
        if (this.lastCongestionInfoIsStale()) {
            congestionInfo = {
                'success': false,
                'name': null,
                'isCongested': null
            };
            if (this.isRequestingCongestion) {
                this.callbacks.push(callback);
            }
            else {
                callback(congestionInfo);
            }
        }
        else {
            congestionInfo = {
                'success': true,
                'name': this.lastCongestionResponse.asnDisplayName,
                'isCongested': this.lastCongestionResponse.isCongested
            };
            callback(congestionInfo);
        }
        return congestionInfo;
    };
    CongestionService.prototype.fetchCongestionInfo = function () {
        var self = this;
        this.isRequestingCongestion = true;
        var request = this.createRequest();
        var response = this.http.download(request, function (response) {
            if (response.success) {
                try {
                    var congestionInfo = self.parseResponseContent(response.content);
                    self.setCongestionInfo(congestionInfo);
                    self.scheduleNextFetch();
                    self.runCallbacks({
                        'success': true,
                        'name': self.lastCongestionResponse.asnDisplayName,
                        'isCongested': self.lastCongestionResponse.isCongested
                    });
                }
                catch (e) {
                    self.log.error('Response Processing Failed', e);
                    self.runCallbacks({
                        'success': false,
                        'name': null,
                        'isCongested': null
                    });
                    setTimeout(self.fetchCongestionInfo.bind(self), CongestionService.retryTimeout);
                }
            }
            else {
                self.log.error('HTTP Request Failed');
                self.runCallbacks({
                    'success': false,
                    'name': null,
                    'isCongested': null
                });
                setTimeout(self.fetchCongestionInfo.bind(self), CongestionService.retryTimeout);
            }
            self.isRequestingCongestion = false;
        });
    };
    CongestionService.prototype.runCallbacks = function (congestionInfo) {
        this.callbacks.forEach(function (callback) {
            callback(congestionInfo);
        });
        this.callbacks = [];
    };
    CongestionService.prototype.createRequest = function () {
        var url = this.apiEndpoint;
        return {
            url: url,
            responseType: http$RESPONSETYPE_BINARY,
            withCredentials: true,
            diagCaption: 'congestion-service'
        };
    };
    CongestionService.prototype.parseResponseContent = function (contentBuffer) {
        var content = new Uint8Array(contentBuffer), data = String.fromCharCode.apply(null, content), json = JSON.parse(data);
        return {
            success: json['success'],
            asnName: json['asnName'],
            asnDisplayName: json['asnDisplayName'],
            isCongested: json['isCongested'],
            ttlEpoch: json['ttlEpoch']
        };
    };
    CongestionService.prototype.lastCongestionInfoIsStale = function () {
        if (this.lastCongestionResponse && this.clock.getEpoch() < this.lastCongestionResponse.ttlEpoch) {
            return false;
        }
        else {
            return true;
        }
    };
    CongestionService.prototype.setCongestionInfo = function (congestionResponse) {
        var epochNow = this.clock.getEpoch();
        if (congestionResponse && congestionResponse.success) {
            this.timeStampOfLastRequest = epochNow;
            if (congestionResponse.ttlEpoch - epochNow < (this.minTtlSeconds * 1000)) {
                congestionResponse.ttlEpoch = epochNow + (this.minTtlSeconds * 1000);
            }
            this.lastCongestionResponse = congestionResponse;
        }
    };
    CongestionService.prototype.scheduleNextFetch = function () {
        var fetchDelayMs = (this.lastCongestionResponse.ttlEpoch - this.clock.getEpoch() - (60 * 1000));
        if (fetchDelayMs < 0) {
            fetchDelayMs = 0;
        }
        setTimeout(this.fetchCongestionInfo.bind(this), fetchDelayMs);
    };
    CongestionService.retryTimeout = 60000;
    return CongestionService;
})();



// -- trickplay/parseTrickPlay.js
var parseTrickPlay$MAGIC = [0x89, 0x42 /*B*/, 0x49 /*I*/, 0x46 /*F*/, 0xd, 0xa, 0x1a, 0xa],
    parseTrickPlay$VERSION = 0,
    parseTrickPlay$RESERVEDLENGTH = 44;

function parseTrickPlay(buffer) {
    if (!buffer) {
        throw new Error('invalid array buffer');
    }

    var arrayBuffer = new Uint8Array(buffer);
    var stream = new DataStream(arrayBuffer);

    var header = _parseHeader(stream);
    var images = _parseImages(stream);

    return  {
        header: header,
        images: images
    };

    function _parseHeader(stream) {
        if (stream.getRemaining() < _requiredHeaderBytes()) {
            throw new Error('array buffer too short');
        }

        // check magic number
        parseTrickPlay$MAGIC.forEach(function (byte) {
            if (byte != stream.readByte()) {
                throw new Error('BIF has invalid magic.');
            }
        });

        var version = stream.readUIntLittleEndian();
        if (version > parseTrickPlay$VERSION) {
            throw new Error('BIF version in unsupported');
        }

        var numberOfImages = stream.readUIntLittleEndian();
        if (numberOfImages == 0) {
            throw new Error('BIF has no frames.');
        }

        var timestampMultiplier = stream.readUIntLittleEndian();

        var reserved = stream.readArray(parseTrickPlay$RESERVEDLENGTH);

        return {
            version: version,
            numberOfImages: numberOfImages,
            timestampMultiplier: timestampMultiplier,
            reserved: reserved
        };
    };

    function _parseImages(stream) {
        var images = [];

        // the last offset is the end of the file, which we only need for the size of previous entry
        for (var i = 0; i <= header.numberOfImages; i++) {
            var previousEntry,
                entry = {
                    timestamp: stream.readUIntLittleEndian(),
                    offset: stream.readUIntLittleEndian()
                };

            if (previousEntry != undefined) {
                images.push(arrayBuffer.subarray(previousEntry.offset, entry.offset));
            }

            previousEntry = entry;
        }

        return images;
    };

    function _requiredHeaderBytes() {
        return parseTrickPlay$MAGIC.length +
            4 + // version
            4 + // number of images
            4 + // timestamp multiplier
            parseTrickPlay$RESERVEDLENGTH;
    };
}


// -- api-VideoPlayer/VideoPlayer.js
/**
* @constructor
*/
function VideoPlayer(accountKey, movieId, playbackParams, uiLabel, manifestData) {
    var _self = this,
        _playback = createPlayback(accountKey, movieId, playbackParams),
        _diagnostics = _playback.diagnostics,
        _log = new _playback.log.CategoryLog('VideoPlayer'),
        _eventSource = new EventSource(),
        _ended = new ObservableProperty(false, function () { _firePublicEvent(publicEvent$endedChanged); }),
        _loadedEventFired,
        _pendingCustomTimedTextTracks = [];

    _playback.uiLabel = uiLabel;
    _playback.manifestData = manifestData;

    // --------------------------------------------------------------------------------
    // -- initialization & public api

    // listens to internal events, and fires corresponding public events
    _wireEvents();

    mixIn(_self, {

        'addEventListener': _eventSource.addListener,

        'removeEventListener': _eventSource.removeListener,

        'getElement': function () {
            return _playback.rootElement;
        },

        // warms up playback for faster startup, once subsequent load() or play() is called
        'prepare': function () {
            // Note: for now this is NOOP, to unblock the UI development
        },

        'load': function () {
            _load();
        },

        'close': _close,

        'play': function () {
            _load();
            _playback.paused.set(false);
        },

        'pause': function () {
            _load();
            _playback.paused.set(true);
        },

        'getPaused': function () {
            return _playback.paused.value;
        },

        'getMuted': function () {
            return _playback.muted.value;
        },

        'setMuted': function (v) {
            _playback.muted.set(!!v);
        },

        'getVolume': function () {
            return _playback.volume.value;
        },

        'setVolume': function (v) {
            _playback.volume.set(Number$clamp(v, 0, 1));
        },

        'getEnded': function () {
            return _ended.value;
        },

        'getBusy': function () {
            var busy = _playback.busy.value;
            if (busy) {
                return {
                    'networkStalled': !!busy.stalled,
                    'stalled': !!busy.stalled,
                    'progress': busy.progress,
                    'progressRollback': !!busy.progressRollback
                };
            }
        },

        'getError': function () {
            var fatalError = _playback.fatalError;
            return fatalError && fatalError.toPublic();
        },

        'getCurrentTime': function () {
            return _playback.mediaTime.value;
        },

        'getBufferedTime': function () {
            var mediaBuffer = _playback.mediaBuffer;
            if (mediaBuffer) {
                return mediaBuffer.getBufferedTime();
            }
        },

        'getDuration': function () {
            return _playback.duration;
        },

        'seek': function (time) {
            _playback.mediaPresenter ? _playback.mediaPresenter.seek(time) : _playback.bookmarkTime = time;
        },

        'getVideoSize': function () {
            return _playback.videoSize ? { 'width': _playback.videoSize.width, 'height': _playback.videoSize.height } : null;
        },

        // public members - assistive assets
        'getAudioTrackList': function () {
            var tracks = [];
            for (var i = 0; i < _playback.audioTrackList.length; i++) {
                tracks.push(VideoPlayer$_getTrackPublicInterface(_playback.audioTrackList[i]));
            }
            return tracks;
        },

        'getAudioTrack': function () {
            return VideoPlayer$_getTrackPublicInterface(_playback.audioTrack.value);
        },

        'setAudioTrack': function (audioTrackPublicInterface) {
            var track;
            for (var i = 0; i < _playback.audioTrackList.length; i++) {
                track = _playback.audioTrackList[i];
                if (VideoPlayer$_getTrackPublicInterface(track) == audioTrackPublicInterface) {
                    _playback.audioTrack.set(track);
                    return;
                }
            }
            _log.error('Invalid setAudioTrack call');
        },

        'getTimedTextTrackList': function () {
            var timedTextTrackList = _playback.audioTrack.value.timedTextTrackList;
            var tracks = [];
            for (var i = 0; i < timedTextTrackList.length; i++) {
                tracks.push(VideoPlayer$_getTrackPublicInterface(timedTextTrackList[i]));
            }
            return tracks;
        },

        // If buffering has stalled due network conditions, this does a force retry.
        'tryRecoverFromStall' : function() {
            _playback.tryRecoverFromStall();
        },

        'getTimedTextTrack': function () {
            return VideoPlayer$_getTrackPublicInterface(_playback.timedTextTrack.value);
        },

        'setTimedTextTrack': function (timedTextTrackPubicInterface) {
            var timedTextTrackList = _playback.audioTrack.value.timedTextTrackList;
            var track;
            for (var i = 0; i < timedTextTrackList.length; i++) {
                track = timedTextTrackList[i];
                if (!timedTextTrackPubicInterface && track == null) {
                    _playback.timedTextTrack.set(null);
                    return;
                }
                if (VideoPlayer$_getTrackPublicInterface(track) == timedTextTrackPubicInterface) {
                    _log.info('Setting Timed Text, profile:' + track.nccpProfile);
                    _playback.timedTextTrack.set(track);
                    return;
                }
            }
            _log.error('Invalid setTimedTextTrack call');
        },

        'setTimedTextBounds': function setTimedTextBounds(bounds) {
            if (_playback.timedTextPresenter) { // check to ensure resizing doesn't throw when player is being initialized
                _playback.timedTextPresenter.setTimedTextBounds(bounds);
            }
        },

        'getTrickPlayFrame': function (time) {
            if (_playback.trickPlay) {
                return _playback.trickPlay.getFrame(time);
            }
        },

        'getXid': function () {
            return _playback.xid;
        },

        'getAdditionalLogInfo': function () {
            // returns a dictonary of items to log via consolidate logging
            return mixIn({
                'playerver': VERSION,
                'jssid': JSSID,
                'groupName': config.groupName,
                'xid': _playback.xid,
                'pbi': _playback.index
            }, PLATFORM_EXTRA_INFO, { prefix: 'pi_' });
        },

        'induceError': function (externalCode) {
            _playback.closeWithError(new PlayerError(ErrorCodes.EXTERNAL, ErrorSubCodes.UNKNOWN, externalCode));
        },

        'loadCustomTimedTextTrack': _loadCustomTimedTextTrack,

        'diagnostics': {
            'addEventListener': _diagnostics.addEventListener,
            'removeEventListener': _diagnostics.removeEventListener,
            'getModel': _diagnostics.getModel,
            'getTime': clock$getTime,
            'getGroups': function () {
                return _playback.playbackInfoPanel.getGroups();
            }
        },

        'getSessionSummary': function(){
            var result = {},
                didPlaybackStart = _playback.playDelay;
            try{
                if(_playback.fatalError){
                    result['errorCode'] = _playback.fatalError.displayCode;
                    result['errorType'] = didPlaybackStart ? 'endplay' : 'startplay';
                }
                result['playdelay'] = _playback.playDelay;
                result['xid'] = _playback.xid;
                result['auth'] = _playback.getAuthDelay();
                result['hdr'] = _playback.getIntialHeadersDelay();
                if (didPlaybackStart) {
                    result['totaltime'] = NccpClient$formatSeconds(_playback.playTimeTracker.getTotalPlayTime());
                    result['abrdel'] = _playback.playTimeTracker.getAverageBitrateDelivered();
                    var mediaPresenter = _playback.mediaPresenter;
                    var n;
                    n = mediaPresenter.getDroppedFrameCount();
                    if (isNumber(n)) {
                        result['totdfr'] = n;
                    }
                    n = mediaPresenter.getCorruptedFrameCount();
                    if (isNumber(n)) {
                        result['totcfr'] = n;
                    }
                    var rbfr = mediaPresenter.getIntrplayCount();
                    result['rbfrs_decoder'] = rbfr.decoderIntrplayCount;
                    result['rbfrs_network'] = rbfr.networkIntrplayCount;
                    result['rbfrs_delay'] = _playback.playTimeTracker.getIntrplayWaitTimeMs();
                    result['init_vbr'] = _playback.initialVideoBitrate;
                    var pdlTime = getPlayerDownloadTime();
                    if (isDefined(pdlTime)) {
                        result['pdltime'] = getPlayerDownloadTime();
                    }
                    var presentedVideo = _playback.presentedVideo.value;
                    var presentedVideoStream = presentedVideo && presentedVideo.stream;
                    if(presentedVideoStream){
                        result['vbr'] = presentedVideoStream.bitrate;
                    }
                    result['bufferedTime'] = _playback.getBufferedLength();

                }
            }catch(e){
                _log.error('error capturing session summary', e);
            }
            return result;
        },


        /**
         * Gets congested info from Congestion service.
         * Congestion info is fetched and kept up to date by Cadmium.
         *
         * Returns current congestionInfo sync or can be passed a callback function
         * that is called as soon as the current request finishes, or right alway
         * if one is not in progress.
         *
         * Example usage: videoPlayer['getCongestionInfo'](callback)
         *
         * Sample Congestion Info:
         * {succes: true, isCongested: true, name: ‘Some ISP’}
         * {success: false}
         *
         * @param {function({success: boolean, name: ?string, isCongested: ?boolean})} callback
         * @return {{success: boolean, name: ?string, isCongested: ?boolean}}
         */
        'getCongestionInfo': function (callback) {
            return _playback.getCongestionInfo(callback);
        },
        
        /**
         * Sends the engage command to the server. This is used for playback initiation
         * and is sent when a user decides to continue to play a title that the UX 
         * started on its own accord.
         * 
         * Current valid actions are:
         * - User_Interaction
         * 
         * If 'action' is null, undefined or any other value, the server will 
         * return an error
         * 
         * @param {string}              action      The input paramters to the server 
         *                                          command. The value for action can be
         *                                          'MDP_Timer'
         * @param {function({success:boolean,error:(Object|undefined)})}
         *                              callback    Called on completion, 'success' 
         *                                          will be true on success, on failure
         *                                          success will be false and error 
         *                                          will have failure information 
         */
        'engage': function (action, callback) {
            if (_playback.playbackSessionId &&
                isNumber(_playback.mediaTime.value) &&
                _playback.nccpPlayback) {
                _playback.nccpPlayback.engage(action).then(function () {
                    callback({
                        'success': true
                    });
                }).catch(function (err) {
                    callback({
                        'success': false,
                        'error': PlayerError$createPublicError(ErrorCodes.ENGAGE, err)
                    });
                });
            }
        }
    });

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _wireEvents() {
        _playback.addEventListener(Playback$throttledMediaTimeChanged, function () {
            _firePublicEvent(publicEvent$currentTimeChanged);
        });

        _playback.addEventListener(MediaBuffer$changed, function () {
            _firePublicEvent(publicEvent$bufferedTimeChanged);
        });

        _playback.addEventListener(Playback$repositioned, function () {
            _firePublicEvent(publicEvent$bufferedTimeChanged);
        });

        _playback.paused.addListener(function () {
            _firePublicEvent(publicEvent$pausedChanged);
        });

        _playback.muted.addListener(function () {
            _firePublicEvent(publicEvent$mutedChanged);
        });
        _playback.volume.addListener(function () {
            _firePublicEvent(publicEvent$volumeChanged);
        });

        _playback.presentingState.addListener(_udpateEnded);
        _playback.state.addListener(_udpateEnded);

        _playback.busy.addListener(function (args) {
            if (!_loadedEventFired) {
                if (_playback.state.value == Playback$STATE_NORMAL && !args.newValue) {
                    // if we are in normal state and no longer busy fire the "loaded" event
                    _loadedEventFired = true;
                    _firePublicEvent(publicEvent$loaded);
                    // capture when all handlers are done.
                    dispatch(_log.debug.bind(_log, 'summary ', _self['getSessionSummary']()));
                }
            }
            _firePublicEvent(publicEvent$busyChanged);
        });

        _playback.audioTrack.addListener(function (args) {
            _firePublicEvent(publicEvent$audioTrackChanged);
            if (!args.oldValue || args.oldValue.timedTextTrackList != args.newValue.timedTextTrackList) {
                _firePublicEvent(publicEvent$timedTextTrackChanged);
            }
            // give the caller a chance to pick compatable timed text track
            dispatch(function () {
                var timedTextTrackList = _playback.audioTrack.value.timedTextTrackList;
                if (!(timedTextTrackList.indexOf(_playback.timedTextTrack.value) >= 0)) {
                    _log.info('Changing timed text track to match audio track');
                    _playback.timedTextTrack.set(timedTextTrackList[0]);
                }
            });
        });

        _playback.timedTextTrack.addListener(function () {
            _firePublicEvent(publicEvent$timedTextTrackChanged);
        });

        _playback.addEventListener(Playback$timedTextTrackListChanged, function () {
            _firePublicEvent(publicEvent$timedTextTrackListChanged);
        });

        _playback.addEventListener(Playback$trickPlayFramesChanged, function () {
            _firePublicEvent(publicEvent$trickPlayFramesChanged);
        });

        _playback.state.addListener(function (e) {
            switch (e.newValue) {
                case Playback$STATE_NORMAL:
                    _firePublicEvent(publicEvent$durationChanged);
                    _firePublicEvent(publicEvent$videoSizeChanged);
                    _firePublicEvent(publicEvent$audioTrackListChanged);
                    _firePublicEvent(publicEvent$timedTextTrackListChanged);
                    _firePublicEvent(publicEvent$loadedmetadata);
                    _processPendingCustomTimedTextTrack();
                    _wireTimedTextEvents();
                    break;

                case Playback$STATE_CLOSING:
                    if (_playback.fatalError) {
                        _firePublicEvent(publicEvent$error, _playback.fatalError.toPublic());
                    }
                    break;

                case Playback$STATE_CLOSED:
                    _firePublicEvent(publicEvent$closed);
                    _eventSource.dispose();
                    break;
            }
        });
    }

    function _wireTimedTextEvents(){
        _playback.timedTextManager.addEventListener('showsubtitle', function(s) {
            _firePublicEvent(publicEvent$showsubtitle, s, true);
        });

        _playback.timedTextManager.addEventListener('removesubtitle', function(s) {
            _firePublicEvent(publicEvent$removesubtitle, s, true);
        });
    }

    /**
    * @param {Object=} args
    * @param {boolean=} fireSynch
    */
    function _firePublicEvent(eventName, args, fireSynch) {
        // be defencive, dispatch public events to a seperate cycle
        // so external exceptions don't affect us
        args = args || {};
        args['target'] = _self;
        _eventSource.fire(eventName, args, !fireSynch);
    }

    function _load() {
        _load = NOOP;
        _playback.load(function (playback, callback) {
            try {
                // fire synchroniously so the calling code can change the track before we kick off donwloads
                _firePublicEvent(publicEvent$loadedtracks, undefined, true);

                if (playback.manifestData['watermark']) {
                    _firePublicEvent(publicEvent$watermark, playback.manifestData['watermark'], true);
                }

                callback(SUCCESS);
            }
            catch (e) {
                callback({
                    errorSubCode: ErrorSubCodes.EXCEPTION,
                    errorDetails: exceptionToString(e)
                });
            }
        });
    }

    function _close(callback) {
        _load = NOOP;
        _playback.close(callback);
    }

    function _udpateEnded() {
        _ended.set(_playback.state.value == Playback$STATE_NORMAL && _playback.presentingState.value == PresentingState$ENDED);
    }

    function _loadCustomTimedTextTrack(url, name, autoLoad) {
        if (!isUrl(url)) {
            throw new Error('invalid url');
        }
        _pendingCustomTimedTextTracks.push({
            url: url,
            name: name,
            autoLoad: autoLoad
        });
        _processPendingCustomTimedTextTrack();
    }

    function _processPendingCustomTimedTextTrack() {
        if (_playback.state.value == Playback$STATE_NORMAL) {
            var track;
            var pending;
            var setTrack;
            while (pending = _pendingCustomTimedTextTracks.shift()) {
                track = _playback.timedTextManager.addCustomTrack(pending.url, pending.name);
                if (pending.autoLoad) {
                    setTrack = track;
                }
            }
            // do we need to autoLoad one?
            setTrack && _playback.timedTextTrack.set(setTrack);
        }
    }
};

function VideoPlayer$_getTrackPublicInterface(track) {
    if (track) {
        track.publicInterface = track.publicInterface || {
            'trackId': track.trackId,
            'bcp47': track.bcp47,
            'displayName': track.displayName,
            'trackType': track.trackType,
            'channels': track.channels
        };
        if(track.isImageBased){
            track.publicInterface['isImageBased'] = true;
        }
        return track.publicInterface;
    }
    return null;
}

var
    // player loaded track list, [.getAudioTrackList()], [.getAudioTrack()], [.setAudioTrack()], [.getTimedTextTrackList()], [.getTimedTextTrack()], [.setTimedTextTrack()] should be operational
    publicEvent$loadedtracks = 'loadedtracks',
    // player has loaded metadata. [.getDuration()], [.getCurrentTime()], [.getVideoSize()] should return valid values
    // Note: player might still be buffering
    publicEvent$loadedmetadata = 'loadedmetadata',
    // player buffered enough to start playback (it will start if paused=false)
    // Note: this is essnetially getBusy() becomming false first time
    publicEvent$loaded = 'loaded',
    // There was an error and playback is terminated, this will be followed by a "closed", after playdata and logs are flushed
    publicEvent$error = 'error',
    // Player is closed, all the logs are flushed and playdata is sent
    publicEvent$closed = 'closed',

    publicEvent$currentTimeChanged = 'currenttimechanged',
    publicEvent$bufferedTimeChanged = 'bufferedtimechanged',
    publicEvent$durationChanged = 'durationchanged',
    publicEvent$videoSizeChanged = 'videosizechanged',
    publicEvent$pausedChanged = 'pausedchanged',
    publicEvent$endedChanged = 'endedchanged',
    publicEvent$busyChanged = 'busychanged',
    publicEvent$audioTrackListChanged = 'audiotracklistchanged',
    publicEvent$audioTrackChanged = 'audiotrackchanged',
    publicEvent$timedTextTrackListChanged = 'timedtexttracklistchanged',
    publicEvent$timedTextTrackChanged = 'timedtexttrackchanged',
    publicEvent$trickPlayFramesChanged = 'trickplayframeschanged',

    publicEvent$mutedChanged = 'mutedchanged',
    publicEvent$volumeChanged = 'volumechanged',
    publicEvent$showsubtitle = 'showsubtitle',
    publicEvent$removesubtitle = 'removesubtitle',

    publicEvent$watermark = 'watermark';



// -- api-VideoPlayer/createClipPlayer.js
function createClipPlayer(videoPlayer, clipStart, clipDuration) {
    var SMALL_CLIP = 2000;

    // use the video player as clip player's prorotype, and override methods on it
    var clipPlayer = Object['create'](videoPlayer);

    var _eventSource = new EventSource(),
        _reroutedEvents = arrayToHashSet([publicEvent$pausedChanged, publicEvent$endedChanged]), 
        _paused = new ObservableProperty(false, function () { _eventSource.fire(publicEvent$pausedChanged); }),
        _ended = new ObservableProperty(false, function () { _eventSource.fire(publicEvent$endedChanged); });

    _seek(clipStart || 0);

    videoPlayer['addEventListener'](publicEvent$loadedmetadata, function () {
        var actualDuration = videoPlayer['getDuration']();
        clipStart = Math$min(actualDuration - SMALL_CLIP, clipStart || 0);
        clipDuration = Math$min(actualDuration - clipStart, clipDuration || actualDuration);

        // clips ignore bookmarks
        _seek(0);
    });

    videoPlayer['addEventListener'](publicEvent$currentTimeChanged, _updateEnded);

    mixIn(clipPlayer, {
        'addEventListener': function (name) {
            (_reroutedEvents[name] ? _eventSource.addListener : videoPlayer['addEventListener']).apply(null, arguments);
        },

        'removeEventListener': function (name) {
            (_reroutedEvents[name] ? _eventSource.removeListener : videoPlayer['removeEventListener']).apply(null, arguments);
        },

        'play': _play,

        'pause': _pause,

        'getPaused': function () {
            return _paused.value;
        },

        'getEnded': function () {
            return _ended.value
        },

        'getCurrentTime': _getCurrentTime,

        'getDuration': function () {
            return clipDuration;
        },

        'seek': _seek
    });

    function _play() {
        _paused.set(false);
        if (_getCurrentTime() < clipDuration - 1) {
            videoPlayer['play']();
        }
    };

    function _pause() {
        _paused.set(true);
        videoPlayer['pause']();
    };

    function _updateEnded() {
        var didEnd = _getCurrentTime() >= clipDuration || videoPlayer['getEnded']();
        if (didEnd) {
            videoPlayer['pause']();
        }
        if (_paused.value) {
            _pause();
        } else {
            _play();
        }
        _ended.set(didEnd);
    };

    function _getCurrentTime() {
        return Number$clamp(videoPlayer['getCurrentTime']() - clipStart, 0, clipDuration);
    };

    function _seek(time) {
        videoPlayer['seek'](Number$clamp(clipStart + time, clipStart, clipStart + clipDuration - SMALL_CLIP));
        _updateEnded();
    };

    return clipPlayer;
};


// -- api-VideoPlayer/VideoSession.js
/**
* @constructor
*/
function VideoSession(/* one more many init params, which are combined */) {
    var _self = this;

    config$load(arguments);

    // creates a new video player
    _self['createPlayer'] = function VideoSession_createPlayer(movieId, params) {
        var playbackParams,
            uiLabel,
            manifest;
        if (params) {
            if (isObject(params)) {
                playbackParams = {
                    trackingId: params['trackingId'],
                    sessionParams: params['sessionParams'],
                    authParams: params['authParams'],
                };
                uiLabel = params['uiLabel'] || '';
                manifest = params['manifest'];
            } else {
                // support trackingId as the only param passed directly
                playbackParams = {
                    trackingId: params
                };
            }
        }

        // get the account we attribute this playback to
        // if this is empty, it will be replaced by default key when playback loads
        var accountKey = params['accountKey'];
        // create the player
        var videoPlayer = new VideoPlayer(accountKey, movieId, playbackParams, uiLabel, manifest);

        // should we conver this to a clip player?
        var clipStart = params['clipStart'];
        var clipDuration = params['clipDuration'];
        if (clipStart > 0 || clipDuration > 0) {
            return createClipPlayer(videoPlayer, clipStart, clipDuration);
        }
        return videoPlayer;
    };

    // closes all open players
    _self['closeAllPlayers'] = function VideoSession_close(callback) {
        Playback$closeOpenPlaybacks(function () {
            callback && callback();
        });
    };

    // loads the API that needs to be initialized asynchroniously
    _self['init'] = function VideoSession_init(callback) {
        loadAsync(function (result) {
            if (result.success) {
                // augment self with the async components
                mixIn(_self, VideoSession$asyncComponents);
                // and call back with those
                callback && callback(mixIn({ 'success': true }, VideoSession$asyncComponents));
            } else {
                callback && callback({
                    'success': false,
                    'error': PlayerError$createPublicError(result.errorCode || ErrorCodes.INIT_ASYNCCOMPONENT, result)
                });
            }
        });
    };

    // applies config overrides
    // Note: the preferred place to pass in config is the VideoSession's constructor, but if some config is only available alter
    // it can be passed in here.
    _self['applyConfig'] = function VideoSession_applyConfig(params) {
        config$apply(params);
    };

    _self['prepare'] = function VideoSession_prepare(list) {
        var movies = list.map(function(m) {
            return {
                movieId: m['movieId'],
                priority: m['priority'],
                params: m['params'],
                uiLabel: m['uiLabel'],
                uiExpectedStartTime: m['uiExpectedStartTime'],
                uiExpectedEndTime: m['uiExpectedEndTime'],
                firstTimeAdded: m['firstTimeAdded']
            }
        });
        //sanitize. TODO: remove this after fix from the model.
        try {
            var moviesList = [];
            movies.forEach(function(m1, i) {
                var exists = movies.filter(function(m2, j) {
                    return (j > i) && (m2.movieId == m1.movieId);
                })[0];
                if (!exists) {
                    moviesList.push(m1);
                }
            });
            if (config.prepareCadmium && videoPreparer) {
                if (config.useDummySessionManagerForPrepare) {
                    dummyEmeSessionManager.createSession();
                } else {
                    videoPreparer.prepare(moviesList);
                }
            }
        } catch (e) {}
    };

    _self['canFulfillUIIntent'] = function VideoSession_canFulfillUIIntent(videoId, uiLabel, callback){
        var context = {
            prefix: config.prepItemsStorePrefix,
            isTest: config.environmentIsTest,
            storage: storage
        };
        if(config.prepareCadmium && videoPreparer){
            videoPreparer.canFulfillUIIntent(videoId, uiLabel, context,callback);
        }else{
            log.trace('canFulfillUIIntent failed because videoPreparer does not exist'); // should not happen if config.prepareCadmium is true.
            callback(false);
        }
    };
    
};

// this is augmented by async api components as they are loaded
var VideoSession$asyncComponents = {};




// -- api-VideoPlayer/VideoSession-nccp.js
// register for async loading
loadAsync$register(ErrorCodes.INIT_ASYNCCOMPONENT, function asyncLoadNccpApi(callback) {

    var _log = new log.CategoryLog('NccpApi');

    // --------------------------------------------------------------------------------
    // -- initialization & public api

    VideoSession$asyncComponents['nccp'] = {

        'getEsn': _getEsn,

        // gets languages used by NCCP (array of string)
        'getPreferredLanguages': _getPreferredLanguages,
        // sets languages to be sent to NCCP, this what dictates language of error messages
        // example: nccp.setPreferredLanguages(['es-MX', 'en-US']);
        'setPreferredLanguages': _setPreferredLanguages,

        'ping': _ping,
        'netflixId': _netflixId,
        'getDeviceTokens': _getDeviceTokens,

        'getRegistered': _getRegistered,
        'unregister': _unregister

    };

    callback(SUCCESS);

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _getEsn() {
        return device.esn;
    };

    function _getPreferredLanguages() {
        return config.edge.preferredlanguages;
    };

    function _setPreferredLanguages(preferredLanguages) {
        debug$assert(isArray(preferredLanguages) && isValidString(preferredLanguages[0]))
        config.edge.preferredlanguages = preferredLanguages;
    };

    function _ping(params, callback) {
        _getNccpContext(params, function (result) {
            nccp.ping(result.nccpContext, function (result) {
                if (!callback) return;
                if (result.success) {
                    callback({
                        'success': true
                    });
                } else {
                    callback({
                        'success': false,
                        'error': PlayerError$createPublicError(ErrorCodes.NCCP_PING, result)
                    });
                }
            });
        });
    };

    function _getDeviceTokens(callback) {
        debug$assert(isFunction(callback));
        nccp.bindNetflixId({
            log: _log,
            http: http
        }).then(function(result) {
            if (callback) {
                callback(result);
            }
        }).catch(function(err) {
            callback({
                'success': false,
                'error': PlayerError$createPublicError(ErrorCodes.NCCP_NETFLIXID, err)
            });
        });
    }

    function _netflixId(params, callback) {
        _getNccpContext(params, function(result) {
            nccp.bindNetflixId(result.nccpContext).then(function(result) {
                if (callback) {
                    // Netflix ID doesn't return any data so return success: true
                    // using quoted notation so videoSession clients will see the
                    // correct property name.
                    callback({
                        'success': true
                    });
                }
            }).catch(function(err) {
                callback({
                    'success': false,
                    'error': PlayerError$createPublicError(ErrorCodes.NCCP_NETFLIXID, err)
                });
            });
        });
    }
    /**
    * Log out the user by deleting the userIdToken from MSL store
    * @param {string|undefined|null} accountKey of the account to log out, if blank, default account will be used
    */
    function _unregister(accountKey, callback) {
        try {
            msl.mslClient['removeUserIdToken'](accountKey || account$getLatest().accountKey);
            // TODO: should we wait for the MSL store to get persisted?
            callback({ 'success': true });
        }
        catch (e) {
            callback({ 'success': false });
        }
    };

    /**
    * Checks whether the user is registered, basically by checking if there is a userId token
    * @param {string|undefined|null} accountKey of the account to log out, if blank, default account will be used
    */
    function _getRegistered(accountKey, callback) {
        try {
            var isRegistered = msl.mslClient['hasUserIdToken'](accountKey || account$getLatest().accountKey);
            callback({
                'success': true,
                'registered': isRegistered
            });
        }
        catch (e) {
            callback({ 'success': false });
        }
    };

    function _getNccpContext(params, callback) {
        var accountKey = params['accountKey'];
        var nccpContext = {
            log: _log,
            http: http
        };

        if (params['email']) {
            nccpContext.email = params['email'];
            nccpContext.password = params['password'] || '';
        }

        if (params['sendNetflixIdUserAuthData']) {
            // Use quoted notation for useNetflixUserAuthData to get around 
            // closure compiler issue
            nccpContext['useNetflixUserAuthData'] = params['sendNetflixIdUserAuthData'];
        }

        debug$assert(accountKey != 'browser' && accountKey != 'browsertest', 'Do not specify browser account explicitly, leave it blank');
        if (accountKey) {
            account$load(accountKey, function (result) {
                var account = result.account;
                debug$assert(result.success && account);
                nccpContext.accountKey = account.accountKey;
                account$_latest = account;
                callback({
                    success: true,
                    nccpContext: nccpContext
                });
            });
        } else {
            nccpContext.accountKey = account$getLatest().accountKey;
            callback({
                success: true,
                nccpContext: nccpContext
            });
        }
    };

});


// -- api-VideoPlayer/VideoSession-mdx.js
// register for async loading
loadAsync$register(ErrorCodes.INIT_ASYNCCOMPONENT, function asyncLoadMdxApi(callback) {

    // --------------------------------------------------------------------------------
    // -- initialization & public api

    VideoSession$asyncComponents['mdx'] = {
        'getEsn': _getEsn,
        'createCryptoContext': _createCryptoContext,
        'createCryptoContextFromSharedSecret': _createCryptoContextFromSharedSecret,
        'getServerEpoch': _getServerEpoch
    };

    callback(SUCCESS);

    // --------------------------------------------------------------------------------
    // -- private implementation

    function _getEsn() {
        return device.esn;
    }

    function _createCryptoContext(callback) {
        var mslState = msl.mslClient['getStateForMdx'](account$getLatest().accountKey);
        var mslCryptoContext = mslState['cryptoContext'];
        var masterToken = mslState['masterToken'];
        var userIdToken = mslState['userIdToken'];

        if (!masterToken || !userIdToken) {
            debug$assert(false, 'Must login first');
            callback({ 'success': false });
            return;
        }

        debug$assert(mslCryptoContext);

        var cTicket = [
            '1',
            base64$encode(JSON.stringify(masterToken['toJSON']())),
            base64$encode(JSON.stringify(userIdToken['toJSON']()))
        ].join(',');

        callback({
            'success': true,

            'cryptoContext': {

                'cTicket': cTicket,

                'encrypt': function encrypt(stringOrArray, callback) {
                    var data = isString(stringOrArray) ? utf8$getBytes(stringOrArray) : stringOrArray;
                    mslCryptoContext['encrypt'](data, {
                        'result': function (mslEncryptionEnvelopeBytes) {
                            var s = base64$encode(mslEncryptionEnvelopeBytes);
                            callback({
                                'success': true,
                                'mslEncryptionEnvelopeBase64': s
                            });
                        },
                        'timeout': function () {
                            callback({ 'success': false });
                        },
                        'error': function (e) {
                            debug$assert(false, 'Encrypt error: ' + e);
                            callback({ 'success': false });
                        }
                    });
                },

                'decrypt': function decrypt(mslEncryptionEnvelopeBase64, callback) {
                    var mslEncryptionEnvelopeBytes = base64$decode(mslEncryptionEnvelopeBase64);
                    mslCryptoContext['decrypt'](mslEncryptionEnvelopeBytes, {
                        'result': function (data) {
                            callback({
                                'success': true,
                                'text': utf8$getString(data)
                            });
                        },
                        'timeout': function () {
                            callback({ 'success': false });
                        },
                        'error': function (e) {
                            debug$assert(false, 'Decrypt error: ' + e);
                            callback({ 'success': false });
                        }
                    });
                },

                'hmac': function hmac(stringOrArray, callback) {
                    var data = isString(stringOrArray) ? utf8$getBytes(stringOrArray) : stringOrArray;
                    mslCryptoContext['sign'](data, {
                        'result': function (signature) {
                            callback({
                                'success': true,
                                'hmacBase64': base64$encode(signature)
                            });
                        },
                        'timeout': function () {
                            callback({ 'success': false });
                        },
                        'error': function (e) {
                            debug$assert(false, 'Hmac error: ' + e);
                            callback({ 'success': false });
                        }
                    });
                }

            }
        });
    }

    function _createCryptoContextFromSharedSecret(sharedSecretBase64, callback) {
        var sharedSecret = base64$decode(sharedSecretBase64),
            rawEncryptionKey = sharedSecret['subarray'](32, 32 + 16),
            rawHmacKey = sharedSecret['subarray'](0, 32);

        if (rawEncryptionKey['length'] != 16 || rawHmacKey['length'] != 32) {
            throw new Error('Bad shared secret');
        }

        Promise['all']([
            op2promise(cryptoSubtle['importKey']('raw', rawEncryptionKey, { 'name': 'AES-CBC' }, false, ['encrypt', 'decrypt'])),
            op2promise(cryptoSubtle['importKey']('raw', rawHmacKey, { 'name': 'HMAC', 'hash': { 'name': 'SHA-256' } }, false, ['sign', 'verify']))
        ])['then'](
            function (a) {
                var encryptionKey = a[0];
                var hmacKey = a[1];
                callback({
                    'success': true,
                    'cryptoContext': _createCryptoContextFromKeys(encryptionKey, hmacKey)
                });
            },
            function () {
                callback({ 'success': false });
            }
        );
    }

    function _createCryptoContextFromKeys(encryptionKey, hmacKey) {
        function toBase64Asn1(encryptedData, iv) {
            var buffer = [],
                stream = new DataStream(buffer);

            // version
            stream.writeByte(2);
            stream.writeAsn1Octet(iv);
            stream.writeAsn1Octet(encryptedData);

            return base64$encode(buffer);
        }

        function fromBase64Asn1(data) {
            var stream = new DataStream(base64$decode(data));
            var version = stream.readByte();
            return {
                iv: stream.readAsn1Octet(),
                encryptedData: stream.readAsn1Octet()
            };
        }

        return {

            'encrypt': function encrypt(stringOrArray, callback) {
                var data = isString(stringOrArray) ? utf8$getBytes(stringOrArray) : stringOrArray;
                var iv = crypto['getRandomValues'](new Uint8Array(16));
                op2promise(cryptoSubtle['encrypt']({ 'name': 'AES-CBC', 'iv': iv }, encryptionKey, data))['then'](
                    function (result) {
                        var ciphertext = new Uint8Array(result);
                        callback({
                            'success': true,
                            'encryptedDataAsn1Base64': toBase64Asn1(ciphertext, iv)
                        });
                    },
                    function (e) {
                        debug$assert(false, 'Encrypt error: ' + e);
                        callback({ 'success': false });
                    }
                );
            },

            'decrypt': function decrypt(encryptedDataAsn1Base64, callback) {
                var o = fromBase64Asn1(encryptedDataAsn1Base64);
                var iv = o.iv;
                var ciphertext = o.encryptedData;
                op2promise(cryptoSubtle['decrypt']({ 'name': 'AES-CBC', 'iv': iv }, encryptionKey, ciphertext))['then'](
                    function (result) {
                        var data = new Uint8Array(result);
                        callback({
                            'success': true,
                            'text': utf8$getString(data)
                        });
                    },
                    function (e) {
                        debug$assert(false, 'Decrypt error: ' + e);
                        callback({ 'success': false });
                    }
                );
            },

            'hmac': function hmac(stringOrArray, callback) {
                var data = isString(stringOrArray) ? utf8$getBytes(stringOrArray) : stringOrArray;
                op2promise(cryptoSubtle['sign']({ 'name': 'HMAC', 'hash': { 'name': 'SHA-256' } }, hmacKey, data))['then'](
                    function (result) {
                        var hmac = new Uint8Array(result);
                        callback({
                            'success': true,
                            'hmacBase64': base64$encode(hmac)
                        });
                    },
                    function (e) {
                        debug$assert(false, 'Hmac error: ' + e);
                        callback({ 'success': false });
                    }
                );
            }

        };
    }

    function _getServerEpoch() {
        return nccp.getServerEpoch();
    }
});


// -- api-VideoPlayer/api.js
// expose window.netflix.player API
window['netflix'] = window['netflix'] || {};
debug$assert(!window['netflix']['player']);
window['netflix']['player'] = {
    'VideoSession': VideoSession,
    'diag': {
        'togglePanel': function togglePanel(panelId, showOrHide) {
            var panels;
            switch (panelId) {
                case 'info':
                    panels = Playback$openPlaybacks.map(function (playback) {
                        return playback.playbackInfoPanel;
                    });
                    break;
                case 'streams':
                    panels = Playback$openPlaybacks.map(function (playback) {
                        return playback.playbackStreamManager;
                    });
                    break;
                case 'log':
                    panels = [logDisplay];
                    break;
            }
            panels && panels.forEach(function (panel) {
                if (isDefined(showOrHide)) {
                    if (showOrHide) {
                        panel.show();
                    } else {
                        panel.hide();
                    }
                } else {
                    panel.toggle();
                }
            });
        },
        'addNccpLogMessageSink': function(listener) {
            nccp$eventSource.addListener(nccp$logMessageQueued, function(args) {
                listener({
                    'data': args.logMessage.data
                });
            });
        }
    },
    'log': new log.CategoryLog('Ext'),
    'LogLevel': LogLevel,
    'addLogSink': function(sink) {
        log$_sinks.push(sink);
    },
    'getVersion': function() {
        return VERSION;
    },
    'isWidevineSupported': function(callback) {
        if (typeof callback !== 'function') {
            throw new Error("input param is not a function");
        }

        var keySystemId = 'com.widevine.alpha',
            emeOptions = [{
                'distinctiveIdentifier': 'not-allowed',
                'videoCapabilities': [{
                    'contentType': MEDIA_TYPE_VIDEO_H264,
                    'robustness': "SW_SECURE_DECODE"
                }],
                'audioCapabilities': [{
                    'contentType': MEDIA_TYPE_AUDIO_HEAAC,
                    'robustness': "SW_SECURE_CRYPTO"
                }]
            }];

        function isContent(type) {
            return function(acc, a) {
                return a['contentType'] == type;
            }
        }

        try {
            navigator['requestMediaKeySystemAccess'](keySystemId, emeOptions)
                .then(function(mediaKeySystemAccess) {
                    var configuration = mediaKeySystemAccess['getConfiguration'](),
                        video = configuration['videoCapabilities'] || [],
                        audio = configuration['audioCapabilities'] || [];

                    var isAudioSupported = audio.reduce(isContent(MEDIA_TYPE_AUDIO_HEAAC), false);
                    var isVideoSupported = video.reduce(isContent(MEDIA_TYPE_VIDEO_H264), false);

                    callback(isAudioSupported && isVideoSupported);
                })
                .catch(function() {
                    callback(false);
                })
        } catch (e) {
            callback(false)
        }
    }
};


// -- prepare/VideoPreparer.js
/*jshint sub:true*/
var videoPreparer; // loaded async

loadAsync$register(ErrorCodes.INIT_COMPONENT_VIDEO_PREPARER, function asyncLoadMsl(callback) {

    var legacyClock = {
        getTime: clock$getTime,
        getEpoch: clock$getEpoch
    };

    var VideoPreparer = CadmiumTypescript.VideoPreparer,
        PrepareStream = CadmiumTypescript.PrepareStream,
        isType = new CadmiumTypescript.DefaultIsType(),
        Enums = CadmiumTypescript.Enums,
        utils = new CadmiumTypescript.DefaultUtilities(),
        clock = legacyClock,
        _cachedMediaKeys = [],
        _log = new log.CategoryLog('VideoPreparer'),
        _createdPlaybackMovieId,
        _startedPlaybackMovieId,
        _ldls_during_playback_after_create = {},
        _ldls_during_playback_after_start = {},
        context = {
            //accountKey: account$getLatest().accountKey, will be set when the request is to be made
            http: http,
            log: _log
        };

    if (!EmeSession || !DrmRequests) {
        var eme = PLATFORM_EME();
        EmeSession = eme.session;
        DrmRequests = eme.request;
    }

    _log.info('instance created');
    videoPreparer = new VideoPreparer({
        log:        _log,
        clock:      legacyClock,
        xidCreator: clock$createId,

        getManifest:    getManifest,
        getLdl:         config.enableLdlPrefetch && isLimitedDurationLicenseSupported(config) && getLdl,
        
        onPlaybackCreated:      _onPlaybackCreated,
        onPlaybackStarted:      _onPlaybackStarted,
        onPlaybackClosing:      _onPlaybackClosing,
        getDuringPlaybackStats: _getDuringPlaybackStats,

        getPersistedData:                   getPersistedData,
        deletePersistedData:                deletePersistedData,
        deleteCacheOnPlayback:              config.deleteCacheOnPlayback,
        deleteOtherManifestCacheOnCreate:   config.deleteOtherManifestCacheOnCreate,
        deleteOtherLdlCacheOnCreate:        config.deleteOtherLdlCacheOnCreate,
        

        cacheSizeCountForManifest:  config.prepareManifestCacheMaxCount,
        cacheSizeCountForLdl:       config.prepareLdlCacheMaxCount,
        expiryManifestMilliseconds: config.prepareManifestExpiryMilliseconds,
        expiryLdlMilliseconds:      config.prepareLdlExpiryMilliseconds,
        isDebug: DEBUG || DEV
    });

    /**
        * @param {Object} data
        * @param {boolean=} isError
        */
    function queueLogMessage(data, isError){
        // data['trigger'] can be 'prefetch start', or 'prefetch complete' or periodic update
        var logMessage = new NccpLogMessage(null, 'prepare', (isError ? 'error' : 'info'), data);
        nccpLogBatcher.queueLogMessage(logMessage);
    }

    var periodicLogsInterval = config.periodicPrepareLogsIntervalMilliseconds;
    var lastTimeStamp = legacyClock.getTime(),
        logsTimer;
    if (periodicLogsInterval) {
        logsTimer = new RecurringTimer(periodicLogsInterval, queuePrepareLogs);
        logsTimer.setTimer();
    }

    if (config.enableLdlPrefetch && isLimitedDurationLicenseSupported(config) && config.preCacheMediaKeys) {
        dispatch(createMediaKeys.bind(null, 0, config.preCacheMediaKeys));
    }

    function _getDuringPlaybackStats() {
        return {
            'ldls_after_create': _ldls_during_playback_after_create,
            'ldls_after_start': _ldls_during_playback_after_start
        };
    }
    function _onPlaybackCreated(movieId){
        _createdPlaybackMovieId = movieId;
    }
    
    function _onPlaybackStarted(movieId) {
        if (logsTimer) {
            logsTimer.clearTimer();
            queuePrepareLogs();
        }
        _startedPlaybackMovieId = movieId;
    }

    function _onPlaybackClosing() {
        logsTimer && logsTimer.setTimer();
        _createdPlaybackMovieId = undefined;
        _startedPlaybackMovieId = undefined;
    }

    function queuePrepareLogs(){
        if (config.prepareCadmium) {
            var data = {};
            data['trigger'] = Enums.PREPARE_LOGBLOB_TRIGGER.PERIODIC_UPDATE;
            var currentTime = legacyClock.getTime();
            var stats = videoPreparer.getStats(lastTimeStamp, currentTime);
            data['startoffset'] = lastTimeStamp;
            data['endoffset'] = currentTime;
            lastTimeStamp = currentTime;
            data['cache'] = JSON.stringify(stats.cache);
            data['tasks'] = JSON.stringify(stats.tasks);
            data['general'] = JSON.stringify(stats.general);
            if (DEBUG) {
                _log.info('queue up stats', data);
            }
            queueLogMessage(data);
        }
    }


    function getManifest(movieId, params, callback) {
        _log.trace('getManifest: ' + movieId);
        // A have this manifest and it is not expired
        // B have this manifest but it is expired
        // C do not have this manifest
        // D this manifest request is in flight 

        videoPreparer.getCachedData(movieId, 'manifest').
        then(function(manifest) {
            callback(null, manifest);
        }).
        catch(function(reason) {
            _log.trace('manifest not available in cache', reason);
            if (videoPreparer.hasCachedData(movieId, 'manifest')) {
                // redundant task
                callback({
                    status: Enums.PREPARE_TASK_STATUS.CANCELLED
                });
                return;
            }
            var requestStartTime = legacyClock.getTime();
            var p = _makeServerRequest();
            videoPreparer.setCachedData(movieId, 'manifest', p);
            p.then(function(data) {
                data.requestStartTimePrepare = requestStartTime;
                data.requestEndTimePrepare = legacyClock.getTime();
                videoPreparer.setCachedData(movieId, 'manifest', data);
                callback(null, data);
            }).catch(function(err) {
                callback(err);
                videoPreparer.setCachedData(movieId, 'manifest', undefined);
            });
        });

        function _makeServerRequest() {
            return new Promise(function(res, rej) {
                // backward compatibility. TODO check with UI if used anymore.
                if (!isType.anObject(params)) {
                    params = {
                        'trackingId': params
                    };
                }
                var authData = getManifestParams(config, params['authParams'] || {}, params['sessionParams'] || {}, params['trackingId'], JSSID);
                authData.viewableIds = [movieId];
                var account = params['accountKey'] ? account$get(params['accountKey']) : account$getLatest();
                context.accountKey = account.accountKey;
                _log.trace('manifest request for:' + movieId);
                nccp.getManifest(authData, context).then(function(response) {
                    var viewable = response.authorizationData['viewables'][0];
                    _log.trace('manifest response for:' + movieId + ', status: ' + response.success);
                    if (viewable && viewable['success']) {
                        res(viewable);
                    } else {
                        rej(viewable);
                    }
                }).catch(function(err) {
                    rej(err);
                });
            });
        }
    }

    function getLdl(movieId, callback) {
        videoPreparer.getCachedData(movieId, 'ldl').
        then(function(emeSession) {
            callback(null, emeSession);
        }).catch(function(reason) {
            _log.trace('ldl not available in cache', reason);

            videoPreparer.getCachedData(movieId, 'manifest').
            then(function(cachedManifest) {

                // if manifest request was in flight, and another ldl task was created.
                if (videoPreparer.hasCachedData(movieId, 'ldl')) {
                    // redundant task
                    callback({
                        status: Enums.PREPARE_TASK_STATUS.CANCELLED
                    });
                    return;
                }
                if (config.doNotPerformLdlOnPlaybackCreate) {
                    if (_createdPlaybackMovieId && _createdPlaybackMovieId != movieId) {
                        callback({
                            status: Enums.PREPARE_TASK_STATUS.CANCELLED_ON_CREATE
                        });
                        return;
                    }
                }
                if (config.doNotPerformLdlOnPlaybackStart) {
                    if (_startedPlaybackMovieId && _startedPlaybackMovieId != movieId) {
                        callback({
                            status: Enums.PREPARE_TASK_STATUS.CANCELLED_ON_START
                        });
                        return;
                    }
                }

                if (_createdPlaybackMovieId && _createdPlaybackMovieId != movieId) {
                    _ldls_during_playback_after_create[movieId] = (_ldls_during_playback_after_create[movieId] | 0) + 1;
                }
                if (_startedPlaybackMovieId && _startedPlaybackMovieId != movieId) {
                    _ldls_during_playback_after_start[movieId] = (_ldls_during_playback_after_start[movieId] | 0) + 1;
                }

                var psshb64 = cachedManifest['psshb64'],
                    _getLicense = function _getLicense(challenge) {
                        var licenseRequest = {
                            challengeBase64: base64$encode(challenge.data),
                            clientTime: clock$getEpoch(),
                            drmContextIds: [cachedManifest['drmContextId']],
                            licenseType: Enums.convertLicenseEnumToString(challenge.licenseType),
                            method: 'license',
                            playbackContextId: cachedManifest['playbackContextId'],
                            xid: videoPreparer.createXid(movieId)
                        };
                        _log.trace('xid created ', {'MovieId': movieId, 'xid': licenseRequest.xid});
                        return nccp.getLicense(licenseRequest, context)
                            .then(function(result) {
                                return {
                                    success: true,
                                    response: {
                                        data: base64$decode(result.licenseResponseBase64)
                                    }
                                };
                            });
                    };

                function _handleError(err) {
                    _log.warn('ldl is now invalid', err);
                    emeSession.close();
                    videoPreparer.setCachedData(movieId, 'ldl', undefined); // this ldl became invalid now
                    videoPreparer.clearXid(movieId);
                }

                var emeSession = _createEmeSession({
                    initDataType: 'cenc',
                    cert: cachedManifest['cert'],
                    emeLog: _log,
                    getLicense: _getLicense,
                    stopRequest: function() {
                        return Promise.resolve();
                    },
                    errorHandler: _handleError,
                    notifyMilestone: undefined, // let eme session handle it 
                    notifyLicenseRequest: NOOP,
                    clock: clock
                });
                videoPreparer.setCachedData(movieId, 'ldl', emeSession, function closeEme() {
                    emeSession.close();
                });
                var cachedMediaKeyInstance = _cachedMediaKeys.shift();
                log.trace('cached mediakeys count ' + _cachedMediaKeys.length);
                return emeSession.create(config.keySystemId, cachedMediaKeyInstance).then(function() {
                    return emeSession.license(Enums.LICENSE_TYPE.LIMITED, base64$decode(psshb64), true);
                }).then(function() {
                    callback(null, emeSession);
                }).catch(function(err) {
                    _handleError(err); // remove from cache, close eme session
                    callback(err);
                });

            }).catch(function(err) {
                _log.warn('Manifest not available for ldl request', err);
                callback({
                    status: Enums.PREPARE_TASK_STATUS.CANCELLED
                });
            });
        });
    }

    function _createEmeSession(options) {
        var requests = new DrmRequests(options.emeLog, options.getLicense, options.stopRequest, {
            isDebug: DEBUG,
            isDev: DEV,
            cert: options.cert,
        });

        return new EmeSession(options.emeLog, options.initDataType, options.notifyMilestone, {
            isDebug: DEBUG,
            isDev: DEV,
            isSecureStopEnabled: config.secureStopEnabled,
            secureStopTimeouts: {
                messageTimeout: config.secureStopKeyMessageTimeoutMilliseconds,
                changedTimeout: config.secureStopKeyAddedTimeoutMilliseconds
            },
            requests: requests,
            promiseBased: config.promiseBasedEme,
            videoElement: undefined,
            useCdmId: config.useCdmId,
            verboseLogging: config.enableEmeVerboseLogging,
            onerror: options.errorHandler,
            notifyLicenseRequest: options.notifyLicenseRequest,
            clock: options.clock,
            playbackInitiated: false,
            serverCertificate: config.useSetServerCertificateApi && config.serverCertificate,
            ignoreKeyStatusOutputNotAllowed: config.ignoreKeyStatusOutputNotAllowed
        });
    }

    /**
    *  1. read indexedDb, status can be: uninitiated, pending, complete
    *  2. getManifest. 
    *  3. populate streams from cache
    *  4. downloadHeaders if required
    *  5. schedule media download (and save to disk) tasks
    */
    function getPersistedData(movieId, options, taskCallback) {
        readFromStorage(movieId).then(evaluateStatus).catch(handleInitialReadError);

        function readFromStorage(movieId) {
            return new Promise(function (resolve, reject){
                var storeKey = utils.getStoreKey(movieId, config.prepItemsStorePrefix, config.environmentIsTest);
                storage.load(storeKey, function(result) {
                    var entry,
                        isError;
                    
                    if(result.success){
                        _log.trace('storage load, entry exists',storeKey);
                        entry = result.data;
                        resolve(entry);
                    }else if (result.errorSubCode == ErrorSubCodes.STORAGE_NODATA){
                        _log.trace('storage load, no entry in store',storeKey);
                        entry = createNewEntry();
                        resolve(entry);
                    }else{
                        _log.error('storage load error: ', storeKey, result);
                        entry = {
                            'status': Enums.PERSISTED_TASK_STATUS.STORAGE_LOAD_FAILED,
                            'movieId': movieId
                        };
                        reject(result);
                    }

                    sendLogblob(entry, Enums.PREPARE_LOGBLOB_TRIGGER.UIREQUEST, isError);
                });
            });
        }
        /**
        * @param {Object} entry
        * @param {string} trigger
        * @param {boolean=} isError
        */
        function sendLogblob(entry, trigger, isError){
            var data = utils.getPrefetchLogData(entry);
            data['trigger'] = trigger;
            queueLogMessage(data, isError);
        }
        function evaluateStatus(entry){
            var logFields = {
                'status': entry['status'],
                'attempts': entry['attempts'],
                'abitrate':  entry['audio'] && entry['audio']['bitrate'],
                'vbitrate':  entry['video'] && entry['video']['bitrate']
            };
            _log.trace('prefetch status', logFields);
            if(entry['status'] === Enums.PERSISTED_TASK_STATUS.COMPLETED){
                taskCallback(null); // TODO logblob with status
            }else{
                entry['status'] = Enums.PERSISTED_TASK_STATUS.PENDING;
                startOrResumePrefetch(entry);
            }
        }
        function handleInitialReadError(err) {
            _log.error('prefetch error: failed to load entry for movieId', movieId); // TODO define error codes and add to err
            taskCallback(err);
        }
        function startOrResumePrefetch(entry){
            sendLogblob(entry, Enums.PREPARE_LOGBLOB_TRIGGER.PREFETCH_START); //if attempts==0,mean start. if >0 it is resume
            
            getManifest(movieId, options.params, function(err, manifest){
                if(err){
                    _log.error('prefetch error: manifest failed', err);
                    taskCallback(err);
                }else{
                    downloadMedia(manifest, entry);
                }
            });
        }
        function createNewEntry() {
            var entry = {
                'movieId': movieId,
                'attempts': 0,
                'status': Enums.PERSISTED_TASK_STATUS.STARTED,
                'uiLabel': options.uiLabel,
                'uiExpectedStartTime': options.uiExpectedStartTime,
                'uiExpectedEndTime': options.uiExpectedEndTime || null,
                'audio': {}, //header, bitrate, chunks
                'video': {}
            };
            return entry;
        }
        // if entry exists, then atleast one header is available already
        function downloadMedia(manifest, entry){
            var context = {
                http: http,
                log: _log,
                createChunkInfos: CadmiumMediaStream$_parseChunkInfos,
                firstWithType: firstWithType
            };
            entry['attempts']++;
            // TODO handle exception parsing the manifest. abort here. for now it is handled automatically by promise catch
            var audioStream = new PrepareStream(manifest, 'audio', context, entry['audio']),
                videoStream = new PrepareStream(manifest, 'video', context, entry['video']); // if no bitrate is specified, it gets the max;
            
            var requestCount = 0;
            // if header is available, then it does not download
            var headerRequests = [audioStream, videoStream].map(function(stream) {
                if (!stream.header) { // for logs
                    requestCount++;
                }
                return stream.downloadHeader(); // return promise 
            });
            Promise.all(headerRequests).then(saveHeadersToStorage).catch(taskCallback); //todo specific error code for catch

            function saveHeadersToStorage(headers) {
                if (requestCount == 1) {
                    _log.error('prefetch: only one header was in cache'); // should never happen, add type if we see this in logs.
                }
                if (requestCount) {
                    saveToStorage().then(scheduleChunkDownload).catch(taskCallback); // todo specific error code 
                }else{
                    scheduleChunkDownload();
                }
            }

            function saveToStorage() {
                entry['audio'] = audioStream.toJson();
                entry['video'] = videoStream.toJson();
                updateStatusIfComplete(entry);
                return new Promise(function(resolve, reject) {
                    var storeKey = utils.getStoreKey(movieId, config.prepItemsStorePrefix, config.environmentIsTest);
                    storage.save(storeKey, entry, false, function(saveResult) {
                        _log.trace('prefetch storage save results: ' + storeKey, saveResult);
                        if (saveResult.success) {
                            resolve(saveResult); // pass content only
                        } else {
                            _log.error('save failed for: ' + storeKey, saveResult);
                            reject(saveResult);
                        }
                    });
                });
            }

            function scheduleChunkDownload() {
                var streams = [audioStream, videoStream];
                var streamOps = streams.map(function(stream) {
                    var ops = [],
                        index = 0,
                        chunk;
                    while (chunk = stream.getNthChunk(index)) {
                        if (chunk.content) {
                            _log.trace('media available for chunk', {
                                index: index,
                                type: stream.type
                            });
                        } else {
                            ops.push(chunkDownloader.bind(null, chunk, stream));
                        }
                        index++;
                    }
                    return ops;
                });

                var operations = utils.alternateMerge(streamOps[0], streamOps[1]);
                if(!operations.length){
                    // this can happen if entries were downloaded and saved but status wasn't updated.
                    _log.warn('inconsistency in data, status: ', entry['status']);
                }

                taskCallback(null); // original task is not complete.

                dispatch(function() {
                    videoPreparer.prepare([{
                        movieId: movieId,
                        label: 'append',
                        taskType: 'chunkdownload',
                        operations: operations,
                        priority: 1
                    }]);
                });

                function chunkDownloader(chunk, stream, callback) {
                    stream.downloadChunk(chunk)
                        .then(saveToStorage)
                        .then(function() {
                            setTimeout(callback.bind(null, null), 1); //so that if there is an error in taskCallback, we don't catch in taskCallback
                        })
                        .catch(callback);
                }
            }

            function updateStatusIfComplete(entry){
                var audio = entry['audio'],
                    video = entry['video'];
                if(!audio['header'] || !video['header']){
                    return;
                }
                
                if(!audio['chunks'].length || !video['chunks'].length){
                    return;
                }

                function containsMedia(chunk){
                    return chunk['media'] && chunk['media'].length;
                }
                if(audio['chunks'].every(containsMedia) && video['chunks'].every(containsMedia)){
                    entry['status'] = Enums.PERSISTED_TASK_STATUS.COMPLETED;
                    sendLogblob(entry, Enums.PREPARE_LOGBLOB_TRIGGER.PREFETCH_COMPLETE);
                }
            }
        }
    }

    function deletePersistedData(movieId, taskCallback) {
        var storeKey = utils.getStoreKey(movieId, config.prepItemsStorePrefix, config.environmentIsTest);
        storage.remove(storeKey, function(result) {
            if (result.success) {
                var data = {};
                data['trigger'] = Enums.PREPARE_LOGBLOB_TRIGGER.PREFETCH_DELETE;
                queueLogMessage(data, false);
                taskCallback(null);
            } else {
                taskCallback(result);
            }

        });
    }

    function createMediaKeys(count, max) {
        if (count === 0) {
            log.trace('generete mediakeys for pre-caching');
        }
        if (count < max) {
            if(EmeSession.createMediaKeys) {
                EmeSession.createMediaKeys('cenc', config.keySystemId, log, config.useSetServerCertificateApi && config.serverCertificate).then(function(mediaKeys) {
                    _cachedMediaKeys.push(mediaKeys);
                    dispatch(createMediaKeys.bind(null, ++count, max));
                }).catch(function(err) {
                    log.error('abort pre-caching due to error in creating mediakeys', err);
                });
            }
        } else {
            log.trace('pre-cached mediakeys complete, number of instances: ' + max);
        }
    }
    callback(SUCCESS);

});
// TODO move this to utility methods
function getManifestParams(config, authParams, sessionParams, trackingId, jssid) {

    function _combineParams() {
        var result = {};

        if (authParams) {
            enumerateOwnProperties(authParams, function(key, value) {
                result[key] = isString(value) ? value : JSON.stringify(value);
            });
        }
        if (sessionParams) {
            enumerateOwnProperties(sessionParams, function(key, value) {
                result[key] = isString(value) ? value : JSON.stringify(value);
            });
        }
        return result;
    }

    return {
        videoProfiles: config.videoProfiles,
        audioProfiles: config.audioProfiles,
        textProfiles: config.timedTextProfiles,
        trickplayProfiles: ['BIF240', 'BIF320'],
        drmSystem: MediaElement$getDrmType(),
        appId: config.appId || jssid,
        sessionId: config.sessionId || jssid,
        trackingId: trackingId,
        sessionParams: _combineParams(),
        flavor: Enums.PLAYBACKCONTEXT_FLAVORS.PRE_FETCH,
        lookupType: Enums.MANIFEST_LOAD_TYPE.PREPARE
    };
}




    /**
    * @const
    */
 //   var DEV = false;

})(window);

},{"2":2,"3":3,"4":4,"48":48,"50":50,"52":52,"6":6,"61":61,"7":7,"88":88,"9":9,"91":91,"96":96,"98":98}],2:[function(require,module,exports){
var CadmiumTypescript = require(9);

var Errors = {};
Errors.Codes = CadmiumTypescript.ErrorCodes;
Errors.SubCodes = CadmiumTypescript.ErrorSubCodes;
var Enums = CadmiumTypescript.Enums;
var Utf8 = new CadmiumTypescript.Utf8Encoder();
var base64 = new CadmiumTypescript.Base64Encoder();
var utils = require(4);

/**
 * Provides facilities to request license and secure stop data from the server
 * @constructor
 * @param {Object}            log         object to use for recording logging information
 * @param {function({
 *        drmType:string,
 *        data:Uint8Array
 *   }) : Promise}            getLicense  function to make a call to the edge API to get license information
 * @param {{
 *     isDebug:boolean,
 *     isDev:boolean,
 *     cert:string
 * }}                         context     contains flags that control what information is reported
 *                                        to the logging system and cert (base64 string) information containing
 *                                        the attestation data
 */
var DrmRequests = function(log, getLicense, secureStop, context) {
    this.log = log;
    this.getLicense = getLicense;
    this.secureStop = secureStop;
    this.context = context;
};

/**
 * Sends an HTTP request containing license challenge data and returns the response.
 *
 * This method may be invoked many times and can be used to make the attestation request as
 * well as the license.
 *
 * @param  {{ initdata: Uint8Array,
 *            licenseType: number,
 *            messageType: string,
 *            drmType: string
 *         }} cdmResponse the data from the CDM
 * @return {Promise} the promise will resolve on successfull completion of the request returning an
 *                       object:
 *                       <code>{
 *                           success: boolean,
 *                           response: Uint8Array,
 *                       }</code>
 *                       If the request fails the Promise will reject with an object:
 *                       <code>{
 *                           success: boolean,
 *                           code: number,
 *                           subCode: number,
 *                           extCode: number,
 *                           message: string,
 *                           cause: Object
 *                       }</code>
 */
DrmRequests.prototype.license = function request_license(cdmResponse) {
    var self = this;

    if (self.context.isDebug || self.context.isDev) {
        self.log.debug('Requesting a license', cdmResponse);
    }

    function getAttestationData() {

        self.log.trace('Requesting WideVine attestation data.');

        return new Promise(function(resolve, reject) {
            if (self.context.cert) {
                // This supports Widevine's "ChromeOS Remote Attestation" feature.
                // This feature allows the CDM to complete the attestation process
                // to tell the server client is operating 'verified mode', which can
                // allow playback of higher-valued content.
                //
                // This feature is enabled with the SUPPORTS_WIDEVINE_ATTESTATION
                // platform variable. When the message is exactly [8,4],we know we
                // must send the Netflix Server Certificate to the CDM.
                //
                // NOTE: This is the 'short-circuit' method. Normally the client
                // requests the Server Certificate from the server and then hands it
                // to the CDM. But since the cert rarely changes, we can save a
                // round-trip here by simply sending in the known cert directly.
                // If the server certificate has to change, we will change the server
                // piece and this client code at the same time.
                //resolve(base64.decode(self.context.cert));
                resolve({
                    success: true,
                    response: {
                        data: new Uint8Array(base64.decode(self.context.cert))
                    }
                });
            }else{
                reject({
                    success: false,
                    code: Errors.Codes.PLAY_MSE_EME_MISSING_CERT,
                    message: 'Cert not available in context'
                });
            }
        });
    }

    function downloadLicense() {
        self.log.trace('Requesting license', {
            'drmType': cdmResponse.drmType
        });
        return new Promise(function(resolve, reject) {
            var licenseData = {
                licenseType: cdmResponse.licenseType,
                drmType: cdmResponse.drmType,
                data: cdmResponse.initdata
            };

            self.getLicense(licenseData).then(function(result) {
                resolve(result);
            }).catch(function(err) {
                self.log.error('Unable to get the Widevine license', err);
                reject({
                    success: false,
                    code: Errors.Codes.LICENSE,
                    subCode: err.errorSubCode,
                    extCode: err.errorExternalCode,
                    errorDisplayMessage: err.errorDisplayMessage,
                    message: 'Unable to send the Widevine license request. ' + err.errorDisplayMessage,
                    cause: err
                });
            });
        });
    }

    if (utils.compareArrays([8, 4], cdmResponse.initdata)) {
        return getAttestationData();
    }
    return downloadLicense();
};

/**
 * Sends and HTTP request to the server to release the license and retrieve secure stop information
 * @param  {{
 *     playbackSessionId:string,
 *     mediaId: string,
 *     type: string,
 *     position: number,
 *     licenseContextId: string,
 *     secureStopData: string
 * }}  stopRequestData the data to send for the server stop request
 * @return {Promise} promise that resolves with the requested secure stop data upon success;
 *                   otherwise rejects with error information
 */
DrmRequests.prototype.stop = function request_stop(stopRequestData) {
    var self = this;

    self.log.trace('Releasing Widevine license');

    return new Promise(function(resolve, reject) {
        self.secureStop(stopRequestData).then(function(result) {
            resolve(result);
        }).catch(function(err) {
            self.log.error('Unable to release the Widevine license.', {
                'success': err.success,
                'code': err.code,
                'subCode': err.subCode,
                'extCode': err.extCode,
                'edgeCode': err.edgeCode,
                'message': err.errorDisplayMessage
            });
            reject({
                success: false,
                code: Errors.Codes.SECURESTOP,
                subCode: err.errorSubCode,
                extCode: err.errorExternalCode,
                edgeCode: err.errorEdgeCode,
                errorDisplayMessage: err.errorDisplayMessage,
                message: 'Unable to release the Widevine license. ' + err.errorDisplayMessage,
                cause: err
            });
        });
    });
};

module.exports = DrmRequests;

},{"4":4,"9":9}],3:[function(require,module,exports){
var CadmiumTypescript = require(9);

var Errors = {};
Errors.Codes = CadmiumTypescript.ErrorCodes;
Errors.SubCodes = CadmiumTypescript.ErrorSubCodes;
var base64 = new CadmiumTypescript.Base64Encoder();
var Enums = CadmiumTypescript.Enums;
var is = new CadmiumTypescript.DefaultIsType();
var utils = require(4);

var MESSAGETYPE_REQUEST = 'license-request';
var MESSAGETYPE_RENEWAL = 'license-renewal';
var EVENT_MESSAGE = 'message';
var EVENT_KEYSTATUSESCHANGE = 'keystatuseschange';

// TODO convert constants and shortcuts into node modules
var MEDIA_TYPE_VIDEO_H264 = 'video/mp4; codecs="avc1.640028"';
var MEDIA_TYPE_AUDIO_HEAAC = 'audio/mp4; codecs="mp4a.40.5"';
var MediaKeys = window['MediaKeys'] || window['WebKitMediaKeys']; //shortcut

/**
 * Class to abstract access to the W3C EME interface. This class abstract the Chrome DRM
 * specific implementation of the EME specification
 * @constructor
 * @param {Object}            log          An object to use for recording logging information
 * @param {string}            initDataType indicates what format the initialization data is provided
 * @param {function(string)}  onMilestone    function to set application milestones
 * @param {{
 *     isDebug:boolean,
 *     isDev:boolean,
 *     promiseBased:boolean,
 *     videoElement:Object,
 *     useCdmId:boolean,
 *     verboseLogging
 * }}                         context      contains flags that control what information is reported
 *                                         to the logging system as well as information as to what
 *                                         version of the Eme to support
 */
var EmeSession = function(log, initDataType, onMilestone, context) {
    var self = this;
    this.log = log;
    this.initDataType = initDataType;
    this.onMilestone = onMilestone || milestoneHandler.bind(this);
    this.context = context;
    this.mediaKeys = undefined;
    this.keySession = undefined;
    this.keySessionId = undefined;
    this.cdmIdProcessed = undefined;
    this.keySystem = undefined;
    this.challenge = undefined;
    this.pendingLicenseChallenge = undefined;
    this.milestones = {};
    this.onMessage = messageHandler.bind(this);
    this.onKeyStatusesChange = keyStatusesChangeHandler.bind(this);
    this._keyStatuses = {};

    this.waitForLicenseReceived = new Promise(function(res, rej) {
        self.resolveLicenseReceived = res;
        self.rejectLicenseReceived = rej;
    });

    this.waitForLicenseReceived.catch(function(e) {
        self.log.error('wait for license rejected', e);
    });

    /**
     * @param {number|Object} err
     * @param {number|Object=} errorSubcode
     */
    this.onError = function(err, errorSubcode) {
        self.rejectLicenseReceived(err, errorSubcode);
        self.context.onerror(err, errorSubcode);
    };
    this.onLicenseReceived = function() {
        self.resolveLicenseReceived();
    };

    // Make sure we have invoked this function using 'new'
    if (!(this instanceof EmeSession)) {
        throw new TypeError('EmeSession constructor not called correctly.');
    }
};

EmeSession.prototype.getKeyStatuses = function() {
    return this._keyStatuses;
};

// used by prepare when the eme session is handed over to the player
EmeSession.prototype.updateProperties = function eme_updateProperties(props, context) {
    var self = this;
    //explicitly list all the props for documentation.
    if (props.log) {
        self.log = props.log;
    }
    if (props.onMilestone) {
        self.onMilestone = props.onMilestone;
    }

    if (context.requests) {
        self.context.requests = context.requests;
    }
    if (context.onerror) {
        self.context.onerror = context.onerror;
    }
};

/**
 * Gets the key session id if the key session is viable and has an id
 * @return {number|undefined} the key session id if the session is viable and has an id; undefined otherwise
 */
EmeSession.prototype.getSessionId = function eme_getSessionId() {
    var self = this;
    if (self.keySession) {
        return self.keySession['sessionId'];
    } else if (self.keySessionId) {
        return self.keySessionId;
    }
};

/**
 * Gets the EME media keys object created by the create function.
 * @return {Object|undefined} media keys object instantiated by the create function if it been called; undefined otherwise
 */
EmeSession.prototype.getMediaKeys = function eme_getMediaKeys() {
    return this.mediaKeys;
};

function getErrorObject(err, code, errorString) {
    return {
        success: false,
        code: code,
        subCode: Errors.SubCodes.EXCEPTION, // redundant. Either capture more data about the error or remove this and update help articles.
        message: errorString + ' ' + err['message'],
        errorDetails: utils.exceptionToString(err),
        cause: err,
        alreadyCaptured: true
    };
}

function forwardError(log, code, errorString, isFatal) {
    return function(err) {
        if (err && err.alreadyCaptured) {
            return Promise.reject(err);
        } else {
            log.error(errorString, err);
            if (!isFatal) {
                return Promise.resolve();
            }
            var errorObject = getErrorObject(err, code, errorString);
            return Promise.reject(errorObject);
        }
    };
}

EmeSession.createMediaKeys = function _createMediaKeys(initDataType, keySystem, log, certificate) {
    return new Promise(function(resolve, reject) {
        var options = getEmeOptions(initDataType),
            _mediaKeys,
            _handleReturnKeySystemAccessReject = forwardError(log, Errors.Codes.EME_CREATE_MEDIAKEYS_SYSTEMACCESS_FAILED, 'request mediaKeySystem access rejected:', true),
            _handleCreateMediaKeysReject = forwardError(log, Errors.Codes.EME_CREATE_MEDIAKEYS_FAILED, 'create media keys rejected:', true),
            _handleSetServerCertificate = forwardError(log, null, 'set servercertificate api failed:', false);

        navigator['requestMediaKeySystemAccess'](keySystem, options)
            .then(_returnKeySystemAccess)
            .catch(_handleReturnKeySystemAccessReject)
            .then(_createMediaKeys)
            .catch(_handleCreateMediaKeysReject)
            .then(_setServerCertificate)
            .catch(_handleSetServerCertificate)
            .then(_resolveMediaKeys)
            .catch(_handleFatalError);

        function _returnKeySystemAccess(keySystemAccess) {
            log.trace('keysystemaccess config', JSON.stringify(keySystemAccess['getConfiguration'](), null, ' '));
            return keySystemAccess;
        }

        function _createMediaKeys(keySystemAccess) {
            return keySystemAccess['createMediaKeys']();
        }

        function _setServerCertificate(mediaKeys) {
            _mediaKeys = mediaKeys;

            if (!certificate) {
                return Promise.resolve();
            }
            if (!is.aFunction(mediaKeys['setServerCertificate'])) {
                log.error('mediaKeys setServerCertificate is not a function');
                return Promise.resolve();
            }
            var cert = base64.decode(certificate);
            log.trace('calling setServerCertificate');
            return mediaKeys['setServerCertificate'](cert['buffer']);
        }

        function _resolveMediaKeys() {
            log.trace('mediakeys resolved');
            resolve(_mediaKeys);
        }

        function _handleFatalError(err) {
            if (err && err.alreadyCaptured) {
                reject(err);
            } else {
                var errorObject = getErrorObject(log, Errors.Codes.EME_MEDIAKEYS_GENERIC_ERROR, 'generic mediakeys error');
                reject(errorObject);
            }
        }

    });
};
/**
 * Creates the EME media keys interface to the CDM
 * @param {string} keySystem determines what CDM to use, can be either 'com.adobe.access' for PrimeTime or 'org.w3.clearkey' for ClearKey
 * @param {Object=} mediaKeys instance.
 * @return {Promise} a promise that resolves on success returning a reference to the media keys object; rejects on failure
 */
EmeSession.prototype.create = function eme_create(keySystem, mediaKeys) {
    var self = this;
    self.onMilestone('lg');
    self.log.trace('Creating the mediakeys: ' + keySystem);
    self.keySystem = keySystem;

    function returnResolvedResult(mediaKeys) {
        self.mediaKeys = mediaKeys;
        return ({
            success: true,
            mediaKeys: mediaKeys
        });
    }

    function createPromiseEme() {
        if (mediaKeys) {
            self.log.trace('consuming pre-cached mediakeys instance');
            return Promise.resolve(returnResolvedResult(mediaKeys));
        } else {
            return EmeSession.createMediaKeys(self.initDataType, keySystem, self.log, self.context.serverCertificate)
                .then(returnResolvedResult);
        }
    }

    function createPrefixEme() {
        return new Promise(function(resolve, reject) {
            resolve({
                success: true,
                mediaKeys: null
            });
        });
    }

    if (self.context.promiseBased) {
        return createPromiseEme();
    }
    return createPrefixEme();
};

/**
 * Close the session without removing session from the CDM
 */
EmeSession.prototype.close = function eme_close() {
    var self = this;
    if (!self.keySession) {
        return Promise.resolve();
    }
    if (this.closedKeySession) {
        return Promise.resolve();
    }
    self.log.trace('closing keysession', {
        'sessionId': self.keySession['sessionId']
    });

    this.closedKeySession = true;
    return self.keySession['close']().
    then(function() {
        self.log.trace('keysession closed');
    }).
    catch(function(err) {
        self.log.trace('error occurred while closing keysession', err);
    });

};

/**
 * Add a license to the CDM.
 *
 * The second parameter will need to accept an object of this type:
 * <code> {
 *     data: Uint8Array,
 *     drmType: string
 * }
 * </code>
 *
 * @param {number} licenseType the type of license to add: standard/limited/preview
 * @param {Uint8Array} initData the initData to supply to the CDM to start the license process
 * @return {Promise}  a promise that resolves on keys changed event; rejects on error event
 */
EmeSession.prototype.license = function eme_license(licenseType, initData, updateLicenseLater) {

    var AWAITING_CERT_REQUEST = 1,
        RECEIVED_CERT_REQUEST = 2,
        RECEIVED_CERT = 3,
        AWAITING_LICENSE_CHALLENGE = 11,
        RECEIVED_LICENSE_CHALLENGE = 12,
        RECEIVED_LICENSE = 13,
        AWAITING_RENEWAL_CHALLENGE = 21,
        RECEIVED_RENEWAL_CHALLENGE = 22,
        RECEIVED_RENEWED_LICENSE = 23,
        COMPLETE = 30;

    var self = this,
        state = AWAITING_CERT_REQUEST;

    function promiseLicense() {

        if (self.isDebugMode()) {
            self.log.trace('LICENSE: Setting license with promise based EME');
        }

        return new Promise(function(resolve, reject) {
            var onLicenseMessage,
                onLicenseError;

            function shutdown(result) {
                if (self.keySession) {
                    self.keySession.removeEventListener(EVENT_MESSAGE, onLicenseMessage);
                    self.keySession.addEventListener(EVENT_MESSAGE, self.onMessage); // Add message event handler for license renewal.
                }
                result.state = state;
                if (result.success) {
                    resolve(result);
                } else {
                    self.close();
                    self.rejectLicenseReceived(result);
                    reject(result);
                }
            }

            if (!self.keySession) {
                self.log.trace('LICENSE: Creating the key session.');
                try {
                    self.keySession = self.mediaKeys['createSession']();
                } catch (ex) {
                    shutdown({
                        success: false,
                        code: Errors.Codes.EME_CREATE_SESSION_FAILED,
                        subCode: Errors.SubCodes.EXCEPTION,
                        message: 'Unable to create a persisted key session',
                        errorDetails: utils.exceptionToString(ex),
                        cause: ex
                    });
                }
            }

            onLicenseMessage = function(event) {
                var messageView = new Uint8Array(event['message']),
                    messageType = event['messageType'],
                    isCertRequest = (messageView[0] == 8 && messageView[1] == 4);

                // potentially 2 types of licene message can be received in this handler: RA license request, license challenge request
                // license-renewal will be handled in self.onMessage after the license is complete.
                state = isCertRequest ? RECEIVED_CERT_REQUEST : RECEIVED_LICENSE_CHALLENGE;

                var logFields = {
                    'sessionId': event['target']['sessionId'],
                    'messageType': messageType,
                    'isCertRequest': isCertRequest
                };
                if (self.isDebugMode()) {
                    logFields['message'] = base64.encode(messageView);
                }

                self.log.trace('LICENSE: Received event: ' + event['type'], logFields);

                var drmType = /clearkey/i.test(self.keySession['keySystem']) ? 'clearkey' : 'widevine',
                    response = {
                        initdata: messageView,
                        licenseType: licenseType,
                        messageType: messageType,
                        drmType: drmType
                    };

                if (state === RECEIVED_LICENSE_CHALLENGE) {
                    self.onMilestone('lc');
                    var licenseChallenge = {
                        data: messageView,
                        drmType: drmType
                    };
                    if (self.context.playbackInitiated) {
                        self.context.notifyLicenseRequest(licenseChallenge);
                    } else {
                        self.pendingLicenseChallenge = licenseChallenge;
                    }
                }
                //TODO add milestones for license renewal challenge in endplay
                self.context.requests.license(response).then(function(license) {
                    if (state === RECEIVED_LICENSE_CHALLENGE) {
                        self.onMilestone('lr');
                        self.onLicenseReceived();
                        if (!self.context.playbackInitiated) { // eme created from prepare
                            self.pendingLicenseData = license.response.data;
                            state = RECEIVED_LICENSE;
                            shutdown({
                                success: true,
                                state: state
                            });
                            return;
                        }
                    }
                    var waitForUpdate = setLicense(self, license.response.data, self.keySession);
                    
                    if (state === RECEIVED_CERT_REQUEST) {
                        return waitForUpdate;
                    } else {
                        return waitForUpdate.then(function() {
                            state = COMPLETE;
                            shutdown({
                                success: true,
                                state: state
                            });
                        });
                    }
                }).catch(function(err) {
                    shutdown(utils.mixIn(err, {
                        state: state
                    }));
                });
            }; // license message handler function ends here

            self.keySession.addEventListener(EVENT_MESSAGE, onLicenseMessage);
            self.keySession.addEventListener(EVENT_KEYSTATUSESCHANGE, self.onKeyStatusesChange);

            self.log.trace('LICENSE: Calling generateRequest', {
                'initDataType': self.initDataType,
                'initData': base64.encode(initData)
            });

            self.keySession['generateRequest'](self.initDataType, initData)
                .then(function(result) {  
                    if (self.isDebugMode()) {
                        self.log.trace('LICENSE: Generate succeeded', {
                            'sessionId': self.keySession['sessionId']
                        });
                    }
                }, function(err) {
                    self.log.error('LICENSE: Unable to generate a license request', err);
                    shutdown({
                        success: false,
                        code: Errors.Codes.EME_GENERATEREQUEST_FAILED,
                        subCode: Errors.SubCodes.EXCEPTION,
                        state: state,
                        message: 'Unable to generate request.',
                        errorDetails: utils.exceptionToString(err),
                        cause: err
                    });
                });
        });
    }

    function prefixLicense() {

        if (self.isDebugMode()) {
            self.log.trace('LICENSE: Setting license with prefixed EME');    
        }

        function setLicense(data) {
            self.context.videoElement['webkitAddKey'](self.keySystem, data, self.challenge, self.keySessionId);
        }

        return new Promise(function(resolve, reject) {

            function onKeyMessage(event) {

                var sessionId = event['sessionId'],
                    message = event['message'];

                self.log.trace('Received event: ' + event['type'], {
                    'sessionId': sessionId
                });
                self.keySessionId = sessionId;
                self.challenge = message;

                var response = {
                    initdata: message,
                    licenseType: licenseType,
                    messageType: 'license-request',
                    drmType: /clearkey/i.test(self.keySystem) ? 'clearkey' : 'widevine'
                };

                self.onMilestone('lc');
                self.context.requests.license(response)
                    .then(function(license) {
                        self.onMilestone('lr');
                        return setLicense(license.response.data);
                    }).catch(function(err) {
                        reject(err);
                    });
            }

            function onKeyAdded(event) {
                self.log.trace('Received event: ' + event['type'], {
                    'keySystem': event['keySystem'],
                    'sessionId': self.keySessionId
                });


                // If the challenge is two bytes then we have not added the license
                // yet just attestation data so we need to exit without resolving 
                // the promise, otherwise clean up and resolve
                if (self.challenge && self.challenge.length > 2) {
                    // Remove event listeners, these were only installed for license
                    // other operation would need to install there own listeners
                    self.context.videoElement.removeEventListener('webkitkeyerror', onKeyError);
                    self.context.videoElement.removeEventListener('webkitkeymessage', onKeyMessage);
                    self.context.videoElement.removeEventListener('webkitkeyadded', onKeyAdded);
                    // And were all good, not data to return
                    resolve({
                        success: true
                    });

                    self.context.videoElement.addEventListener('webkitkeyerror', prefixedEmeErrorHandler.bind(self));
                    self.context.videoElement.addEventListener('webkitkeymessage', function() {
                        self.log.error('renewal not supported in prefixed eme'); // for now,prepare will only be done for unprefixed eme.
                        self.onError(Errors.Codes.EME_LDL_RENEWAL_ERROR);
                    });
                }
            }

            function onKeyError(err) {
                self.log.error('Received event: ' + err['type'], {
                    'errorCode': Errors.SubCodes.EME_MEDIA_KEYERR_BASE + err['errorCode']['code']
                });
                var errorData = utils.getChromePrefixedEmeErrorResult(err);
                errorData.success = false;
                errorData.state = state;
                errorData.code = Errors.Codes.PLAY_MSE_EVENT_KEYERROR;
                errorData.message = 'Received a key error';
                reject(errorData);
                // Should we call self.close() ???
                self.keySession = undefined;
            }

            self.context.videoElement.addEventListener('webkitkeyerror', onKeyError);
            self.context.videoElement.addEventListener('webkitkeymessage', onKeyMessage);
            self.context.videoElement.addEventListener('webkitkeyadded', onKeyAdded);

            try {
                self.context.videoElement['webkitGenerateKeyRequest'](self.keySystem, initData);
            } catch (e) {
                reject({
                    code: Errors.Codes.PLAY_MSE_GENERATEKEYREQUEST,
                    subCode: Errors.SubCodes.EXCEPTION
                });
            }
        });
    }

    if (self.context.promiseBased) {
        return promiseLicense();
    }
    return prefixLicense();
};

EmeSession.prototype.applyExistingLicense = function eme_applyExistingLicense() {
    var pendingLicenseData = this.pendingLicenseData;
    if (!pendingLicenseData) {
        self.log.error('pending license must exist at this point');
    }
    this.pendingLicenseData = undefined;
    return setLicense(this, pendingLicenseData, this.keySession);
};

/**
 * Renew a limited duration license
 * @return {Promise} always resolve as we do not explicitly call renew in widevine
 */
EmeSession.prototype.renew = function eme_renew() {

    var self = this;

    // For widevide there is no explicit need to call renew
    return Promise.resolve({
        success: true
    });
};

/**
 * Release a license and send secure stop data to the CDM to free the persisted license
 * @return {Promise} a promise that is resolved on success and rejected on failure
 */
EmeSession.prototype.expediteSecureStop = function eme_expediteSecureStop(stopRequestData) {

    var self = this;

    self.log.trace('SECURE_STOP: Executing expedite');

    // Currently Chrome doesn't support secure stop so all we need to do
    // here is make the server 'stop' call

    return new Promise(function(resolve, reject) {
        function shutdown(result) {
            self.close().then(function() {
                var method = result.success ? resolve : reject;
                method(result);

            });
        }
        return self.context.requests.stop.call(self.context.requests, stopRequestData).then(function() {
            shutdown({
                success: true,
                messageTime: undefined,
                serverTime: undefined,
                completeTime: undefined
            });
        }).catch(function(err) {
            self.log.error('SECURE_STOP: Server request failed', {
                'code': err.code,
                'subCode': err.subCode,
                'extCode': err.extCode,
                'edgeCode': err.edgeCode,
                'message': err.errorDisplayMessage
            });
            shutdown(err);
        });
    });
};

/**
 * Load a persisted session and release a license and send secure stop data to the CDM to
 * free the persisted license
 * @param  {number} sessionId       the id of the session to load
 * @param  {Object} stopRequestData the data to send to the server along with stop data
 *                                  provided by the CDM
 * @return {Promise}                a promise that is resolved on success and rejected on failure
 */
EmeSession.prototype.deferredSecureStop = function eme_deferredSecureStop(sessionId, stopRequestData) {

    var self = this;

    self.log.trace('SECURE_STOP: Executing deferred');

    // Currently Chrome doesn't support secure stop so there is nothing to 
    // load 

    return self.expediteSecureStop(stopRequestData);
};

EmeSession.prototype.isDebugMode = function eme_isDebugMode() {
    return this.context.isDebug || this.context.isDev;
};


// For promise based eme.
function setLicense(self, license, keySession) {
    if (self.isDebugMode()) {
        self.log.trace('LICENSE: Got the response, calling update', {
            'sessionId': keySession['sessionId'],
            'license': base64.encode(license)
        });
    }
    return new Promise(function(resolve, reject) {
        keySession['update'](license)
            .then(function(response) {
                if (self.isDebugMode()) {
                    self.log.trace('LICENSE: Update succeeded', {
                        'sessionId': keySession['sessionId']
                    });
                }
                resolve();
            }).catch(function(err) {
                var emeErr = utils.getChromeUnprefixedEmeErrorResult(err);
                emeErr.code = Errors.Codes.PLAY_MSE_EVENT_KEYERROR;
                emeErr.message = 'Unable to update the EME.';
                self.log.error('LICENSE: Unable to update the EME.', err);
                reject(emeErr);
            });
    });
}

// license renew message
function messageHandler(event) {
    var self = this,
        messageView = new Uint8Array(event['message']),
        messageType = event['messageType'],
        logFields = {
            'sessionId': self.getSessionId(),
            'messageType': messageType,
        };
    if (self.isDebugMode()) {
        logFields['message'] = base64.encode(new Uint8Array(event['message']));
    }
    
    self.log.trace('Received event: ' + event['type'], logFields);

    if (event['messageType'] === MESSAGETYPE_RENEWAL) {
        self.onMilestone('renew_lc');
        var response = {
            initdata: messageView,
            licenseType: Enums.LICENSE_TYPE.STANDARD,
            messageType: event['messageType'],
            drmType: /clearkey/i.test(self.keySession['keySystem']) ? 'clearkey' : 'widevine'
        };

        self.context.requests.license(response)
            .then(function(license) {
                self.onMilestone('renew_lr');
                if (!self.closedKeySession) { // do not set, if keysession was closed before renewal response came back.
                    return setLicense(self, license.response.data, self.keySession)
                        .then(function() {
                            self.onMilestone('renew_ld');
                        }).catch(function(err) {
                            self.onMilestone('renew_ld_failed');
                            if (self.onError) {
                                self.onError(err.code, err);
                            }
                        });
                }
            }).catch(function(err) {
                self.onMilestone('renew_lr_failed');
                if (self.onError) {
                    self.onError(err.code, err);
                }
            });
    } else {
        self.log.error('unrecognized messageType', event['messageType']);
    }
}

function keyStatusesChangeHandler(event) {
    var self = this;
    self.log.trace('Received event: ' + event['type']);
    try {
        utils.eachKeyStatus(event, function(key, status) {
            self.log.trace('key status: ' + status);
            var entry  = self._keyStatuses[status];
            if(!entry){
                entry = self._keyStatuses[status] = [];
            }
            entry.push(self.context.clock.getTime());
            if (self.isDebugMode()) {
                self.log.trace('key status change', {
                    'sessionId': event['target']['sessionId'],
                    'keyId': base64.encode(new Uint8Array(key)),
                    'status': status
                });
            }
            if (self.onError) {
                if (status == 'expired') {
                    self.onError(Errors.Codes.PLAY_MSE_EME_KEY_STATUS_CHANGE_EXPIRED);
                }
                if (status == 'internal-error') {
                    self.onError(Errors.Codes.PLAY_MSE_EME_KEY_STATUS_CHANGE_INTERNAL_ERROR);
                }
                if (status == 'output-not-allowed') {
                    if (self.context.ignoreKeyStatusOutputNotAllowed) {
                        self.log.warn('ignoring keystatus: ', status);
                    } else {
                        self.onError(Errors.Codes.PLAY_MSE_EME_KEY_STATUS_CHANGE_OUTPUT_NOT_ALLOWED);
                    }
                }
                if (status == 'output-restricted' || status == 'output-downscaled') {
                    self.log.warn('output protection status', status); //Address this when different keys for different content is implemented.
                }
            }
        });
    } catch (ex) {
        self.log.error('Exception in iterating keystatuses', ex);
    }
}

function prefixedEmeErrorHandler(err) {
    var self = this,
        errData = utils.getChromePrefixedEmeErrorResult(err);

    self.log.error('Received event: ' + err['type']); 

    if (self.onError) {
        self.onError(Errors.Codes.PLAY_MSE_EVENT_KEYERROR, errData);
    }
    // Should we call self.keySession.close() ???
    self.keySession = undefined;
}

function getEmeOptions(initDataType) {
    return [{
            'initDataTypes': [initDataType],
            'persistentState': "required",
            'audioCapabilities': [{
                'contentType': MEDIA_TYPE_AUDIO_HEAAC,
                'robustness': "SW_SECURE_CRYPTO"
            }],
            'videoCapabilities': [{
                'contentType': MEDIA_TYPE_VIDEO_H264,
                'robustness': "HW_SECURE_DECODE"
            }, {
                'contentType': MEDIA_TYPE_VIDEO_H264,
                'robustness': "SW_SECURE_DECODE"
            }]
            //label: "M43+" // For debugging - only supported in Chrome 43+.
        }, {
            'initDataTypes': [initDataType],
            'persistentState': "required"
        } // For M42.
    ];
}

function milestoneHandler(m) {
    var self = this;
    if (self.context.clock) {
        self.milestones[m] = self.context.clock.getTime();
        self.log.trace('Milestone: ' + m + ', ' + self.milestones[m]);
    }
}
module.exports = EmeSession;
},{"4":4,"9":9}],4:[function(require,module,exports){
var CadmiumTypescript = require(9);

var base16 = new CadmiumTypescript.Base16Encoder();
var Errors = {};
Errors.Codes = CadmiumTypescript.ErrorCodes;
Errors.SubCodes = CadmiumTypescript.ErrorSubCodes;
var is = new CadmiumTypescript.DefaultIsType();
var Enums = CadmiumTypescript.Enums;

module.exports = {
    compareArrays: compareArrays,    
    exceptionToString: exceptionToString,
    enumerateOwnProperties: enumerateOwnProperties,
    mixIn: mixIn,
    eachKeyStatus: eachKeyStatus,
    getChromeUnprefixedEmeErrorResult: getChromeUnprefixedEmeErrorResult,
    getChromePrefixedEmeErrorResult: getChromePrefixedEmeErrorResult,
    randomInt: randomInt,
    alternateMerge: alternateMerge,
    getStoreKey: getStoreKey,
    getPrefetchLogData: getPrefetchLogData,
    createElement: createElement,
    filterBy: filterBy
};

function compareArrays(a1, a2) {
    if (a1.length == a2.length) {
        var i = a1.length;
        while (i--) {
            if (a1[i] != a2[i]) {
                return false;
            }
        }
        return true;
    }
    return false;
}

function exceptionToString(e) {
    if (e) {
        // stack has the exception, don't duplicate it
        var stack = e['stack'];
        var number = e['number'];
        var message = e['message'];
        if (!message) {
            message = '' + e;
        }
        var s;
        if (stack) {
            s = '' + stack;
            if (s.indexOf(message) !== 0) {
                s = message + '\n' + s;
            }
        } else {
            s = message;
        }
        if (number) {
            // some exceptions have a "number", track that to
            s += '\nnumber:' + number;
        }
        return s;
    }
}

/**
 * @param {Object} o
 * @param {function(string, Object=)} handler
 */
function enumerateOwnProperties(o, handler) {
    for (var k in o) {
        o.hasOwnProperty(k) && handler(k, o[k]);
    }
}

/**
 * @param {Object} o
 * @param {Object=} o2
 * @param {{makeLowerCase,prefix,onlyIfDefined}=} options
 */
function mixIn(o, o2, options) {
    if (o2) {
        if (options) {
            var makeLowerCase = options.makeLowerCase,
                prefix = options.prefix,
                onlyIfDefined = options.onlyIfDefined;

            enumerateOwnProperties(o2, function(k, v) {
                if (!onlyIfDefined || is.definedAndNotNull(v)) {
                    o[(prefix || '') + (makeLowerCase ? k.toLowerCase() : k)] = v;
                }
            });

        } else {
            // keep simple and common case simple
            enumerateOwnProperties(o2, function(k, v) {
                o[k] = v;
            });
        }
    }
    return o;
}

function eachKeyStatus(event, keyStatus) {
    var session,
        map,
        entries,
        entry,
        key,
        status;

    session = event['target'];
    map = session['keyStatuses'];
    entries = map['entries']();
    entry = entries['next']();
    while (!entry['done']) {
        key = entry['value'][0];
        status = entry['value'][1];
        if (keyStatus) {
            keyStatus(key, status);
        }
        entry = entries['next']();
    }
}

function getChromeUnprefixedEmeErrorResult(ex) {
    var result = {},
        code = ex['code'];
    if (is.definedAndNotNull(ex['code'])) {
        code = parseInt(ex['code'], 10);
        if (code >= 1 && code <= 9) {
            result.subCode = Errors.SubCodes.EME_MEDIA_KEYERR_BASE + code;
        } else {
            result.subCode = Errors.SubCodes.EME_MEDIA_KEYERR_BASE;
        }
    } else {
        result.subCode = Errors.SubCodes.EXCEPTION;
    }

    try {
        var systemCode = ex['message'].match(/\((\d*)\)/)[1];
        result.extCode = base16.fromInt(systemCode, 4);
    } catch (e) {}

    result.errorDetails = exceptionToString(ex);
    return result;
}

function getChromePrefixedEmeErrorResult(e) {
    var errorData = {};
    try {
        var systemCode = parseInt(e['systemCode'], 10),
            code = e['errorCode']['code'];

        errorData.subCode = Errors.SubCodes.EME_MEDIA_KEYERR_BASE + code;
        errorData.extCode = base16.fromInt(systemCode, 4);
        errorData.errorDetails = exceptionToString(e);
    } catch (ex) {
        //ignore if error occurs parsing error object
    }
    return errorData;
}

function getFunctionName(f) {
    var funcNameRegex = /function (.{1,})\(/;
    var results = (funcNameRegex).exec(f.toString());
    return (results && results.length > 1) ? results[1] : '';
}

function getConstructorName(o) {
    return getFunctionName(o.constructor);
}

function objectToStringTrace(o) {
    var s = '';
    if (is.anArray(o) || is.anUint8Array(o)) {
        s = Array.prototype.reduce.call(o, function(s, c) {
            return s + ((c >= 32 && c < 128) ? String.fromCharCode(c) : '.');
        }, '');
    } else if (is.aString(o)) {
        s = o;
    } else {
        enumerateOwnProperties(o, function(k, v) {
            s += (s ? ', ' : '') + '{' + k + ': ' + (is.aFunction(v) ? (getFunctionName(v) || 'function') : v) + '}';
        });
    }
    return '[' + getConstructorName(o) + ' ' + s + ']';
}

function randomInt(min, max) {
    return Math.round(min + Math.random() * (max - min));
}

function alternateMerge(arr1, arr2){
    if(!arr1.length){
        return [].concat(arr2);
    }else{
        return arr1.reduce(function(acc, entry, i) {
            if (is.definedAndNotNull(entry)) {
                acc.push(entry);
            }
            if (arr2[i]) {
                acc.push(arr2[i]);
            }
            if ((i === arr1.length - 1) && (arr2.length > i)) {
                acc = acc.concat(arr2.slice(i + 1));
            }
            return acc;
        }, []);
    }
}

function getStoreKey(movieId, prefix, isTest) {
    var storePrefix = prefix;
    if (isTest) {
        storePrefix += 'test';
    }
    return storePrefix + '_' + movieId;
}

function getPrefetchLogData(entry) {
    var data = {},
        status = entry && entry['status'],
        taskStatuses = Enums.PERSISTED_TASK_STATUS;
    
    if (!entry || !status) { // nothing existed in indexedDB when checked during playback.
        data['status'] = taskStatuses.NOT_STARTED; 
        data['attempts'] = 0;
        return data;
    }

    data['status'] = status;
    data['movieId'] = entry['movieId'];

    if(status == taskStatuses.STORAGE_LOAD_FAILED){
        return data;
    }    

    if (entry['status'] == taskStatuses.PENDING || entry['status'] == taskStatuses.COMPLETED) {
        data['attempts'] = entry['attempts'];
        data['uiExpectedStartTime'] = entry['uiExpectedStartTime'];
        data['uiExpectedEndTime'] = entry['uiExpectedEndTime'];
        setStreamData(entry['audio'], data, 'a');
        setStreamData(entry['video'], data, 'v');
    } else if (entry['status'] == taskStatuses.STARTED) {
        data['attempts'] = 1;
    }

    return data;
}
function setStreamData(stream, data, prefix) {
    if (!stream) {
        return;
    }
    try {
        if (stream['bitrate']) {
            data[prefix + 'Bitrate'] = stream['bitrate'];
        }
        if (stream['header']) {
            data[prefix + 'Header'] = stream['header'].length;
        }
        var chunks = stream['chunks'];
        var chunksBytes = 0,
            downloadedChunks = 0;
        if (chunks && chunks.length) {
            chunks.forEach(function(chunk) {
                if (chunk['media'] && chunk['media'].length) {
                    chunksBytes += chunk['media'].length
                    downloadedChunks++;
                }
            });
        }
        data[prefix + 'ChunksBytes'] = chunksBytes;
        data[prefix + 'DownloadedChunks'] = downloadedChunks;
    } catch (e) {
        //log.warn('error in setStreamData', e);
    }
}

/**
* @param {string} tagName
* @param {string|null=} cssText
* @param {string=} innerHTML
* @param {Object=} elementAttributes
*/
function createElement(tagName, cssText, innerHTML, elementAttributes) {
    var element = window['document']['createElement'](tagName);
    if (cssText) {
        element['style']['cssText'] = cssText;
    }
    if (innerHTML) {
        element['innerHTML'] = innerHTML;
    }
    if (elementAttributes) {
        enumerateOwnProperties(elementAttributes, function (k, v) {
            element['setAttribute'](k, v);
        });
    }
    return element;
}

function filterBy(field, val) {
    return function(data) {
        return data[field] === val;
    };
}
},{"9":9}],5:[function(require,module,exports){
var playbackLog,
    createFilteredVideoStreamList,
    lhcache,
    storage,
    Date$now,
    clock$getTime,
    _getCurrentPts,
    aseConsole,
    ipAddress,
    getMediaDownloader,
    getMediaElement,
    getMediaSourceCounter,
    incrementMediaSourceCounter,
    NOOP = function() {};


//=============================================================================
// Storage
//=============================================================================

/**
 *
 * @constructor
 */
function ASEStorage() {
}

ASEStorage.prototype.constructor = ASEStorage;
ASEStorage.prototype.set = function set(key, value) {
    storage.save(key, value);
};

ASEStorage.prototype.get = function get(key, cb) {
    if ( lhcache.hasOwnProperty(key) ) {
        return lhcache[key];
    } else {
        aseConsole.trace("key: " + key + ", is not available in storage cache and needs to be retrieved asynchronously");
        storage.load(key, function (result) {
                if (result.success) {
                    lhcache[key] = result.data;
                    if ( cb ) {
                        cb(result.data);
                    }
                }else{
                    //mark it as available, so that we don't call the storage API again
                    lhcache[key] = undefined;
                }
            });
    }
};

ASEStorage.prototype.remove = function remove(key) {
    storage.remove(key);
};

ASEStorage.prototype.clear = function clear() {
    // TODO: What is the Cadmium equivalent?
    aseConsole.info('WARNING: Calling unimplemented function Storage.clear()');
};


//=============================================================================
// Time
//=============================================================================
/**
 *
 * @constructor
 */
function Time() {
}

Time.prototype.now = function now() {
    return Date$now();

};

// Can be undefined on platforms that don't have it, so one can do
// if (platform.time.mono) foo = platform.time.mono();
Time.prototype.mono = function mono() {
    return clock$getTime();
};

Time.prototype.drm = function drm() {
    // TODO: Not used in JS-ASE. Do we need this in Cadmium?
    aseConsole.info('WARNING: Calling unimplemented function Time.drm()');
};

Time.prototype.monotonow = function (mono) {
    return mono + Date$now() - clock$getTime();
};

Time.prototype.nowtomono = function (now) {
    return now + clock$getTime() - Date$now();
};

//=============================================================================
// Events
//=============================================================================

var EventEmitter = require(94).EventEmitter,
    mixin = require(95);

/**
 *
 * @constructor
 */
function Events() {
    //TODO: Do we need to add anything here?
}

mixin(EventEmitter, Events.prototype);


//=============================================================================
// Network
//=============================================================================

function getNetworkName() {
    return ipAddress;
}

//=============================================================================
// Logging
//=============================================================================

// A constructor that accepts a "trace area" and returns an object with:
//   trace, log, info, warn, error, fatal
// Where 'trace' is not the same as Node or Chrome console.trace, but simply
// another log level that gets compiled out in release builds.

/**
 *
 * @param {string} title
 * @param {string} subtitle
 * @constructor
 */
function ASEConsole(title, subtitle){
    var cadmiumLog = new playbackLog.CategoryLog(title + '|' + subtitle);
    this.info = cadmiumLog.info.bind(cadmiumLog);
    this.fatal = cadmiumLog.fatal.bind(cadmiumLog);
    this.error = cadmiumLog.error.bind(cadmiumLog);
    this.warn = cadmiumLog.warn.bind(cadmiumLog);
    this.trace = cadmiumLog.trace.bind(cadmiumLog);
    this.debug = cadmiumLog.debug.bind(cadmiumLog);
    this.log = cadmiumLog.log.bind(cadmiumLog);
}

//=============================================================================
// Media Time
//=============================================================================

function getCurrentPts(ctxt) {
    return _getCurrentPts();
}
//=============================================================================
// Memory
//=============================================================================
function getHeapSize(cb) {
    var memoryInfo = {
        osallocatorcommitted: 0,
        systemallocated: 0,
        heapsize: 0,
        fastmalloc: 0
    };
    cb(memoryInfo);
}

//=============================================================================
// MediaRequest
//=============================================================================

var PromiseASE = (function PROMISE_FOR_CADASE(){
                        var PromiseASE = Promise;
                        PromiseASE.prototype.fail = Promise.prototype.catch;
                        return PromiseASE;
                })();
var MediaRequest;
var DownloadTrack;
var DownloadTrackFactory;
var SourceBufferASE;
var MediaSourceASE;

//=============================================================================
// Exports
//=============================================================================

module.exports = function(platformDeps) {
    playbackLog = platformDeps.playbackLog;
    storage = platformDeps.storage;
    lhcache = platformDeps.lhcache;
    Date$now = platformDeps.getNow;
    getMediaDownloader = platformDeps.getMediaDownloader;
    getMediaElement = platformDeps.getMediaElement;
    getMediaSourceCounter = platformDeps.getMediaSourceCounter;
    incrementMediaSourceCounter = platformDeps.incrementMediaSourceCounter;
    clock$getTime = platformDeps.getTime;
    aseConsole = new playbackLog.CategoryLog('JS-ASE | Platform');
    MediaRequest = platformDeps.MediaRequest;
    DownloadTrack = platformDeps.DownloadTrack;
    SourceBufferASE = platformDeps.SourceBuffer;
    MediaSourceASE = platformDeps.MediaSource;
    _getCurrentPts = platformDeps.getCurrentPts;
    ipAddress = platformDeps.ipAddress;
    createFilteredVideoStreamList = platformDeps.createFilteredVideoStreamList;

    return {
        name: "cadmium",

        createFilteredVideoStreamList: createFilteredVideoStreamList,

        playbackLog: playbackLog,

        getMediaDownloader: getMediaDownloader,

        getMediaElement: getMediaElement,

        getMediaSourceCounter: getMediaSourceCounter,

        incrementMediaSourceCounter: incrementMediaSourceCounter,

        // ready
        ready: NOOP,

        //Error Map
        /** @const */
        aseErrorCodes: {
            AS_DNS_ERROR: 1,
            AS_DNS_TIMEOUT: 2,
            AS_DNS_QUERY_REFUSED: 3,
            AS_DNS_NOT_FOUND: 4,
            AS_CONNECTION_NET_UNREACHABLE: 5,
            AS_CONNECTION_REFUSED: 6,
            AS_CONNECTION_TIMEOUT: 7,
            AS_CONNECTION_CLOSED: 8,
            AS_CONNECTION_RESET: 9,
            AS_CONNECTION_ERROR: 10,
            AS_HTTP_CONNECTION_ERROR: 11,
            AS_HTTP_CONNECTION_TIMEOUT: 12,
            AS_HTTP_CONNECTION_STALL: 13,
            AS_HTTP_PROTOCOL_ERROR: 14,
            AS_HTTP_RESPONSE_4XX: 15,
            AS_HTTP_RESPONSE_5XX: 16,
            AS_HTTP_TOO_MANY_REDIRECTS: 17,
            AS_HTTP_TRANSACTION_TIMEOUT: 18,
            AS_HTTP_MESSAGE_LENGTH_ERROR: 19,
            AS_HTTP_HEADER_LENGTH_ERROR: 20,
            AS_CONNECTION_NO_ROUTE_TO_HOST: 21,
            AS_CONNECTION_NETWORK_DOWN: 22,
            AS_CONNECTION_NO_ADDRESS: 23,
            AS_CONNECTION_RESET_ON_CONNECT: 24,
            AS_CONNECTION_RESET_WHILE_RECEIVING: 25,
            AS_DNS_BAD_FAMILY: 26,
            AS_DNS_BAD_FLAGS: 27,
            AS_DNS_BAD_HINTS: 28,
            AS_DNS_BAD_NAME: 29,
            AS_DNS_BAD_STRING: 30,
            AS_DNS_CANCELLED: 31,
            AS_DNS_CHANNEL_DESTROYED: 32,
            AS_DNS_CONNECTION_REFUSED: 33,
            AS_DNS_EOF: 34,
            AS_DNS_FILE: 35,
            AS_DNS_FORMAT_ERROR: 36,
            AS_DNS_NOT_IMPLEMENTED: 37,
            AS_DNS_NOT_INITIALIZED: 38,
            AS_DNS_NO_DATA: 39,
            AS_DNS_NO_MEMORY: 40,
            AS_DNS_NO_NAME: 41,
            AS_DNS_QUERY_MALFORMED: 42,
            AS_DNS_RESPONSE_MALFORMED: 43,
            AS_DNS_SERVER_FAILURE: 44,
            AS_SOCKET_ERROR: 45,
            AS_TIMEOUT: 46,
            AS_HTTPS_CONNECTION_ERROR: 47,
            AS_HTTPS_CONNECTION_TIMEOUT: 48,
            AS_HTTPS_CONNECTION_REDIRECT_TO_HTTP: 49
        },

        // Storage
        storage: new ASEStorage(),
        Storage: ASEStorage,

        // Time
        time: new Time(),

        // Events
        events: new Events(),

        // Logging
        console: new ASEConsole('JS-ASE', 'default'),
        Console: ASEConsole,

        // Options
        options: NOOP,

        // Promise
        Promise: PromiseASE,

        // MediaRequest
        MediaRequest: MediaRequest,
        DownloadTrack: DownloadTrack,
        MediaSourceBuffer: SourceBufferASE,
        MediaSource: MediaSourceASE,

        // Network
        network: {name: getNetworkName},

        // Memory
        memory: {getHeapSize: getHeapSize},

        // CurrentPts
        // This will be updated in playback.createWorkedObjects
        getCurrentPts: _getCurrentPts,

        // MediaBuffer
        // This will be updated in playback.createWorkedObjects
        mediaBuffer: undefined
    };
};

},{"94":94,"95":95}],6:[function(require,module,exports){
/*
 * (c) 1997-2014 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

//=============================================================================
// This overrides ASE parameters with Cadmium defaults.
//
//=============================================================================

module.exports = function (config) {
    return {
        'minInitVideoBitrate': config.minInitVideoBitrate,

        'minHCInitVideoBitrate': config.minHCInitVideoBitrate,

        'maxInitVideoBitrate': config.maxInitVideoBitrate,

        'minInitAudioBitrate': config.minInitAudioBitrate,

        'maxInitAudioBitrate': config.maxInitAudioBitrate,

        'minHCInitAudioBitrate': config.minHCInitAudioBitrate,

        'minAcceptableVideoBitrate': config.minAcceptableVideoBitrate,

        'minRequiredBuffer': config.minRequiredBuffer,

        'minPrebufSize': config.minPrebufSize,

        'rebufferingFactor': config.rebufferingFactor,

        'useMaxPrebufSize': config.useMaxPrebufSize,

        'maxPrebufSize': config.maxPrebufSize,

        'maxBufferingTime': config.maxBufferingTime,

        'initialBitrateSelectionCurve': config.initialBitrateSelectionCurve,

        'initSelectionLowerBound': config.initSelectionLowerBound,

        'initSelectionUpperBound': config.initSelectionUpperBound,

        'throughputPercentForAudio': config.throughputPercentForAudio,

        'bandwidthMargin': config.bandwidthMargin,

        'bandwidthMarginCurve': config.bandwidthMarginCurve,

        'conservBandwidthMargin': config.conservBandwidthMargin,

        'conservBandwidthMarginTputThreshold': config.conservBandwidthMarginTputThreshold,

        'conservBandwidthMarginCurve': config.conservBandwidthMarginCurve,

        'bandwidthMarginScaledRatioUpperBound': config.bandwidthMarginScaledRatioUpperBound,

        'maxTotalBufferLevelPerSession': config.maxTotalBufferLevelPerSession,

        'highWatermarkLevel': config.highWatermarkLevel,

        'toStableThreshold': config.toStableThreshold,

        'toUnstableThreshold': config.toUnstableThreshold,

        'skipBitrateInUpswitch': config.skipBitrateInUpswitch,

        'watermarkLevelForSkipStart': config.watermarkLevelForSkipStart,

        'highStreamRetentionWindow': config.highStreamRetentionWindow,

        'highStreamTransitionWindow': config.highStreamTransitionWindow,

        'lowestBufForUpswitch': config.lowestBufForUpswitch,

        'lockPeriodAfterDownswitch': config.lockPeriodAfterDownswitch,

        'lowWatermarkLevel': config.lowWatermarkLevel,

        'maxSimuLength': config.maxSimuLength,

        'lowestWaterMarkLevel': config.lowestWaterMarkLevel,

        'mediaRate': config.mediaRate,

        'maxTrailingBufferLen': config.maxTrailingBufferLen,

        'audioBufferTargetAvailableSize': config.audioBufferTargetAvailableSize,

        'videoBufferTargetAvailableSize': config.videoBufferTargetAvailableSize,

        'maxVideoTrailingBufferSize': config.maxVideoTrailingBufferSize,

        'maxAudioTrailingBufferSize': config.maxAudioTrailingBufferSize,

        'fastUpswitchFactor': config.fastUpswitchFactor,

        'maxMediaBufferAllowed': config.maxMediaBufferAllowed,

        'simulatePartialBlocks': config.simulatePartialBlocks,

        'simulateBufferFull': config.simulateBufferFull,

        'considerConnectTime': config.considerConnectTime,

        'connectTimeMultiplier': config.connectTimeMultiplier,

        'lowGradeModeEnterThreshold': config.lowGradeModeEnterThreshold,

        'lowGradeModeExitThreshold': config.lowGradeModeExitThreshold,

        'maxDomainFailureWaitDuration': config.maxDomainFailureWaitDuration,

        'maxAttemptsOnFailure': config.maxAttemptsOnFailure,

        'exhaustAllLocationsForFailure': config.exhaustAllLocationsForFailure,

        'maxNetworkErrorsDuringBuffering': config.maxNetworkErrorsDuringBuffering,

        'maxBufferingTimeAllowedWithNetworkError': config.maxBufferingTimeAllowedWithNetworkError,

        'fastDomainSelectionBwThreshold': config.fastDomainSelectionBwThreshold,

        'throughputProbingEnterThreshold': config.throughputProbingEnterThreshold,

        'throughputProbingExitThreshold': config.throughputProbingExitThreshold,

        'locationProbingTimeout': config.locationProbingTimeout,

        'finalLocationSelectionBwThreshold': config.finalLocationSelectionBwThreshold,

        'throughputHighConfidenceLevel': config.throughputHighConfidenceLevel,

        'throughputLowConfidenceLevel': config.throughputLowConfidenceLevel,

        'locationStatisticsUpdateInterval': config.locationStatisticsUpdateInterval,

        'countGapInBuffer': config.countGapInBuffer,

        'allowReissueMediaRequestAfterAbort': config.allowReissueMediaRequestAfterAbort,

        'preciseBufferCalculation': config.preciseBufferCalculation,

        'bufferThresholdForAbort': config.bufferThresholdForAbort,

        'allowCallToStreamSelector': config.allowCallToStreamSelector,

        'pipelineScheduleTimeoutMs': config.pipelineScheduleTimeoutMs,

        'maxPartialBuffersAtBufferingStart': config.maxPartialBuffersAtBufferingStart,

        'minPendingBufferLen': config.minPendingBufferLen,

        'maxPendingBufferLen': config.maxPendingBufferLen,

        'maxStreamingSkew': config.maxStreamingSkew,

        'maxPendingBufferPercentage': config.maxPendingBufferPercentage,

        'maxRequestsInBuffer': config.maxRequestsInBuffer,

        'headerRequestSize': config.headerRequestSize,

        'minBufferLenForHeaderDownloading': config.minBufferLenForHeaderDownloading,

        'reserveForSkipbackBufferMs': config.reserveForSkipbackBufferMs,

        'pipelineEnabled': config.pipelineEnabled,

        'maxParallelConnections': config.maxParallelConnections,

        'socketReceiveBufferSize': config.socketReceiveBufferSize,

        // TODO: need to hook up with system capability
        // audio socket receive buffer size
        'audioSocketReceiveBufferSize': config.audioSocketReceiveBufferSize,

        // video socket receive buffer size
        'videoSocketReceiveBufferSize': config.videoSocketReceiveBufferSize,

        // header socket receive buffer size
        'headersSocketReceiveBufferSize': config.headersSocketReceiveBufferSize,

        'updatePtsIntervalMs': config.updatePtsIntervalMs,

        'bufferLevelNotifyIntervalMs': config.bufferLevelNotifyIntervalMs,

        'enableAbortTesting': config.enableAbortTesting,

        'abortRequestFrequency': config.abortRequestFrequency,

        'streamingStatusIntervalMs': config.streamingStatusIntervalMs,

        'prebufferTimeLimit': config.prebufferTimeLimit,

        'minBufferLevelForTrackSwitch': config.minBufferLevelForTrackSwitch,

        'penaltyFactorForLongConnectTime': config.penaltyFactorForLongConnectTime,

        'longConnectTimeThreshold': config.longConnectTimeThreshold,

        'additionalBufferingLongConnectTime': config.additionalBufferingLongConnectTime,

        'additionalBufferingPerFailure': config.additionalBufferingPerFailure,

        'rebufferCheckDuration': config.rebufferCheckDuration,

        'enableLookaheadHints': config.enableLookaheadHints,

        'lookaheadFragments': config.lookaheadFragments,

        'updateDrmRequestOnNetworkFailure': config.updateDrmRequestOnNetworkFailure,

        'deferAseScheduling': config.deferAseScheduling,

        'maxDiffAudioVideoEndPtsMs': config.maxDiffAudioVideoEndPtsMs,

        'defaultHeaderCacheSize': config.defaultHeaderCacheSize,

        'defaultHeaderCacheDataCount': config.defaultHeaderCacheDataCount,

        'headerCacheMaxPendingData': config.headerCacheMaxPendingData,

        'recreateHeaderCacheDownloadTracks': config.recreateHeaderCacheDownloadTracks,

        'headerCachePriorityLimit': config.headerCachePriorityLimit,

        'headerCacheFlushForCircularBuffer':config.headerCacheFlushForCircularBuffer,

        'enableUsingHeaderCount': config.enableUsingHeaderCount,

        'networkFailureResetWaitMs': config.networkFailureResetWaitMs,

        'networkFailureAbandonMs': config.networkFailureAbandonMs,

        'maxThrottledNetworkFailures': config.maxThrottledNetworkFailures,

        'throttledNetworkFailureThresholdMs': config.throttledNetworkFailureThresholdMs,

        'abortUnsentBlocks': config.abortUnsentBlocks,

        'maxUnsentBlocks': config.maxUnsentBlocks,

        'lowThroughputThreshold': config.lowThroughputThreshold,

        'mp4ParsingInNative': config.mp4ParsingInNative,

        'sourceBufferInOrderAppend': config.sourceBufferInOrderAppend,

        'allowAudioToStreamPastVideo': config.allowAudioToStreamPastVideo,

        'pruneRequestsFromNative': config.pruneRequestsFromNative,

        'preciseBufferLevel': config.preciseBufferLevel,

        'enableManagerDebugTraces': config.enableManagerDebugTraces,

        'managerDebugMessageInterval': config.managerDebugMessageInterval,

        'managerDebugMessageCount': config.managerDebugMessageCount,

        'bufferThresholdToSwitchToSingleConnMs': config.bufferThresholdToSwitchToSingleConnMs,

        'bufferThresholdToSwitchToParallelConnMs': config.bufferThresholdToSwitchToParallelConnMs,

        'expandDownloadTime': config.expandDownloadTime,

        'minimumMeasurementTime': config.minimumMeasurementTime,

        'minimumMeasurementBytes': config.minimumMeasurementBytes,

        'throughputMeasurementTimeout': config.throughputMeasurementTimeout,

        'initThroughputMeasureDataSize':  config.initThroughputMeasureDataSize,

        'throughputMeasureWindow': config.throughputMeasureWindow,

        'connectTimeHalflife': config.connectTimeHalflife,

        'responseTimeHalflife': config.responseTimeHalflife,

        'historicBandwidthUpdateInterval': config.historicBandwidthUpdateInterval,

        'throughputMeasurementWindowCurve': config.throughputMeasurementWindowCurve,

        'throughputWarmupTime': config.throughputWarmupTime,

        'throughputWarmupMode': config.throughputWarmupMode,

        'minimumBufferToStopProbing': config.minimumBufferToStopProbing,

        'enableDecayInThroughputEstimate': config.enableDecayInThroughputEstimate,

        'throughputPredictor': config.throughputPredictor,

        'holtWintersDiscretizeInterval': config.holtWintersDiscretizeInterval, //ms

        'holtWintersHalfLifeAlpha': config.holtWintersHalfLifeAlpha, // halfLife in ms

        'holtWintersHalfLifeGamma': config.holtWintersHalfLifeGamma, // halfLife in ms

        'holtWintersInitialCounts': config.holtWintersInitialCounts,

        'holtWintersMinInitialCounts': config.holtWintersMinInitialCounts,

        'holtWintersHalfLifeCurveEnabled': config.holtWintersHalfLifeCurveEnabled,

        'holtWintersUpperBoundEnabled': config.holtWintersUpperBoundEnabled,

        'ase_stream_selector': config.ase_stream_selector,

        'initBitrateSelectorAlgorithm': config.initBitrateSelectorAlgorithm,

        'debugLocationSelectorFailureSimulation': config.debugLocationSelectorFailureSimulation,

        'debugDumpFragments': config.debugDumpFragments,

        'debugLocationHistoryThroughput': config.debugLocationHistoryThroughput,

        'debugNetworkMonitorThroughput': config.debugNetworkMonitorThroughput,

        'debugVerboseSimulation': config.debugVerboseSimulation,

        'logChunkLevelTput': config.logChunkLevelTput,

        'logOverallTputAsRef': config.logOverallTputAsRef,

        'overallTputInterval': config.overallTputInterval,

        'maxIQRSamples': config.maxIQRSamples,

        'bufferBased': config.bufferBased,

        'periodicHistoryPersistMs': config.periodicHistoryPersistMs
    };
};

},{}],7:[function(require,module,exports){
module.exports = require(5);
},{"5":5}],8:[function(require,module,exports){
"use strict";
exports.numberComparator = function (first, second) { return first - second; };
/** String comparison based on String.localeCompare */
exports.stringComparator = function (first, second) { return first.localeCompare(second); };

},{}],9:[function(require,module,exports){
"use strict";
var DefaultBase16Encoder_1 = require(10);
var DefaultBase64Encoder_1 = require(11);
var DefaultUtf8Encoder_1 = require(21);
var DefaultThroughputTracker_1 = require(36);
var CDNThroughputTrackerImpl_1 = require(38);
var CDNDownloadImpl_1 = require(37);
var DefaultThroughputConfig_1 = require(35);
var DefaultDownload_1 = require(34);
var DefaultRange_1 = require(18);
var DefaultClock_1 = require(12);
var DefaultDispatcher_1 = require(13);
var DefaultIdProvider_1 = require(15);
var DefaultRandomGenerator_1 = require(17);
var DefaultLogger_1 = require(23);
var DefaultSystemClock_1 = require(20);
var errors_1 = require(25);
var errors_2 = require(25);
var enums_1 = require(24);
var DefaultError_1 = require(14);
var DefaultIsType_1 = require(16);
var DefaultStringUtils_1 = require(19);
var Utils_1 = require(8);
var VideoPreparer_1 = require(41);
var SubtitleTracker_1 = require(33);
var DefaultUtilities_1 = require(22);
var EnvelopeDecryptorImpl_1 = require(27);
var PrepareMessageHandlerImpl_1 = require(28);
var SharedSecretServiceImpl_1 = require(29);
var LocalStorageImpl_1 = require(31);
var DebugImpl_1 = require(26);
module.exports = {
    DefaultThroughputTracker: DefaultThroughputTracker_1.DefaultThroughputTracker,
    CDNThroughputTrackerImpl: CDNThroughputTrackerImpl_1.CDNThroughputTrackerImpl,
    DefaultThroughputConfig: DefaultThroughputConfig_1.DefaultThroughputConfig,
    DefaultDownload: DefaultDownload_1.DefaultDownload,
    CDNDownloadImpl: CDNDownloadImpl_1.CDNDownloadImpl,
    DefaultRange: DefaultRange_1.DefaultRange,
    DefaultClock: DefaultClock_1.DefaultClock,
    DefaultDispatcher: DefaultDispatcher_1.DefaultDispatcher,
    DefaultIdProvider: DefaultIdProvider_1.DefaultIdProvider,
    DefaultRandomGenerator: DefaultRandomGenerator_1.DefaultRandomGenerator,
    DefaultLogger: DefaultLogger_1.DefaultLogger,
    DefaultSystemClock: DefaultSystemClock_1.DefaultSystemClock,
    ErrorCodes: errors_1.ErrorCodes,
    ErrorSubCodes: errors_1.ErrorSubCodes,
    ErrorExtCodes: errors_2.ErrorExtCodes,
    Enums: enums_1.Enums,
    DefaultError: DefaultError_1.DefaultError,
    DefaultIsType: DefaultIsType_1.DefaultIsType,
    Base16Encoder: DefaultBase16Encoder_1.DefaultBase16Encoder,
    Base64Encoder: DefaultBase64Encoder_1.DefaultBase64Encoder,
    Utf8Encoder: DefaultUtf8Encoder_1.DefaultUtf8Encoder,
    Utils: { numberComparator: Utils_1.numberComparator, stringComparator: Utils_1.stringComparator },
    VideoPreparer: VideoPreparer_1.VideoPreparer,
    SubtitleTracker: SubtitleTracker_1.SubtitleTracker,
    DefaultStringUtils: DefaultStringUtils_1.DefaultStringUtils,
    EnvelopeDecryptorImpl: EnvelopeDecryptorImpl_1.EnvelopeDecryptorImpl,
    SharedSecretServiceImpl: SharedSecretServiceImpl_1.SharedSecretServiceImpl,
    PrepareMessageHandlerImpl: PrepareMessageHandlerImpl_1.PrepareMessageHandlerImpl,
    DefaultUtilities: DefaultUtilities_1.DefaultUtilities,
    LocalStorage: LocalStorageImpl_1.LocalStorageImpl,
    DebugImpl: DebugImpl_1.DebugImpl
};

},{"10":10,"11":11,"12":12,"13":13,"14":14,"15":15,"16":16,"17":17,"18":18,"19":19,"20":20,"21":21,"22":22,"23":23,"24":24,"25":25,"26":26,"27":27,"28":28,"29":29,"31":31,"33":33,"34":34,"35":35,"36":36,"37":37,"38":38,"41":41,"8":8}],10:[function(require,module,exports){
"use strict";
var BASE16_DIGITS = '0123456789ABCDEF';
var BASE16_DIGITS_INV = {
    '0': 0,
    '1': 1,
    '2': 2,
    '3': 3,
    '4': 4,
    '5': 5,
    '6': 6,
    '7': 7,
    '8': 8,
    '9': 9,
    'A': 10,
    'B': 11,
    'C': 12,
    'D': 13,
    'E': 14,
    'F': 15,
    'a': 10,
    'b': 11,
    'c': 12,
    'd': 13,
    'e': 14,
    'f': 15
};
/**
 * Default implementation of the [[Base16Encoder]] contract
 *
 * @author Kevin Gallagher<keving@netflix.com>
 */
var DefaultBase16Encoder = (function () {
    function DefaultBase16Encoder() {
    }
    DefaultBase16Encoder.prototype.decode = function (hex) {
        var array = new Uint8Array(hex.length / 2);
        for (var i = 0; i < array.length; i++) {
            array[i] = this.toUInt(hex.substr(i * 2, 2));
        }
        return array;
    };
    DefaultBase16Encoder.prototype.encode = function (array) {
        var hex = '', length = array.length, b;
        for (var i = 0; i < length; i++) {
            b = array[i];
            hex += BASE16_DIGITS[b >>> 4] + BASE16_DIGITS[b & 0xF];
        }
        return hex;
    };
    DefaultBase16Encoder.prototype.fromInt = function (i, bytes) {
        var hex = '';
        bytes = bytes << 1;
        while (bytes--) {
            hex = (BASE16_DIGITS[i & 0xF] || '0') + hex;
            i = i >>> 4;
        }
        return hex;
    };
    DefaultBase16Encoder.prototype.toUInt = function (hex) {
        var length = hex.length;
        if (length > 7)
            throw new Error('hex to long');
        var result = 0;
        for (var i = 0; i < length; i++) {
            result = result * 0x10 + BASE16_DIGITS_INV[hex[i]];
        }
        return result;
    };
    return DefaultBase16Encoder;
}());
exports.DefaultBase16Encoder = DefaultBase16Encoder;

},{}],11:[function(require,module,exports){
"use strict";
var CHARS_COMMON = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
var CHARS = CHARS_COMMON + '+/';
var CHARS_URL_SAFE = CHARS_COMMON + '-_';
var slice = Array.prototype.slice;
var map = slice.call(CHARS);
var mapUrlSafe = slice.call(CHARS_URL_SAFE);
var charNumber1 = {};
var charNumber2 = {};
var charNumber3 = {};
var charNumber4 = {};
var prepRegex = /\s+/g;
[map, mapUrlSafe].forEach(function (map) {
    var i = map.length;
    var c;
    while (i--) {
        // pre-calculate values for each of quad-s
        c = map[i];
        charNumber1[c] = i << 18;
        charNumber2[c] = i << 12;
        charNumber3[c] = i << 6;
        charNumber4[c] = i;
    }
});
/**
 * Default implementation of the [[Base64Encoder]] contract
 *
 * @author Kevin Gallagher<keving@netflix.com>
 */
var DefaultBase64Encoder = (function () {
    function DefaultBase64Encoder() {
    }
    /**
     * Encode an array of bytes into a base 64 string
     * @param {Uint8Array} array the array to encode
     */
    DefaultBase64Encoder.prototype.encode = function (array) {
        return DefaultBase64Encoder.encodeInternal(array, map, '=');
    };
    /**
     * Decode a base 64 string into an array of bytes
     * @param {string} s the string to decode
     */
    DefaultBase64Encoder.prototype.decode = function (s) {
        return DefaultBase64Encoder.decodeInternal(s);
    };
    DefaultBase64Encoder.decodeInternal = function (s) {
        s = s.replace(prepRegex, '');
        var l = s.length, c;
        // strip at most 2 pad chars from the end ('=' for regular, '.' for url safe)
        c = s.charAt(l - 1);
        if (c === '=' || c === '.') {
            l--;
        }
        c = s.charAt(l - 1);
        if (c === '=' || c === '.') {
            l--;
        }
        var aLength = ((l >> 2) * 3);
        var aPaddedLength = 0;
        switch (l % 4) {
            case 2:
                aPaddedLength = 1;
                break;
            case 3:
                aPaddedLength = 2;
                break;
            case 1:
                throw new Error('bad base64');
        }
        var a = new Uint8Array(aLength + aPaddedLength), si = 0, ai = 0, triplet;
        while (ai < aLength) {
            triplet = charNumber1[s[si++]] + charNumber2[s[si++]] + charNumber3[s[si++]] + charNumber4[s[si++]];
            if (!(triplet >= 0 && triplet <= 0xFFFFFF)) {
                throw new Error('bad base64');
            }
            a[ai++] = (triplet >>> 16);
            a[ai++] = (triplet >>> 8) & 0xFF;
            a[ai++] = (triplet) & 0xFF;
        }
        if (aPaddedLength > 0) {
            triplet = charNumber1[s[si++]] + charNumber2[s[si++]];
            a[ai++] = (triplet >>> 16);
            if (aPaddedLength > 1) {
                triplet = triplet + charNumber3[s[si++]];
                a[ai++] = (triplet >>> 8) & 0xFF;
            }
            if (!(triplet >= 0 && triplet <= 0xFFFF00 && ((triplet & (aPaddedLength > 1 ? 0x0000FF : 0x00FFFF)) === 0))) {
                throw new Error('bad base64');
            }
        }
        return a;
    };
    DefaultBase64Encoder.encodeInternal = function (a, map, padChar) {
        var s = '', i = 0, l = a.length, lMinus2 = l - 2, triplet;
        while (i < lMinus2) {
            triplet =
                (a[i++] << 16) +
                    (a[i++] << 8) +
                    (a[i++]);
            if (!(triplet >= 0 && triplet <= 0xFFFFFF)) {
                throw new Error('not bytes');
            }
            s +=
                map[(triplet >>> 18)] +
                    map[(triplet >>> 12) & 0x3F] +
                    map[(triplet >>> 6) & 0x3F] +
                    map[(triplet) & 0x3F];
        }
        if (i == lMinus2) {
            triplet =
                (a[i++] << 8) +
                    (a[i++]);
            if (!(triplet >= 0 && triplet <= 0xFFFF)) {
                throw new Error('not bytes');
            }
            s +=
                map[(triplet >>> 10)] +
                    map[(triplet >>> 4) & 0x3F] +
                    map[(triplet << 2) & 0x3F] +
                    padChar;
        }
        else if (i == l - 1) {
            triplet =
                (a[i++]);
            if (!(triplet >= 0 && triplet <= 0xFF)) {
                throw new Error('not bytes');
            }
            s +=
                map[(triplet >>> 2)] +
                    map[(triplet << 4) & 0x3F] +
                    padChar +
                    padChar;
        }
        else {
        }
        return s;
    };
    return DefaultBase64Encoder;
}());
exports.DefaultBase64Encoder = DefaultBase64Encoder;

},{}],12:[function(require,module,exports){
"use strict";
/**
 * Clock implementation based on Date object.
 *
 * @author neddy@netflix.com
 */
var DefaultClock = (function () {
    function DefaultClock(systemClock, clockListener) {
        if (clockListener === void 0) { clockListener = { onClockRolledback: function () { } }; }
        this.systemClock = systemClock;
        this.clockListener = clockListener;
        // so getElapsedRuntimeMilliseconds never returns a 0, 1 ms precision sacrifice is ok
        // TODO: why is this important?
        this.genesis = this.systemClock.getEpochMilliseconds() - 1;
        this.lastGetTime = 0;
    }
    DefaultClock.prototype.getElapsedRuntimeMilliseconds = function () {
        var time = this.systemClock.getEpochMilliseconds() - this.genesis;
        if (time < this.lastGetTime) {
            var fixedTime = this.lastGetTime + 1;
            var delta = fixedTime - time;
            this.clockListener.onClockRolledback(delta);
            this.genesis -= delta;
            time = fixedTime;
        }
        return this.lastGetTime = time;
    };
    DefaultClock.prototype.getLaunchTimeSeconds = function () {
        return DefaultClock.toSeconds(this.genesis);
    };
    DefaultClock.prototype.getEpochSeconds = function () {
        return DefaultClock.toSeconds(this.systemClock.getEpochMilliseconds());
    };
    DefaultClock.toSeconds = function (milliseconds) {
        return Math.floor(milliseconds / DefaultClock.MILLISECONDS_PER_SECOND);
    };
    DefaultClock.prototype.getGenesisMilliseconds = function () {
        return this.genesis;
    };
    DefaultClock.MILLISECONDS_PER_SECOND = 1000;
    return DefaultClock;
}());
exports.DefaultClock = DefaultClock;

},{}],13:[function(require,module,exports){
"use strict";
/**
 * Window based dispatcher that works in Browser.
 *
 * @author neddy@netflix.com
 */
var DefaultDispatcher = (function () {
    function DefaultDispatcher() {
    }
    DefaultDispatcher.prototype.dispatch = function (command) {
        return this.dispatchAfter(command, 0);
    };
    DefaultDispatcher.prototype.dispatchAfter = function (command, delayMilliseconds) {
        return { getId: function () { return window.setTimeout(command, delayMilliseconds); }, isInterval: function () { return false; } };
    };
    DefaultDispatcher.prototype.dispatchAtInterval = function (command, delayMilliseconds) {
        return { getId: function () { return window.setInterval(command, delayMilliseconds); }, isInterval: function () { return true; } };
    };
    DefaultDispatcher.prototype.cancelDispatch = function (handle) {
        if (handle.isInterval()) {
            window.clearInterval(handle.getId());
        }
        else {
            window.clearTimeout(handle.getId());
        }
    };
    return DefaultDispatcher;
}());
exports.DefaultDispatcher = DefaultDispatcher;

},{}],14:[function(require,module,exports){
"use strict";
var errors_1 = require(25);
/**
 * Default CadmiumError implementation
 *
 * @author Kevin Gallagher <keving@netflix.com>
 */
var DefaultError = (function () {
    /**
     * Creates a new instance of [[DefaultError]].
     * @param {number} code     The primary error code
     * @param {number} subCode  The sub error code - generally indicates a specialization of the primary error
     * @param {string} extCode  The external error code - generally the error code returned by the browser
     * @param {string} edgeCode The error code that may originate from the Edge API server layer
     * @param {string} message  Human readable description of the error
     * @param {string} details  Human readable additional details, typically extracted from exception data
     * @param {Object} data     Additional data such as exceptions
     */
    function DefaultError(code, subCode, extCode, edgeCode, message, details, data) {
        if (code === void 0) { code = errors_1.ErrorCodes.UNKNOWN; }
        this.code = code;
        this.subCode = subCode;
        this.extCode = extCode;
        this.edgeCode = edgeCode;
        this.message = message;
        this.details = details;
        this.data = data;
        this.success = false;
    }
    /**
     * Extracts information from exceptions. Pulls the stack, number and message fields from
     * the input parameter is they exist. Formats the data as:
     *
     * <code>
     * e.message<br>
     * e.stack<br>
     * number: e.number
     * </code>
     *
     * @param  {Object} e The error information to inspect
     * @return {string}   The formatted exception information
     */
    DefaultError.exceptionToString = function (e) {
        if (e) {
            // stack has the exception, don't duplicate it
            var stack = e['stack'];
            var number = e['number'];
            var message = e['message'];
            if (!message) {
                message = '' + e;
            }
            var s;
            if (stack) {
                s = '' + stack;
                if (s.indexOf(message) !== 0) {
                    s = message + '\n' + s;
                }
            }
            else {
                s = message;
            }
            if (number) {
                // some exceptions have a "number", track that to
                s += '\nnumber:' + number;
            }
            return s;
        }
        return '';
    };
    /**
     * Converts a javascript error or exception into a human readable string and assigns it to the
     * details property. Then it assigns the data property the value of e.
     * @param e The error information to convert and assign
     */
    DefaultError.prototype.detailsFromException = function (e) {
        this.details = DefaultError.exceptionToString(e);
        this.data = e;
    };
    return DefaultError;
}());
exports.DefaultError = DefaultError;

},{"25":25}],15:[function(require,module,exports){
"use strict";
/**
 * IdProvider that uses an [[AppClock]] to generate values.
 *
 * @author neddy@netflix.com
 */
var DefaultIdProvider = (function () {
    function DefaultIdProvider(clock, random) {
        this.clock = clock;
        this.random = random;
    }
    DefaultIdProvider.prototype.createId = function () {
        return this.clock.getEpochSeconds() * DefaultIdProvider.CONSTANT + Math.floor(this.random.getRandomNumber() * DefaultIdProvider.CONSTANT);
    };
    DefaultIdProvider.CONSTANT = 10000;
    return DefaultIdProvider;
}());
exports.DefaultIdProvider = DefaultIdProvider;

},{}],16:[function(require,module,exports){
"use strict";
var TYPEOF_STRING = 'string';
var TYPEOF_NUMBER = 'number';
var TYPEOF_FUNCTION = 'function';
var TYPEOF_OBJECT = 'object';
var URLREGEX = /^\S+$/;
/**
 * Default implementation of the [[IsType]] contract
 *
 * @author Kevin Gallagher<keving@netflix.com>
 */
var DefaultIsType = (function () {
    function DefaultIsType() {
    }
    /**
     * Determines if a value is defined
     * @param {?} o Value to inspect
     * @returns {boolean} True if the value is defined; false otherwise
     */
    DefaultIsType.prototype.defined = function (o) {
        return o !== undefined;
    };
    ;
    /**
     * Determines if a value is defined and not null
     * @param {?} o Value to inspect
     * @returns {boolean} True if the value is defined and not null; false otherwise
     */
    DefaultIsType.prototype.definedAndNotNull = function (o) {
        return o !== null && o !== undefined;
    };
    ;
    /**
     * Determines if a value is an object
     * @param {?} o Value to inspect
     * @returns {boolean} True if the value is an object; false otherwise
     */
    DefaultIsType.prototype.anObject = function (o) {
        return DefaultIsType.anObjectInteranl(o);
    };
    ;
    /**
     * Determines if a value is a valid object (not undefined)
     * @param {?} o Value to inspect
     * @returns {boolean} True if the value is an object; false otherwise
     */
    DefaultIsType.prototype.aValidObject = function (o) {
        return !!(o && DefaultIsType.anObjectInteranl(o));
    };
    ;
    /**
     * Determines if a value is an array
     * @param {?} o Value to inspect
     * @returns {boolean} True if the value is an array; false otherwise
     */
    DefaultIsType.prototype.anArray = function (o) {
        return Array.isArray(o);
    };
    ;
    /**
     * Determines if a value is a Uint8Array array
     * @param {?} o Value to inspect
     * @returns {boolean} True if the value is a Uint8Array array; false otherwise
     */
    DefaultIsType.prototype.anUint8Array = function (o) {
        return !!(o && o.constructor == Uint8Array);
    };
    ;
    /**
     * Determines if a value is an number, optionally validating if the value
     * falls within an allowed range
     * @param {?} n value to check
     * @param {number=} min Minimum allowed value
     * @param {number=} max Maximum allowed value
     * @returns {boolean} true if it is an integer in the allowed range; false otherwise
     */
    DefaultIsType.prototype.aNumber = function (n, min, max) {
        return DefaultIsType.aNumberInternal(n, min, max);
    };
    ;
    /**
     * Determines if a value is an integer, optionally validating if the value
     * falls within an allowed range
     * @param {?} n value to check
     * @param {number=} min Minimum allowed value
     * @param {number=} max Maximum allowed value
     * @returns {boolean} true if it is an integer in the allowed range; false otherwise
     */
    DefaultIsType.prototype.anInt = function (n, min, max) {
        return DefaultIsType.anIntInternal(n, min, max) && n % 1 === 0;
    };
    ;
    /**
     * Determines if a value is an unsigned integer, optionally validating if the value
     * falls within an allowed range
     * @param {?} n value to check
     * @param {number=} min Minimum allowed value
     * @param {number=} max Maximum allowed value
     * @returns {boolean} true if it is an unsigned integer in the allowed range; false otherwise
     */
    DefaultIsType.prototype.anUInt = function (n, min, max) {
        return DefaultIsType.anIntInternal(n, min || 0, max);
    };
    ;
    /**
     * Determines if a value is a positive integer
     * @param {?} n Value to inspect
     * @returns {boolean} True if the value is a positive integer; false otherwise
     */
    DefaultIsType.prototype.aPositiveInt = function (n) {
        return DefaultIsType.anIntInternal(n, 1);
    };
    ;
    /**
     * Determines if a value is a byte
     * @param {?} n Value to inspect
     * @returns {boolean} True if the value is a byte; false otherwise
     */
    DefaultIsType.prototype.aByte = function (n) {
        return DefaultIsType.anIntInternal(n, 0, 0xFF);
    };
    ;
    /**
     * Determines if a value is a floating point number, optionally validating if the value
     * falls within an allowed range
     * @param {?} n Value to inspect
     * @param {number=} min Minimum allowed value
     * @param {number=} max Maximum allowed value
     * @returns {boolean} True if the value is a floating point number in the allowed range; false otherwise
     */
    DefaultIsType.prototype.aFloat = function (n, min, max) {
        return n === +n &&
            (n === 0 || n !== (n | 0)) &&
            (min === undefined || n >= min) &&
            (max === undefined || n <= max);
    };
    ;
    /**
     * Determines if a valid URL
     * @param {?} s Value to inspect
     * @returns {boolean} True if the value is a valid URL; false otherwise
     */
    DefaultIsType.prototype.anUrl = function (s) {
        return !!(s && URLREGEX.test(s));
    };
    ;
    /**
     * Determines if a string
     * @param {?} s Value to inspect
     * @returns {boolean} True if the value is a string; false otherwise
     */
    DefaultIsType.prototype.aString = function (s) {
        return DefaultIsType.aStringInternal(s);
    };
    ;
    /**
     * Determines if a valid string (has characters)
     * @param {?} s Value to inspect
     * @returns {boolean} True if the value is a valid string; false otherwise
     */
    DefaultIsType.prototype.aValidString = function (s) {
        return !!(DefaultIsType.aStringInternal(s) && s);
    };
    ;
    /**
     * Determines if a boolean
     * @param {?} o Value to inspect
     * @returns {boolean} True if the value is a boolean; false otherwise
     */
    DefaultIsType.prototype.aBool = function (o) {
        return o === true || o === false;
    };
    ;
    /**
     * Determines if a valid function
     * @param {?} f Value to inspect
     * @returns {boolean} True if the value is a function; false otherwise
     */
    DefaultIsType.prototype.aFunction = function (f) {
        return typeof f == TYPEOF_FUNCTION;
    };
    ;
    /**
     * @param {?} s
     * @returns {boolean}
     */
    DefaultIsType.aStringInternal = function (s) {
        return typeof s == TYPEOF_STRING;
    };
    ;
    /**
     * @param {?} n
     * @param {number=} min
     * @param {number=} max
     * @returns {boolean}
     */
    DefaultIsType.aNumberInternal = function (n, min, max) {
        return typeof n == TYPEOF_NUMBER && !isNaN(n) && isFinite(n) && (min === undefined || n >= min) && (max === undefined || n <= max);
    };
    ;
    /**
     * @param {?} n
     * @param {number=} min
     * @param {number=} max
     * @returns {boolean}
     */
    DefaultIsType.anIntInternal = function (n, min, max) {
        return DefaultIsType.aNumberInternal(n, min, max) && n % 1 === 0;
    };
    ;
    /**
     * @param {?} o
     * @returns {boolean}
     */
    DefaultIsType.anObjectInteranl = function (o) {
        return typeof o == TYPEOF_OBJECT;
    };
    ;
    return DefaultIsType;
}());
exports.DefaultIsType = DefaultIsType;

},{}],17:[function(require,module,exports){
"use strict";
/**
 * RandomGenerator based on [[Math.random]].
 *
 * @author neddy@netflix.com
 */
var DefaultRandomGenerator = (function () {
    function DefaultRandomGenerator() {
    }
    DefaultRandomGenerator.prototype.getRandomNumber = function () {
        return Math.random();
    };
    return DefaultRandomGenerator;
}());
exports.DefaultRandomGenerator = DefaultRandomGenerator;

},{}],18:[function(require,module,exports){
"use strict";
var DefaultRange = (function () {
    function DefaultRange(start, end, comparator) {
        this.start = start;
        this.end = end;
        if (comparator != null) {
            if (comparator(start, end) > 0) {
                throw DefaultRange.createRangeError(start, end);
            }
        }
        else if (end.compareTo && end.compareTo(start) > 0) {
            throw DefaultRange.createRangeError(start, end);
        }
    }
    DefaultRange.prototype.getStart = function () {
        return this.start;
    };
    DefaultRange.prototype.getEnd = function () {
        return this.end;
    };
    DefaultRange.createRangeError = function (start, end) {
        return new RangeError('end [' + end + '] must be >= start [' + start + ']');
    };
    return DefaultRange;
}());
exports.DefaultRange = DefaultRange;

},{}],19:[function(require,module,exports){
"use strict";
var DefaultStringUtils = (function () {
    function DefaultStringUtils() {
    }
    DefaultStringUtils.prototype.padRight = function (text, padWith, minLength) {
        var count = (minLength - text.length) / padWith.length;
        var result = text;
        while (count-- > 0) {
            result += padWith;
        }
        return result;
    };
    DefaultStringUtils.prototype.format = function (formatString, var_args) {
        var args = Array.prototype.slice.call(arguments, 1);
        return formatString.replace(/{(\d+)}/g, function (match, number) {
            return typeof args[number] != 'undefined' ? args[number] : match;
        });
    };
    DefaultStringUtils.prototype.stringToArrayBuffer = function (text) {
        var length = text.length;
        var uint16Array = new Uint16Array(length);
        for (var i = 0; i < length; i++) {
            uint16Array[i] = text.charCodeAt(i);
        }
        return uint16Array.buffer;
    };
    return DefaultStringUtils;
}());
exports.DefaultStringUtils = DefaultStringUtils;

},{}],20:[function(require,module,exports){
"use strict";
/**
 * System clock based on [[Date]] object.
 */
var DefaultSystemClock = (function () {
    function DefaultSystemClock() {
    }
    /**
     *
     * @returns {number}
     */
    DefaultSystemClock.prototype.getEpochMilliseconds = function () {
        return Date.now();
    };
    return DefaultSystemClock;
}());
exports.DefaultSystemClock = DefaultSystemClock;

},{}],21:[function(require,module,exports){
"use strict";
/**
 * Default implementation of the [[Utf8Encoder]] contract
 *
 * @author Kevin Gallagher<keving@netflix.com>
 */
var DefaultUtf8Encoder = (function () {
    function DefaultUtf8Encoder() {
    }
    /**
     * Converts a byte array into a unicode-8 string
     * @param {Uint8Array} bytes byte array to decode
     * @returns {string} The converted string
     */
    DefaultUtf8Encoder.prototype.encode = function (bytes) {
        return DefaultUtf8Encoder.encodeInternal(bytes);
    };
    /**
     * Converts a unicode 8 string into a byte array
     * @param {string} str string to encode
     * @returns {Uint8Array} the byte array
     */
    DefaultUtf8Encoder.prototype.decode = function (str) {
        return DefaultUtf8Encoder.decodeInternal(str);
    };
    DefaultUtf8Encoder.encodeInternal = function (bytes) {
        if (!bytes) {
            throw new TypeError('Invalid byte array');
        }
        var i = 0, charCode, bytesLength = bytes.length, str = '';
        while (i < bytesLength) {
            charCode = bytes[i++];
            if (!(charCode >= 0 && charCode <= 0xFF)) {
                throw new Error('bad utf8');
            }
            // check the first flag, which indicates that this is a multi-byte character
            if (charCode & 0x80) {
                // 1xxxxxxx
                if ((charCode & 0xE0) === 0xC0) {
                    // 110xxxxx 10xxxxxx
                    charCode = ((charCode & 0x1F) << 6) + (bytes[i++] & 0x3F);
                }
                else if ((charCode & 0xF0) === 0xE0) {
                    // 1110xxxx 10xxxxxx 10xxxxxx
                    charCode = ((charCode & 0x0F) << 12) + ((bytes[i++] & 0x3F) << 6) + (bytes[i++] & 0x3F);
                }
                else {
                    // 1111xxxx 10xxxxxx 10xxxxxx 10xxxxxx (or more)
                    // JavaScript only rupports 2 byte characters
                    throw new Error('unsupported utf8 character');
                }
            }
            str += String.fromCharCode(charCode);
        }
        return str;
    };
    DefaultUtf8Encoder.decodeInternal = function (str) {
        var strLength = str.length, bytes, bytesLength = 0, i, j = 0, charCode;
        if (!(strLength >= 0)) {
            throw new Error('bad string');
        }
        // Note: JavaScript only supports 2 byte characters, so the charCode can never be more than 0xFFFF
        // first pass to calculate the size, which we need to allocate the byte array
        i = strLength;
        while (i--) {
            charCode = str.charCodeAt(i);
            if (charCode < 0x0080) {
                bytesLength++;
            }
            else if (charCode < 0x0800) {
                bytesLength += 2;
            }
            else {
                bytesLength += 3;
            }
        }
        // second pass, allocate the byte array and do actual encoding
        bytes = new Uint8Array(bytesLength);
        for (i = 0; i < strLength; i++) {
            charCode = str.charCodeAt(i);
            if (charCode < 0x0080) {
                // 0xxxxxxx
                bytes[j++] = charCode;
            }
            else if (charCode < 0x0800) {
                // 110xxxxx 10xxxxxx
                bytes[j++] = 0xC0 | (charCode >>> 6);
                bytes[j++] = 0x80 | (charCode & 0x3F);
            }
            else {
                // 1110xxxx 10xxxxxx 10xxxxxx
                bytes[j++] = 0xE0 | (charCode >>> 12);
                bytes[j++] = 0x80 | ((charCode >>> 6) & 0x3F);
                bytes[j++] = 0x80 | (charCode & 0x3F);
            }
        }
        return bytes;
    };
    return DefaultUtf8Encoder;
}());
exports.DefaultUtf8Encoder = DefaultUtf8Encoder;

},{}],22:[function(require,module,exports){
"use strict";
var DefaultIsType_1 = require(16);
var errors_1 = require(25);
var DefaultBase16Encoder_1 = require(10);
/**
 * Default implementation of the [[Utilities]] contract
 *
 * @author Kevin Gallagher<keving@netflix.com>
 */
var DefaultUtilities = (function () {
    function DefaultUtilities() {
        this.mixin = DefaultUtilities.mixInIntenal;
        this.enumerateProperties = DefaultUtilities.enumerateOwnPropertiesInternal;
        /**
         * Compares two numeric arrays and make sure they are the same size and have the
         * same values in the arrays
         * @param a1 the first array to compare
         * @param a2 the second array to compare
         * @returns {boolean} true if the arrays are equivalent; false otherwise
         */
        this.compareArrays = DefaultUtilities.compareArraysInternal;
        this.exceptionToString = DefaultUtilities.exceptionToStringInternal;
        this.eachKeyStatus = DefaultUtilities.eachKeyStatusInternal;
        this.getChromeUnprefixedEmeErrorResult = DefaultUtilities.getChromeUnprefixedEmeErrorResultInternal;
        this.getChromePrefixedEmeErrorResult = DefaultUtilities.getChromePrefixedEmeErrorResultInternal;
        this.getFunctionName = DefaultUtilities.getFunctionNameInternal;
        this.getConstructorName = DefaultUtilities.getConstructorNameInternal;
        this.objectToStringTrace = DefaultUtilities.objectToStringTraceInternal;
        this.randomInt = DefaultUtilities.randomIntInternal;
        this.alternateMerge = DefaultUtilities.alternateMergeInternal;
        this.setStreamData = DefaultUtilities.setStreamDataInternal;
        this.getStoreKey = DefaultUtilities.getStoreKeyInternal;
        this.getPrefetchLogData = DefaultUtilities.getPrefetchLogDataInternal;
        this.createElement = DefaultUtilities.createElementInternal;
        this.filterBy = DefaultUtilities.filterByInternal;
    }
    DefaultUtilities.mixInIntenal = function (o1, o2, options) {
        if (o2) {
            if (options) {
                var makeLowerCase_1 = options.makeLowerCase, prefix_1 = options.prefix, onlyIfDefined_1 = options.onlyIfDefined;
                DefaultUtilities.enumerateOwnPropertiesInternal(o2, function (k, v) {
                    if (!onlyIfDefined_1 || DefaultUtilities.isType.definedAndNotNull(v)) {
                        o1[(prefix_1 || '') + (makeLowerCase_1 ? k.toLowerCase() : k)] = v;
                    }
                });
            }
            else {
                // keep simple and common case simple
                DefaultUtilities.enumerateOwnPropertiesInternal(o2, function (k, v) {
                    o1[k] = v;
                });
            }
        }
        return o1;
    };
    /**
     * Enumerate all the properties owned by an object calling the supplied function
     * for each
     * @param {Object} o                              the object to enumerate
     * @param {function(string, Object=)} callback  the function to call
     */
    DefaultUtilities.enumerateOwnPropertiesInternal = function (o, callback) {
        for (var k in o) {
            o.hasOwnProperty(k) && callback(k, o[k]);
        }
    };
    DefaultUtilities.compareArraysInternal = function (a1, a2) {
        if (a1.length == a2.length) {
            var i = a1.length;
            while (i--) {
                if (a1[i] != a2[i]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    DefaultUtilities.exceptionToStringInternal = function (e) {
        if (e) {
            // stack has the exception, don't duplicate it
            var stack = e['stack'];
            var number = e['number'];
            var message = e['message'];
            if (!message) {
                message = '' + e;
            }
            var s;
            if (stack) {
                s = '' + stack;
                if (s.indexOf(message) !== 0) {
                    s = message + '\n' + s;
                }
            }
            else {
                s = message;
            }
            if (number) {
                // some exceptions have a "number", track that to
                s += '\nnumber:' + number;
            }
            return s;
        }
    };
    DefaultUtilities.eachKeyStatusInternal = function (event, keyStatus) {
        var session, map, entries, entry, key, status;
        session = event['target'];
        map = session['keyStatuses'];
        entries = map['entries']();
        entry = entries['next']();
        while (!entry['done']) {
            key = entry['value'][0];
            status = entry['value'][1];
            if (keyStatus) {
                keyStatus(key, status);
            }
            entry = entries['next']();
        }
    };
    DefaultUtilities.getChromeUnprefixedEmeErrorResultInternal = function (ex) {
        var code = ex['code'], errorData = new ErrorData(), base16 = new DefaultBase16Encoder_1.DefaultBase16Encoder();
        if (DefaultUtilities.isType.definedAndNotNull(ex['code'])) {
            code = parseInt(ex['code'], 10);
            if (code >= 1 && code <= 9) {
                errorData.subCode = errors_1.ErrorSubCodes.EME_MEDIA_KEYERR_BASE + code;
            }
            else {
                errorData.subCode = errors_1.ErrorSubCodes.EME_MEDIA_KEYERR_BASE;
            }
        }
        else {
            errorData.subCode = errors_1.ErrorSubCodes.EXCEPTION;
        }
        try {
            var systemCode = ex['message'].match(/\((\d*)\)/)[1];
            errorData.extCode = base16.fromInt(systemCode, 4);
        }
        catch (e) { }
        errorData.errorDetails = this.exceptionToStringInternal(ex);
        return errorData;
    };
    DefaultUtilities.getChromePrefixedEmeErrorResultInternal = function (e) {
        var errorData = new ErrorData(), base16 = new DefaultBase16Encoder_1.DefaultBase16Encoder();
        try {
            var systemCode = parseInt(e['systemCode'], 10), code = e['errorCode']['code'];
            errorData.subCode = errors_1.ErrorSubCodes.EME_MEDIA_KEYERR_BASE + code;
            errorData.extCode = base16.fromInt(systemCode, 4);
            errorData.errorDetails = this.exceptionToStringInternal(e);
        }
        catch (ex) {
        }
        return errorData;
    };
    DefaultUtilities.getFunctionNameInternal = function (f) {
        var funcNameRegex = /function (.{1,})\(/;
        var results = (funcNameRegex).exec(f.toString());
        return (results && results.length > 1) ? results[1] : '';
    };
    DefaultUtilities.getConstructorNameInternal = function (o) {
        return this.getFunctionNameInternal(o.constructor);
    };
    DefaultUtilities.objectToStringTraceInternal = function (o) {
        var s = '';
        var isType = DefaultUtilities.isType;
        if (isType.anArray(o) || isType.anUint8Array(o)) {
            s = Array.prototype.reduce.call(o, function (s, c) {
                return s + ((c >= 32 && c < 128) ? String.fromCharCode(c) : '.');
            }, '');
        }
        else if (isType.aString(o)) {
            s = o;
        }
        else {
            this.enumerateOwnPropertiesInternal(o, function (k, v) {
                s += (s ? ', ' : '') + '{' + k + ': ' + (isType.aFunction(v) ? (this.getFunctionNameInternal(v) || 'function') : v) + '}';
            });
        }
        return '[' + this.getConstructorNameInternal(o) + ' ' + s + ']';
    };
    DefaultUtilities.randomIntInternal = function (min, max) {
        return Math.round(min + Math.random() * (max - min));
    };
    DefaultUtilities.alternateMergeInternal = function (arr1, arr2) {
        if (!arr1.length) {
            return [].concat(arr2);
        }
        else {
            return arr1.reduce(function (acc, entry, i) {
                if (DefaultUtilities.isType.definedAndNotNull(entry)) {
                    acc.push(entry);
                }
                if (arr2[i]) {
                    acc.push(arr2[i]);
                }
                if ((i === arr1.length - 1) && (arr2.length > i)) {
                    acc = acc.concat(arr2.slice(i + 1));
                }
                return acc;
            }, []);
        }
    };
    DefaultUtilities.getStoreKeyInternal = function (movieId, prefix, isTest) {
        var storePrefix = prefix;
        if (isTest) {
            storePrefix += 'test';
        }
        return storePrefix + '_' + movieId;
    };
    DefaultUtilities.getPrefetchLogDataInternal = function (entry) {
        var data = {}, status = entry && entry['status'], taskStatuses = {
            NOT_STARTED: 'not_started',
            STARTED: 'started',
            PENDING: 'pending',
            COMPLETED: 'completed',
            STORAGE_LOAD_FAILED: 'storage_load_failed'
        };
        if (!entry || !status) {
            data['status'] = taskStatuses.NOT_STARTED;
            data['attempts'] = 0;
            return data;
        }
        data['status'] = status;
        data['movieId'] = entry['movieId'];
        if (status == taskStatuses.STORAGE_LOAD_FAILED) {
            return data;
        }
        if (entry['status'] == taskStatuses.PENDING || entry['status'] == taskStatuses.COMPLETED) {
            data['attempts'] = entry['attempts'];
            data['uiExpectedStartTime'] = entry['uiExpectedStartTime'];
            data['uiExpectedEndTime'] = entry['uiExpectedEndTime'];
            this.setStreamDataInternal(entry['audio'], data, 'a');
            this.setStreamDataInternal(entry['video'], data, 'v');
        }
        else if (entry['status'] == taskStatuses.STARTED) {
            data['attempts'] = 1;
        }
        return data;
    };
    DefaultUtilities.setStreamDataInternal = function (stream, data, prefix) {
        if (!stream) {
            return;
        }
        try {
            if (stream['bitrate']) {
                data[prefix + 'Bitrate'] = stream['bitrate'];
            }
            if (stream['header']) {
                data[prefix + 'Header'] = stream['header'].length;
            }
            var chunks = stream['chunks'];
            var chunksBytes = 0, downloadedChunks = 0;
            if (chunks && chunks.length) {
                chunks.forEach(function (chunk) {
                    if (chunk['media'] && chunk['media'].length) {
                        chunksBytes += chunk['media'].length;
                        downloadedChunks++;
                    }
                });
            }
            data[prefix + 'ChunksBytes'] = chunksBytes;
            data[prefix + 'DownloadedChunks'] = downloadedChunks;
        }
        catch (e) {
        }
    };
    /**
    * @param {string} tagName
    * @param {string|null=} cssText
    * @param {string=} innerHTML
    * @param {Object=} elementAttributes
    */
    DefaultUtilities.createElementInternal = function (tagName, cssText, innerHTML, elementAttributes) {
        var element = window['document']['createElement'](tagName);
        if (cssText) {
            element['style']['cssText'] = cssText;
        }
        if (innerHTML) {
            element['innerHTML'] = innerHTML;
        }
        if (elementAttributes) {
            this.enumerateOwnPropertiesInternal(elementAttributes, function (k, v) {
                element['setAttribute'](k, v);
            });
        }
        return element;
    };
    DefaultUtilities.filterByInternal = function (field, val) {
        return function (data) {
            return data[field] === val;
        };
    };
    DefaultUtilities.isType = new DefaultIsType_1.DefaultIsType();
    return DefaultUtilities;
}());
exports.DefaultUtilities = DefaultUtilities;
var ErrorData = (function () {
    function ErrorData() {
    }
    return ErrorData;
}());

},{"10":10,"16":16,"25":25}],23:[function(require,module,exports){
"use strict";
var DefaultUtilities_1 = require(22);
/**
 * @author neddy@netflix.com
 */
var DefaultLogger = (function () {
    function DefaultLogger(clock, category) {
        if (category === void 0) { category = "General"; }
        this.clock = clock;
        this.category = category;
        this.sinks = [];
        this.index = 0;
    }
    DefaultLogger.prototype.addSink = function (sink) {
        this.sinks.push(sink);
    };
    DefaultLogger.prototype.removeSink = function (sink) {
        this.sinks.splice(this.sinks.indexOf(sink), 1);
    };
    DefaultLogger.prototype.fatal = function (message) {
        this._write(1 /* FATAL */, message, DefaultLogger.buildFields(arguments));
    };
    DefaultLogger.prototype.error = function (message) {
        this._write(2 /* ERROR */, message, DefaultLogger.buildFields(arguments));
    };
    DefaultLogger.prototype.warn = function (message) {
        this._write(3 /* WARN */, message, DefaultLogger.buildFields(arguments));
    };
    DefaultLogger.prototype.info = function (message) {
        this._write(4 /* INFO */, message, DefaultLogger.buildFields(arguments));
    };
    DefaultLogger.prototype.trace = function (message) {
        this._write(5 /* TRACE */, message, DefaultLogger.buildFields(arguments));
    };
    DefaultLogger.prototype.debug = function (message) {
        this._write(6 /* DEBUG */, message, DefaultLogger.buildFields(arguments));
    };
    DefaultLogger.prototype.log = function (message) {
        this.debug.apply(this, arguments);
    };
    DefaultLogger.prototype.write = function (logLevel, message) {
        this._write(logLevel, message, DefaultLogger.buildFields(arguments, 2));
    };
    DefaultLogger.prototype._write = function (logLevel, message, fields) {
        // FIXME: Why isn't this break done someplace else? It could be done by having a debugger listen to logs direclty so this class knows nothing about debugger stuff.
        //if (logLevel == LogLevel.DEBUG && logLevel <= LogLevel.ERROR && debug$breakOnError) debugger;
        var entry = new DefaultLogger.DefaultLogEntry(logLevel, message, fields, //DefaultLogger.buildFields(fields),
        this.clock.getElapsedRuntimeMilliseconds(), this.index++, this.category);
        // FIXME: Seems like this is a config that some sink should care about and not the logger
        //if (this.doNotSendToNccp) {
        //    entry.doNotSendToNccp = true;
        //}
        for (var _i = 0, _a = this.sinks; _i < _a.length; _i++) {
            var sink = _a[_i];
            sink(entry);
        }
    };
    /**
     *
     * @param {Object} values
     * @param {number=} numArgsToSkip
     * @returns {Object}
     */
    DefaultLogger.buildFields = function (values, numArgsToSkip) {
        if (numArgsToSkip === void 0) { numArgsToSkip = 1; }
        var fields = [];
        var utils = new DefaultUtilities_1.DefaultUtilities();
        for (var i = numArgsToSkip; i < values.length; ++i) {
            if (values[i]) {
                fields = fields.concat(DefaultLogger.toField(values[i]));
            }
        }
        if (fields.length == 1) {
            return fields[0];
        }
        var result = {};
        fields.forEach(function (value) {
            utils.mixin(result, value);
        });
        return result;
    };
    DefaultLogger.toField = function (value) {
        function hasLogField(value) {
            return value['logFields'];
        }
        function hasLogFieldGetter(value) {
            return value['getLogFields'] instanceof Function;
        }
        if (hasLogField(value)) {
            return value.logFields;
        }
        if (hasLogFieldGetter(value)) {
            return value.getLogFields();
        }
        if (value instanceof Error) {
            return new DefaultLogger.ErrorField(value);
        }
        if (value instanceof Object) {
            return value;
        }
        if (typeof value == 'string') {
            return { 'Details': value };
        }
        return {};
    };
    DefaultLogger.ErrorField = (function () {
        function class_1(error) {
            function hasStack(error) {
                return error['stack'] !== undefined;
            }
            this.Exception = error.message;
            this.StackTrace = hasStack(error) ? error.stack : "nostack";
        }
        return class_1;
    }());
    DefaultLogger.DefaultLogEntry = (function () {
        function class_2(_level, _message, _fields, _time, _index, _category) {
            this._level = _level;
            this._message = _message;
            this._fields = _fields;
            this._time = _time;
            this._index = _index;
            this._category = _category;
        }
        class_2.prototype.level = function () { return this._level; };
        class_2.prototype.message = function () { return this._message; };
        class_2.prototype.fields = function () { return this._fields; };
        class_2.prototype.time = function () { return this._time; };
        class_2.prototype.index = function () { return this._index; };
        class_2.prototype.category = function () { return this._category; };
        return class_2;
    }());
    return DefaultLogger;
}());
exports.DefaultLogger = DefaultLogger;

},{"22":22}],24:[function(require,module,exports){
"use strict";
/**
 * @author Sahil <sbudhiraja@netflix.com>
 */
var LICENSE_TYPE;
(function (LICENSE_TYPE) {
LICENSE_TYPE.STANDARD = 0;
LICENSE_TYPE.LIMITED = 1;
LICENSE_TYPE.PREVIEW = 2;
})(LICENSE_TYPE || (LICENSE_TYPE = {}));
;
var PREPARE_TASK_STATUS = (function () {
    function PREPARE_TASK_STATUS() {
    }
    PREPARE_TASK_STATUS.CREATED = 'created';
    PREPARE_TASK_STATUS.STARTED = 'started';
    PREPARE_TASK_STATUS.SUCCEEDED = 'succeeded';
    PREPARE_TASK_STATUS.FAILED = 'failed';
    PREPARE_TASK_STATUS.CANCELLED = 'cancelled';
    PREPARE_TASK_STATUS.CANCELLED_ON_CREATE = 'cancelled_on_create';
    PREPARE_TASK_STATUS.CANCELLED_ON_START = 'cancelled_on_start';
    return PREPARE_TASK_STATUS;
}());
exports.PREPARE_TASK_STATUS = PREPARE_TASK_STATUS;
function convertLicenseEnumToString(index) {
    var licenseTypes = ['STANDARD', 'LIMITED', 'PREVIEW'];
    return licenseTypes[index];
}
var PERSISTED_TASK_STATUS = (function () {
    function PERSISTED_TASK_STATUS() {
    }
    PERSISTED_TASK_STATUS.NOT_STARTED = 'not_started';
    PERSISTED_TASK_STATUS.STARTED = 'started';
    PERSISTED_TASK_STATUS.PENDING = 'pending';
    PERSISTED_TASK_STATUS.COMPLETED = 'completed';
    PERSISTED_TASK_STATUS.STORAGE_LOAD_FAILED = 'storage_load_failed';
    return PERSISTED_TASK_STATUS;
}());
;
var PREPARE_LOGBLOB_TRIGGER = (function () {
    function PREPARE_LOGBLOB_TRIGGER() {
    }
    PREPARE_LOGBLOB_TRIGGER.UIREQUEST = 'uirequest';
    PREPARE_LOGBLOB_TRIGGER.PREFETCH_START = 'prefetch_start';
    PREPARE_LOGBLOB_TRIGGER.PREFETCH_COMPLETE = 'prefetch_complete';
    PREPARE_LOGBLOB_TRIGGER.PREFETCH_DELETE = 'prefetch_delete';
    PREPARE_LOGBLOB_TRIGGER.PERIODIC_UPDATE = 'periodic_update';
    return PREPARE_LOGBLOB_TRIGGER;
}());
;
var PLAYBACKCONTEXT_FLAVORS;
(function (PLAYBACKCONTEXT_FLAVORS) {
PLAYBACKCONTEXT_FLAVORS.PRE_FETCH = 0;
PLAYBACKCONTEXT_FLAVORS.QC = 1;
PLAYBACKCONTEXT_FLAVORS.STANDARD = 2;
PLAYBACKCONTEXT_FLAVORS.SUPPLEMENTAL = 3;
})(PLAYBACKCONTEXT_FLAVORS || (PLAYBACKCONTEXT_FLAVORS = {}));
;
function convertPlaybackContextFlavorEnumToString(index) {
    var names = ['PRE_FETCH', 'QC', 'STANDARD', 'SUPPLEMENTAL'];
    return names[index];
}
var MANIFEST_LOAD_TYPE;
(function (MANIFEST_LOAD_TYPE) {
MANIFEST_LOAD_TYPE.STANDARD = 0;
MANIFEST_LOAD_TYPE.PREPARE = 1;
MANIFEST_LOAD_TYPE.LAZY = 2;
})(MANIFEST_LOAD_TYPE || (MANIFEST_LOAD_TYPE = {}));
;
function convertManifestLoadTypesEnumToString(index) {
    var names = ['STANDARD', 'PREPARE', 'LAZY'];
    return names[index];
}
var Enums = (function () {
    function Enums() {
    }
    Enums.LICENSE_TYPE = LICENSE_TYPE;
    Enums.convertLicenseEnumToString = convertLicenseEnumToString;
    Enums.PREPARE_TASK_STATUS = PREPARE_TASK_STATUS;
    Enums.PERSISTED_TASK_STATUS = PERSISTED_TASK_STATUS;
    Enums.PREPARE_LOGBLOB_TRIGGER = PREPARE_LOGBLOB_TRIGGER;
    Enums.PLAYBACKCONTEXT_FLAVORS = PLAYBACKCONTEXT_FLAVORS;
    Enums.convertPlaybackContextFlavorEnumToString = convertPlaybackContextFlavorEnumToString;
    Enums.MANIFEST_LOAD_TYPE = MANIFEST_LOAD_TYPE;
    Enums.convertManifestLoadTypesEnumToString = convertManifestLoadTypesEnumToString;
    return Enums;
}());
exports.Enums = Enums;

},{}],25:[function(require,module,exports){
"use strict";
/**
 * Possible error codes that can be reported by the player
 *
 * There is an automated process that converts this file into a markdown file that
 * lists all the errors and there description and then is published so members of
 * other teams can quickly look up error codes. Whenever a new code is added a
 * comment should follow the code explaining what the error is and any possible
 * remedies. Add *(obsolete)* anywhere in the comment will cause the error code
 * to be removed from the markdown file.
 *
 * Note: When deprecating, comment unused codes out, but leave the comment so that number is not re-used
 *
 * @author Kevin Gallagher<keving@netflix.com>
 */
(function (ErrorCodes) {
ErrorCodes.UNKNOWN = 7001;
    // errors that can occur during initialization (excluding NCCP errors)
ErrorCodes.INIT_ASYNCCOMPONENT = 7010;
    // DO NOT RE-USE= INIT_ASYNCCOMPONENT_EXCEPTION= 7012,
ErrorCodes.INIT_BADMOVIEID = 7014;
ErrorCodes.INIT_NETFLIXID_MISSING = 7016;
ErrorCodes.INIT_NETFLIXID_INVALID = 7017;
ErrorCodes.INIT_SECURENETFLIXID_MISSING = 7018;
ErrorCodes.INIT_PLAYBACK_LOCK = 7020;
ErrorCodes.INIT_SESSION_LOCK = 7022;
ErrorCodes.INIT_POSTAUTHORIZE = 7029;
ErrorCodes.INIT_HEADER_MEDIA = 7031;
    // DO NOT RE-USE= INIT_HEADER_VIDEO= 7032,                              
ErrorCodes.INIT_CORE_OBJECTS1 = 7041;
ErrorCodes.INIT_CORE_OBJECTS2 = 7042;
ErrorCodes.INIT_CORE_OBJECTS3 = 7043;
    // specific component load failure error codes
ErrorCodes.INIT_COMPONENT_REQUESTQUOTA = 7051;
ErrorCodes.INIT_COMPONENT_FILESYSTEM = 7052;
ErrorCodes.INIT_COMPONENT_STORAGE = 7053;
ErrorCodes.INIT_COMPONENT_STORAGELOCK = 7054;
ErrorCodes.INIT_COMPONENT_LOGPERSIST = 7055;
ErrorCodes.INIT_COMPONENT_NRDDPI = 7056;
ErrorCodes.INIT_COMPONENT_PEPPERCRYPTO = 7057;
ErrorCodes.INIT_COMPONENT_MAINTHREADMONITOR = 7058;
ErrorCodes.INIT_COMPONENT_DEVICE = 7059;
ErrorCodes.INIT_COMPONENT_MOCKVIDEOELEMENT = 7060;
ErrorCodes.INIT_COMPONENT_MOCKNCCPPLAYBACK = 7061;
ErrorCodes.INIT_COMPONENT_NTBA = 7062;
ErrorCodes.INIT_COMPONENT_MSL = 7063;
ErrorCodes.INIT_COMPONENT_NCCPDEVICEPARAMETERS = 7064;
ErrorCodes.INIT_COMPONENT_NCCP = 7065;
ErrorCodes.INIT_COMPONENT_NCCPLOGBATCHER = 7066;
ErrorCodes.INIT_COMPONENT_PERSISTEDPLAYDATA = 7067;
ErrorCodes.INIT_COMPONENT_PLAYBACKHEURISTICSRANDOM = 7068;
ErrorCodes.INIT_COMPONENT_ACCOUNT = 7069;
ErrorCodes.INIT_COMPONENT_NRDP = 7081;
ErrorCodes.INIT_COMPONENT_NRDP_DEVICE = 7082;
ErrorCodes.INIT_COMPONENT_WEBCRYPTO = 7083;
ErrorCodes.INIT_COMPONENT_VIDEO_PREPARER = 7084;
ErrorCodes.INIT_CONGESTION_SERVICE = 7085;
ErrorCodes.INIT_COMPONENT_DUMMY_EME = 7086;
ErrorCodes.INIT_COMPONENT_TRACKING_LOG = 7087;
    // errors caused by NCCP (during initialization and playback)
ErrorCodes.NCCP_AUTHORIZE = 7111;
ErrorCodes.NCCP_AUTHORIZE_REGISTER = 7113;
ErrorCodes.NCCP_AUTHORIZE_AUTHRENEW = 7115;
ErrorCodes.NCCP_AUTHORIZE_VERIFY = 7117;
ErrorCodes.START = 7120;
ErrorCodes.LICENSE = 7121;
ErrorCodes.SECURESTOP = 7122;
ErrorCodes.NCCP_FPSAPPDATA = 7123;
ErrorCodes.NCCP_HEARTBEAT = 7125;
    // NCCP errors (activation without playback)                                
ErrorCodes.NCCP_ACTIVATE = 7130;
ErrorCodes.NCCP_PING = 7131;
ErrorCodes.NCCP_NETFLIXID = 7133;
ErrorCodes.ENGAGE = 7134;
    // errors that occur after player is loaded                             
ErrorCodes.PLAY_INIT_EXCEPTION = 7202;
    // media download errors                                
ErrorCodes.MEDIA_DOWNLOAD = 7301;
    // MSE and EME caused errors that occur during playback
ErrorCodes.PLAY_MSE_EME_CREATE_KEYSESSION_FAILED = 7330;
ErrorCodes.PLAY_MSE_EME_KEY_SESSION_UPDATE_EXCEPTION = 7331;
ErrorCodes.PLAY_MSE_EME_KEY_STATUS_CHANGE_EXPIRED = 7332;
ErrorCodes.PLAY_MSE_EME_KEY_STATUS_CHANGE_INTERNAL_ERROR = 7333;
ErrorCodes.PLAY_MSE_EME_KEY_STATUS_CHANGE_OUTPUT_NOT_ALLOWED = 7334;
ErrorCodes.PLAY_MSE_NOTSUPPORTED = 7351;
ErrorCodes.PLAY_MSE_EME_NOTSUPPORTED = 7352;
ErrorCodes.PLAY_MSE_DECODER_TIMEOUT = 7353;
    // MediaKeys.isTypeSupported indicated that type is not supported or threw an exception
ErrorCodes.PLAY_MSE_EME_TYPE_NOTSUPPORTED = 7354;
ErrorCodes.PLAY_MSE_SOURCEADD = 7355;
    // new MediaKeys threw an exception
    // CAUSE= usually happens when Playready is not installed
ErrorCodes.PLAY_MSE_CREATE_MEDIAKEYS = 7356;
ErrorCodes.PLAY_MSE_GENERATEKEYREQUEST = 7357;
ErrorCodes.PLAY_MSE_PARSECHALLENGE = 7358;
ErrorCodes.PLAY_MSE_ADDKEY = 7359;
ErrorCodes.PLAY_MSE_UNEXPECTED_NEEDKEY = 7360;
    // VIDEO element fired "error" event
ErrorCodes.PLAY_MSE_EVENT_ERROR = 7361;
    // VIDEO element setMediaKeys rejected promise
ErrorCodes.PLAY_MSE_SETMEDIAKEYS = 7362;
    // KeySession (or VIDEO for older EME) fired "keyerror" event
ErrorCodes.PLAY_MSE_EVENT_KEYERROR = 7363;
    // on Key session close
ErrorCodes.PLAY_MSE_EME_SESSION_CLOSE = 7364;
ErrorCodes.PLAY_MSE_GETCURRENTTIME = 7365;
ErrorCodes.PLAY_MSE_SETCURRENTTIME = 7367;
ErrorCodes.PLAY_MSE_SOURCEAPPEND = 7371;
ErrorCodes.PLAY_MSE_SOURCEAPPEND_INIT = 7373;
ErrorCodes.PLAY_MSE_UNEXPECTED_SEEKING = 7375;
ErrorCodes.PLAY_MSE_UNEXPECTED_SEEKED = 7376;
ErrorCodes.PLAY_MSE_UNEXPECTED_REWIND = 7377;
ErrorCodes.PLAY_MSE_SOURCE_EOS = 7379;
ErrorCodes.PLAY_MSE_SOURCEBUFFER_ERROR = 7381;
    // DO NOT RE-USE= PLAY_MSE_LICENSE_CHALLENGE_TIMEOUT= 7383,
ErrorCodes.PLAY_MSE_KEYSESSION_UPDATE = 7385;
ErrorCodes.PLAY_MSE_CREATE_MEDIASOURCE = 7391;
ErrorCodes.PLAY_MSE_CREATE_MEDIASOURCE_OBJECTURL = 7392;
ErrorCodes.PLAY_MSE_CREATE_MEDIASOURCE_OPEN = 7393;
    // BladeRunner PSSH errors
ErrorCodes.PLAY_MSE_EME_MISSING_DRMHEADER = 7394;
ErrorCodes.PLAY_MSE_EME_MISSING_PSSH = 7395;
ErrorCodes.PLAY_MSE_EME_MISSING_CERT = 7396;
    // When UI fails to load the nessesary metadata, and can force a playback failure.
ErrorCodes.EXTERNAL = 7400;
ErrorCodes.PAUSE_TIMEOUT = 7500;
    // Inactivity = when User's Laptop is in sleep mode for a long time  
ErrorCodes.INACTIVITY_TIMEOUT = 7502;
    // The URLs will get form authorization will expire at this time.
ErrorCodes.AUTHORIZATION_EXPIRED = 7510;
    // error decrypting audio in player for preview content
ErrorCodes.DECRYPT_AUDIO = 7520;
    // Secure stop errors
ErrorCodes.SECURE_STOP_PROMISE_EXPIRED = 7600;
ErrorCodes.SECURE_STOP_KEY_ERROR = 7601;
ErrorCodes.SECURE_STOP_VIDEO_ERROR = 7602;
ErrorCodes.SECURE_STOP_NCCP_ERROR = 7603;
ErrorCodes.SECURE_STOP_NCCP_PARSE_PAYLOAD_ERROR = 7604;
ErrorCodes.SECURE_STOP_STORAGE_REMOVE_ERROR = 7605;
ErrorCodes.SECURE_STOP_PERSISTED_KEY_SESSION_NOT_AVAILABLE = 7620;
ErrorCodes.SECURE_STOP_PERSISTED_NO_MORE_ERROR = 7621;
ErrorCodes.SECURE_STOP_PERSISTED_MAX_ATTEMPTS_EXCEEDED = 7622;
ErrorCodes.SECURE_STOP_PERSISTED_MSE_CREATE_MEDIASOURCE_OPEN = 7623;
ErrorCodes.SECURE_STOP_PERSISTED_PLAY_MSE_GENERATEKEYREQUEST = 7624;
ErrorCodes.SECURE_STOP_PERSISTED_CREATE_SESSION_WITH_KEY_RELEASE_FAILED = 7625;
ErrorCodes.SECURE_STOP_PERSISTED_NCCP_FPSAPPDATA = 7626;
ErrorCodes.SECURE_STOP_PERSISTED_PLIST_PARSE_ERROR = 7627;
ErrorCodes.SECURE_STOP_PERSISTED_PENDING_KEY_ADDED_EXPIRED = 7628;
ErrorCodes.SECURE_STOP_PERSISTED_KEY_ERROR = 7631;
ErrorCodes.SECURE_STOP_PERSISTED_VIDEO_ERROR = 7632;
ErrorCodes.SECURE_STOP_PERSISTED_PLAY_MSE_KEYSESSION_UPDATE = 7633;
ErrorCodes.SECURE_STOP_PERSISTED_DRM_NOT_SUPPORTED = 7634;
ErrorCodes.SECURE_STOP_PERSISTED_UNEXPECTED_MESSAGE_TYPE = 7635;
    // EME errors
ErrorCodes.EME_INVALID_KEYSYSTEM = 7700;
ErrorCodes.EME_CREATE_MEDIAKEYS_SYSTEMACCESS_FAILED = 7701;
ErrorCodes.EME_CREATE_MEDIAKEYS_FAILED = 7702;
ErrorCodes.EME_GENERATEREQUEST_FAILED = 7703;
ErrorCodes.EME_UPDATE_FAILED = 7704;
ErrorCodes.EME_KEYSESSION_ERROR = 7705;
ErrorCodes.EME_NO_KEYMESSAGE = 7706;
ErrorCodes.EME_REMOVE_FAILED = 7707;
ErrorCodes.EME_LOAD_FAILED = 7708;
ErrorCodes.EME_CREATE_SESSION_FAILED = 7709;
ErrorCodes.EME_LDL_RENEWAL_ERROR = 7710;
ErrorCodes.EME_INVALID_INITDATA_DATA = 7711;
ErrorCodes.EME_INVALID_LICENSE_DATA = 7712;
ErrorCodes.EME_LDL_KEYSSION_ALREADY_CLOSED = 7713;
ErrorCodes.EME_MEDIAKEYS_GENERIC_ERROR = 7714;
})(exports.ErrorCodes || (exports.ErrorCodes = {}));
var ErrorCodes = exports.ErrorCodes;
;
/**
 * Possible sub error codes that can be reported by the player
 *
 * Note: When deprecating, comment unused codes out, but leave the comment so that number is not re-used
 *
 * @author Kevin Gallagher<keving@netflix.com>
 */
(function (ErrorSubCodes) {
ErrorSubCodes.UNKNOWN = 1001;
ErrorSubCodes.EXCEPTION = 1003;
ErrorSubCodes.ASYNCLOAD_EXCEPTION = 1011;
ErrorSubCodes.ASYNCLOAD_TIMEOUT = 1013;
ErrorSubCodes.ASYNCLOAD_BADCONFIG = 1015;
ErrorSubCodes.HTTP_UNKNOWN = 1101;
ErrorSubCodes.HTTP_XHR = 1102;
ErrorSubCodes.HTTP_PROTOCOL = 1103;
ErrorSubCodes.HTTP_OFFLINE = 1104;
ErrorSubCodes.HTTP_TIMEOUT = 1105;
ErrorSubCodes.HTTP_READTIMEOUT = 1106;
ErrorSubCodes.HTTP_ABORT = 1107;
ErrorSubCodes.HTTP_PARSE = 1108;
ErrorSubCodes.HTTP_BAD_URL = 1110;
ErrorSubCodes.HTTP_PROXY = 1111;
ErrorSubCodes.MSE_AUDIO = 1203;
ErrorSubCodes.MSE_VIDEO = 1204;
    // Sub codes matching MediaError codes= http=//dev.w3.org/html5/spec-author-view/video.html#mediaerror
ErrorSubCodes.MSE_MEDIA_ERR_BASE = 1250;
ErrorSubCodes.MSE_MEDIA_ERR_ABORTED = 1251;
ErrorSubCodes.MSE_MEDIA_ERR_NETWORK = 1252;
ErrorSubCodes.MSE_MEDIA_ERR_DECODE = 1253;
ErrorSubCodes.MSE_MEDIA_ERR_SRC_NOT_SUPPORTED = 1254;
ErrorSubCodes.MSE_MEDIA_ERR_ENCRYPTED = 1255;
    // range up to 1259 reserved for future MSE_MEDIA_ERR
ErrorSubCodes.EME_MEDIA_KEYERR_BASE = 1260;
ErrorSubCodes.EME_MEDIA_KEYERR_UNKNOWN = 1261;
ErrorSubCodes.EME_MEDIA_KEYERR_CLIENT = 1262;
ErrorSubCodes.EME_MEDIA_KEYERR_SERVICE = 1263;
ErrorSubCodes.EME_MEDIA_KEYERR_OUTPUT = 1264;
ErrorSubCodes.EME_MEDIA_KEYERR_HARDWARECHANGE = 1265;
ErrorSubCodes.EME_MEDIA_KEYERR_DOMAIN = 1266;
ErrorSubCodes.EME_MEDIA_UNAVAILABLE_CDM = 1269;
    // range up to 1269 reserved for future EME_MEDIA_KEYERR
ErrorSubCodes.EME_ERROR_NODRMSESSSION = 1280;
ErrorSubCodes.EME_ERROR_NODRMREQUESTS = 1281;
ErrorSubCodes.EME_ERROR_INDIV_FAILED = 1282;
ErrorSubCodes.EME_ERROR_UNSUPPORTED_MESSAGETYPE = 1283;
ErrorSubCodes.EME_TIMEOUT_MESSAGE = 1284;
ErrorSubCodes.EME_TIMEOUT_KEYCHANGE = 1285;
ErrorSubCodes.EME_UNDEFINED_DATA = 1286;
ErrorSubCodes.EME_EMPTY_DATA = 1286;
ErrorSubCodes.NCCP_METHOD_NOT_SUPPORTED = 1303;
ErrorSubCodes.NCCP_PARSEXML = 1305;
ErrorSubCodes.NCCP_PROCESS_EXCEPTION = 1309;
ErrorSubCodes.NCCP_NETFLIXID_MISSING = 1311;
ErrorSubCodes.NCCP_SECURENETFLIXID_MISSING = 1312;
ErrorSubCodes.NCCP_HMAC_MISSING = 1313;
ErrorSubCodes.NCCP_HMAC_MISMATCH = 1315;
ErrorSubCodes.NCCP_HMAC_FAILED = 1317;
ErrorSubCodes.NCCP_CLIENTTIME_MISSING = 1321;
ErrorSubCodes.NCCP_CLIENTTIME_MISMATCH = 1323;
ErrorSubCodes.NCCP_PROTOCOL = 1331;
ErrorSubCodes.NCCP_PROTOCOL_INVALIDDEVICECREDENTIALS = 1333;
ErrorSubCodes.NCCP_PROTOCOL_REDIRECT_LOOP = 1337;
ErrorSubCodes.NCCP_TRANSACTION = 1341;
ErrorSubCodes.NCCP_INVALID_DRMTYPE = 1343;
ErrorSubCodes.NCCP_INVALID_LICENCE_RESPONSE = 1344;
ErrorSubCodes.NCCP_MISSING_PAYLOAD = 1345;
ErrorSubCodes.STORAGE_NODATA = 1402;
ErrorSubCodes.STORAGE_EXCEPTION = 1403;
ErrorSubCodes.STORAGE_QUOTA_NOT_GRANTED = 1405;
ErrorSubCodes.STORAGE_QUOTA_TO_SMALL = 1407;
ErrorSubCodes.STORAGE_LOAD_ERROR = 1411;
ErrorSubCodes.STORAGE_LOAD_TIMEOUT = 1412;
ErrorSubCodes.STORAGE_SAVE_ERROR = 1414;
ErrorSubCodes.STORAGE_SAVE_TIMEOUT = 1415;
ErrorSubCodes.STORAGE_DELETE_ERROR = 1417;
ErrorSubCodes.STORAGE_DELETE_TIMEOUT = 1418;
ErrorSubCodes.STORAGE_FS_REQUESTFILESYSTEM = 1421;
ErrorSubCodes.STORAGE_FS_GETDIRECTORY = 1423;
ErrorSubCodes.STORAGE_FS_READENTRIES = 1425;
ErrorSubCodes.STORAGE_FS_FILEREAD = 1427;
ErrorSubCodes.STORAGE_FS_FILEWRITE = 1429;
ErrorSubCodes.STORAGE_FS_FILEREMOVE = 1431;
ErrorSubCodes.STORAGE_FS_PARSEJSON = 1432;
ErrorSubCodes.STORAGE_NO_LOCALSTORAGE = 1451;
ErrorSubCodes.STORAGE_LOCALSTORAGE_ACCESS_EXCEPTION = 1453;
ErrorSubCodes.NTBA_UNKNOWN = 1501;
ErrorSubCodes.NTBA_EXCEPTION = 1502;
ErrorSubCodes.NTBA_CRYPTO_KEY = 1504;
ErrorSubCodes.NTBA_CRYPTO_OPERATION = 1506;
ErrorSubCodes.NTBA_CRYPTO_KEYEXCHANGE = 1508;
ErrorSubCodes.NTBA_DECRYPT_UNSUPPORTED = 1515;
ErrorSubCodes.DEVICE_NO_ESN = 1553;
ErrorSubCodes.DEVICE_ERROR_GETTING_ESN = 1555;
    // DO NOT RE-USE= NCCP_TRANSACTION= 1541,
    // DO NOT RE-USE= NCCP_INVALID_DRMTYPE= 1543,
ErrorSubCodes.PLUGIN_LOAD_MISSING = 1603;
ErrorSubCodes.PLUGIN_LOAD_ERROR = 1605;
ErrorSubCodes.PLUGIN_LOAD_TIMEOUT = 1607;
ErrorSubCodes.PLUGIN_LOAD_EXCEPTION = 1609;
ErrorSubCodes.PLUGIN_EXCEPTION = 1625;
ErrorSubCodes.PLUGIN_CALLBACK_ERROR = 1627;
ErrorSubCodes.PLUGIN_CALLBACK_TIMEOUT = 1629;
ErrorSubCodes.FORMAT_UNKNOWN = 1701;
ErrorSubCodes.FORMAT_XML = 1713;
ErrorSubCodes.FORMAT_XML_CONTENT = 1715;
ErrorSubCodes.FORMAT_BASE64 = 1721;
ErrorSubCodes.FORMAT_DFXP = 1723;
ErrorSubCodes.INDEXDB_NOT_SUPPORTED = 1802;
ErrorSubCodes.INDEXDB_OPEN_ERROR = 1803;
ErrorSubCodes.INDEXDB_OPEN_NULL = 1804;
ErrorSubCodes.INDEXDB_OPEN_BLOCKED = 1805;
ErrorSubCodes.INDEXDB_OPEN_TIMEOUT = 1807;
ErrorSubCodes.INDEXDB_ACCESS_EXCEPTION = 1809;
    // DO NOT RE-USE= INDEXDB_GET_ERROR= 1821,
    // DO NOT RE-USE= INDEXDB_GET_NODATA= 1823,
    // DO NOT RE-USE= INDEXDB_PUT_ERROR= 1825,
    // DO NOT RE-USE= INDEXDB_DELETE_ERROR= 1827,
ErrorSubCodes.MSL_UNKNOWN = 1901;
ErrorSubCodes.MSL_INIT_NO_MSL = 1911;
ErrorSubCodes.MSL_INIT_ERROR = 1913;
ErrorSubCodes.MSL_INIT_NO_WEBCRYPTO = 1915;
ErrorSubCodes.MSL_ERROR = 1931;
ErrorSubCodes.MSL_REQUEST_TIMEOUT = 1933;
ErrorSubCodes.MSL_READ_TIMEOUT = 1934;
ErrorSubCodes.MSL_ERROR_HEADER = 1935;
ErrorSubCodes.MSL_ERROR_ENVELOPE = 1936;
ErrorSubCodes.MSL_ERROR_MISSING_PAYLOAD = 1937;
ErrorSubCodes.MSL_ERROR_REAUTH = 1957;
    // Try to match msl codes to 1950 + mslCode
ErrorSubCodes.WEBCRYPTO_MISSING = 2103;
ErrorSubCodes.WEBCRYPTOKEYS_MISSING = 2105;
ErrorSubCodes.WEBCRYPTO_IFRAME_LOAD_ERROR = 2107;
})(exports.ErrorSubCodes || (exports.ErrorSubCodes = {}));
var ErrorSubCodes = exports.ErrorSubCodes;
;
(function (ErrorExtCodes) {
ErrorExtCodes.BR_VIEWABLE_OUT_OF_AVAILABILITY_WINDOW = 5003;
ErrorExtCodes.BR_ACCOUNT_ON_HOLD = 5005;
ErrorExtCodes.BR_CONCURRENT_STREAM_QUOTA_EXCEEDED = 5006;
ErrorExtCodes.BR_INSUFFICIENT_MATURITY_LEVEL = 5033;
ErrorExtCodes.BR_BLACKLISTED_IP = 5059;
ErrorExtCodes.BR_AGE_VERIFICATION_REQUIRED = 5070;
    // These errors are new and have new codes
ErrorExtCodes.BR_PLAYBACK_CONTEXT_CREATION = 2204;
ErrorExtCodes.BR_DRM_LICENSE_AQUISITION = 2205;
ErrorExtCodes.BR_PLAYBACK_SERVICE_ERROR = 2206;
ErrorExtCodes.BR_ENDPOINT_ERROR = 2207;
ErrorExtCodes.BR_AUTHORIZATION_ERROR = 2208;
})(exports.ErrorExtCodes || (exports.ErrorExtCodes = {}));
var ErrorExtCodes = exports.ErrorExtCodes;
;

},{}],26:[function(require,module,exports){
"use strict";
var DebugImpl = (function () {
    function DebugImpl(isDebug, breakOnError, log, isType, startDebugger) {
        if (breakOnError === void 0) { breakOnError = function () { return false; }; }
        this.isDebug = isDebug;
        this.breakOnError = breakOnError;
        this.log = log;
        this.isType = isType;
        this.startDebugger = startDebugger;
        this.getStackTrace = DebugImpl.getStackTraceFunction();
    }
    DebugImpl.prototype.assert = function (expression, message) {
        if (this.isDebug) {
            if (!expression) {
                if (this.breakOnError()) {
                    this.startDebugger();
                }
                this.log.error(message || 'Assertion failed', { 'StackTrace': this.getStackTrace(DebugImpl.prototype.assert) });
            }
        }
    };
    DebugImpl.prototype.assertDefined = function (variable, message) {
        this.assert(this.isType.defined(variable), message);
    };
    DebugImpl.prototype.assertDefinedAndNotNull = function (variable, message) {
        this.assert(this.isType.definedAndNotNull(variable), message);
    };
    DebugImpl.prototype.assertString = function (variable, message) {
        this.assert(this.isType.aString(variable), message);
    };
    DebugImpl.prototype.assertValidString = function (variable, message) {
        this.assert(this.isType.aValidString(variable), message);
    };
    DebugImpl.prototype.assertStringOrNullOrUndefined = function (variable, message) {
        this.assert(this.isType.aString(variable) || variable === null || variable === undefined, message);
    };
    DebugImpl.prototype.assertNumber = function (variable, message) {
        this.assert(this.isType.aNumber(variable), message);
    };
    DebugImpl.prototype.assertInt = function (variable, message) {
        this.assert(this.isType.anInt(variable), message);
    };
    DebugImpl.prototype.assertUInt = function (variable, message) {
        this.assert(this.isType.anUInt(variable), message);
    };
    DebugImpl.prototype.assertPositiveInt = function (variable, message) {
        this.assert(this.isType.aPositiveInt(variable), message);
    };
    DebugImpl.prototype.assertBool = function (variable, message) {
        this.assert(this.isType.aBool(variable), message);
    };
    DebugImpl.prototype.assertFunction = function (variable, message) {
        this.assert(this.isType.aFunction(variable), message);
    };
    DebugImpl.prototype.invalidOperation = function () {
        this.assert(false, 'invalid operation, this method should not be called');
    };
    /**
     * Detects if running in node or browser environment and returns the appropiate getStackTrack function
     */
    DebugImpl.getStackTraceFunction = function () {
        var captureStackTrace = Error['captureStackTrace'], getStackTrace;
        if (captureStackTrace) {
            getStackTrace = function getStackTrace(upTo) {
                var o = {};
                o.toString = function () { return ''; };
                captureStackTrace(o, upTo || getStackTrace);
                return o['stack'];
            };
        }
        else {
            getStackTrace = function getStackTrace(upTo) {
                try {
                    throw new Error('capture stack');
                }
                catch (e) {
                    return e['stack'];
                }
            };
        }
        return getStackTrace;
    };
    return DebugImpl;
}());
exports.DebugImpl = DebugImpl;

},{}],27:[function(require,module,exports){
"use strict";
var EnvelopeDecryptorImpl = (function () {
    function EnvelopeDecryptorImpl(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    EnvelopeDecryptorImpl.prototype.decrypt = function (envelope, secret) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.keyFromSecret(secret).then(function (cryptoKey) {
                _this.subtleCrypto["decrypt"](_this.algorithm(envelope), cryptoKey, envelope.ciphertext).then(function (clearText) {
                    resolve(_this.stringFromArrayBufferView(clearText));
                }).catch(function (e) {
                    reject(e);
                });
            }).catch(function (e) {
                reject(e);
            });
        });
    };
    EnvelopeDecryptorImpl.prototype.algorithm = function (envelope) {
        return {
            "name": "AES-GCM",
            "iv": envelope.iv,
            "tagLength": envelope.tagLength
        };
    };
    EnvelopeDecryptorImpl.prototype.keyFromSecret = function (secret) {
        return this.subtleCrypto["importKey"]("raw", secret.data, { "name": "AES-GCM" }, false, ["decrypt"]);
    };
    EnvelopeDecryptorImpl.prototype.stringFromArrayBufferView = function (buffer) {
        return String.fromCharCode.apply(null, new Uint8Array(buffer));
    };
    return EnvelopeDecryptorImpl;
}());
exports.EnvelopeDecryptorImpl = EnvelopeDecryptorImpl;

},{}],28:[function(require,module,exports){
"use strict";
var PrepareMessageHandlerImpl = (function () {
    function PrepareMessageHandlerImpl(sharedSecret, decryptor, base64Encoder, backgroundChannel, logger, isType) {
        this.sharedSecret = sharedSecret;
        this.decryptor = decryptor;
        this.base64Encoder = base64Encoder;
        this.backgroundChannel = backgroundChannel;
        this.logger = logger;
        this.isType = isType;
    }
    PrepareMessageHandlerImpl.prototype.init = function (prepareCallBack) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.fetchSharedSecrets = _this.sharedSecret.fetchSecrets();
            _this.prepareCallBack = prepareCallBack;
            _this.backgroundChannel["onMessage"] = _this.onMessage.bind(_this);
            _this.fetchSharedSecrets.then(function () {
                resolve();
            }).catch(function (e) {
                _this.logger.error('Failed to fetch secrets', e);
                reject(e);
            });
        });
    };
    PrepareMessageHandlerImpl.prototype.onMessage = function (message) {
        var _this = this;
        this.fetchSharedSecrets.then(function () {
            var envelope, secret;
            try {
                envelope = _this.envelopeFromMessage(message);
            }
            catch (e) {
                _this.logger.error("Failed to parse prepare message", e);
                return;
            }
            try {
                secret = _this.sharedSecret.getForEnvelope(envelope);
            }
            catch (e) {
                _this.logger.error("Failed to load shared secret", e);
            }
            _this.decryptor.decrypt(envelope, secret).then(function (clearText) {
                try {
                    var prepareItems = _this.prepareItemsFromPrefetchHints(clearText);
                    _this.logger.debug("Sending movies to nrdp.prepare", prepareItems);
                    _this.prepareCallBack(prepareItems);
                }
                catch (e) {
                    _this.logger.error("Failed to call prepare", e);
                }
            }).catch(function (e) {
                _this.logger.debug("Failed to decrypt envelope");
            });
        }).catch(function (e) {
            _this.logger.warn("Can't decrypt, failed to load shared secrets", e);
        });
    };
    PrepareMessageHandlerImpl.prototype.envelopeFromMessage = function (messageJSON) {
        var message = JSON.parse(messageJSON), is = this.isType;
        if (is.definedAndNotNull(message["keyId"]) &&
            is.definedAndNotNull(message["iv"]) &&
            is.definedAndNotNull(message["taglength"]) &&
            is.definedAndNotNull(message["ciphertext"])) {
            return {
                keyId: message["keyId"],
                iv: this.base64Encoder.decode(message["iv"]).buffer,
                tagLength: message["taglength"],
                ciphertext: this.base64Encoder.decode(message["ciphertext"]).buffer
            };
        }
        else {
            throw ('Missing required fields on message');
        }
    };
    PrepareMessageHandlerImpl.prototype.prepareItemsFromPrefetchHints = function (prefetchHintsJSON) {
        var decryptedPrepareMessage = JSON.parse(prefetchHintsJSON);
        return decryptedPrepareMessage["movies"].map(function (movie) {
            return {
                "movieId": parseInt(movie["movieId"], 10),
                "priority": movie["priority"],
                "params": {
                    "sessionParams": { "uiplaycontext": null },
                    "authParams": { "pinCapableClient": "true" },
                    "trackingId": 0
                }
            };
        });
    };
    return PrepareMessageHandlerImpl;
}());
exports.PrepareMessageHandlerImpl = PrepareMessageHandlerImpl;

},{}],29:[function(require,module,exports){
"use strict";
var SharedSecretServiceImpl = (function () {
    function SharedSecretServiceImpl(bladerunnerClient, base64Encoder, context) {
        this.bladerunnerClient = bladerunnerClient;
        this.cachedKeyIds = {};
        this.base64Encoder = base64Encoder;
        this.context = context;
    }
    SharedSecretServiceImpl.prototype.getForEnvelope = function (envelope) {
        if (this.cachedKeyIds[envelope.keyId]) {
            return this.cachedKeyIds[envelope.keyId];
        }
        else {
            throw (new Error("KeyId not in cache"));
        }
    };
    SharedSecretServiceImpl.prototype.fetchSecrets = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.bladerunnerClient.getPrefetchSharedSecret(SharedSecretServiceImpl.dateOffsets, _this.context).
                then(function (result) {
                if (result.success) {
                    Object.keys(result.prefetchKeys).forEach(function (key) {
                        var keyData;
                        try {
                            keyData = _this.base64Encoder.decode(result.prefetchKeys[key]['gcmKey']['key']);
                        }
                        catch (e) {
                            reject({ name: 'Exception base64 decoding secret key', originalError: e });
                        }
                        _this.cachedKeyIds[key] = {
                            data: keyData
                        };
                        resolve();
                    });
                }
                else {
                    reject('Shared secret API call failed');
                }
            }).
                catch(function (e) {
                reject(e);
            });
        });
    };
    SharedSecretServiceImpl.dateOffsets = "-1,0,1";
    return SharedSecretServiceImpl;
}());
exports.SharedSecretServiceImpl = SharedSecretServiceImpl;

},{}],30:[function(require,module,exports){
"use strict";
var DefaultBase64Encoder_1 = require(11);
var DefaultIsType_1 = require(16);
var mp4reader = require(96), parseMp4 = mp4reader.readAllBoxes;
var base64 = new DefaultBase64Encoder_1.DefaultBase64Encoder(), isType = new DefaultIsType_1.DefaultIsType();
var chunkSize = {
    'audio': 16000,
    'video': 4004 // in ms
};
var PrepareStream = (function () {
    function PrepareStream(manifest, type, context, existingStream) {
        var self = this, bitrate = existingStream && existingStream['bitrate'], downloadable = getDownloadableFromManifest(manifest, type, bitrate);
        self.urls = downloadable['urls'];
        self.bitrate = downloadable['bitrate'];
        self.downloadableId = downloadable['downloadableId'];
        self.header = null;
        self.type = type;
        self.runtime = manifest['runtime'];
        self.context = context; // log, http
        self.chunkInfos = null;
        var headerFromCache = existingStream['header'];
        if (headerFromCache && isType.aString(headerFromCache)) {
            self.header = base64.decode(headerFromCache);
        }
        self.chunksFromCache = existingStream['chunks'];
    }
    PrepareStream.prototype.toJson = function () {
        var self = this, chunks = [], header;
        if (self.chunkInfos) {
            chunks = self.chunkInfos.map(function (chunkInfo) {
                return {
                    'media': chunkInfo.content ? base64.encode(chunkInfo.content) : null,
                    'cdn': {}
                };
            });
        }
        if (self.header instanceof Uint8Array) {
            header = base64.encode(self.header);
        }
        return {
            'bitrate': self.bitrate,
            'header': header,
            'chunks': chunks,
            'chunkSize': chunkSize[self.type]
        };
    };
    PrepareStream.prototype.download = function (request) {
        var self = this, log = self.context.log;
        return new Promise(function (resolve, reject) {
            var urlMap = self.urls, cdns = Object.keys(urlMap), currentCdnIndex = 0;
            function attemptDownload() {
                request.url = urlMap[cdns[currentCdnIndex]];
                request.cdn = cdns[currentCdnIndex];
                request.responseType = PrepareStream.http$RESPONSETYPE_BINARY;
                request.cacheBuster = true;
                self.context.http.download(request, function (result) {
                    if (result.success) {
                        resolve(new Uint8Array(result.content));
                    }
                    else {
                        if (currentCdnIndex >= cdns.length) {
                            reject({
                                errorcode: result.errorSubCode,
                                success: false
                            });
                        }
                        else {
                            setTimeout(attemptDownload, 50);
                        }
                    }
                });
            }
            attemptDownload();
        });
    };
    PrepareStream.prototype.downloadHeader = function () {
        var self = this, waitForHeader, log = self.context.log;
        if (self.header) {
            waitForHeader = Promise.resolve(self.header);
            log.trace('header consumed from storage');
        }
        else {
            var request = {
                diagCaption: self.type + '-' + self.bitrate + '-hdr',
                offset: 0,
                length: estimateHeaderSize(self.runtime)
            };
            waitForHeader = self.download(request);
            log.trace('downloading header', self.type, request);
        }
        return waitForHeader.then(function (content) {
            self.header = content;
            var boxes = parseHeaderBoxes(self.header), sidxBox = self.context.firstWithType(boxes, 'sidx'), chunkInfos = self.context.createChunkInfos(self, chunkSize[self.type], sidxBox);
            self.chunkInfos = chunkInfos;
            if (self.chunksFromCache && isType.anArray(self.chunksFromCache)) {
                self.chunksFromCache.forEach(function (c, i) {
                    if (c['media']) {
                        self.chunkInfos[i].content = base64.decode(c['media']);
                    }
                });
            }
        });
    };
    PrepareStream.prototype.downloadChunk = function (chunk) {
        var request = {
            offset: chunk.offset,
            length: chunk.length,
            diagCaption: this.type + '-' + this.bitrate + '-chunk'
        };
        return this.download(request).then(function (content) {
            chunk.content = content;
            return content;
        });
    };
    PrepareStream.prototype.getNthChunk = function (n) {
        if (n < this.chunkInfos.length) {
            return this.chunkInfos[n];
        }
    };
    PrepareStream.http$RESPONSETYPE_BINARY = 3;
    PrepareStream.HEADER_CONSTANT_SIZE = 256 /* ftyp and nflx header */ + 2000 /* moov box */ + 36 /* sidx metadata*/;
    PrepareStream.HEADER_SIZE_PER_MILLISECOND = 12 / 2000 /* each fragment is 12 bytes in sidx, and each fragment is 2000 ms */;
    return PrepareStream;
}());
exports.PrepareStream = PrepareStream;
function estimateHeaderSize(runtime) {
    var headerSize = Math.ceil(PrepareStream.HEADER_CONSTANT_SIZE + runtime * PrepareStream.HEADER_SIZE_PER_MILLISECOND);
    return headerSize;
}
function parseHeaderBoxes(header) {
    var boxes = parseMp4(header);
    boxes.byteLength = header.byteLength;
    return boxes;
}
function getDownloadableFromManifest(manifest, type, bitrate) {
    var trackType = (type === 'audio') ? 'AUDIO' : 'VIDEO';
    var selectedMedia = manifest['media'].filter(function (media) {
        return media['mediaId'] == manifest['defaultMedia'];
    })[0];
    var defaultTrack = selectedMedia['tracks'].filter(function (tracks) {
        return tracks['type'] == trackType;
    })[0];
    var track = manifest[type + 'Tracks'].filter(function (track) {
        return track['id'] == defaultTrack['id'];
    })[0];
    var downloadable = track['downloadables'].reduce(function (current, downloadable) {
        if (bitrate) {
            return downloadable['bitrate'] === bitrate ? downloadable : current;
        }
        else {
            return (downloadable['bitrate'] > current['bitrate']) ? downloadable : current;
        }
    }, {
        'bitrate': 0
    });
    return downloadable;
}

},{"11":11,"16":16,"96":96}],31:[function(require,module,exports){
"use strict";
var StorageResultImpl_1 = require(32);
var errors_1 = require(25);
var DefaultUtilities_1 = require(22);
var utils = new DefaultUtilities_1.DefaultUtilities();
var LocalStorageImpl = (function () {
    function LocalStorageImpl(platformLocalStorage) {
        this._platformStorage = platformLocalStorage;
    }
    LocalStorageImpl.prototype.load = function (key, callback) {
        var storageResult;
        var value;
        value = this._platformStorage["getItem"](key);
        try {
            value = value && value[0] === "{" ? JSON.parse(value) : value;
        }
        catch (ex) {
        }
        storageResult = new StorageResultImpl_1.StorageResultImpl(true, value, key);
        callback && callback(storageResult);
    };
    LocalStorageImpl.prototype.save = function (key, value, exclusive, callback) {
        var existingVal = this._platformStorage["getItem"](key);
        var storageResult;
        if (existingVal && exclusive) {
            storageResult = new StorageResultImpl_1.StorageResultImpl(false);
        }
        else {
            try {
                storageResult = new StorageResultImpl_1.StorageResultImpl(true, null, key);
                if (typeof value === "object") {
                    value = JSON.stringify(value);
                }
                this._platformStorage["setItem"](key, value);
            }
            catch (ex) {
                storageResult = new StorageResultImpl_1.StorageResultImpl(false, value, key, errors_1.ErrorSubCodes.STORAGE_SAVE_ERROR, utils.exceptionToString(ex));
            }
        }
        callback && callback(storageResult);
    };
    LocalStorageImpl.prototype.remove = function (key, callback) {
        var storageResult = new StorageResultImpl_1.StorageResultImpl(true);
        this._platformStorage["removeItem"](key);
        callback && callback(storageResult);
    };
    return LocalStorageImpl;
}());
exports.LocalStorageImpl = LocalStorageImpl;

},{"22":22,"25":25,"32":32}],32:[function(require,module,exports){
"use strict";
var StorageResultImpl = (function () {
    function StorageResultImpl(success, data, storageToken, errorSubCode, errorDetails) {
        this.success = success;
        this.data = data;
        this.storageToken = storageToken;
        this.errorSubCode = errorSubCode;
        this.errorDetails = errorDetails;
    }
    return StorageResultImpl;
}());
exports.StorageResultImpl = StorageResultImpl;

},{}],33:[function(require,module,exports){
"use strict";
/* global console */
//TODO leverage activation timing for other stats ?
/**
 * @constructor
 */
var SubtitleTracker = (function () {
    function SubtitleTracker(log, verboseLogging, utils) {
        var self = this;
        self.log = log;
        self.verboseLogging = verboseLogging;
        self.mixIn = utils.mixIn;
        self.debugAssert = utils.debugAssert || function () { };
        // private members
        self.current = undefined;
        self.ranges = [];
        self.seeking = undefined;
    }
    SubtitleTracker.prototype.activating = function (pts, track) {
        if (this.seeking) {
            return;
        }
        this.newRange(pts, track, [], 'activating');
    };
    SubtitleTracker.prototype.deActivating = function (pts, track) {
        if (!this.current) {
            return; // the current range was closed due to seeking
        }
        this.endRange(pts, 'de-activating');
    };
    SubtitleTracker.prototype.seekBegin = function (pts) {
        this.seeking = true;
        this.endRange(pts, 'seek begin');
    };
    SubtitleTracker.prototype.seekComplete = function (pts, track, subtitles) {
        var self = this, current = self.current;
        self.seeking = false;
        if (current && current.track == track) {
            current.subtitles = subtitles.concat(current.subtitles); // only happens in the beginning when playback begins from a bookmark.
        }
        else {
            self.newRange(pts, track, subtitles, 'seek complete');
        }
    };
    SubtitleTracker.prototype.newRange = function (pts, track, subtitles, reason) {
        var self = this;
        if (self.current) {
            self.endRange(pts, 'close current for new');
        }
        self.current = new TrackerRange(pts, track, subtitles);
        if (self.verboseLogging) {
            self.log.trace('new range: ' + reason, self.mixIn({}, self.current));
        }
    };
    SubtitleTracker.prototype.endRange = function (pts, reason) {
        var self = this;
        if (self.current) {
            self.current.end = pts;
            self.ranges.push(self.current);
            if (self.verboseLogging) {
                self.log.trace('end range: ' + reason, self.mixIn({}, self.current || {}));
            }
            self.current = undefined;
        }
    };
    SubtitleTracker.prototype.updateWithSubtitle = function (subtitle) {
        if (!this.current) {
            // when presenting state changes to playing on seek complete, sync is called in timedTextManager, it updates timedText.value, then "seekComplete" is called
            return;
        }
        this.current.subtitles.push(subtitle);
    };
    SubtitleTracker.prototype.getSubtitleQoe = function (endPts) {
        var self = this, ranges = self.ranges.slice(0);
        if (self.current && typeof endPts != 'undefined') {
            var currentRange = new TrackerRange(self.current.start, self.current.track, self.current.subtitles);
            currentRange.end = endPts;
            ranges.push(currentRange);
        }
        var mapByDlid = ranges.reduce(function (acc, r) {
            if (!r.track) {
                return acc;
            }
            var dlId = r.track.downloadableId, expected = r.track.getSubtitlesList(r.start, r.end);
            if (!expected) {
                return acc;
            }
            var actual = removeDuplicates(r.subtitles, self.log), entry;
            if (acc[dlId]) {
                entry = acc[dlId];
                entry['expected'] += expected.length;
                entry['missed'] += expected.length - actual.length;
            }
            else {
                entry = {};
                entry['dlid'] = dlId;
                entry['bcp47'] = r.track.bcp47;
                entry['expected'] = expected.length;
                entry['missed'] = expected.length - actual.length;
                acc[dlId] = entry;
            }
            return acc;
        }, {});
        var result = convertMapToArray(mapByDlid);
        if (self.verboseLogging) {
            self.log.trace('subtitleqoe:', JSON.stringify(result, null, '\t'));
        }
        return result;
    };
    SubtitleTracker.prototype.getScore = function (endPts) {
        var self = this, ranges = self.ranges.slice(0), totalDuration = 0, totalScore = 0, qoeScore;
        if (self.current && typeof endPts != 'undefined') {
            var currentRange = new TrackerRange(self.current.start, self.current.track, self.current.subtitles);
            currentRange.end = endPts;
            ranges.push(currentRange);
        }
        ranges.forEach(function (r) {
            if (!r.track) {
                r.score = 100;
            }
            else {
                if (r.end < r.start) {
                    self.debugAssert('negative range', r);
                    r.score = 0;
                    return;
                }
                var actual = removeDuplicates(r.subtitles, self.log), expected = r.track.getSubtitlesList(r.start, r.end);
                r.expected = expected ? expected.map(function (e) { return e['id']; }) : [];
                if (!expected) {
                    r.score = 0;
                }
                else if (expected.length === 0) {
                    r.score = 100; // none was expected in the time range.
                }
                else {
                    r.score = (actual.length * 100) / expected.length;
                }
            }
            var duration = r.end - r.start; // ignore the case when user switched timed text tracks when paused.
            totalDuration += duration;
            totalScore += r.score * duration;
        });
        qoeScore = totalDuration ? Math.round(totalScore / totalDuration) : 100;
        self.log.trace('qoe score ' + qoeScore + ', at pts: ' + endPts);
        if (self.verboseLogging) {
            var rangeScores = ranges.map(function (r) {
                return {
                    'start': r.start,
                    'end  ': r.end,
                    'duration': r.end - r.start,
                    'score': Math.round(r.score),
                    'lang': r.track ? r.track.bcp47 : 'none',
                    'actual  ': r.subtitles.join(' '),
                    'expected': (r.expected || []).join(' ')
                };
            });
            self.log.trace('score for each range: ', JSON.stringify(rangeScores, (function (k, v) { return v; }), ' '));
        }
        return qoeScore;
    };
    return SubtitleTracker;
}());
exports.SubtitleTracker = SubtitleTracker;
var TrackerRange = (function () {
    /**
    * @constructor
    * @param {number} start
    * @param {Object=} track
    * @param {Array.<number>=} subtitles
    */
    function TrackerRange(start, track, subtitles) {
        var self = this;
        self.start = start;
        self.end = undefined;
        self.track = track;
        self.subtitles = Array.isArray(subtitles) ? subtitles : []; // we will use es6 sets here but lets first see if we ever get duplicates in the field.
    }
    ;
    return TrackerRange;
}());
// 2 and '2' will be considered duplicate, but since we are only dealing with strings, we can use this here.
function hasDuplicates(arr) {
    var duplicate = false;
    arr.reduce(function (acc, e, i) {
        acc[e] = ((acc[e]) | 0) + 1;
        if (acc[e] > 1) {
            duplicate = true;
        }
        return acc;
    }, Object['create'](null));
    return duplicate;
}
function removeDuplicates(entries, log) {
    // avoid any processing if there aren't any duplicates.
    if (hasDuplicates(entries)) {
        log.error('duplicates in entries'); // lets just see how often we get this and add more logging then.
        return entries.filter(function (item, i, arr) {
            return arr.indexOf(item) === i;
        });
    }
    return entries;
}
function convertMapToArray(m) {
    var pluckFromM = function (k) {
        return m[k];
    };
    return Object.keys(m).map(pluckFromM);
}

},{}],34:[function(require,module,exports){
"use strict";
var DefaultDownload = (function () {
    function DefaultDownload(timeMs, bytes) {
        this.timeMs = timeMs;
        this.bytes = bytes;
        // TODO: Should this through an exception?
        this.bytes = Math.max(0, bytes);
    }
    DefaultDownload.prototype.getDownloadTimeMs = function () { return this.timeMs; };
    DefaultDownload.prototype.getBytes = function () { return this.bytes; };
    return DefaultDownload;
}());
exports.DefaultDownload = DefaultDownload;

},{}],35:[function(require,module,exports){
"use strict";
var DefaultThroughputConfig = (function () {
    function DefaultThroughputConfig(downloadTimesToBuffer) {
        if (downloadTimesToBuffer === void 0) { downloadTimesToBuffer = 10; }
        this.downloadTimesToBuffer = downloadTimesToBuffer;
    }
    DefaultThroughputConfig.prototype.getDownloadTimesToBuffer = function () {
        return this.downloadTimesToBuffer;
    };
    return DefaultThroughputConfig;
}());
exports.DefaultThroughputConfig = DefaultThroughputConfig;

},{}],36:[function(require,module,exports){
"use strict";
var DefaultThroughputTracker = (function () {
    function DefaultThroughputTracker(config) {
        this.config = config;
        this.bytesDownloaded = 0;
        this.sortedDownloadTimes = [];
        this.downloadStart = null;
        this.downloadEnd = null;
    }
    DefaultThroughputTracker.prototype.getThroughput = function () {
        var bitsPerMs, kiloBitsPerSec, downloadTimeInMs, downloadToAdd;
        while (this.sortedDownloadTimes.length > 0) {
            downloadToAdd = this.sortedDownloadTimes.shift();
            this.addDownloadToDownloadTime(downloadToAdd);
        }
        downloadTimeInMs = this.downloadEnd - this.downloadStart;
        bitsPerMs = (this.bytesDownloaded * DefaultThroughputTracker.BITS_PER_BYTE) / downloadTimeInMs;
        kiloBitsPerSec = bitsPerMs;
        return {
            throughputKbps: Math.floor(kiloBitsPerSec),
            downloadTimeMs: downloadTimeInMs
        };
    };
    DefaultThroughputTracker.prototype.addDownload = function (download) {
        var downloadTimeToAdd;
        this.bytesDownloaded += download.getBytes();
        this.sortedDownloadTimes.push(download.getDownloadTimeMs());
        // Interval calculation requires that downloads are sorted by start time in ascending order
        this.sortedDownloadTimes.sort(function (a, b) {
            return a.getStart() - b.getStart();
        });
        while (this.sortedDownloadTimes.length > this.config.getDownloadTimesToBuffer()) {
            downloadTimeToAdd = this.sortedDownloadTimes.shift();
            this.addDownloadToDownloadTime(downloadTimeToAdd);
        }
    };
    DefaultThroughputTracker.prototype.addDownloadToDownloadTime = function (download) {
        if (this.downloadStart === null) {
            this.downloadStart = download.getStart();
        }
        if (this.downloadEnd !== null && this.downloadEnd < download.getStart()) {
            this.downloadStart += (download.getStart() - this.downloadEnd);
        }
        if (this.downloadEnd === null || this.downloadEnd < download.getEnd()) {
            this.downloadEnd = download.getEnd();
        }
    };
    DefaultThroughputTracker.BITS_PER_BYTE = 8;
    return DefaultThroughputTracker;
}());
exports.DefaultThroughputTracker = DefaultThroughputTracker;

},{}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
/** @constructor */
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var DefaultDownload_1 = require(34);
var CDNDownloadImpl = (function (_super) {
    __extends(CDNDownloadImpl, _super);
    function CDNDownloadImpl(time, bytes, cdnId) {
        _super.call(this, time, bytes);
        this.cdnId = cdnId;
    }
    CDNDownloadImpl.prototype.getCdnId = function () { return this.cdnId; };
    return CDNDownloadImpl;
}(DefaultDownload_1.DefaultDownload));
exports.CDNDownloadImpl = CDNDownloadImpl;

},{"34":34}],38:[function(require,module,exports){
"use strict";
/**
* Tracks throughput per CDN.
* Depends on the ThroughputTracker to do the actual throughput calculation.
* @constructor
* @param {{downloadTimesToBuffer: number}} number of downloads to buffer. Default is 50
*/
var CDNThroughputTrackerImpl = (function () {
    function CDNThroughputTrackerImpl(config, isType, ThroughputTrackerClass) {
        this.config = config;
        this.isType = isType;
        this.ThroughputTrackerClass = ThroughputTrackerClass;
        this.throughputTrackerMap = {};
    }
    /**
    * Returns the CDNthroughput as an array.
    */
    CDNThroughputTrackerImpl.prototype.getCDNThroughputs = function () {
        var _this = this;
        var cdnThroughputs = [];
        Object.keys(this.throughputTrackerMap).forEach(function (key) {
            var throughputTracker = _this.throughputTrackerMap[key];
            cdnThroughputs.push({
                cdnId: key,
                throughputKbps: throughputTracker.getThroughput().throughputKbps,
                downloadTimeMs: throughputTracker.getThroughput().downloadTimeMs
            });
        });
        return cdnThroughputs;
    };
    /**
    * Add a download to be included in the throughput measurements
    * startTime and endTime are in milliseconds
    */
    CDNThroughputTrackerImpl.prototype.addDownload = function (download) {
        var cdnId = download.getCdnId(), throughputTracker = this.throughputTrackerMap[cdnId];
        if (!throughputTracker) {
            throughputTracker = new this.ThroughputTrackerClass(this.config);
            this.throughputTrackerMap[cdnId] = throughputTracker;
        }
        throughputTracker.addDownload(download);
    };
    return CDNThroughputTrackerImpl;
}());
exports.CDNThroughputTrackerImpl = CDNThroughputTrackerImpl;

},{}],39:[function(require,module,exports){
"use strict";
var DefaultIsType_1 = require(16);
var enums = require(24);
var counter = 0;
var isType = new DefaultIsType_1.DefaultIsType();
function Task(movieId, priority, type, clock, dependency) {
    if (dependency === void 0) { dependency = null; }
    var task = this;
    task.movieId = movieId; //undefined for bulkManifest
    task.priority = priority;
    task.id = ++counter;
    task.type = type; //manifest or ldl
    task.dependency = dependency; // another task or taskId
    task.operation = undefined; // will be set later
    task.created = clock.getTime();
    task.status = enums.PREPARE_TASK_STATUS.CREATED; // created, started, succeeded, failed
    //task.startTime;
    //task.endTime;
}
exports.Task = Task;
Task.prototype.getLogFields = function () {
    var self = this, logFields = {
        'id': self.id,
        'type': self.type,
        'created': self.created,
        'status': self.status,
        'movieId': self.movieId
    };
    if (isType.definedAndNotNull(self.startTime)) {
        logFields['startTime'] = self.startTime;
    }
    if (isType.definedAndNotNull(self.endTime)) {
        logFields['duration'] = self.endTime - self.startTime;
        logFields['endTime'] = self.endTime;
    }
    return logFields;
};

},{"16":16,"24":24}],40:[function(require,module,exports){
"use strict";
// TODO 
// Add expiry timeout for a task ?
var DefaultIsType_1 = require(16);
var enums_1 = require(24);
var is = new DefaultIsType_1.DefaultIsType();
function TaskScheduler(options) {
    this.log = options.log;
    this.clock = options.clock;
    this.currentTaskIndex = 0;
    this.currentIteration = 0;
    this.tasks = [];
    this.paused = false;
    this.idle = true;
    this.startedTasks = [];
    this.completedTasks = [];
    this.clearedTaskCount = 0;
}
exports.TaskScheduler = TaskScheduler;
TaskScheduler.prototype.addTasks = function TaskScheduler_addTasks(list) {
    // record how many tasks we are about to clear
    this.clearedTaskCount += this.tasks.length - this.currentTaskIndex;
    // this will clear the existing tasks.
    this.log.trace('adding tasks, number of tasks: ' + list.length);
    this.paused = false;
    this.idle = false;
    this.tasks = list;
    this.currentTaskIndex = 0;
    this.currentIteration += 1;
    //this.rootNode = this.createGraph(list);
    this.dispatch();
};
TaskScheduler.prototype.pause = function TaskScheduler_pause() {
    this.paused = true;
};
TaskScheduler.prototype.dispatch = function TaskScheduler_dispatch() {
    if (this.currentTaskIndex === this.tasks.length) {
        this.log.trace('all tasks completed');
        this.idle = true;
        return;
    }
    if (this.paused) {
        this.log.trace('in paused state', {
            'currentTaskIndex': this.currentTaskIndex,
            'numberOfTasks': this.tasks.length
        });
        return;
    }
    var task = this.getNextTask(), iteration = this.currentIteration;
    task.startTime = this.clock.getTime();
    task.status = enums_1.PREPARE_TASK_STATUS.STARTED;
    this.startedTasks.push(task);
    task.operation(function (err, data) {
        task.endTime = this.clock.getTime();
        if (err) {
            if ([enums_1.PREPARE_TASK_STATUS.CANCELLED, enums_1.PREPARE_TASK_STATUS.CANCELLED_ON_CREATE, enums_1.PREPARE_TASK_STATUS.CANCELLED_ON_START].indexOf(err.status) >= 0) {
                task.status = err.status;
                this.log.trace('cancelled task', task.getLogFields());
            }
            else {
                task.status = enums_1.PREPARE_TASK_STATUS.FAILED;
                this.log.warn('task failed', task.getLogFields(), err);
            }
        }
        else {
            task.status = enums_1.PREPARE_TASK_STATUS.SUCCEEDED;
            this.log.trace('task succeeded', task.getLogFields());
        }
        this.completedTasks.push(task);
        // remove completed task from started tasks
        this.startedTasks.splice(this.startedTasks.indexOf(task), 1);
        if (this.currentIteration === iteration) {
            this.currentTaskIndex++;
            this.dispatch();
        }
        else {
        }
    }.bind(this));
};
TaskScheduler.prototype.getNextTask = function TaskScheduler_getNextTask() {
    return this.tasks[this.currentTaskIndex];
};
/**
* @param {number=} movieId
*/
TaskScheduler.prototype.getStats = function getStats(startTime, endTime, movieId) {
    var completed = this.completedTasks.map(getTaskLogFields), started = this.startedTasks.map(getTaskLogFields), captureDelta = (is.definedAndNotNull(startTime) && is.definedAndNotNull(endTime)), data = {};
    if (is.definedAndNotNull(movieId)) {
        data.completed = completed.filter(function (t) { return t['movieId'] === movieId; });
        return data;
    }
    // combine completed + started tasks // 
    var allTasks = completed.concat(started);
    allTasks.forEach(function (t) {
        data[t.type + '_' + t.status] = (data[t.type + '_' + t.status] | 0) + 1;
        var reference = (t.status == enums_1.PREPARE_TASK_STATUS.STARTED) ? t.startTime : t.endTime;
        if (captureDelta) {
            if (reference >= startTime && reference < endTime) {
                data[t.type + '_' + t.status + '_delta'] = (data[t.type + '_' + t.status + '_delta'] | 0) + 1;
            }
        }
    });
    return data;
};
function getTaskLogFields(task) {
    return task.getLogFields();
}
// Based on the Fetch Strategy, get next node on Graph traversal
//if(this.algo === ALGO_TYPES.BF){
// }
// }
// var ALGO_TYPES = {
//     BF: 'BF',
//     DF: 'DF',
//     HYBRID: 'HYBRID'
// };

},{"16":16,"24":24}],41:[function(require,module,exports){
"use strict";
var TaskScheduler_1 = require(40);
var Task_1 = require(39);
var DefaultIsType_1 = require(16);
var PrepareStream_1 = require(30);
var DefaultUtilities_1 = require(22);
var enums_1 = require(24);
var CacheManager = require(89);
var utils = new DefaultUtilities_1.DefaultUtilities();
var isType = new DefaultIsType_1.DefaultIsType();
var debugAssert = function (x) {
    if (!x) {
        throw new Error('Debug Assert Failed ');
    }
};
/**
 * log: object
 * getManifest : fn
 * getLdl: fn
 */
function VideoPreparer(options) {
    this.log = options.log;
    this.clock = options.clock;
    this.getManifest = options.getManifest;
    this.getLdl = options.getLdl;
    this.getPersistedData = options.getPersistedData;
    this.deletePersistedData = options.deletePersistedData;
    this.deleteCacheOnPlayback = options.deleteCacheOnPlayback;
    this.deleteOtherManifestCacheOnCreate = options.deleteOtherManifestCacheOnCreate;
    this.deleteOtherLdlCacheOnCreate = options.deleteOtherLdlCacheOnCreate;
    this.xidCreator = options.xidCreator;
    this.onPlaybackCreated = options.onPlaybackCreated;
    this.onPlaybackStarted = options.onPlaybackStarted;
    this.onPlaybackClosing = options.onPlaybackClosing;
    this.getDuringPlaybackStats = options.getDuringPlaybackStats;
    this.isDebug = options.isDebug || false;
    this._xidMap = {};
    this._movieStats = {};
    this._stats = {
        'num_of_calls': 0,
        'num_of_movies': 0
    };
    this.cacheManager = new CacheManager({
        log: this.log,
        clock: this.clock,
        Promise: Promise,
        isDebug: this.isDebug,
        cacheSizeCountForManifest: options.cacheSizeCountForManifest,
        cacheSizeCountForLdl: options.cacheSizeCountForLdl,
        expiryManifestMilliseconds: options.expiryManifestMilliseconds,
        expiryLdlMilliseconds: options.expiryLdlMilliseconds
    });
    this.taskScheduler = new TaskScheduler_1.TaskScheduler({
        log: this.log,
        clock: this.clock
    });
    this.getCachedData = this.cacheManager.getData.bind(this.cacheManager);
    this.setCachedData = this.cacheManager.setData.bind(this.cacheManager);
    this.hasCachedData = this.cacheManager.hasData.bind(this.cacheManager);
}
exports.VideoPreparer = VideoPreparer;
// list of movie Ids with priority, params(authParams, sessionParams, trackingId)
VideoPreparer.prototype.prepare = function videopreparer_prepare(list) {
    var _this = this;
    var tasks = list.map(function (movie) { return _this._createTasksForMovie(movie); })
        .reduce(function (acc, x) { return (acc = acc.concat(x)); }, []);
    //es6change
    var logFields = tasks.map(function (t) { return t.movieId + '-' + t.type; });
    this.log.trace('prepare tasks', logFields);
    this.taskScheduler.addTasks(tasks);
    this._stats['num_of_calls']++;
    this._stats['num_of_movies'] = this._stats['num_of_movies'] + list.length;
};
VideoPreparer.prototype.updateStats = function videopreparer_updateStats(movieId, firstTimeAdded) {
    if (!this._movieStats[movieId]) {
        this._movieStats[movieId] = {};
    }
    var entry = this._movieStats[movieId];
    entry.prepareAttempts = (entry.prepareAttempts | 0) + 1;
    entry.firstTimeAdded = firstTimeAdded; //absolute time, update it 
};
VideoPreparer.prototype.getStats = function videopreparer_getStats(startTime, endTime, movieId) {
    var stats = (movieId && this._movieStats[movieId]) || {};
    stats.tasks = this.taskScheduler.getStats(startTime, endTime, movieId);
    stats.cache = this.cacheManager.getStats(startTime, endTime);
    stats.general = utils.mixin(this.getDuringPlaybackStats(), this._stats);
    return stats || {};
};
/**
 * @param {{movieId: number, priority: number, params: Object, operations: Array, uiLabel: string}} movie
 */
VideoPreparer.prototype._createTasksForMovie = function videopreparer_createTasksForMovie(movie) {
    if (movie.uiLabel == 'trailer') {
        return createTrailerTasks.call(this, movie);
    }
    else if (isType.definedAndNotNull(movie.operations)) {
        return createTasksFromOperations.call(this, movie);
    }
    var movieTasks = [], movieId = movie.movieId;
    this.updateStats(movieId, movie.firstTimeAdded);
    var manifestInCache = this.cacheManager.hasData(movieId, 'manifest'), manifestTaskId;
    if (!manifestInCache) {
        var manifest = new Task_1.Task(movieId, movie.priority, 'manifest', this.clock);
        manifestTaskId = manifest.id;
        manifest.operation = this.getManifest.bind(this, movieId, movie.params);
        movieTasks.push(manifest);
    }
    else {
        this.log.trace('manifest exists in cache for ' + movieId);
    }
    if (this.getLdl) {
        var ldlInCache = this.cacheManager.hasData(movieId, 'ldl');
        if (!ldlInCache) {
            var ldl = new Task_1.Task(movieId, movie.priority, 'ldl', this.clock, manifestTaskId);
            ldl.operation = this.getLdl.bind(this, movieId);
            movieTasks.push(ldl);
        }
        else {
            this.log.trace('ldl exists in cache for ' + movieId);
        }
    }
    return movieTasks;
};
VideoPreparer.prototype.handlePlaybackStarted = function videopreparer_handlePlaybackStarted(movieId) {
    this.onPlaybackStarted(movieId);
};
VideoPreparer.prototype.handlePlaybackCreated = function videopreparer_handlePlaybackCreated(movieId) {
    this.log.trace('task scheduler paused on playback created');
    this.taskScheduler.pause();
    // deletes other entries from the cache
    if (this.deleteOtherManifestCacheOnCreate) {
        this.cacheManager.clearAllOtherData(movieId, ['manifest']);
    }
    if (this.deleteOtherLdlCacheOnCreate) {
        this.cacheManager.clearAllOtherData(movieId, ['ldl']);
    }
    this.onPlaybackCreated(movieId);
};
// some of these will be invoked only if there was an error in playback and start event didn't fire.
VideoPreparer.prototype.handlePlaybackClosing = function videopreparer_handlePlaybackClosing(movieId) {
    if (this.deleteCacheOnPlayback) {
        this.cacheManager.clearData(movieId, 'manifest');
    }
    this.cacheManager.clearData(movieId, 'ldl');
    this.clearXid(movieId);
    this.onPlaybackClosing();
};
VideoPreparer.prototype.clearXid = function clearXid(movieId) {
    this._xidMap[movieId] = undefined;
};
VideoPreparer.prototype.getXid = function videopreparer_getXid(movieId) {
    return this._xidMap[movieId];
};
VideoPreparer.prototype.createXid = function videopreparer_createXid(movieId) {
    return (this._xidMap[movieId] = this.xidCreator());
};
function createTrailerTasks(movie) {
    var tasks = [], expectedStartTime = movie.uiExpectedStartTime, expectedEndTime = movie.uiExpectedEndTime, currentTime = Date.now(), logFields = {
        'expectedStartTime': expectedStartTime,
        'expectedEndTime': expectedEndTime
    };
    // either before window
    // or during window
    // or after window
    if (currentTime <= expectedStartTime || currentTime <= expectedEndTime) {
        var getStatus = new Task_1.Task(movie.movieId, movie.priority, 'persisteddatastatus', this.clock);
        getStatus.operation = this.getPersistedData.bind(this, movie.movieId, movie);
        tasks.push(getStatus);
    }
    else if (currentTime > expectedEndTime) {
        // delete from storage
        var deletePersistedData = new Task_1.Task(movie.movieId, movie.priority, 'deletepersisteddata', this.clock);
        deletePersistedData.operation = this.deletePersistedData.bind(this, movie.movieId);
        tasks.push(deletePersistedData);
    }
    else {
        this.log.warn('inconsistent dates', logFields);
    }
    return tasks;
}
function createTasksFromOperations(movie) {
    debugAssert(isType.anArray(movie.operations));
    var clock = this.clock;
    var tasks = movie.operations.map(function (operation) {
        var task = new Task_1.Task(movie.movieId, movie.priority, movie.taskType, clock);
        task.operation = operation;
        return task;
    });
    return tasks;
}
VideoPreparer.prototype.getPrefetchedStreams = function videopreparer_getPrefetchedStreams(manifest, context) {
    var self = this;
    self.log.trace('start loading prefetched streams');
    if (!manifest) {
        return Promise.reject({
            result: false,
            reason: 'manifest not available'
        });
    }
    return new Promise(function (resolve, reject) {
        var movieId = manifest['movieId'], storeKey = utils.getStoreKey(movieId, context.prefix, context.isTest);
        self.log.trace('storage read ', storeKey);
        context.storage.load(storeKey, function (result) {
            var summary;
            if (result.success) {
                self.log.trace('storage load, entry exists', storeKey);
                var entry = result.data;
                summary = utils.getPrefetchLogData(entry);
                if (entry['status'] == enums_1.Enums.PERSISTED_TASK_STATUS.COMPLETED) {
                    var audioStream = new PrepareStream_1.PrepareStream(manifest, 'audio', context, entry['audio']), videoStream = new PrepareStream_1.PrepareStream(manifest, 'video', context, entry['video']);
                    self.setCachedData(movieId, 'audio', audioStream);
                    self.setCachedData(movieId, 'video', videoStream);
                    self.log.trace('prefetch was complete', summary);
                    resolve({
                        summary: summary,
                        streams: [audioStream, videoStream]
                    });
                }
                else {
                    self.log.trace('prefetch was pending', summary);
                    reject({
                        summary: summary,
                        reason: 'prefetch was not completed'
                    });
                }
            }
            else {
                self.log.error('storage load error: ', storeKey, result);
                summary = utils.getPrefetchLogData({});
                reject({
                    summary: summary,
                    reason: 'entry not available'
                }); // TODO error codes
            }
        });
    });
};
VideoPreparer.prototype.canFulfillUIIntent = function videopreparer_canFulfillUIIntent(movieId, uiLabel, context, callback) {
    var self = this, storeKey = utils.getStoreKey(movieId, context.prefix, context.isTest), log = self.log;
    context.storage.load(storeKey, function (result) {
        var summary, found = false, entry;
        if (result.success) {
            log.trace('canFulfillUIIntent: storage load, entry exists', storeKey);
            entry = result.data;
            summary = utils.getPrefetchLogData(entry);
            if (entry['uiLabel'] !== uiLabel) {
                log.trace('canFulfillUIIntent: uiLabel does not match', uiLabel, summary);
            }
            else {
                if (entry['status'] == enums_1.Enums.PERSISTED_TASK_STATUS.COMPLETED) {
                    self.log.trace('canFulfillUIIntent: prefetch was complete', summary);
                    found = true;
                }
                else {
                    self.log.trace('canFulfillUIIntent: prefetch was pending', summary);
                }
            }
        }
        else {
            self.log.error('canFulfillUIIntent: storage load error', storeKey, result);
        }
        callback(found);
    });
};

},{"16":16,"22":22,"24":24,"30":30,"39":39,"40":40,"89":89}],42:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],43:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

/* global setTimeout, setInterval, clearInterval, clearTimeout */

var _ = require(103);

var Events = require(94);
var EventEmitter = Events.EventEmitter;
var EventListenerGroup = Events.EventListenerGroup;

var network = require(57);
var LocationHistory = network.LocationHistory;
var NetworkMonitor = network.NetworkMonitor;
var NetworkHistory = network.NetworkHistory;

var Enums = require(48);
var Mp4Parser = require(56).Mp4Parser;
var generateMp4DoneEvent = require(56).generateMp4DoneEvent;
var HeaderCache = require(51);
var StreamSelector = require(66);
var LocationSelector = require(54);
var ErrorDirector = require(49);
var config = require(47);
var Predictor = require(62).SimpleMarginPredictor;
var ObservableProperty = require(84).ObservableProperty;

var RequestManager = require(63);
var BufferManager = require(44);

// import some util functions
var concatBuffers = require(84).concatBuffers;
var platform = require(61);
var DownloadTrack = platform.DownloadTrack;
var MediaRequest = platform.MediaRequest;
var Promise = platform.Promise;
var console = new platform.Console('ASEJS', 'media|asejs');

var VERBOSE = false;
var DEBUG = ("debug" !== 'release');
var headerSizeFuzzy = 128; // added bytes to last header size to request for next header

("clear" === 'obfuscate') && jscrambler &&
    jscrambler("jscrambler ignore_transformations_@ jscrambler_high");

//////////////////////////////////////
// globals (for this file)
//////////////////////////////////////
var manager;

//////////////////////////////////////
// Utilities
//////////////////////////////////////

var _trace = console.trace.bind(console);
var _warn = console.warn.bind(console);
var _log = console.log.bind(console);

DownloadTrack.prototype.isParallel = function isParallel()
{
   return (this.config["connections"] > 1 ? true : false);
};

var bufferingReason = {
    startup:   0,
    seek:      1,
    underflow: 2
};

//////////////////////////////////////
// Manager
//////////////////////////////////////
/**
 * @constructor
 */
function Manager(disableHeaderCache)
{
    this._initted = false;

    // sessions
    this._sessions = [];

    // video bitrate ranges
    this._videoBitrateRanges = undefined;

    // global counter for requestID
    this._currentRequestId = 0;

    // add event emitter api
    this.addEventListener = EventEmitter.addEventListener;
    this.on = EventEmitter.addEventListener;
    this.removeEventListener = EventEmitter.removeEventListener;
    this.callEventListeners = EventEmitter.callEventListeners;
    this.emit = EventEmitter.callEventListeners;

//    if (!disableHeaderCache)
    {
        // create header cache
        this._headerCache = new HeaderCache(this);
    }

    // remember the singleton manager
    manager = this;
}
Manager.prototype.constructor = Manager;

Object.defineProperties(Manager.prototype, /** @lends {Manager.prototype} */{
    MEDIA_AUDIO: { get: function() { return 0; } },
    MEDIA_VIDEO: { get: function() { return 1; } },
    MEDIA_HEADERS:{ get:function() { return 3; } },
    networkMonitor:{get:function() { return this._networkMonitor; } },
    networkHistory:{get:function() { return this._networkHistory; } }
});

/**
 * Initializes ASE. You must call this before any other functions.
 * This only needs to be called once and supports multiple playback sessions.
 *
 * @param {number} audioBufferSize
 * @param {number} videoBufferSize
 * @param {Object} ctxt passed back to implementing application
 */
Manager.prototype.init = function init(audioBufferSize, videoBufferSize, ctxt)
{
    var forwardEvent;

    DEBUG && _trace("creating ASE manager: bufferSizes: " +
           audioBufferSize + ", " + videoBufferSize);
    this._bufferSize = [audioBufferSize, videoBufferSize];

    DEBUG && _trace("using platform: " + platform.name);

    // create network monitors
    this._locationHistory = new LocationHistory();
    this._networkHistory = new NetworkHistory();
    this._networkMonitor = new NetworkMonitor(
        this._networkHistory, this._locationHistory);

    // set up periodic saving of location and network history
    if (config.periodicHistoryPersistMs) {
        setInterval(function() {
            this._locationHistory.save();
            this._networkHistory.save();
        }.bind( this ), config.periodicHistoryPersistMs );
    }

    // header cache
    if (this._headerCache)
    {
        this._headerCache.init(ctxt);

        forwardEvent = function(evt)
        {
            // forward to our listeners
            this.callEventListeners(evt['type'], evt);
        }.bind(this);

        this._headerCache.addEventListener('prebuffstats', forwardEvent);
        this._headerCache.addEventListener('discardedBytes', forwardEvent);
        this._headerCache.addEventListener('flushedBytes', forwardEvent);
    }

    this._initted = true;
};

// start streaming from [manifest]
// XXX - note that the index's are into manifest audio_tracks and video_tracks
// XXX - if it's easier to index into flat "tracks" we can do that as well

/**
 * Opens a new session.
 * Needs to be called once for each playback session.
 *
 * @param {Object} manifest - manifest of content
 * @param {Array} trackIndexes - array of track index's (AUDIO, VIDEO).
 *                               Ex: [0, 1] indicates audio track 0 and video track 1
 * @param {number} pts - play position to begin streaming at
 * @param {{
 *	fastplay: ?boolean,
 *  useHeaderCache: ?boolean,
 *  useHeaderCacheData: ?boolean,
 *  loopVideo: ?boolean,
 *  expectedStartTime: ?number
 * }} flags
 * @param {Object} ctxt passed back to implementing application
 *
 * @return {Object|undefined} new session that was created
 */
Manager.prototype.createSession = function createSession(
    manifest, trackIndexes, pts, flags, ctxt, attributes)
{
    if (!this._initted)
    {
        _warn("open: streamingManager not initted");
        return;
    }

    DEBUG && _trace("createSession: movieId:", manifest["movieId"],
                    "pts:", pts,
                    "flags:", flags,
                    "trackIndexes:", trackIndexes);

    // reset the network monitor
    this._networkMonitor.reset();
    this._networkHistory.startStreaming();

    // get the attributes if necessary
    if ( attributes === undefined )
    {
        attributes = this.getAttributes( manifest, trackIndexes );
    }

    // start a new Session
    var sess = new Session(manifest, trackIndexes, pts, flags, ctxt, attributes );

    // add to sessions array
    this._sessions.push(sess);

    return sess;
};

// done with current session
Manager.prototype._removeSession = function _removeSession(session)
{
    DEBUG && _trace("manager removeSession");

    // clear the current network location
    this._networkMonitor.setLocation(null);

    // remove this session
    var idx = this._sessions.indexOf(session);
    if (_.isUndefined(idx))
    {
        _warn("can't find session in array, movieId:", session._movieId);
        return;
    }

    this._sessions.splice(idx, 1);

    if ( this._sessions.length === 0 )
    {
        this._networkHistory.stopStreaming();
    }

    // store location history state
    this._networkHistory.save();
    this._locationHistory.save();
};

/**
 * Does nothing
 * @deprecated
 */
Manager.prototype.setStreamingBufferRange = function setStreamingBufferRange(
    minBufferLen, maxBufferLen)
{
};

/**
 * Gets the audio and video attributes from the manifest
 * @param {Object} manifest - manifest of content
 * @param {Array} trackIndexes - array of track index's (AUDIO, VIDEO). Ex: [0, 1] indicates audio track 0 and video track 1
 * @param {Object=} type - audio or video
 */
Manager.prototype.getAttributes = function getAttributes( manifest, trackIndexes, type )
{
    var attributes = [ {}, {} ];
    var trackProperty = (type === this.MEDIA_AUDIO) ?
        [ "audio_tracks" ] : [ "audio_tracks", "video_tracks" ]; // AUDIO, VIDEO

    trackProperty.forEach(function(property, trackType) {

        manifest[property].some(function(track, trackIndex) {

            if (trackIndex === trackIndexes[trackType] )
            {
                // override any profile from streams with one from track
                attributes[trackType].profile = track["profile"];

                attributes[trackType].frameRateValue = track["max_framerate_value"];
                attributes[trackType].frameRateScale = track["max_framerate_scale"];
                attributes[trackType].maxWidth = track["maxWidth"];
                attributes[trackType].maxHeight = track["maxHeight"];
                attributes[trackType].pixelAspectX = track["pixelAspectX"];
                attributes[trackType].pixelAspectY = track["pixelAspectY"];

                attributes[trackType].channels = track["channels"];

                // currently all our content is at 48k. If this changes we'll have to
                // add this value to manifest and pull from there (unless we want to
                // parse audio headers)
                attributes[trackType].sampleRate = 48000;

                return true;
            }

            return false;
        } );

    } );

    return attributes;
};

/**
 * Gets the aggregate statistics from the last session
 * Requires Manager.prototype.init to have run
 *
 * @return {{avtp: number}|undefined} average throughput in Kb/s
 */
Manager.prototype.getSessionStatistics = function getSessionStatistics()
{
    if (!this._initted)
    {
        _warn("getSessionStatistics: StreamingManager not initted");
        return;
    }

    return this._networkMonitor.getAggregateStatistics();
};

/**
 * Removes location from history and resets the network monitor
 *
 * @param {string} location - key attribute from manifest location object. Ex: '1-12-high'
 */
Manager.prototype.clearLocationHistory = function clearLocationHistory(location) {
    var history = this._locationHistory || new LocationHistory();
    history.erase(location);
    history.save();
    if (this._networkMonitor) {
        this._networkMonitor.reset();
    }
};

//////////////////////////////////////
// Helper Functions
//////////////////////////////////////

/**
 * Adds or replaces attributes of the platform implemnetation
 *
 * @param {Object} implementation - implementations to be added or replaced.
 *                                  Ex: {time: NewTimeClass}
 */
Manager.prototype.updatePlatformImplementation = function updatePlatformImplementation(
    implementation)
{
    platform.implement(implementation);
};

/**
 * Gets the current RequestId
 * The RequestId identifies an http request and is unique only to
 * this instance of ASE.
 *
 * @return {number}
 */
Manager.prototype.getRequestId = function getRequestId()
{
    return this._currentRequestId;
};

/**
 * Increments the currentRequestId
 *
 */
Manager.prototype.genRequestId = function genRequestId()
{
    this._currentRequestId++;
};

//////////////////////////////////////
// Session
//////////////////////////////////////
/**
 *
 * @param {Object} manifest
 * @param {Array} trackIndexes
 * @param {number} pts
 * @param {Object} flags
 * @param {Object} ctxt
 * @constructor
 */
function Session(manifest, trackIndexes, pts, flags, ctxt, attributes)
{
    this._ctxt = ctxt;

    this._fastplay = flags.fastplay;
    this._truncateHeaders = flags.fastplay;
    this._useHeaderCache = flags.useHeaderCache;
    this._useHeaderCacheData = flags.useHeaderCacheData;
    this._loopVideo = flags.loopVideo;

    // calculate the mono time playback is expected to start
    this._expectedStartTimeMono = platform.time.mono() + flags.expectedStartTime;

    this._playerState = new ObservableProperty(Enums.PLAYER_STATE.STARTING);
    this._movieId = manifest["movieId"];
    this._duration = manifest["duration"];
    this._startPts = pts || 0;
    this._manifest = manifest;
    this._drmManifest = undefined;
    this._manifestIndex = 0;
    this._attributes = attributes; // initialize empty audio/video attributes
    this._videoLocation = undefined;
    this._streamingFailureReported = false;

    this._currentTracks = trackIndexes;
    this._headerTrack = undefined;
    this._pipelineTimeout = undefined;
    this._adaptiveParallelTimeout = undefined;
    this._numPlays = 0; // how many times have we called play on session
    this._streamingOffset = 0;
    this._activePipelines = 0;

    // make a console for this session
    this._console = new platform.Console(
        'ASEJS', 'media|asejs', '(' + ctxt.sessionId + ')');
    this._error = this._console.error.bind(this._console);
    this._warn = this._console.warn.bind(this._console);
    this._trace = this._console.trace.bind(this._console);
    this._log = this._console.log.bind(this._console);

    // event emitter
    this.addEventListener = EventEmitter.addEventListener;
    this.on = EventEmitter.addEventListener;
    this.removeEventListener = EventEmitter.removeEventListener;
    this.callEventListeners = EventEmitter.callEventListeners;
    this.emit = EventEmitter.callEventListeners;

    // create listener group
    this._listenerGroup = new EventListenerGroup();

    // create playerState change event
    if( config.streamSelectorAlgorithm === 'bufferbased')
    {
        this._playerState.addListener(function (args) {
            // fire a playerState change event
            this.emit('playerstatechanged', args);
        }.bind(this));
    }

    if (config.enableManagerDebugTraces && manager._headerCache)
    {
        // listen for debug events from headerCache
        this._listenerGroup.on(
            manager._headerCache, "managerdebugevent",
            function(evt) {
                _callEventListeners(this, evt["type"], evt);
            }.bind(this));
    }

    // create location selector and listen for its events
    this._locationSelector = new LocationSelector(
        this,
        manager._networkMonitor,
        manager._locationHistory,
        // In fast play, probing starts out as NOT allowed
        !this._fastplay);
    this._listenerGroup.on(
        this._locationSelector, 'locationSelected',
        this._notifyLocationSelected, this);

    // create error director and listen for its events
    this._errorDirector = new ErrorDirector(this, this._locationSelector);
    this._listenerGroup.on(
        this._errorDirector, 'streamingFailure',
        this._handleStreamingFailure, this);
    this._listenerGroup.on(
        this._errorDirector, 'networkFailureReset',
        this._handleNetworkFailureReset, this);

    // Add manifest after error director has been created and hooked up
    this._locationSelector.addManifest(manifest);

    if ( config.marginPredictor === 'scaled' ){
        Predictor = require(62).ScaledMarginPredictor;
    }
    this._predictor = new Predictor();

    // create pipelines
    this._pipelines = []; // two pipelines, 0 Audio, 1 Video
    this._pipelines.push(new Pipeline(
        this, manager.MEDIA_AUDIO, this._startPts, this, this._errorDirector));
    this._pipelines.push(new Pipeline(
        this, manager.MEDIA_VIDEO, this._startPts, this, this._errorDirector));

    // now process the manifest
    this._processManifest(this._manifest, this._currentTracks, this._fastplay);

    DEBUG && this._trace(
        "Session: pipeline 0 trackIndex:", this._pipelines[0].trackIndex);
    DEBUG && this._trace(
        "Session: pipeline 1 trackIndex:", this._pipelines[1].trackIndex);
}
Session.prototype.constructor = Session;

Object.defineProperties(Session.prototype, {
    mediaSourceId: {
        get: function() {
            return this._mediaSource ? this._mediaSource.sourceId : undefined;
        }
    },
    attributes: { get: function() { return this._attributes; } },
    listenerGroup: { get: function() { return this._listenerGroup; } }
});

Session.prototype.open = function open()
{
    var bufferTypes = [ manager.MEDIA_VIDEO, manager.MEDIA_AUDIO ];
    var downloadConfigs = this._getConfigs();

    this._downloadTrackCreatesInProgress = 0;

    if (config.pruneRequestsFromNative) {
        // disable ASE default pruning
        DEBUG && this._trace("Pipeline pruning will happen from native.");
        this._pruneRequests = function () {};
    }

    // prevent header cache downloading more media data
    manager._headerCache && manager._headerCache.notifyStreamerStart();

    var headerCacheP;

    // create downloadTracks
    var downloadTrackList = this._createDownloadTracks(downloadConfigs);

    DEBUG && this._trace("init created downloadTracks:", downloadTrackList);

    downloadConfigs.forEach(function(c, idx) {
        if (c.type == manager.MEDIA_HEADERS)
        {
            DEBUG && this._trace("headerIndex:", idx);
            DEBUG && this._trace("headerDownloadTrack:", downloadTrackList[idx]);
            this._headerTrack = downloadTrackList[idx];
        }
        else
        {
            var pipeline = this._pipelines[c.type];
            if (!pipeline)
            {
                this._warn("pipeline missing for type:", c.type, c);
                throw "missing pipeline";
            }
            pipeline.track = downloadTrackList[idx];
            DEBUG && pipeline._trace("set pipeline with download config:",
                                     downloadTrackList[idx]);
        }

    }.bind(this));

    // Next create MediaSource
    this._notifyStartEvent("createMediaSourceStart");

    var mediaSource = new platform.MediaSource(this._ctxt.player);
    if ( mediaSource.readyState === platform.MediaSource.READYSTATES.OPEN )
    {
        DEBUG && this._trace("MediaSource created, MediaSource: " +
                             mediaSource.toString() );
        this._notifyStartEvent("createMediaSourceEnd");
    }
    else
    {
        this._trace("Error:", mediaSource.error );
        this._reportStreamingFailure(
                "exception in init", "NFErr_MC_StreamingInitFailure");
        return;
    }

    // Once MediaSource is created, now we can create SourceBuffers
    this._mediaSource = mediaSource;

    if( !mediaSource.addSourceBuffers(bufferTypes) )
    {
        this._trace("Error:", mediaSource.error );
        throw mediaSource.error;
    }

    // add sourceBuffers
    DEBUG && this._trace("sourceBuffers added: " + mediaSource.sourceBuffers);
    // set Id's into pipelines
    mediaSource.sourceBuffers.forEach(function(sourceBuffer) {

        var pipeline = this._pipelines[ sourceBuffer.mediaType ];
        if (!pipeline)
        {
            this._warn("pipeline missing for type: " + sourceBuffer.mediaType );
            throw "missing pipeline";
        }
        DEBUG && pipeline._trace("Source Buffer: " + sourceBuffer.toString() );

        // now that we have the source buffer, create the buffer manager
        pipeline.bufferManager = new BufferManager(
            pipeline._console, pipeline.mediaType, this._movieId,
            sourceBuffer, pipeline.headers, pipeline.streamMap);

        // listen for buffer manager events
        pipeline.bufferManager.addEventListener(
            "headerAppended", this._handleHeaderAppended.bind(this));

        if (config.enableManagerDebugTraces)
        {
            pipeline.bufferManager.addEventListener(
                'managerdebugevent', function(evt) {
                    _callEventListeners(this, evt['type'], evt);
                }.bind(this));
        }

    }.bind(this));

    var completeOpen = function completeOpen()
    {
        // notify that we've finished initializing
        this._notifyOpenComplete();

        // make sure we're not shutdown
        if (this._isClosed())
        {
            DEBUG && this._warn("shutdown detected before startRequests");
            return;
        }

        // go to our main loop
        this._startRequests(this._startPts);

    }.bind( this );

    if ( config.deferAseHeaderCache )
    {
        setTimeout( function() {

            this._checkForHeaderCacheData();

            completeOpen();

        }.bind( this ), 0 );
    }
    else
    {
        this._checkForHeaderCacheData();

        setTimeout( completeOpen, 0 );
    }
};

Session.prototype.close = function close()
{
    DEBUG && this._trace("session close");
    this.stop();

    this._pendingClose = true;
    this.emit('close');

    this._streamingFailureReported = false;

    delete this._locationSelector;

    // if we haven't already notified header cache, do so
    if (!this._headerCacheNotifiedEnd && manager._headerCache)
    {
        DEBUG && this._trace("notifying header cache of streamer end");

        // both pipelines are EOS, notify header cache
        manager._headerCache.notifyStreamerEnd();
        this._headerCacheNotifiedEnd = true;
        if (config.notifyManifestCacheEom)
        {
            var evt = {
                'type': 'streamerend',
                'time': platform.time.mono()
            };
            _callEventListeners(this, evt['type'], evt);
        }
    }

    // tear down pipelines in cleanup() so we guarentee the player is stopped

    // tell manager this session is going away
    manager._removeSession(this);
};

// called after player as finished closing
Session.prototype.cleanup = function cleanup()
{
    DEBUG && this._trace("session cleanup");

    // remove intervals
    this._cleanupIntervals();

    // tear down pipelines
    this._destroyPipelines();

    this._playerState.set(Enums.PLAYER_STATE.STOPPED);

    // remove listeners
    this._listenerGroup.clear();

    // destroy mediaSource
    var mediaSource = this._mediaSource;
    delete this._mediaSource;
    if (!_.isUndefined(mediaSource))
    {
        // destroy media source
        if ( !mediaSource.destroy() )
        {
            _warn("Error on MediaSource destroy: ", mediaSource.error );
            return;
        }

        DEBUG && _trace("destroyed mediaSource: " + mediaSource.toString());
    }
};

Session.prototype.suspend = function suspend()
{
    DEBUG && _trace("suspending streaming");
    this._suspended = true;

    // XXX notify network monitor?
//    manager._networkMonitor.stop(platform.time.mono());
};

Session.prototype.resume = function resume()
{
    DEBUG && _trace("resuming streaming");
    this._suspended = false;
    this._schedulePipelines();

    // XXX notify network monitor?
//    manager._networkMonitor.start(platform.time.mono());
};

Session.prototype._isClosed = function _isClosed()
{
    return (this._pendingClose || (this._pipelines.length === 0));
};

Session.prototype._cleanupIntervals = function _cleanupIntervals()
{
    if (this._ptsInterval)
    {
        clearInterval(this._ptsInterval);
        this._ptsInterval = undefined;
    }
    if (this._bufferLevelInterval)
    {
        clearInterval(this._bufferLevelInterval);
        this._bufferLevelInterval = undefined;
    }
    if (this._streamingStatusInterval)
    {
        clearInterval(this._streamingStatusInterval);
        this._streamingStatusInterval = undefined;
    }

    if (this._bufferingCompleteTimeout)
    {
        clearTimeout(this._bufferingCompleteTimeout);
        delete this._bufferingCompleteTimeout;
    }
};

// notifies streaming session that playback has started
Session.prototype.play = function play()
{
    DEBUG && this._trace("play, playerState: " + this._playerState.value);
    this._numPlays++;

    // ignore if we were shutdown
    if (this._isClosed())
    {
        this._warn("play called after pipelines already shutdown");
        return;
    }

    this._playerState.set(Enums.PLAYER_STATE.PLAYING);
    if (!this._ptsInterval)
    {
        this._ptsInterval = setInterval(
            this._updatePts.bind(this),
            config.updatePtsIntervalMs);
    }
    if (!this._bufferLevelInterval)
    {
        this._bufferLevelInterval = setInterval(
            this._notifyBufferLevel.bind(this),
            config.bufferLevelNotifyIntervalMs);
    }
    if (!this._streamingStatusInterval)
    {
        this._streamingStatusInterval = setInterval(
            this._notifyStreamingStatus.bind(this),
            config.streamingStatusIntervalMs);
    }

    // resume bufferManager's in case they were paused
    this._pipelines.forEach(function(pipeline) {
        // resume appending if we're not doing an audio track switch
        if (pipeline.waitingForAudioTrackSwitchStart)
        {
            pipeline._warn("play: not resuming bufferManager due to audio track switch");
        }
        else
        {
            pipeline.bufferManager.resume();
        }
    });

    this.emit('play');
};

Session.prototype.stop = function stop()
{
    DEBUG && this._trace("stop, playerState:", this._playerState.value);
    this._playerState.set(Enums.PLAYER_STATE.STOPPING);

    this._cleanupIntervals();

    // clear EOS, lastHeaderAppended/Presented
    this._pipelines.forEach(function(pipeline) {
        pipeline.EOS = false;

        // Don't reset the pipeline.waitingForAudioTrackSwitchStart here as it will
        // break any track switch going on at the same time
        // The switch will be turned off once track switch starts or rejects

        // pause the buffer manager to prevent append's while stopping
        if (pipeline.bufferManager)
            pipeline.bufferManager.pause();
    });

    this.emit('stop');
};

Session.prototype.seek = function seek(pts)
{
    var currentPts = platform.getCurrentPts(this._ctxt);
    DEBUG && this._trace("seek:", pts,
                         "media.currentPts:", currentPts,
                         "playerState:", this._playerState.value);

    if (config.enableManagerDebugTraces)
    {
        this._reportDebugMessage("seek pts: " + pts +
                                 ", currentPts: " + currentPts +
                                 ", state: " + this._playerState.value);
    }

    this._playerState.set(Enums.PLAYER_STATE.STOPPED);

    // reset the pipelines
    this._pipelines.forEach(function(pipeline) {
        // reset the pipeline
        this._resetPipeline(pipeline);
    }.bind(this));

    // reset streamingOffset for whole session
    this._streamingOffset = 0;

    this._playerState.set(Enums.PLAYER_STATE.STARTING);

    // set streamingPts
    this._pipelines.forEach(function(pipeline) {
        // if the pipeline is inProgress, flag it to abort
        if (pipeline.inProgress)
        {
            DEBUG && pipeline._trace("pipeline inProgress, delaying seek");
            pipeline.seekPts = pts;
        }
        else
        {
            DEBUG && pipeline._trace("seeking pipeline to", pts);
            pipeline.inProgress = true;
            this._processSeek(pipeline, pts);
            pipeline.inProgress = false;
        }
    }.bind(this));

    // check to see if we were stopped before we go to buffering
    if (this._playerState.value != Enums.PLAYER_STATE.STARTING)
    {
        this._warn("after seeking, playerState no longer STARTING: " +
                   this._playerState.value);
        return;
    }

    DEBUG && this._trace("pipelines seeked, start buffering");

    this.emit('seek');
    this._startBuffering(bufferingReason.seek);
    this._schedulePipelines();
};

// called when player rebuffer's
Session.prototype.underflow = function underflow(pts)
{
    this._warn("underflow: going to BUFFERING at pts: " + pts);

    // change state to buffering
    this._pipelines.forEach(function(pipeline) {
        var debugMessage;

        if (DEBUG || config.enableManagerDebugTraces)
        {
            debugMessage = "underflow: " + pts +
                ", mediaType: " + pipeline.mediaType +
                ", bufferLevelBytes: " + pipeline.bufferLevelBytes +
                ", appendedBufferMs: " + pipeline.appendedBufferMs +
                ", appendedBufferBytes: " + pipeline.appendedBufferBytes +
                ", totalBufferMs: " + pipeline.totalBufferMs +
                ", totalBufferBytes: " + pipeline.totalBufferBytes +
                ", partials: " + pipeline.requestManager.partialBuffers +
                ", streamingPts: " + pipeline.streamingPts +
                ", streamingOffset: " + this._streamingOffset +
                ", completeStreamingPts: " + pipeline.completeStreamingPts +
                ", sentData: " + JSON.stringify(pipeline.requestManager._sentData) +
                ", toAppend: " + JSON.stringify(pipeline.bufferManager._toAppend) +
                ", nextAppendPts: " + pipeline.bufferManager._nextAppendPts;
        }

        DEBUG && (function() {
            pipeline._trace(debugMessage);

            var latestRequest = pipeline.requestManager.getLatestCompletedRequest();
            pipeline._trace("latestCompletedRequest: " + latestRequest);
        }.bind(this))();

        if (config.enableManagerDebugTraces)
        {
            this._reportDebugMessage(debugMessage);
        }

        pipeline.bufferingComplete = false;
        pipeline.recalculateCompleteBuffer(pts);

    }.bind(this));

    this.emit('underflow');

    this._startBuffering(bufferingReason.underflow);

    this._schedulePipelines();
};

Session.prototype.skipped = function skipped(pts)
{
    this._trace("skipped detected, pts:", pts);

    this._pipelines.forEach(function(pipeline) {
        // recalculate complete buffer info
        pipeline.recalculateCompleteBuffer(pts);

        // resume appending if we're not doing an audio track switch
        if (pipeline.waitingForAudioTrackSwitchStart)
        {
            pipeline._warn("skip: not resuming bufferManager due to audio track switch");
        }
        else
        {
            pipeline.bufferManager.resume();
        }
    }.bind(this));

    this.emit('skip');
};

// adds a manifest to be streamed
Session.prototype.addManifest = function addManifest(manifest)
{
    var headerSize;
    var info;
    var location;

    if (this._isClosed())
    {
        DEBUG && this._trace("addManifest: pipelines already shutdown");
        return;
    }

    var ap = this._pipelines[manager.MEDIA_AUDIO];
    var vp = this._pipelines[manager.MEDIA_VIDEO];
    DEBUG && this._trace(
        "addManifest at streaming pts:", ap.streamingPts, vp.streamingPts);

    // save manifest
    this._drmManifest = manifest;

    // once we have the new manifest, we should no longer truncate headers
    this._truncateHeaders = false;

    function makeFakeToString(streamId)
    {
        return function toString() {
            return "Fake header request for " + streamId;
        };
    }

    // reparse any truncated audio headers
    var header;
    for (var streamId in ap.headers)
    {
        if (ap.headers.hasOwnProperty(streamId))
        {
            header = ap.headers[streamId];
            if (header.truncated)
            {
                DEBUG && ap._trace("reparsing truncated header for", streamId);

                // move savedData to data
                header.data = header.savedData;
                delete header.savedData;

                // create a temporary "request" to hold parser
                header.request = {
                    streamId: streamId,
                    fragments: header.fragments,
                    avgFragmentDuration: header.avgFragmentDurationMs,
                    toString: makeFakeToString(streamId)
                };

                this._parseMp4Header(ap, header.request, header.data);
            }
        }
    }

    // see if we need drm headers or fragments
    if (vp.drmHeaderSent)
    {
        DEBUG && vp._trace("already have drm header for pipeline");
    }
    else
    {
        // get a url stream
        info = this._getDrmStream(manifest, vp.trackIndex);
        DEBUG && vp._trace("getting drm headers from:", info);

        // location doesn't matter for this header
        location = undefined;

        // fetch a header from the drmManifest (speculative)
        // XXX The header of a DRM stream is going to be somewhat larger than a non-DRM
        //     one because of the DRM headers (PSSH)
        headerSize = vp.lastHeaderSize ? vp.lastHeaderSize : this._estimateHeaderSize();
        var params = {
            location: location,
            url: info.url,
            streamId: info.streamId,
            byteStart: 0,
            byteEnd: headerSize,
            speculative: true,
            drmHeaderRequest: true,
            manifestIndex: this._manifestIndex+1,    // stream isn't from current manifest
            lookahead: _.isUndefined( vp.lastHeaderSize )
        };
        this._requestHeader(vp, params, function(mediaRequest) {
            DEBUG && vp._trace(
                "header for drm stream request, mediaRequest:", mediaRequest);
        });
    }

    // try switching to the drm manifest
    this._trySwitchToDrmManifest();
};

// notifies manager that the license has been acquired and that we can start fetching
// drm data
Session.prototype.drmReady = function drmReady()
{
    if (this._isClosed())
    {
        DEBUG && this._trace("pipelines already shutdown, ignoring drmReady");
        return;
    }

    DEBUG && this._trace("drmReady at streaming pts:",
                         this._pipelines[manager.MEDIA_AUDIO].streamingPts,
                         this._pipelines[manager.MEDIA_VIDEO].streamingPts);

    // ignore if license already available
    if (this._licenseAvailable)
    {
        DEBUG && this._trace("licenseAvailable already set");
        return;
    }

    this._licenseAvailable = true;

    // if location selector is gone, this session has been closed
    if (_.isUndefined(this._locationSelector))
    {
        DEBUG && this._trace("session already closed, ignoring drmReady");
        return;
    }

    // try to switch
    this._trySwitchToDrmManifest();
};

Session.prototype._trySwitchToDrmManifest = function _trySwitchToDrmManfiest()
{
    if (!this._fastplay)
    {
        DEBUG && this._trace("switchToDrmManifest ignored, not fastplay");
        return;
    }
    if (!this._licenseAvailable)
    {
        DEBUG && this._trace("switchToDrmManifest ignored, license not available");
        return;
    }
    if (!this._drmManifest)
    {
        DEBUG && this._trace("switchToDrmManifest ignored, no drm manifest");
        return;
    }
    if (!this._drmFragmentsAvailable)
    {
        DEBUG && this._trace("switchToDrmManifest ignored, waiting for drm fragments");
        return;
    }

    DEBUG && this._trace("switchToDrmManifest, manifestIndex:", this._manifestIndex,
                         "->", (this._manifestIndex+1));

    this._fastplay = false;
    this._truncateHeaders = false;
    this._manifest = this._drmManifest;
    this._drmManifest = undefined;
    ++this._manifestIndex;

    // process drm manifest
    this._processManifest(this._manifest, this._currentTracks, this._fastplay);

    // update locationSelector with new manifest
    this._locationSelector.addManifest(this._manifest);

    // mark that we've swapped streamLists's
    this._pipelines.forEach(function(pipeline) {
        pipeline.changedManifest = true;

        if (pipeline.lastSelectedStream)
        {
            pipeline.lastSelectedStream.changedManifest = true;
            pipeline.lastSelectedStream.location = undefined;
        }
    });

    // schedule pipelines
    this._schedulePipelines();
};

Session.prototype.onAudioTrackSwitchStarted = function onAudioTrackSwitchStarted()
{
    var pipeline = this._pipelines[manager.MEDIA_AUDIO];
    DEBUG && pipeline._trace("onAudioTrackSwitchStarted");

    this._processTrackSwitch(pipeline);

    DEBUG && pipeline._trace("audioTrackSwitch now buffering");
    pipeline.waitingForAudioTrackSwitchStart = false;

    // bufferManager resume will be handled by the processTrackSwitch (reset)
    this._schedulePipelines();
};

Session.prototype.onAudioTrackSwitchRejected = function onAudioTrackSwitchRejected()
{
    var pipeline = this._pipelines[manager.MEDIA_AUDIO];

    DEBUG && pipeline._trace("onAudioTrackSwitchRejected");
    pipeline.waitingForAudioTrackSwitchStart = false;

    // resume appending
    pipeline.bufferManager.resume();

    // remove the pending switch
    delete pipeline.newAudioTrack;

    this._schedulePipelines();
};

// switch streaming tracks
/**
 *
 * @param {{audioTrackId: number, subtitleTrackId: number}} newtracks
 */
Session.prototype.switchTracks = function switchTracks(newtracks)
{
    DEBUG && this._trace("switchTracks:", newtracks);
    var audioTrackId = newtracks.audioTrackId;
    var pipeline = this._pipelines[manager.MEDIA_AUDIO];

    // fail if we're buffering
    if (this._isBufferingState(this._playerState.value))
    {
        this._warn("switchTracks rejected, buffering");
        return false;
    }

    // fail if we don't have enough buffer
    var bufferLevelMs = this._pipelines[manager.MEDIA_VIDEO].bufferLevelMs;
    if (bufferLevelMs < config.minBufferLevelForTrackSwitch)
    {
        this._warn("switchTracks rejected, bufferLevelMs", bufferLevelMs, "<",
                   config.minBufferLevelForTrackSwitch);
        return false;
    }

    // fail if we have a previous switch waiting for completion
    if (this._audioTrackChange)
    {
        this._warn("switchTracks rejected, previous switch still in progress: " +
                   JSON.stringify(this._audioTrackChange));
        return false;
    }

    // fail if waiting for previous switch to start
    if (pipeline.waitingForAudioTrackSwitchStart)
    {
        this._warn("switchTracks rejected, previous switch still waiting to start");
        return false;
    }

    // find index
    var audioTracks = this._manifest["audio_tracks"];
    var audioIndex;
    var found = audioTracks.some(function(track, idx) {
        if (track["track_id"] == audioTrackId)
        {
            audioIndex = idx;
            return true;
        }
        return false;
    });
    if (!found)
    {
        this._warn("switchTracks can't find trackId:", audioTrackId);
        return false;
    }

    var currentIndex = this._currentTracks[manager.MEDIA_AUDIO];
    if (audioIndex == currentIndex)
    {
        DEBUG && this._trace("switchTracks: ignoring, same track:", audioTrackId,
                             "index:", audioIndex);
        return false;
    }

    DEBUG && this._trace("switchTracks: audioTrack change, index:",
                         currentIndex, "->", audioIndex);

    if (config.enableManagerDebugTraces)
    {
        this._reportDebugMessage("switchTracks current: " + currentIndex +
                                 " to index: " + audioIndex);
    }

    pipeline.newAudioTrack = {
        trackId: audioTrackId,
        trackIndex: audioIndex
    };

    this._startAudioTrackSwitch(pipeline);

    return true;
};

// request a streaming stat event
Session.prototype.obtainStreamingStat = function obtainStreamingStat()
{
    DEBUG && this._trace("obtainStreamingStat");
    this._notifyStreamingStatus();
};

Session.prototype.setVideoBitrateRanges = function setVideoBitrateRanges(filters)
{
    this._bitrateRanges = filters;

    var pipeline = this._pipelines[manager.MEDIA_VIDEO];
    DEBUG && pipeline._trace("session filtering streams bitrate ranges");

    // ranges is an array of objects containing "profile", "min", "max"
    pipeline.streamList.forEach(function(stream) {
        stream.inRange = this._applyFilters(
            stream.contentProfile, stream.bitrate, filters);
    }.bind(this));
};

Session.prototype._applyFilters = function _applyFilters(profile, bitrate, filters)
{
    var inRange = true; // assume inRange to start with
    filters.some(function(filter) {
        if (profile === filter["profile"])
        {
            var ranges = filter["ranges"];
            if (_.isUndefined(ranges))
            {
                // no individual ranges, use singleton min/max
                inRange = (bitrate >= filter["min"]) && (bitrate <= filter["max"]);
            }
            else
            {
                inRange = false; // not inRange unless we find a sub range
                ranges.some(function(range) {
                    inRange = (bitrate >= range["min"]) && (bitrate <= range["max"]);
                    return inRange; // stop once we found something inRange
                });
            }

            return true; // found the profile, don't need to keep looking
        }
    });

    DEBUG && this._trace("applyFilters: profile:" + profile + "bitrate:" + bitrate +
                         "inRange:" + inRange);

    return inRange;
};

Session.prototype.setLoopVideo = function setLoopVideo(enable)
{
    this._trace("setLoopVideo:", enable);
    this._loopVideo = enable;
};

//////////////////////////////////////
// header cache
//////////////////////////////////////

/**
 * Starts downloading headers for the specified manifest
 * Manifest is passed via a callback function that returns the manifest
 * and other information.
 *
 * audioTrackId - string identifier of audio track. track_id attribute of
 * element in audio_tracks array from manifest.
 *
 * @param {{
 *	getManifestInfo: function(): {manifest: Object, audioTrackId: string},
 *	movieId: number,
 *	priority: number,
 *	pts: ?number}} args
 * @param {function()} callback
 */
Manager.prototype.cachePrepare = function cachePrepare(args, callback)
{
    var p;
    if (this._headerCache)
    {
        p = this._headerCache.prepareP(this, args);

        // add callback to promise chain
        if (!_.isUndefined(callback)) {
            p.then(callback);
        }
    }
};

/**
 * Flushes the header cache
 *
 */
Manager.prototype.cacheFlush = function cacheFlush()
{
    if (this._headerCache)
    {
        this._headerCache.flush();
    }
};

/**
 * Returns the header cache list
 *
 * @return {Array}
 */
Manager.prototype.cacheList = function cacheList()
{
    if (this._headerCache)
    {
        return this._headerCache.list();
    }
    else
    {
        return [];
    }
};

/**
 * Sets the max number of items in the headerCache
 *
 * @param {number} maxItems
 */
Manager.prototype.cacheSetSize = function cacheSetSize(maxItems)
{
    if (this._headerCache)
    {
        this._headerCache.setMaxSize(maxItems);
    }
};

/**
 * Destroys the headerCache
 */
Manager.prototype.cacheDestroy = function cacheDestroy()
{
    if (this._headerCache)
    {
        this._headerCache.destroy();
    }
};

/**
 * Gets counts for each track
 *
 * @return Array<{
 *  "requests": number,
 *  "appended": number,
 *  "appendfail": number,
 *  "aborted": number,
 *  "abortfail": number
 * }>
 */
Manager.prototype.cacheRequestAuditCounts = function cacheRequestAuditCounts()
{
    return this._headerCache ? this._headerCache.requestAuditCounts() : null;
};

//////////////////////////////////////
// heuristic calls
//////////////////////////////////////

Session.prototype._makePlayerInfo = function _makePlayerInfo(pipeline)
{
    // player
    var currentPts = platform.getCurrentPts(this._ctxt);
    var buffer = {
        capacity: manager._bufferSize[pipeline.mediaType],
        startPts: null,  // added later
        currentPts: currentPts,
        streamingPts: null, // added later
        completePts: pipeline.completeStreamingPts || currentPts,
        partialBytes: 0,
        fragments: []
    };
    var player = {
        state: this._playerState.value,
        streamingIndex: pipeline.nextFragmentIndex,
        buffer: buffer,
        averageFragmentDuration : pipeline.avgFragmentDurationMs,
        drainingBytes : pipeline.drainingBytes,
        looping: this._loopVideo,
        expectedStartTimeMono: this._expectedStartTimeMono
    };

    // get info on the request buffer
    var info = pipeline.requestManager.getRequestBufferInfo();
    buffer.streamingPts = info.streamingPts;
    buffer.startPts = info.startPts;
    buffer.partialBytes = info.partialBytes;

    // dump the message before adding the fragments (can be very verbose)
    DEBUG && pipeline._trace("playerInfo:", player);

    buffer.fragments = info.fragments;

    if (config.preciseBufferLevel)
    {
        var update = pipeline.requestManager.calculateCompleteBuffer(currentPts);
        player.bufferLevelMs = update.bufferLevelMs;
    }

    if (buffer.startPts === null)  // no requests sent in our buffer?
    {
        buffer.startPts = 0;
        buffer.streamingPts = 0;

        DEBUG && (function() {
            if (pipeline.requestManager.requestCount > 0)
            {
                pipeline._trace("bufferDetails has no startPts");
                pipeline.requestManager.dumpRequests();
            }
        })();
    }
    else if (pipeline.seeking && (buffer.currentPts != buffer.startPts))
    {
        DEBUG && pipeline._trace(
            "makePlayerInfo while seeking, using startPts:", buffer.startPts,
            "in place of currentPts:", buffer.currentPts);
        buffer.currentPts = buffer.startPts;
    }

    return player;
};

/**
 * Expose the lowest video buffer level computed during the heuristics simulation.
 * Used by native.
 */
Session.prototype.getLowestSimulatedBufferLevel = function getLowestSimulatedBufferLevel()
{
    var vp = this._pipelines[Enums.MEDIA_TYPE.VIDEO];
    if (!vp.lowestSimulatedBufferLevel)
        return 0;

    return vp.lowestSimulatedBufferLevel;
};

/**
 * Expose the current throughput so it can be queried by native/Cadmium.
 * Used to make deicsions like the quality of downloaded trickplay.
 */
Session.prototype.getAverageThroughput = function _getAverageThroughput()
{
    var statistics = manager._networkMonitor.get();
    if (statistics.confidence)
        return statistics.throughput.average;
};

Session.prototype._getStreamInfo = function _getStreamInfo(pipeline)
{
    var isVideo = (pipeline.mediaType == manager.MEDIA_VIDEO);
    var oldBitrate = 0;

    // if pipeline's track is not there, don't do anything
    if (!pipeline.track)
    {
        DEBUG && pipeline._warn("ignoring getStreamInfo, no current download track");
        return { streamIndex: undefined };
    }

    var player = this._makePlayerInfo(pipeline);

    DEBUG && (function() {
        var ptsStarts = pipeline.requestManager.getRequestPtsStarts();
        pipeline._trace("_getStreamInfo:" +
                        " media pts:" + platform.getCurrentPts(this._ctxt) +
                        " count:" + pipeline.requestManager.requestCount +
                        " requests:" + ptsStarts);

        // sanity check player
        if (player.buffer.currentPts < player.buffer.startPts)
        {
            pipeline._warn("warning: currentPts:" + player.buffer.currentPts +
                           " < startPts:" + player.buffer.startPts);
        }
    }.bind(this))();

    // get streamList from pipeline
    var streamList = pipeline.streamList;

    // if we changed manifests, try to find a new stream
    var selectedStream = pipeline.lastSelectedStream;
    var streamIndex = selectedStream ?
        selectedStream.index : pipeline.firstSelectedStreamIndex;

    if (selectedStream)
    {
        oldBitrate = selectedStream.bitrate;
        if (selectedStream.changedManifest)
        {
            // find first bitrate at least as high as old
            streamList.some(function(stream, index) {
                if (stream.isAvailable && !stream.hasFailed && stream.inRange &&
                    (stream.bitrate >= oldBitrate))
                {
                    var trace = (stream.bitrate == oldBitrate ?
                                 pipeline._trace : pipeline._warn).bind(pipeline);
                    DEBUG && trace("manifest changed, adjusting from old streamIndex:",
                                   streamIndex, oldBitrate, "Kbps",
                                   "to new streamIndex:", index, stream.bitrate, "Kbps",
                                   "streamId:", stream.id);

                    streamIndex = index;

                    selectedStream.index = index;
                    selectedStream.bitrate = stream.bitrate;

                    return true;
                }
            });

            // So that we don't keep doing this over and over
            delete selectedStream.changedManifest;
        }
    }

    if (pipeline.changedManifest)
    {
        DEBUG && pipeline._trace("getStreamInfo, clearing changedManifest flag");
        delete pipeline.changedManifest;
    }

    if (!this._locationSelector)
    {
        pipeline._warn("location selector no longer there");
        return { streamIndex: undefined };
    }

    // update streamList with locationSelector
    DEBUG && pipeline._trace("calling locationSelector to update urls");
    streamList = this._locationSelector.updateStreamUrlSelection(player, streamList);
    if (!streamList)
    {
        // When the stream list is null, location selector did not find any URLs
        pipeline._error("location selector did not find any urls");
        return { streamIndex: undefined };
    }

    // see if we need to call stream selector
    if (!isVideo)
    {
        if (selectedStream && !pipeline.restart &&
            (selectedStream.location == streamList[streamIndex].location))
        {
            DEBUG && pipeline._trace(
                "audio request at same location, skipping streamSelector");
            return { streamIndex: streamIndex, continueStream: true };
        }

        // if the pipeline was restart, set the audio pipeline to STARTING state so it can
        // pick a new stream
        if (pipeline.restart)
        {
            DEBUG && pipeline._trace("audio pipeline seeked, using STARTING state");
            player.state = Enums.PLAYER_STATE.STARTING;
            selectedStream = undefined;
            streamIndex = undefined;
            delete pipeline.lastSelectedStream;
            delete pipeline.firstSelectedStreamIndex;
        }
        pipeline.restart = undefined;
    }

    // see if our buffer is above the threshold and we would like to disable bitrate
    // selection
    if (isVideo &&
        config.enableAdaptiveParallelStreaming &&
        config.disableBitrateSelectionOnSingleConnection)
    {
        // ideally we probably only need to check whether we are using single connection
        // but in cadmium, we start by using single connection, so we also need to check
        // buffer level
        if (!pipeline.track.isParallel() &&
            pipeline.bufferLevelMs > config.bufferThresholdToSwitchToSingleConnMs)
        {
            DEBUG && pipeline._trace(
                "using single connection & buffer is high," +
                " skipping streamSelector and return the highest stream");
            return {
                streamIndex: pipeline.highestBitrateStreamIndex,
                continueStream: true
            };
        }
    }

    // call stream selector
    var predictor = isVideo ? this._predictor.predictVideo : this._predictor.predictAudio;
    var maxPrebuf = (config.useMaxPrebufSize && this._numPlays === 0) ?
        config.maxPrebufSize : Infinity;
    DEBUG && pipeline._trace("calling streamSelector, maxPrebuf: " + maxPrebuf);
    var result = pipeline.streamSelector.selectStream(
        player, streamList, streamIndex, predictor,
        pipeline.track.config.pipeline, maxPrebuf);
    if (!result)
    {
        pipeline._error("stream selector did not find a stream");
        return { streamIndex: undefined };
    }

    // record the reason for marking the first stream as feasible & the historical throughput (-1 if none)
    if (isVideo && _.isUndefined(pipeline.initSelectionReason)) {
        pipeline.historicalThroughputValue = result.histBw;
        pipeline.initSelectionReason = result.reason;
    }

    pipeline.lowestSimulatedBufferLevel = result.lowestSimulatedBufferLevel;
    var resultIndex = result.selectedStreamIndex;

    // get resulting stream's info
    var resultStream = streamList[resultIndex];
    var newBitrate = resultStream.bitrate;
    var throughput = resultStream.throughput || 0;


    var videoBuffer = this._pipelines[manager.MEDIA_VIDEO].bufferLevelMs;
    // if current stream is not feasible and we are under the critical buffer level
    // fire event, so native can cancel ongoing requests
    if (result.currentStreamInfeasible && videoBuffer < config.bufferThresholdForAbort) {
        pipeline._trace('Current stream came back infeasible');
        if (newBitrate < oldBitrate) {
            var evt = {
                'type': 'currentStreamInfeasible',
                'oldBitrate': oldBitrate,
                'newBitrate': newBitrate
            };
            DEBUG && pipeline._debug("currentStreamInfeasible: " + JSON.stringify(evt));
            _callEventListeners(this, evt['type'], evt);
        }
    }

    if (resultIndex != streamIndex)
    {
        DEBUG && pipeline._trace("streamSelector chose new stream:", resultIndex,
                                 "bitrate:", oldBitrate, "->", newBitrate,
                                 "throughput:", throughput);
        // Given now we selected a new stream,
        // we should check to see if we need to adapt the number of connections,
        if (isVideo && config.enableAdaptiveParallelStreaming)
        {
            this._adaptPipelineConnectionNumbers(pipeline, newBitrate);
        }
        if (!isVideo && !selectedStream)
        {
            this._predictor.setAudioRate(newBitrate);
        }
    }

    if (!_.isNumber(pipeline.firstSelectedStreamIndex))
        pipeline.firstSelectedStreamIndex = resultIndex;

    if ( !pipeline.bufferingComplete )
    {
        if (result.bufferingComplete )
        {
            DEBUG && pipeline._trace("streamSelector reported bufferingComplete with " +
                                     pipeline.bufferLevelMs + "ms buffered");
            pipeline.bufferingComplete = true;
            pipeline.buffCompleteReason = result.reason;
        }
        else
        {
            // Get the estimated amount of buffer
            DEBUG && pipeline._trace("Buffering incomplete:", result );
            pipeline.lowThroughput = result.lowThroughput;
            pipeline.requiredBuffer = result.requiredBuffer;
            pipeline.progress = result.progress;
        }
    }

    this._checkBufferingComplete();

    DEBUG && pipeline._trace("selectedStream index: " + resultIndex +
                             ", bitrate: " + newBitrate +
                             ", statistics: " + JSON.stringify(resultStream.statistics) +
                             ", location: " + resultStream.location);

    // remember any desired headers
    if (!isVideo || !this._setDesiredHeaders(pipeline, result.desiredStreamHeaders))
    {
        // nothing desired, delete the property
        delete pipeline.desiredHeaders;
    }

    return { streamIndex: resultIndex, continueStream: result.continueStream };
};

Session.prototype._setDesiredHeaders = function _setDesiredHeaders(pipeline, desired)
{
    var streamList, stream;

    // did stream selector already request some headers?
    if (desired)
    {
        DEBUG && pipeline._trace("desiredHeaders: for speculative requests", desired);
        pipeline.desiredHeaders = desired;
        return true;
    }
    else if ((!pipeline.desiredHeaders || pipeline.desiredHeaders.length === 0) &&
             pipeline.bufferLevelMs > config.minBufferLenForHeaderDownloading)
    {
        // make an opportunistic speculative request
        for (var i = 0; i < pipeline.streamList.length; ++i)
        {
            stream = pipeline.streamList[i];
            if (stream.isAvailable && stream.inRange && !stream.hasFailed &&
                _.isUndefined(pipeline.headers[stream.id]))
            {
                DEBUG && pipeline._trace(
                    "opportunistic speculative request for streamId:", stream.id);
                pipeline.desiredHeaders = [ i ];
                return true;
            }
        }
    }
    // nothing desired
    return false;
};

Session.prototype._estimateHeaderSize = function _estimateHeaderSize()
{
    var HEADER_CONSTANT_SIZE =
        256 /* ftyp and nflx header */ +
        2000  /* moov box */ +
        36 /* sidx metadata*/;

    /* each fragment is 12 bytes in sidx, and each fragment is 2000 ms */
    var HEADER_SIZE_PER_MILLISECOND = 12 / 2000;
    return HEADER_CONSTANT_SIZE + this._duration * HEADER_SIZE_PER_MILLISECOND;
};

Session.prototype._calculateRangeRequest = function _calculateRangeRequest(
    pipeline, fragments, pts, index)
{
    DEBUG && pipeline._trace("calculateRangeRequest, pts: " + pts + ", index: " + index +
                             ", streamingOffset: " + this._streamingOffset);
    if (_.isUndefined(index))
    {
        index = pipeline._estimateFragmentIndex(pts);
    }

    // cap index
    if (index >= fragments.length)
    {
        index = fragments.length-1;
        pipeline._warn("capping index to: " + index);
    }

    function calculateLookaheadBytes( fragments, index )
    {
        var lookaheadBytes = [ ];
        for(var i=index; i < index+config.lookaheadFragments && i < fragments.length; ++i)
        {
            lookaheadBytes.push( fragments.getFragmentSize( i ) );
        }

        return lookaheadBytes;
    }

    // now find the right frag
    var delta;
    var frag;
    var fragstr;
    var endPts;
    do
    {
        frag = fragments.getFragment(index);
        endPts = frag.startPts + frag.duration;
        fragstr = "frag(" + frag.startPts + " - " + endPts + ")";
        DEBUG && pipeline._trace("checking frag at index:" + index + ", " + fragstr +
                                 ", delta:" + delta);
        if ((!delta && (pts >= frag.startPts) && (pts < endPts)) ||
            ((delta == 1) && (pts < endPts)) ||
            ((delta == -1) && (pts >= frag.startPts)))
        {
            DEBUG && pipeline._trace("using fragment: " + fragstr);

            // remember the actual start pts of pipeline
            pipeline.setActualStartPts(frag.startPts);

            frag.lookaheadBytes = calculateLookaheadBytes( fragments, index );

            return frag;
        }

        if (!delta)
        {
            // determine which direction to look
            delta = (pts >= endPts) ? 1 : -1;
        }

        index += delta;
    }
    while ((index >= 0) && (index < fragments.length));

    if (index >= fragments.length)
    {
        DEBUG && pipeline._trace("calculateRangeRequest, out of range of fragments:",
                                 fragments.length);
        return;
    }

    frag = fragments.getFragment(0);
    frag.lookaheadBytes = calculateLookaheadBytes( fragments, 0 );
    DEBUG && pipeline._trace("pts earlier than first fragment, index:", index,
                             "using first at pts:", frag.startPts);
    return frag;
};

Session.prototype._checkPendingRequests = function(pipeline, streamIndex)
{
    var stream = pipeline.streamList[streamIndex];
    var streamId = stream.id;
    var abortedRequest = false; // have aborted any requests
    DEBUG && pipeline._trace("checkPendingRequests, streamId:", streamId);

    // make sure the headers for this stream are available
    var header = pipeline.headers[streamId];
    if (!header || !header.fragments)
    {
        DEBUG && pipeline._trace("checkPendingRequest ignored, header not available");
        return {
            wait: true,
            aborted: abortedRequest
        };
    }

    // utility function to rewind streamingPts on aborted request
    function rewindStreamingPts(aborted)
    {
        var newPts;

        // if none aborted, noop
        if (aborted.length === 0)
        {
            return;
        }

        DEBUG && pipeline._trace("rewindStreamingPts: " + pipeline.streamingPts +
                                 " streamingOffset: " + this._streamingOffset +
                                 " aborted: " + JSON.stringify(aborted));

        // aborted requests are provided in streaming order
        var request = aborted[ 0 ];

        // if aborted request's streamingPts is earlier, rewind to it
        if (pipeline.streamingPts + this._streamingOffset > request.ptsStart)
        {
            // if request pts >= streamingOffset, deduct it
            newPts = (request.ptsStart >= this._streamingOffset) ?
                request.ptsStart - this._streamingOffset : request.ptsStart;

            DEBUG && pipeline._trace("rewinding streamingPts to: " + newPts +
                                     " streamingOffset: " + this._streamingOffset);
            pipeline.setStreamingPts(newPts);
        }

        // mark that we aborted something
        abortedRequest = true;
    }

    // abort any unsent requests that don't match the bitrate
    if (config.abortUnsentBlocks)
    {
        pipeline.requestManager.setSelectedBitrate(
            this._manifestIndex, stream.bitrate, rewindStreamingPts.bind(this));
    }

    // check if new server location (ignore if pipelines not fully started yet)
    if (this._pipelinesStarted && stream.server && (stream.server != pipeline.server))
    {
        // abort any unsent blocks if feature enabled
        if (config.abortUnsentBlocks)
        {
            DEBUG && pipeline._trace("aborting unsent blocks on server change");
            pipeline.requestManager.abortUnsentRequests(
                this._manifestIndex, rewindStreamingPts.bind(this));

            // log a debug message
            if (config.enableManagerDebugTraces)
            {
                this._reportDebugMessage("abortUnsentRequests on server change");
            }
        }

        // if we still have partial buffers, need to delay pipeline
        if (pipeline.requestManager.partialBuffers > 0)
        {
            DEBUG && pipeline._trace(
                "requesting new server:", stream.server,
                "with partial requests:", pipeline.requestManager.partialBuffers,
                "WAITING");
            return {
                wait: true,
                aborted: abortedRequest
            };
        }
    }

    return {
        wait: false,
        aborted: abortedRequest
    };
};

/**
@param {Object} videoPipeline
@param {Object=} newVideoBitrateFromStreamSelector
*/
Session.prototype._adaptPipelineConnectionNumbers =
    function _adaptPipelineConnectionNumbers(
        videoPipeline, newVideoBitrateFromStreamSelector)
{
    if ( !videoPipeline || !videoPipeline.lastSelectedStream ||
         !videoPipeline.lastStreamNotified)
    {
        // haven't done any stream selection yet, should not change the number of
        // connection
        return;
    }

    var lastSelectedStreamBitrate;
    if (newVideoBitrateFromStreamSelector)
    {
        // if new bitrate from stream selector is available, use the lowest value between
        // newly selected rate, lastSelectedStream & lastStreamNotified the idea is that
        // we want lastSelectedStreamBitrate to be the lower bound of the bitrate that we
        // have been _stably_ using
        lastSelectedStreamBitrate = Math.min(videoPipeline.lastSelectedStream.bitrate,
                                             videoPipeline.lastStreamNotified.bitrate,
                                             newVideoBitrateFromStreamSelector);
    }
    else
    {
        // if new bitrate from stream selector is not available, use the lowest value
        // between lastSelectedStream vs. lastStreamNotified
        lastSelectedStreamBitrate = Math.min(videoPipeline.lastSelectedStream.bitrate,
                                             videoPipeline.lastStreamNotified.bitrate);
    }

    if ( !lastSelectedStreamBitrate )
    {
        DEBUG && console.warn("APC: the bitrate of last selected stream is undefined!");
        return;
    }
    if ( !videoPipeline.track )
    {
        DEBUG && console.warn("Download track is undefined!");
        return;
    }

    if ( this._isBufferingState(this._playerState.value) )
    {
        // still in buffering state, should not change the number of connection
        return;
    }

    var networkStats = manager._networkMonitor.get();
    DEBUG && console.trace("APC: Buffer Level: " + videoPipeline.bufferLevelMs +
                           ", tput= " + networkStats.throughput.average +
                           "kbps (confidence: "+ networkStats.confidence + ")" +
                           ", lastest video bitrate: " + lastSelectedStreamBitrate);
    DEBUG && console.trace("APC: current number of connections = " +
                           videoPipeline.track.config.connections + ", isParallel? " +
                           videoPipeline.track.isParallel());
    if ( videoPipeline.track.isParallel() &&
        videoPipeline.bufferLevelMs > config.bufferThresholdToSwitchToSingleConnMs &&
        lastSelectedStreamBitrate === videoPipeline.highestBitrateStream.bitrate )
    {
        /**
        *    We would switch from multiple (3) connections to single connection if the
        *    following condition is met:
        *    (1) our buffer is reasonably full (threshold configurable), and
        *    (2) We are already streaming the highest video rate
        */
        DEBUG && console.trace("APC: switching from parallel to single connection");
        videoPipeline.track.reconfigure( {  "connections" : 1,  "openRange" : true } );
        videoPipeline.switchFromParallelToSingle += 1;
        return;
    }
    else if ( config.pipelineEnabled &&
              !videoPipeline.track.isParallel() &&
              ( videoPipeline.bufferLevelMs <
                config.bufferThresholdToSwitchToParallelConnMs ||
                lastSelectedStreamBitrate !== videoPipeline.highestBitrateStream.bitrate
              ))
    {
        /**
        *    We would switch from single connection to multiple (3) connections when any
        *    one of the conditions is met:
        *    (1) our buffer level is rebuffer-risky (threshold configurable), OR
        *    (2) We are not streaming at the highest video rate anymore
        */
        DEBUG && console.trace("APC: before change, current number of connections = " +
                               videoPipeline.track.config["connections"] +
                               ", isParallel? " + videoPipeline.track.isParallel());
        videoPipeline.track.reconfigure({
            "connections" : config.maxParallelConnections,
            "openRange" : false
        });
        DEBUG && console.trace("APC: Switch to parallel connection!" +
                               " Number of connections = " +
                               videoPipeline.track.config["connections"] +
                               ", isParallel? " + videoPipeline.track.isParallel() );
        videoPipeline.switchFromSingleToParallel += 1;
        return;
    }
};

Session.prototype._checkPipelineVacancy = function _checkPipelineVacancy(
    pipeline, other)
{
    var otherPts = other.streamingPts;
    DEBUG && pipeline._trace(
        "checkPipelineVacancy, streamingPts: " + pipeline.streamingPts +
        ", other: " + otherPts +
        ", activeRequests: " + pipeline.requestManager.activeRequests);

    // make sure we don't over schedule
    var partialBufferMs =
        pipeline.requestManager.partialBuffers * pipeline.avgFragmentDurationMs;
    if (partialBufferMs >= config.maxPendingBufferLen)
    {
        DEBUG && pipeline._trace("No vacancy, partialBufferMs: " +
                                 partialBufferMs + " >= " + config.maxPendingBufferLen);
        return false;
    }

    // check completed ratio
    if (pipeline.bufferLevelMs)
    {
        var maxPartialMs = Math.max(
            pipeline.bufferLevelMs * config.maxPendingBufferPercentage / 100,
            config.minPendingBufferLen);
        if (partialBufferMs > maxPartialMs)
        {
            DEBUG && pipeline._trace(
                "No vacancy, bufferLevelMs: " + pipeline.bufferLevelMs +
                ", partial ratio would exceed max: " +
                partialBufferMs + ">" + maxPartialMs);
            return false;
        }
    }

    var deltaPts = pipeline.streamingPts - otherPts;
    if (other.EOS)
    {
        DEBUG && pipeline._trace("other pipeline at EOS, ignoring skew check");
    }
    else
    {
        // make sure we're not too far ahead of other buffer
        if ((deltaPts >= config.maxStreamingSkew) &&
            (pipeline.bufferLevelMs > config.minPrebufSize))
        {
            DEBUG && pipeline._trace("No vacancy, pipeline pts skew: " +
                                     deltaPts + " >= " + config.maxStreamingSkew);
            return false;
        }
    }

    // Max unsent blocks
    if (config.abortUnsentBlocks &&
        (pipeline.requestManager.unsentRequests >= config.maxUnsentBlocks))
    {
        DEBUG && pipeline._trace(
            "No vacancy, max unsent requests in buffer: " +
            pipeline.requestManager.unsentRequests + " >= " + config.maxUnsentBlocks);
        return false;
    }

    // max requests
    if (pipeline.requestManager.requestCount >= config.maxRequestsInBuffer)
    {
        DEBUG && pipeline._trace(
            "No vacancy, max requests in buffer: " +
            pipeline.requestManager.requestCount + " >= " + config.maxRequestsInBuffer);
        return false;
    }

    // max buffer length
    var bufferLength = pipeline.totalBufferMs + partialBufferMs;

    // NRDJS-2212. If max media buffer allowed is set to be smaller than the
    // skipback buffer + 2 fragments, requests will never be pruned, and new
    // requests will never be made, resulting in a stall and underflow.
    var maxMediaBufferAllowed = Math.max(config.maxMediaBufferAllowed,
        config.reserveForSkipbackBufferMs + (2 * pipeline.avgFragmentDurationMs));

    if (bufferLength >= maxMediaBufferAllowed)
    {
        DEBUG && pipeline._trace("No vacancy, max buffer length: " +
                                 bufferLength + ">=" + maxMediaBufferAllowed);
        return false;
    }

    // if we're still buffering schedule one request at a time
    if (this._isBufferingState(this._playerState.value))
    {
        var maxPartial = 1;
        if (pipeline.bufferingRequests < config.maxPartialBuffersAtBufferingStart)
            maxPartial = config.maxPartialBuffersAtBufferingStart;

        DEBUG && pipeline._trace("buffering count: " + pipeline.bufferingRequests +
                                 ", partial: " + pipeline.requestManager.partialBuffers +
                                 ", max: " + maxPartial);

        if (pipeline.requestManager.partialBuffers >= maxPartial)
        {
            DEBUG && pipeline._trace(
                "No vacancy, partials " +
                pipeline.requestManager.partialBuffers + ">=" + maxPartial);
            return false;
        }
    }

    // make sure total buffer level does not exceed configured max
    if (config.maxTotalBufferLevelPerSession > 0)
    {
        var totalBytes = this._pipelines.reduce(function(total, pipeline) {
            return total + pipeline.totalBufferBytes;
        }, 0);
        if (totalBytes > config.maxTotalBufferLevelPerSession)
        {
            DEBUG && pipeline._warn(
                "No vacancy, session total buffer exceeded: " +
                totalBytes + ">" + config.maxTotalBufferLevelPerSession);
            return false;
        }
    }

    DEBUG && pipeline._trace(
        "pipeline has vacancy, partialBuffers: " +pipeline.requestManager.partialBuffers +
        ", partialBufferMs: " + partialBufferMs +
        ", bufferLevelMs: " + pipeline.bufferLevelMs +
        ", deltaPts: " + deltaPts);
    return true;
};

Session.prototype._checkBufferingComplete = function _checkBufferingComplete()
{
    var bufferingTime;
    var buffering = this._isBufferingState(this._playerState.value);
    if (!buffering && !this._audioTrackChange)
    {
        // neither buffering or waiting for audio track change, return "complete"
        return true;
    }

    var ap = this._pipelines[manager.MEDIA_AUDIO];
    var vp = this._pipelines[manager.MEDIA_VIDEO];

    var videoMinPrebufSize = config.minPrebufSize;
    if ( config.requireDownloadDataAtBuffering && (vp.precached >= config.minPrebufSize) )
    {
        // forcing the pipeline to download one more gop when it has precached more than
        // config.minPrebufSize
        videoMinPrebufSize = vp.precached + 1000;
    }

    if (config.requireSetupConnectionDuringBuffering &&
        (vp.precached >= config.minPrebufSize))
    {
        // forcing both pipelines to set up the connection first
        if ( !ap.connected || !vp.connected )
        {
            return false;
        }
    }

    var debugMessage = "checkBufferingComplete," +
        " audio: " + ap.bufferLevelMs +
        " video: " + vp.bufferLevelMs;
    DEBUG && this._trace(debugMessage);
    if (config.enableManagerDebugTraces)
    {
        this._reportDebugMessage(debugMessage);
    }

    // check audio
    if (ap.bufferLevelMs >= config.minPrebufSize)
    {
        if (this._audioTrackChange)
        {
            DEBUG && this._trace("completed audioTrackSwitch");
            this._notifyAudioTrackSwitchComplete(this._audioTrackChange);

            this._audioTrackChange = undefined;
        }

        // If stream selection has determined that we can start playing without a
        // rebuffer on the video pipeline and the audio pipeline has at least
        // minPrebufSize, we can start playing
        if (vp.bufferingComplete && (vp.bufferLevelMs >= videoMinPrebufSize))
        {
            this._setBufferingComplete();
            return true;
        }
    }

    // see if we're EOS and no more requests
    if (ap.EOS && vp.EOS)
    {
        if ((ap.requestManager.partialBuffers === 0) &&
            (vp.requestManager.partialBuffers === 0) &&
            ( !config.abortUnsentBlocks || ( ap.requestManager.unsentRequests === 0 &&
                                             vp.requestManager.unsentRequests === 0 )))
        {
            DEBUG && this._trace(
                "both pipelines at EOS, and no more work, setBufferingComplete:",
                "audio completeMs:", ap.bufferLevelMs,
                "video completeMs:", vp.bufferLevelMs);
            this._setBufferingComplete();
            return true;
        }
    }

    if (buffering)
    {
        if ((ap.bufferLevelMs >= config.minPrebufSize) &&
            (vp.bufferLevelMs >= config.minPrebufSize))
        {
            // only force the buffering complete after the player has already downloaded
            // something
            bufferingTime = (platform.time.mono() - this._bufferingStartTime);
            if (bufferingTime >= config.prebufferTimeLimit)
            {
                // if we've waited too long, declare buffering complete
                this._warn("buffering longer than limit: " +
                           bufferingTime + " >= " + config.prebufferTimeLimit +
                           ", audio buffer: " + ap.bufferLevelMs + " ms" +
                           ", video buffer: " + vp.bufferLevelMs + " ms");
                this._setBufferingComplete();
                return true;
            }
        }

        // report buffering percentage since we're not complete yet
        this._notifyBuffering();
    }

    return false;
};

Session.prototype._setBufferingComplete = function _setBufferingComplete()
{
    DEBUG && this._trace("audio pipeline: " + this._pipelines[0].bufferLevelMs +
                         ", video pipeline: " + this._pipelines[1].bufferLevelMs);

    // clear pipeline flags
    this._pipelines.forEach(function(pipeline) {
        delete pipeline.seeking;
    });

    if (this._isBufferingState(this._playerState.value))
    {
        DEBUG && this._trace("bufferingComplete");
        if (DEBUG || config.enableManagerDebugTraces) {
            this._pipelines.forEach(function(pipeline) {
                var debugMessage = "bufferingComplete: " +
                    ", mediaType: " + pipeline.mediaType +
                    ", bufferLevelBytes: " + pipeline.bufferLevelBytes +
                    ", appendedBufferMs: " + pipeline.appendedBufferMs +
                    ", appendedBufferBytes: " + pipeline.appendedBufferBytes +
                    ", totalBufferMs: " + pipeline.totalBufferMs +
                    ", totalBufferBytes: " + pipeline.totalBufferBytes +
                    ", partials: " + pipeline.requestManager.partialBuffers +
                    ", streamingPts: " + pipeline.streamingPts +
                    ", streamingOffset: " + this._streamingOffset +
                    ", completeStreamingPts: " + pipeline.completeStreamingPts +
                    ", sentData: " + JSON.stringify(pipeline.requestManager._sentData) +
                    ", toAppend: " + JSON.stringify(pipeline.bufferManager._toAppend) +
                    ", nextAppendPts: " + pipeline.bufferManager._nextAppendPts;
                this._reportDebugMessage(debugMessage);
            }.bind(this));
        }

        this._notifyBufferingComplete();
    }

    // remove any timeout we may have scheduled
    if (this._bufferingCompleteTimeout)
    {
        clearTimeout(this._bufferingCompleteTimeout);
        delete this._bufferingCompleteTimeout;
    }

    // change the state to be PLAYING so the stream selector will start upswitching
    this._playerState.set(Enums.PLAYER_STATE.PLAYING);

    // make sure we keep pipeline running
    this._schedulePipelines();
};

Session.prototype._setEndOfStream = function _setEndOfStream(pipeline)
{
    // mark pipeline EOS
    pipeline.EOS = true;
    pipeline.endPts = pipeline.streamingPts;
    DEBUG && pipeline._trace("pipeline EOS at pts: " + pipeline.endPts);

    // clear EOSnotified in case we did it before
    pipeline.EOSnotified = false;

    // Delay endOfStream notification until close to end of playback in case the user
    // tries to seek between now and actual endOfPlayback

    // check for end of buffering
    this._checkBufferingComplete();
};

//////////////////////////////////////
// pipeline startup
//////////////////////////////////////

Session.prototype._startRequests = function _startRequests(ptsStart)
{
    this._playerState.set(Enums.PLAYER_STATE.STARTING);
    var ap = this._pipelines[manager.MEDIA_AUDIO];
    var vp = this._pipelines[manager.MEDIA_VIDEO];
    // start up video pipeline
    if (!this._startPipeline(vp, ptsStart))
    {
        this._warn("failed to start video pipeline");
        return;
    }

    // start up audio pipeline
    if (!this._startPipeline(ap, ptsStart))
    {
        this._warn("failed to start audio pipeline");
        return;
    }

    this._pipelinesStarted = true;

    // once both pipelines have been started, check for any header cache data use
    if ((vp.precached > 0) || (ap.precached > 0))
    {
        // send notification of amount of audio/video data precached
        this._notifyHeaderCacheDataHit(this._movieId, ap.precached, vp.precached);
    }

    // check to see if we were stopped already
    if (this._playerState.value != Enums.PLAYER_STATE.STARTING)
    {
        this._warn("startup, playerState no longer STARTING:", this._playerState.value);
        return;
    }

    DEBUG && this._trace("both pipelines started - now buffering");
    this._startBuffering(bufferingReason.startup);

    // notify initial audio track
    this._notifyInitialAudioTrack();
};

Session.prototype._startPipeline = function _startPipeline(pipeline, ptsStart)
{
    DEBUG && pipeline._trace("startPipelineP");

    var streamIndex = this._getStreamInfo(pipeline).streamIndex;
    if (_.isUndefined(streamIndex))
    {
        if (!this._isClosed()) // suppress failure if closing
        {
            // we can't start the pipeline, fail playback
            this._reportStreamingFailure(
                "startPipeline failed", "NFErr_MC_StreamingInitFailure");
        }
        return false;
    }

    var stream = pipeline.streamList[streamIndex];
    var streamId = stream.id;
    var url = stream.url;
    var location = stream.location;

    DEBUG && pipeline._trace(
        "initial bitrate:", stream.bitrate, "streamId:", streamId);

    // check to see if we already have the header (adopted from headercache)
    if (pipeline.headers[streamId] && pipeline.headers[streamId].fragments)
    {
        DEBUG && pipeline._trace(
            "initial header already available, streamId:", streamId);
        return true;
    }

    // header offsets
    var byteStart = 0;
    var byteEnd = config.headerRequestSize-1;

    // if we are not doing fastplay or we are getting an audio header, estimate its real
    // size 4MB will be too small and will result in two network requests
    if (pipeline.mediaType === manager.MEDIA_AUDIO || !this._fastplay)
        byteEnd = this._estimateHeaderSize();

    // if we're not doing fastplay, this should be a drmHeaderRequest
    var drmHeaderRequest =
        !this._fastplay && (pipeline.mediaType === manager.MEDIA_VIDEO);

    // request and attach header
    var params = {
        location: location,
        url: url,
        streamId: streamId,
        byteStart: byteStart,
        byteEnd: byteEnd,
        drmHeaderRequest: drmHeaderRequest,
        firstHeader: true,
        lookahead: true
    };
    this._requestHeader(pipeline, params, function(mediaRequest) {
        DEBUG && pipeline._trace("header requested: " + mediaRequest.toString());
    });

    return true;
};

/**
 * @param {Object=} types
 * @returns {Array}
 * @private
 */
Session.prototype._getConfigs = function _getConfigs(types)
{
    var configs = [];

    if (!types || (types.indexOf(manager.MEDIA_VIDEO) != -1))
    {
        configs.push({
            "type" : manager.MEDIA_VIDEO,
            "openRange": !config.pipelineEnabled,
            "pipeline": config.pipelineEnabled,
            "connections": config.pipelineEnabled ? config.maxParallelConnections : 1,
            "socketBufferSize": config.videoSocketReceiveBufferSize
        });
    }

    if (!types || (types.indexOf(manager.MEDIA_AUDIO) != -1))
    {
        configs.push({
            "type" : manager.MEDIA_AUDIO,
            "openRange": true,
            "pipeline": false,
            "connections": 1,
            "socketBufferSize": config.audioSocketReceiveBufferSize
        });
    }

    if (!types || (types.indexOf(manager.MEDIA_HEADERS) != -1))
    {
        configs.push({
            "type" : manager.MEDIA_HEADERS,
            "openRange": false,
            "pipeline": true,
            "connections": 1,
            "socketBufferSize": config.headersSocketReceiveBufferSize
        });
    }

    return configs;
};

Session.prototype._createDownloadTracks = function _createDownloadTracks(configs)
{
    if ( this._downloadTrackCreatesInProgress === 0 )
    {
        this._notifyStartEvent("createDlTracksStart");
    }

    this._downloadTrackCreatesInProgress += configs.length;

    var tracks = configs.map( function( config )
    {
        var track = new DownloadTrack( config );
        track.session = this;
        track.on( 'created', function()
        {
            // This is only for logging - the track can be used right away
            DEBUG && _trace("downloadTrack created:", track);
            --this._downloadTrackCreatesInProgress;
            if ( this._downloadTrackCreatesInProgress === 0 )
            {
                this._notifyStartEvent("createDlTracksEnd");
            }
        }.bind( this ) );
        track.on( 'networkfailing', _DownloadTrackOnNetworkFailing );
        track.on( 'error', function()
        {
            if (config.enableManagerDebugTraces)
            {
                this.session._reportDebugMessage("DownloadTrack fatal error: " +
                        JSON.stringify(config));
            }
            this.session._reportStreamingFailure(   "DownloadTrack fatal error",
                                                    "NFErr_MC_StreamingFailure",
                                                    this.failureCode,
                                                    0,
                                                    this.nativeCode );
        } );
        track.on( 'transportreport', function( evt )
            {
                DEBUG && this._trace("transportreport: " + JSON.stringify( evt ) );
                this.emit( 'transportreport', evt );
            }.bind( this ) );
        return track;
    }.bind( this ) );

    // Force the DownloadTracks to be created inline, instead of later
    DownloadTrack.execute();

    return tracks;
};

Session.prototype._destroyDownloadTrack = function _destroyDownloadTrack(pipeline)
{
    // reset the stream predictor so new streams can be chosen after new track
    if (pipeline.mediaType == manager.MEDIA_AUDIO)
    {
        pipeline.restart = true;
        this._predictor.setAudioRate(null);
    }

    // remove audio download track
    if (pipeline.track !== undefined)
    {
        if ( !pipeline.track.created )
        {
            --this._downloadTrackCreatesInProgress;
        }

        pipeline.track.destroy();
        pipeline.track = undefined;
    }
};

/**
 * @param {number} reason
 */
Session.prototype._startBuffering = function _startBuffering(reason)
{
    DEBUG && this._trace("startBuffering, reason: " + reason);

    this._playerState.set((reason === bufferingReason.underflow) ?
        Enums.PLAYER_STATE.REBUFFERING : Enums.PLAYER_STATE.BUFFERING);
    this._notifyBufferingStarted();

    // reset pipeline's buffering count
    this._pipelines.forEach(function(pipeline) {
        pipeline.bufferingRequests = 0;
        pipeline.seeking = (reason === bufferingReason.startup ||
                            reason === bufferingReason.seek);
    });

    this._bufferingStartTime = platform.time.mono();

    if (reason === bufferingReason.startup)
    {
        // if we have precached data, check for buffering complete now
        var ap = this._pipelines[manager.MEDIA_AUDIO];
        var vp = this._pipelines[manager.MEDIA_VIDEO];
        if ((vp.precached > 0) && (ap.precached > 0))
        {
            DEBUG && this._trace("header cache data used, checking buffering complete");
            if ( this._checkBufferingComplete() && config.deferAseScheduling )
            {
                // Defer scheduling the pipelines until _updatePts
                if ( this._pipelineTimeout )
                {
                    clearTimeout(this._pipelineTimeout);
                }

                this._pipelinesPaused = true;
                return;
            }
        }
    }

    // schedule a buffering complete check in the future
    if (this._isBufferingState(this._playerState.value))
    {
        DEBUG && this._trace(
            "scheduling a bufferingCompleteCheck in " + config.prebufferTimeLimit);
        this._bufferingCompleteTimeout = setTimeout(function () {
            DEBUG && this._trace("bufferingCompleteCheck timeout, checking now");
            this._checkBufferingComplete();
        }.bind(this), config.prebufferTimeLimit);
    }
    else
    {
        DEBUG && this._trace("already bufferingComplete, not scheduling check");
    }

    this._schedulePipelines();
};

/**
 * @param {Object=} state
 */
Session.prototype._isBufferingState = function _isBufferingState(state)
{
    return ((state === Enums.PLAYER_STATE.BUFFERING) ||
            (state === Enums.PLAYER_STATE.REBUFFERING));
};

Session.prototype._wipeHeaderCache = function _wipeHeaderCache()
{
    if (config.enableManagerDebugTraces)
    {
        this._reportDebugMessage("wipeHeaderCache");
    }

    // recreate header cache's download tracks to make sure we get everything
    manager._headerCache && manager._headerCache.recreateDownloadTracks();
    delete this._adoptedRequests;
};

Session.prototype._checkForHeaderCacheData = function _checkForHeaderCacheData()
{
    if (!this._useHeaderCacheData || !manager._headerCache)
    {
        // There shouldn't be any data in the header cache, but flush it just to be safe
        DEBUG && this._trace("wiping header cache, should be no data");
        this._wipeHeaderCache();
        return;
    }

    DEBUG && this._trace("checking for headerCacheData, movieId:", this._movieId);

    // check the header cache for data
    var result = manager._headerCache.lookupData(this._movieId);
    if (_.isUndefined(result))
    {
        DEBUG && this._trace("headerCacheData not found");

        if (config.headerCacheFlushForCircularBuffer)
        {
            // we're not adopting any data from the header cache
            // due to the PS3 buffer implementation, we have to flush any data held in
            // the header cache now or this playback will rebuffer
            this._wipeHeaderCache();
        }

        return;
    }

    DEBUG && this._trace("headerCacheData found:", result);

    function adoptPipeline( session, pipeline )
    {
        var adoptedStreamId, streamId;
        var mediaType = pipeline.mediaType;
        var needDrm = !session._fastplay && (mediaType === manager.MEDIA_VIDEO);
        var entry = result[mediaType];
        DEBUG && pipeline._trace("adoptPipeline, entry: " + JSON.stringify(entry));

        if (entry)
        {
            streamId = entry.streamId;

            // make sure that stream matches current track
            if (!pipeline.verifyStreamIdOnTrack(streamId))
            {
                DEBUG && pipeline._trace("ignoring cached streamId: " + streamId +
                                         " wrong track");
            }
            else
            {
                // append header from cache
                if (session._addHeaderFromCache(pipeline, streamId, entry.header,
                                                needDrm))
                {
                    // adopt the data
                    session._adoptHeaderCacheData( pipeline, entry.data );
                    adoptedStreamId = streamId;
                }
            }
        }

        return adoptedStreamId;
    }

    // adopt the headers and media
    this._notifyStartEvent("adoptHcdStart");
    if ( !config.headerCacheAdoptBothAV )
    {
        adoptPipeline( this, this._pipelines[manager.MEDIA_VIDEO] );
        adoptPipeline( this, this._pipelines[manager.MEDIA_AUDIO] );
    }
    else
    {
        var adoptedAudioStream = adoptPipeline(
            this, this._pipelines[manager.MEDIA_AUDIO] );
        if ( !_.isUndefined(adoptedAudioStream) )
        {
            var adoptedVideoStream = adoptPipeline(
                this, this._pipelines[manager.MEDIA_VIDEO] );
        }
    }
    this._notifyStartEvent("adoptHcdEnd");
};

Session.prototype._checkHeaderCache = function _checkHeaderCache(
    pipeline, movieId, streamId, needDrm)
{
    var header;

    // check if we have a header cache and are allowed to use it
    if (this._useHeaderCache && manager._headerCache)
    {
        // check headercache for this streamId
        header = manager._headerCache.lookupHeader(movieId, streamId);
        if (header)
        {
            // append header from cache
            if (this._addHeaderFromCache(pipeline, streamId, header, needDrm))
            {
                return true;
            }
        }
    }

    return false;
};

Session.prototype._addHeaderFromCache = function _addHeaderFromCache(
    pipeline, streamId, header, needDrm)
{
    if (needDrm && !header.drmHeader /*used by NRDJS*/ && !header.drmProtected /*used by Cadmium*/)
    {
        DEBUG && pipeline._trace("Not using headercache entry because need drm headers");
        return false;
    }

    DEBUG && pipeline._trace("adding headercache entry for streamId: " + streamId);

    // add fragments (will create header and streamMap entry)
    pipeline.addFragments(streamId, header.fragments, header.avgFragmentDurationMs);

    // add header data
    pipeline.headers[streamId].data = header.headerData;

    // handle drm header if there
    if (header.drmHeader)
    {
        DEBUG && pipeline._trace("found drm header in headercache");
        header.drmHeader.source = "headercache";
        this._handleDrmHeader(pipeline, header.drmHeader);
    }

    return true;
};

Session.prototype._adoptHeaderCacheData = function _adoptHeaderCacheData( pipeline, data )
{
    if ( data.length === 0 )
    {
        return;
    }

    DEBUG && pipeline._trace("adoptHeaderCacheData at pts:", this._startPts,
                             "count:", data.length);
    this._adoptingData = true;

    var lastCompleteRequest;

    while( data.length > 0 )
    {
        // this modifies the array, removing the data from the cache
        var mediaRequest = data.shift();
        var mediaType = mediaRequest.mediaType;

        DEBUG && pipeline._trace("adoptData, checking nextPts:", pipeline.streamingPts,
                                 "mediaRequest:", mediaRequest);

        // make sure mediaRequest wasn't already aborted
        if (mediaRequest.readyState === MediaRequest.READYSTATES.ABORTED)
        {
            pipeline._warn("adoptData, not adopting aborted mediaRequest:",
                           mediaRequest);
        }
        // if request failed, abort it
        else if (mediaRequest.readyState === MediaRequest.READYSTATES.FAILED)
        {
            pipeline._warn("adoptData, not adopting failed mediaRequest:",
                           mediaRequest);
            this._abortRequest(pipeline, mediaRequest, false);
        }
        else if ((pipeline.streamingPts >= mediaRequest.ptsStart) &&
                 (pipeline.streamingPts < mediaRequest.ptsEnd))
        {
            if ( !this._adoptedRequests )
            {
                this._adoptedRequests = [];
            }

            // determine correct mediaRequest state
            this._adoptMediaRequest(pipeline, mediaRequest);

            // move to next pts - set pts directly as it's sequential
            pipeline.streamingPts = mediaRequest.ptsEnd;

            // if the request is complete, count it towards precached
            if (mediaRequest.readyState >= MediaRequest.READYSTATES.DONE)
            {
                pipeline.precached += (mediaRequest.ptsEnd - mediaRequest.ptsStart);

                lastCompleteRequest = mediaRequest;
            }
            else
            {
                this._adoptedRequests.push( mediaRequest );
            }
        }
        else
        {
            DEBUG && pipeline._trace("adoptData, not adopting, nextPts: " +
                                     pipeline.streamingPts +
                                     " mediaRequest: " + mediaRequest);
            this._abortRequest(pipeline, mediaRequest, false);
        }
    }

    DEBUG && pipeline._trace("adoptData loop done, " +
                             this._adoptingData + ", " + lastCompleteRequest );

    if ( lastCompleteRequest )
    {
        this._requestDone( pipeline, lastCompleteRequest );
    }

    this._adoptingData = false;

    // done with data array
    DEBUG && pipeline._trace("adoptData done, precached:", pipeline.precached,
                             "streamingPts:", pipeline.streamingPts);

    // estimate the next fragment index based on what requests we adopted
    pipeline.nextFragmentIndex =
        pipeline._estimateFragmentIndex(pipeline.streamingPts);
};

Session.prototype._adoptMediaRequest = function _adoptMediaRequest(pipeline, mediaRequest)
{
    DEBUG && pipeline._trace("adopting mediaRequest: " + mediaRequest.toString());

    if (config.enableManagerDebugTraces)
    {
        this._reportDebugMessage("adoptMediaRequest: type: " + pipeline.mediaType +
                                 ", state: " + mediaRequest.readyState +
                                 ", pts: " + mediaRequest.ptsStart);
    }

    // set actualStartPts of pipeline
    pipeline.setActualStartPts(mediaRequest.ptsStart);

    // streamline the request complete case
    if ( mediaRequest.readyState === MediaRequest.READYSTATES.DONE )
    {
        // set mediaRequest flags
        mediaRequest.appended = false;
        mediaRequest.started = true;
        mediaRequest.active = false;
        mediaRequest.adopted = true;
        mediaRequest.session = this;

        // calculate duration
        mediaRequest.durationMs = mediaRequest.ptsEnd - mediaRequest.ptsStart;

        // add to pipeline
        var currentPts = platform.getCurrentPts(this._ctxt);
        var update = pipeline.requestManager.addCompleteRequest(mediaRequest, currentPts);
        if (update)
        {
            pipeline.bufferLevelMs += update.addedMs;
            pipeline.bufferLevelBytes += update.addedBytes;
            pipeline.totalBufferMs += update.addedMs;
            pipeline.totalBufferBytes += update.addedBytes;
            if (!_.isUndefined(update.lastPts))
                pipeline.completeStreamingPts = update.lastPts;
        }
        var stream = pipeline.streamMap[mediaRequest.streamId];
        if (  (_.isUndefined(pipeline.lastStreamNotified) ||
                        (pipeline.lastStreamNotified !== stream)))
        {
            DEBUG && pipeline._trace("adoptData loop notifying streamSelected, " );
            pipeline.streamSelector.streamSelected(
                mediaRequest.ptsStart, pipeline.lastStreamNotified, stream);

            pipeline.lastStreamNotified = stream;

            this._notifyStreamSelected(pipeline, stream);
        }
        pipeline.bufferManager.attachRequest( mediaRequest );
    }
    else
    {
        // setup listeners and other parameters
        this._initMediaRequest(pipeline, mediaRequest);

        // mark as adopted
        mediaRequest.adopted = true;

        // add to pipeline
        pipeline.requestManager.addRequest( mediaRequest );

        // migrate load start
        if (mediaRequest.readyState >= MediaRequest.READYSTATES.SENT)
        {
            // notify loadstart
            _MediaRequestOnLoadStart.call( mediaRequest );
        }

        // migrate first byte
        if (mediaRequest.readyState >= MediaRequest.READYSTATES.RECEIVING)
        {
            // notify first byte
            _MediaRequestOnFirstByte.call( mediaRequest );
        }

        // XXX For testing this path
        //if (mediaRequest.readyState === MediaRequest.READYSTATES.DONE)
        //{
            // notify complete
        //    _MediaRequestOnComplete.call( mediaRequest );
        //}
    }
};

/**
 * @param {Object} pipeline
 * @param {Object} params
 * @param {Function=} headercb
 * @private
 */
Session.prototype._requestHeader = function _requestHeader(pipeline, params, headercb)
{
    var isDrmHeaderRequest = !!params.drmHeaderRequest;

    // check to see if we have this stream in the header cache
    var streamId = params.streamId;
    if (this._checkHeaderCache(pipeline, this._movieId, streamId,
                               isDrmHeaderRequest))
    {
        DEBUG && pipeline._trace(
            "requestHeader ignored, found in header cache, streamId:", streamId);

        if (params.firstHeader)
        {
            // send notification
            this._notifyHeaderCacheHit(this._movieId, streamId);
        }

        // start driving pipelines
        this._schedulePipelines();

        return;
    }

    // first header will go off pipeline's track, then rest on headerTrack
    var track;
    if (params.firstHeader)
        track = pipeline.track;
    else
        track = this._headerTrack;

    var stream = pipeline.streamMap[streamId];
    var specstr = (params.speculative ? " speculative" : "");
    var drmstr = (isDrmHeaderRequest ? " drmHeader" : "");
    var descstr = " streamId: " + streamId + " byteStart: " + params.byteStart +
        " byteEnd: " + params.byteEnd + specstr + drmstr +
        (params.firstHeader ? " firstHeader" : "");

    if (!pipeline.headers[streamId])
        pipeline.headers[streamId] = {};

    DEBUG && pipeline._trace("requesting headers:", descstr);
    DEBUG && pipeline._trace("header url:", params.url);
    DEBUG && pipeline._trace("header track:", track);

    // log a server switch if necessary
    if (stream.server && !pipeline.server)
    {
        DEBUG && pipeline._trace(
            "requestHeader, selected new server:", stream.server);
        this._notifyServerSwitch(pipeline, stream.server, stream.selreason,
                                 stream.location, stream.bitrate);

        pipeline.server = stream.server;
    }

    // create the header request
    var mediaRequest = this._createRequest(pipeline, params, track, stream);
    DEBUG && pipeline._trace(
        "creating header MediaRequest: " + mediaRequest.toString() +
        ", manifestIndex: " + mediaRequest.manifestIndex + " " + descstr);

    pipeline.headers[streamId].request = mediaRequest;

    // open the media request
    if (!mediaRequest.open(params.url,
                           {"start": params.byteStart, "end": params.byteEnd},
                           MediaRequest.RESPONSETYPES.ARRAYBUFFER,
                           {}, // headers
                           undefined, // enclosing byte range
                           config.enableLookaheadHints ? params.lookahead : undefined))
    {
        this.session._reportStreamingFailure("MediaRequest open failed (2)",
                                             "NFErr_MC_StreamingFailure");
        return;
    }

    if (headercb)
    {
        headercb(mediaRequest);
    }

    // drive pipeline
    this._schedulePipelines();
};

//////////////////////////////////////
// Request / AV Pipelines
//////////////////////////////////////

/**
 * @param {Object} pipeline
 * @param {Object} params
 * @param {Object} downloadTrack
 * @param {Object=} stream
 * @private
 */
Session.prototype._createRequest = function _createRequest(
    pipeline, params, downloadTrack, stream)
{
    // get requestId and then generate a new one
    var requestId = manager.getRequestId();
    manager.genRequestId();


    DEBUG && pipeline._trace("creating MediaRequest object, ID: " + requestId +
                             ", downloadTrack: " + downloadTrack,
                             ", byteStart: " + params.byteStart,
                             ", byteEnd: " + params.byteEnd);

    var label = "unknown";
    if ( !_.isUndefined( params ) )
    {
        if ( !_.isUndefined( params.ptsStart ) )
        {
            label = "" + stream.id + " pts " + params.ptsStart + "-" + params.ptsEnd;
        }
        else
        {
            label = "" + stream.id + " header";
        }
    }

    var mediaRequest = new MediaRequest( downloadTrack, label );

    // copy some values in to the params
    params.mediaType = pipeline.mediaType;
    if (!_.isUndefined(stream))  // values should already be in params if stream undefined
    {
        params.streamId = stream.id;
        params.location = stream.location;
        params.serverId = stream.server;
        params.serverSelReason = stream.selreason;
        params.bitrate = stream.bitrate;
        params.streamTput = stream.throughput || 0;
        var statistics = manager._networkMonitor.get();
        if (statistics.confidence && statistics.throughput){
            params.networkMonitorTput = statistics.throughput.average;
        } else {
            params.networkMonitorTput = -1;
        }

    }

    // init the mediarequest
    this._initMediaRequest(pipeline, mediaRequest, params);

    // if manifestIndex from previous request use it, otherwise get from session
    if (!_.isUndefined(params.manifestIndex))
    {
        DEBUG && pipeline._trace(
            "createRequest using manifestIndex: " + params.manifestIndex +
            " from passed in param or previous request");
        mediaRequest.manifestIndex = params.manifestIndex;
    }
    else{
        mediaRequest.manifestIndex = this._manifestIndex;
    }

    // add to pipeline
    pipeline.requestManager.addRequest(mediaRequest);
    mediaRequest.timeCreated = platform.time.mono();

    return mediaRequest;
};

/**
 * @param {Object} pipeline
 * @param {Object} mediaRequest
 * @param {Object=} params
 * @private
 */
Session.prototype._initMediaRequest = function _initMediaRequest(
    pipeline, mediaRequest, params)
{
    // set event handlers
    mediaRequest._listenerGroup = new EventListenerGroup();
    mediaRequest._listenerGroup.on(
        mediaRequest, MediaRequest.EVENTS.ONLOADSTART,
        _MediaRequestOnLoadStart );
    mediaRequest._listenerGroup.on(
        mediaRequest, MediaRequest.EVENTS.ONFIRSTBYTE,
        _MediaRequestOnFirstByte );
    mediaRequest._listenerGroup.on(
        mediaRequest, MediaRequest.EVENTS.ONPROGRESS,
        _MediaRequestOnProgress );
    mediaRequest._listenerGroup.on(
        mediaRequest, MediaRequest.EVENTS.ONCOMPLETE,
        _MediaRequestOnComplete );
    mediaRequest._listenerGroup.on(
        mediaRequest, MediaRequest.EVENTS.ONERROR,
        _MediaRequestOnError );

    // Extra information needed by Manager (they are not defined in XHR)
    if (params)
    {
        mediaRequest.mediaType = params.mediaType;
        mediaRequest.streamId = params.streamId;
        mediaRequest.bitrate = params.bitrate;
        mediaRequest.location = params.location;
        mediaRequest.serverId = params.serverId;
        mediaRequest.serverSelReason = params.serverSelReason;
        mediaRequest.byteStart = params.byteStart;
        mediaRequest.byteEnd = params.byteEnd;
        mediaRequest.ptsStart = params.ptsStart;
        mediaRequest.ptsEnd = params.ptsEnd;
        mediaRequest.ptsOffset = params.ptsOffset;
        mediaRequest.lastRequestInSequence = params.lastRequestInSequence;

        // copy some values from original request
        mediaRequest.parser = params.parser;
        mediaRequest.drmHeaderRequest = !!params.drmHeaderRequest;
        mediaRequest.drmHeadersSeen = !!params.drmHeadersSeen;
        mediaRequest.speculative = !!params.speculative;
        mediaRequest.tencOffsets = params.tencOffsets;
        mediaRequest.streamTput = params.streamTput;
        mediaRequest.networkMonitorTput = params.networkMonitorTput;
    }

    mediaRequest.appended = false;
    mediaRequest.started = false;
    mediaRequest.adopted = false;
    mediaRequest.session = this;

    if (!_.isUndefined(mediaRequest.ptsStart))
    {
        // actual data (video or audio)
        mediaRequest.isHeader = false;

        // calculate duration
        mediaRequest.durationMs = mediaRequest.ptsEnd - mediaRequest.ptsStart;
    }
    else
    {
        // header
        mediaRequest.isHeader = true;
    }
};

Session.prototype._pipelineActive = function _pipelineActive( timestamp )
{
    DEBUG && this._trace("activePipelines++: now " + ( this._activePipelines + 1 ) +
                         " actually " +
                         this._pipelines.filter(function(p) {return p.active;}).length);
    if ( ++this._activePipelines === 1 )
    {
        manager._networkMonitor.start( timestamp );
    }
};

Session.prototype._pipelineInactive = function _pipelineInactive( timestamp )
{
    DEBUG && this._trace("activePipelines--: now " + ( this._activePipelines - 1 ) +
                         " actually " +
                         this._pipelines.filter(function(p) {return p.active;}).length);
    if ( --this._activePipelines === 0 )
    {
        manager._networkMonitor.stop( timestamp );
    }
};

/**
* @constructor
*/
function Pipeline(session, mediaType, pts, sessionEventEmitter, errorDirector)
{
    this.session = session;
    this.mediaType = mediaType;
    this.track = undefined;
    this.server = undefined;

    // create sub console for the pipeline
    var prefix = "[" + this.mediaType + "]";
    if (session._console.createSubConsole)
    {
        this._console = session._console.createSubConsole(prefix);
    }
    else
    {
        this._console = new platform.Console('ASEJS', 'media|asejs', prefix);
    }
    this._error = this._console.error.bind(this._console);
    this._warn = this._console.warn.bind(this._console);
    this._trace = this._console.trace.bind(this._console);
    this._log = this._console.log.bind(this._console);
    this._debug = this._console.debug.bind(this._console);

    this.actualStartPts = undefined;

    // pts of next MediaRequest, note this is only approximate until we read fragment data
    this.streamingPts = pts;
    this.nextFragmentIndex = undefined;
    this.completeStreamingPts = undefined;

    // map of streamId -> header data
    this.headers = {};
    this.lastStreamNotified = undefined;
    this.lastStreamPresented = undefined;
    this.lastHeaderSize = undefined;
    this.drmHeaderSent = false;

    // array of Stream's built from manifest for streamSelector
    this.streamList = [];

    // map of dlid -> stream
    this.streamMap = {};

    // request manager
    this.requestManager = new RequestManager(this._console, mediaType);
    this.requestManager.addEventListener(
        'streamingFailure', function(evt) {
            session._reportStreamingFailure(evt["msg"]);
        });
    this.requestManager.addEventListener(
        'active', session._pipelineActive.bind( session ) );
    this.requestManager.addEventListener(
        'inactive', session._pipelineInactive.bind( session ) );

    if (config.enableManagerDebugTraces)
    {
        this.requestManager.addEventListener(
            'managerdebugevent', function(evt) {
                _callEventListeners(session, evt['type'], evt);
            });
    }

    this.inProgress = false;
    this.bufferingComplete = false;
    this.bufferingRequests = 0;
    this.precached = 0;

    this.connected = false;

    this.bufferLevelMs = 0;
    this.bufferLevelBytes = 0;
    this.appendedBufferMs = 0;
    this.appendedBufferBytes = 0;
    this.totalBufferMs = 0;
    this.totalBufferBytes = 0;

    this.parallelDownloadMs = 0;
    this.parallelDownloadBytes = 0;
    this.switchFromParallelToSingle = 0;
    this.singleDownloadMs = 0;
    this.singleDownloadBytes = 0;
    this.switchFromSingleToParallel = 0;

    this.avgFragmentDurationMs = 0;

    this.lastSelectedStream = undefined;
    this.waitingForAudioTrackSwitchStart = false;

    this.lastStreamSelectionTime = platform.time.mono();
    var selectorName = ( mediaType === manager.MEDIA_AUDIO )
                            ? 'selectaudio'
                            : undefined;
    this.streamSelector =
        new StreamSelector(sessionEventEmitter, errorDirector, selectorName);

    // lowest buffer level calculated by the last round of the simulation; used in Cadmium
    this.lowestSimulatedBufferLevel = 0;

    this.drainingBytes = ( mediaType === manager.MEDIA_AUDIO )
                                ? config.audioBufferTargetAvailableSize
                                : config.videoBufferTargetAvailableSize;

    // reason for selecting initial bitrate
    this.initSelectionReason = undefined;
    this.historicalThroughputValue = -1;
    this.buffCompleteReason = undefined;
}

Object.defineProperties(Pipeline.prototype, {
    active: { get: function() { return this.requestManager.active; } }
});

Pipeline.prototype.recalculateCompleteBuffer = function recalculateCompleteBuffer(pts)
{
    // This function should only be called, when the played requests are not in the
    // pipeline. Otherwise, we will also add the requests that are already played
    var result = this.requestManager.calculateCompleteBuffer(pts);
    this.bufferLevelMs = result.bufferLevelMs;
    this.bufferLevelBytes = result.bufferLevelBytes;
    this.appendedBufferMs = result.appendedBufferMs;
    this.appendedBufferBytes = result.appendedBufferBytes;
    this.totalBufferMs = result.totalBufferMs;
    this.totalBufferBytes = result.totalBufferBytes;
};

Pipeline.prototype.setLastSelectedStream = function setLastSelectedStream(stream)
{
    var throughput = (stream.statistics &&
        stream.statistics.confidence &&
        stream.statistics.throughput) ?
            stream.statistics.throughput.average : 0;

    // preserve changedManifest flag
    var changedManifest = this.lastSelectedStream ?
        this.lastSelectedStream.changedManifest : false;

    this.lastSelectedStream = {
        index: stream.streamIndex,
        bitrate: stream.bitrate,
        throughput: throughput,
        location: stream.location,
        changedManifest: changedManifest
    };
    DEBUG && this._trace("setting lastSelectedStream:", this.lastSelectedStream);
};

Pipeline.prototype.setActualStartPts = function setActualStartPts(pts)
{
    var ap;

    // remember the actual start pts of pipeline
    if (_.isUndefined(this.actualStartPts))
    {
        DEBUG && this._trace("set actualStartPts:", pts);
        this.actualStartPts = pts;

        // adjust audio pipeline if needed
        if (this.mediaType === manager.MEDIA_VIDEO)
        {
            ap = this.session._pipelines[manager.MEDIA_AUDIO];
            if (!_.isUndefined(ap.actualStartPts))
            {
                DEBUG && ap._trace(
                    "not syncing audio streamingPts, actual pts already set:",
                    ap.actualStartPts);
            }
            else
            {
                DEBUG && ap._trace("syncing audio streamingPts to video:", pts);
                ap.setStreamingPts(pts);
            }

            this.session.emit( 'ptschanged', pts );
        }
    }
};

Pipeline.prototype.setStreamingPts = function setStreamingPts(pts)
{
    if (config.enableManagerDebugTraces)
    {
        this.session._reportDebugMessage("setStreamingPts, " + this.mediaType +
                                         " pts: " + this.streamingPts +
                                         " -> " + pts);
    }

    this.streamingPts = pts;
    this.nextFragmentIndex = this._estimateFragmentIndex(pts);
};

Pipeline.prototype._estimateFragmentIndex = function _estimateFragmentIndex(pts)
{
    // if we don't know avgFragmentDuration yet, return undefined
    if (!this.avgFragmentDurationMs)
        return;

    // guess at the index based on average fragment duration
    var index = Math.round(pts / this.avgFragmentDurationMs);
    DEBUG && this._trace("estimated index ~ " + index);
    return index;
};

Pipeline.prototype.verifyStreamIdOnTrack = function verifyStreamIdOnTrack(streamId)
{
    var stream = this.streamMap[streamId];

    var debugMessage = "verifying streamId: " + streamId +
                         " stream's track: " + (stream ? stream.trackIndex : "unknown") +
                         " currentTrack: " + this.trackIndex;
    DEBUG && this._trace(debugMessage);
    if (!stream)
    {
        DEBUG && this._trace("unknown streamId: " + streamId);
        this.session._reportDebugMessage("unknown streamId: " + streamId);
        return false;
    }

    if (stream.trackIndex !== this.trackIndex)
    {
        this.session._reportDebugMessage(debugMessage);
    }

    return (stream.trackIndex == this.trackIndex);
};

/**
 * @param {number} streamId
 * @param {Object} fragments
 * @param {number} avgFragmentDurationMs
 * @param {boolean=} truncated
 */
Pipeline.prototype.addFragments = function addFragments(
    streamId, fragments, avgFragmentDurationMs, truncated)
{
    DEBUG && this._trace("addFragments: " + fragments.length);
    this.avgFragmentDurationMs = avgFragmentDurationMs;
    if (!this.headers[streamId])
        this.headers[streamId] = {};
    this.headers[streamId].fragments = fragments;
    this.headers[streamId].truncated = truncated;

    // add fragments to streamMap's info (needed for streamSelector)
    if (!this.streamMap[streamId])
        this.streamMap[streamId] = {};
    var stream = this.streamMap[streamId];
    stream.fragments = fragments;
    stream.truncated = truncated;

    // set max pts from fragments if video pipeline
    var count = truncated ? 60 : fragments.length;
    var frag = fragments.getFragment(count-1);
    var maxPts = frag.startPts + frag.duration;

    // NRDJS needs to use the video stream as the maxPts to allow for playlist stitching
    // Cadmium has issues if the audio stream is shorter than video
    if ((this.mediaType === manager.MEDIA_VIDEO && stream.isDrm) ||
        config.allowAudioToStreamPastVideo && (this.mediaType === manager.MEDIA_AUDIO))
    {
        var newMaxPts;
        // Expected behavior:
        // (1) The difference between Audio and Video is within the limit,
        //     session._maxPts = max(video.maxPts, audio.maxPts)
        // (2) The difference between Audio and Video is beyond the limit,
        //     session._maxPts = min(video.maxPts, audio.maxPts)
        if (_.isUndefined(this.session._maxPts))
        {
            newMaxPts = maxPts;
        }
        else if (Math.abs(this.session._maxPts - maxPts) <=
                 config.maxDiffAudioVideoEndPtsMs)
        {
            newMaxPts = Math.max(maxPts, this.session._maxPts);
        }
        else if (Math.abs(this.session._maxPts - maxPts) >
                 config.maxDiffAudioVideoEndPtsMs)
        {
            newMaxPts = Math.min(maxPts, this.session._maxPts);
            this._warn("the endPts between streams is largely different." +
                       " New Stream endPts: " + maxPts +
                       ", previous maxPts:" + this.session._maxPts);
        }
        if ( !_.isUndefined(newMaxPts) && this.session._maxPts !== newMaxPts)
        {
            DEBUG && this._trace("setting maxPts: " + maxPts);
            this.session._maxPts = newMaxPts;
        }
    }

    // clamp streamingPts to the last video chunk
    if (this.mediaType === manager.MEDIA_VIDEO &&
        this.streamingPts >= this.session._maxPts)
    {
        DEBUG && this._trace("clamping streamingPts to maxPts: " +
                             this.streamingPts + "->" + frag.startPts);
        this.streamingPts = frag.startPts;
        var ap = this.session._pipelines[manager.MEDIA_AUDIO];
        ap.streamingPts = frag.startPts;
    }

    // see if these were drm fragments
    if (stream.isDrm)
    {
        DEBUG && this._trace("marking drmFragments available");
        this.session._drmFragmentsAvailable = true;

        // try switching to the drm manifest
        this.session._trySwitchToDrmManifest();
    }
};

Session.prototype._resetPipeline = function _resetPipeline(pipeline)
{
    var streamId;
    var header;

    DEBUG && pipeline._trace("_resetPipeline");

    // reset values on a stop(), clearing our request pipeline
    pipeline.lastStreamNotified = undefined;
    pipeline.lastStreamPresented = undefined;
    pipeline.actualStartPts = undefined;
    pipeline.bufferingComplete = false;
    pipeline.seeking = undefined;
    pipeline.bufferingRequest = 0;
    pipeline.precached = 0;
    pipeline.connected = false;
    pipeline.bufferLevelMs = 0;
    pipeline.bufferLevelBytes = 0;
    pipeline.appendedBufferMs = 0;
    pipeline.appendedBufferBytes = 0;
    pipeline.totalBufferMs = 0;
    pipeline.totalBufferBytes = 0;
    if (config.enableAdaptiveParallelStreaming)
    {
        pipeline.parallelDownloadMs = 0;
        pipeline.parallelDownloadBytes = 0;
        pipeline.singleDownloadMs = 0;
        pipeline.singleDownloadBytes = 0;
        pipeline.switchFromParallelToSingle = 0;
        pipeline.switchFromSingleToParallel = 0;
    }
    pipeline.completeStreamingPts = undefined;
    pipeline.EOS = false;

    // reset sub manager
    pipeline.bufferManager.reset();
    pipeline.requestManager.reset();

    // remove any headers whose fragments haven't arrived
    for (streamId in pipeline.headers)
    {
        header = pipeline.headers[streamId];
        if (!header.fragments)
        {
            DEBUG && pipeline._trace("removing header for streamId:", streamId,
                                     "no fragments");
            delete pipeline.headers[streamId];
        }
    }
};

//////////////////////////////////////
// Event handlers
//////////////////////////////////////

function _MediaRequestOnError()
{
    this.session._warn("_MediaRequestOnError:", this.toString());

    // ignore if we're shutting down
    if (this.session._isClosed())
    {
        this.session._warn("requestError ignored, pipelines shutdown, mediaRequest: " +
                   this.toString());
        return;
    }

    var timestamp = this.lastEventTime;
    var httpcode = this.status;
    var failureCode = this.failureCode;
    var failureCodeString = this.failureString;
    var nativeCode = this.nativeCode;

    var pipeline = this.session._pipelines[this.mediaType];
    DEBUG && pipeline._trace("request error, mediaRequest: " + this.toString() +
                             ", httpcode: " + httpcode + ", failurecode: " + failureCode
                             + " nativecode: " + nativeCode );

    // Don't delete the header object as we need it here to mark that a request is
    // outstanding for that streamID
    if (!_.isNumber(failureCode))
    {
        // ignore this error
        pipeline._warn(
            "ignoring undefined request error (nativecode: " + nativeCode + ")");
    }
    else if (this.readyState === MediaRequest.READYSTATES.DONE)
    {
        pipeline._warn("Error on a done request " + this.toString() +
                       ", failurecode: " + failureCode );
    }
    else
    {
        if ( config.hackForHttpsErrorCodes &&
                (failureCode === MediaRequest.ERRORCODES.HTTPS_CONNECTION_ERROR) &&
                (this.bytesReceived > 0) )
        {
            // We receive this error in the middle of the transcation,
            // which is not a fatal one
            failureCode = MediaRequest.ERRORCODES.CONNECTION_CLOSED;
        }
        // Send error to error director
        this.session._errorDirector.reportFailure(
            httpcode,  failureCode, nativeCode, {url: this.url} );
    }

    // check url for all outstanding requests
    // TODO: as a result of the call above, we may get a call into
    // _handleStreamingFailure.
    //
    // Either way, we need to do location selection again
    var updated = this.session._updateRequestUrls();
    if (!updated)
    {
        this.session._reportStreamingFailure(failureCodeString,
                                             "NFErr_MC_StreamingFailure",
                                             failureCode,
                                             httpcode,
                                             nativeCode);
        return;
    }

    // drmHeader requests no longer need to be special cased as they should only be needed
    // when not doing mcqueen.
    // In that case, there is no separate drm manifest and all drm streams are available
    // in the original manifest
}

function _MediaRequestOnLoadStart()
{
    // 'this' is the MediaRequest
    var session = this.session,
        streamId = this.streamId;

    // logging whether this mediaRequest is downloaded over parallel connections
    this.isParallel = this.track.isParallel();

    // ignore if we're shutting down
    if (session._isClosed())
    {
        session._warn(
            "onloadstart ignored, pipelines shutdown, mediaRequest: " + this.toString());
        return;
    }

    var pipeline = session._pipelines[this.mediaType];
    DEBUG && pipeline._trace("onloadstart:" + this.toString());

    pipeline.requestManager.onloadstart(this);

    if (!session._continuePipeline(pipeline))
    {
        DEBUG && pipeline._trace("!continuePipeline in onloadstart:", this);
    }

    DEBUG && pipeline._trace("request starting, mediaRequest: " + this.toString() +
                             ", type: " + this.mediaType +
                             ", location: " + this.location +
                             ", serverId: " + this.serverId);

    // send notification of stream selection if we haven't already
    var stream = pipeline.streamMap[streamId];

    if (!this.isHeader &&
        (_.isUndefined(pipeline.lastStreamNotified) ||
         (pipeline.lastStreamNotified !== stream)))
    {
        pipeline.streamSelector.streamSelected(
            this.ptsStart, pipeline.lastStreamNotified, stream);

        pipeline.lastStreamNotified = stream;

        session._notifyStreamSelected(pipeline, stream);
    }

    // XXX - should this happen for speculative requests?
    session._setRequestLocation(this, this.location, this.serverId);
}

function _MediaRequestOnFirstByte()
{
    // 'this' is the MediaRequest
    var timestamp, connect, responseTimes;

    // ignore if we're shutting down
    if (this.session._isClosed())
    {
        this.session._warn(
            "onfirstbyte ignored, pipelines shutdown, mediaRequest: " + this.toString());
        return;
    }

    // notify request manager
    var pipeline = this.session._pipelines[this.mediaType];
    pipeline.requestManager.onfirstbyte(this);

    if (!this.session._continuePipeline(pipeline))
    {
        DEBUG && this.session._trace("!continuePipeline in onfirstbyte:", this);
    }

    if (!this.adopted)
    {
        // XXX - do we care about time from requestStart til firstByte?
        timestamp = this.lastEventTime;
        connect = this.connect;
        responseTimes = this.responseTimes;

        DEBUG && pipeline._trace("onfirstbyte, mediaRequest: " + this.toString() +
                                 ", timestamp: " + timestamp + ", connect:" + connect +
                                 ", response times: " + responseTimes +
                                 ", activeRequests: " +
                                 pipeline.requestManager.activeRequests);

        pipeline.connected = true;

        if (connect && responseTimes.length > 0 )
        {
            manager._networkMonitor.addResponseTime( responseTimes[ 0 ] );
        }

        this.previousBytesReceived = 0;
        this.previousTimestamp = timestamp;
    }

    if (!this.isHeader)
    {
        // give this request to buffer manger
        pipeline.bufferManager.attachRequest(this);
    }
}

function _MediaRequestOnProgress()
{
    // 'this' is the MediaRequest
    var timestamp, newBytes;

    // ignore if we're shutting down
    if (this.session._isClosed())
    {
        this.session._warn(
            "onprogress ignored, pipelines shutdown, mediaRequest: " + this.toString());
        return;
    }

    if (!this.adopted && !_.isUndefined( this.previousTimestamp ) )
    {
        timestamp = this.lastEventTime;
        newBytes = this.bytesReceived - this.previousBytesReceived;

        DEBUG && this.session._trace("onprogress, mediaRequest: " + this.toString() +
                                     ", rt: " + this.responseTimes);

        if( newBytes > 0)
        {
            manager._networkMonitor.addDataReceived(
                newBytes, this.previousTimestamp, timestamp);
        }

        // progress gives total info
        this.previousTimestamp = timestamp;
        this.previousBytesReceived = this.bytesReceived;
        if (timestamp > 0)
        {
            this.session.emit('requestProgress', timestamp);
        }

        if (this.responseTimes && this.responseTimes.length)
        {
            this.responseTimes.forEach(function(r) {
                manager._networkMonitor.addHttpResponseTime(r);
            });
        }
    }
}

function _MediaRequestOnComplete()
{
    // 'this' is the MediaRequest
    var newBytes;
    var timestamp = this.lastEventTime,
        session = this.session;

    // ignore if we're shutting down
    if (session._isClosed())
    {
        session._warn("oncomplete ignored, pipelines shutdown, mediaRequest: " +
                      this.toString());
        return;
    }

    if (session._streamingFailureReported)
    {
        // the network magically comes back;
        DEBUG && session._trace("Network comes back, reset streaming failure");
        session._streamingFailureReported = false;
        session._errorDirector.resetFailures(true);
    }

    var pipeline = session._pipelines[this.mediaType];

    if (!this.adopted)
    {

        if (config.enableAdaptiveParallelStreaming &&
            this.mediaType === manager.MEDIA_VIDEO &&
            !this.isHeader)
        {
            // Since the oncomplete() from requestManager only return latest in-order &
            // continuous completed request, which is independent from the logging
            // purposes here, so I decided to decouple the following logging from
            // requestManager's calculation
            if (this.isParallel)
            {
                pipeline.parallelDownloadMs += this.durationMs;
                pipeline.parallelDownloadBytes += this.bytesReceived;
            }
            else
            {
                pipeline.singleDownloadMs += this.durationMs;
                pipeline.singleDownloadBytes += this.bytesReceived;
            }
        }

        newBytes = this.bytesReceived - this.previousBytesReceived;

        DEBUG && pipeline._trace(
            "request complete, mediaRequest: " + this.toString() +
            ", activeRequests: " + pipeline.requestManager.activeRequests +
            ", newBytes: " + newBytes +
            ", lastTime: " + this.previousTimestamp +
            ", now: " + timestamp);

        // notify network monitor
        if (newBytes > 0)
        {
            manager._networkMonitor.addDataReceived(
                newBytes, this.previousTimestamp, timestamp);
        }

        if (config.logChunkLevelTput && this.bytesReceived > 0) {
            manager._networkMonitor.addChunkReceived(
                pipeline, this.url, this.bytesReceived, this.byteRange, this.readyState, this._loadTime, timestamp);
        }

        if (this.responseTimes && this.responseTimes.length)
        {
            this.responseTimes.forEach(function(r) {
                manager._networkMonitor.addHttpResponseTime(r);
            });
        }
    }

    // update request manager
    // request manager will emit an inactve event if this was the last open request
    // so this must be done after we have reported the data received
    var update = pipeline.requestManager.oncomplete( this, platform.getCurrentPts(session._ctxt) );

    if (update)
    {
        pipeline.bufferLevelMs += update.addedMs;
        pipeline.bufferLevelBytes += update.addedBytes;
        pipeline.totalBufferMs += update.addedMs;
        pipeline.totalBufferBytes += update.addedBytes;
        if (!_.isUndefined(update.lastPts))
            pipeline.completeStreamingPts = update.lastPts;
    }

    // update tracking vars (also after addDataReceived)
    this.previousTimestamp = timestamp;
    this.previousBytesReceived = this.bytesReceived;

    // once request is complete, we don't need it in the global map anymore
    if (this._listenerGroup)
    {
        this._listenerGroup.clear();
    }

    this.cleanup();

    if (this.isHeader)
        session._headerDone(pipeline, this);
    else
        session._requestDone(pipeline, this);

    session.emit('requestComplete', timestamp);
}

Session.prototype._headerDone = function _headerDone(pipeline, mediaRequest)
{
    var streamId = mediaRequest.streamId;

    DEBUG && pipeline._trace(
        "header done, mediaRequest: " + mediaRequest.toString() +
        " streamId: " + streamId);

    var data = mediaRequest.response;
    if (data)
    {
        // do we already have data for this stream?
        var cache = pipeline.headers[streamId];
        if (!cache || !cache.data)
        {
            cache = { data: data };
            pipeline.headers[streamId] = cache;
        }
        else
        {
            // append data
            DEBUG && pipeline._trace("concatenate data: " + data.byteLength +
                                     " to existing: " + cache.data.byteLength);
            var newBuf = concatBuffers(cache.data, data);
            cache.data = newBuf;
        }

        // parse the data
        DEBUG && pipeline._trace("parsing mp4 header for mediaRequest: " +
                                 mediaRequest.toString() +
                                 " dataLength: " + cache.data.byteLength);
        this._parseMp4Header(pipeline, mediaRequest, cache.data);
    }
};

Session.prototype._requestDone = function _requestDone(pipeline, mediaRequest)
{
    var idx;
    var vp;

    // if pipeline is EOS, notify listeners if all requests done
    if (pipeline.EOS && !pipeline.EOSnotified &&
        (pipeline.requestManager.partialBuffers === 0) &&
        (pipeline.requestManager.unsentRequests === 0))
    {
        DEBUG && pipeline._trace("pipeline EOS with no more work: notifyEndOfStream");
        this._notifyEndOfStream(pipeline);
    }

    // if we're stopping, nothing else to do
    if ((this._playerState.value == Enums.PLAYER_STATE.STOPPING) ||
        (this._playerState.value == Enums.PLAYER_STATE.STOPPED))
    {
        DEBUG && pipeline._trace("requestDone but player stopping/stopped: " +
                                 this._playerState.value);
        return;
    }

    this._notifyStreamingPts(pipeline, this._manifestIndex, pipeline.absoluteTrackIndex,
                             pipeline.completeStreamingPts);

    // check if buffering complete (for audio switches)
    if (!this._checkBufferingComplete())
    {
        // If video pipeline isn't already marked buffering complete, check if it should
        // be
        vp = this._pipelines[manager.MEDIA_VIDEO];
        if (!vp.bufferingComplete)
        {
            DEBUG && this._trace(
                "calling getStreamInfo to check on video buffering complete");
            this._getStreamInfo(vp);
        }
    }

    if (this._adoptedRequests)
    {
        // check to see if this request originated from header cache
        idx = this._adoptedRequests.indexOf(mediaRequest);
        if (idx != -1)
        {
            DEBUG && _trace("completed previously adopted request: " +
                            mediaRequest.toString() +
                            ", remaining: " + (this._adoptedRequests.length-1));

            // remove it from list
            this._adoptedRequests.splice(idx, 1);
        }

        // don't recreate download track while in the middle of adopting data
        if (config.headerCacheFlushForCircularBuffer &&
            !this._adoptingData && (this._adoptedRequests.length === 0))
        {
            // notify header cache
            DEBUG && this._trace("wiping header cache tracks, all completed" +
                                 this._adoptingData );
            this._wipeHeaderCache();
        }
    }

    // if pipeline is EOS, notify listeners if all requests done
    if (pipeline.EOS && (pipeline.requestManager.partialBuffers === 0) &&
        (pipeline.requestManager.unsentRequests === 0))
    {
        DEBUG && pipeline._trace("pipeline EOS with no more work: notifyEndOfStream");
        this._notifyEndOfStream(pipeline);
    }

    // make sure pipeline should continue
    if (!this._continuePipeline(pipeline))
    {
        return;
    }

    // see if the pipelines can continue
    this._schedulePipelines();
};

Session.prototype._updatePts = function _updatePts()
{
    // get latest pts from media
    var pts = platform.getCurrentPts(this._ctxt) || 0;
    DEBUG && this._trace("updatePts: " + pts);

    this._pipelines.forEach(function(pipeline) {
        var streamId, stream;

        // if we are close to end of playback do any end of stream notification
        var streamingPts = pts - this._streamingOffset;
        if (pipeline.EOS && !pipeline.EOSnotified &&
            (streamingPts + config.timeBeforeEndOfStreamBufferMark >= pipeline.endPts))
        {
            DEBUG && pipeline._trace("relative streamingPts:", streamingPts,
                                     "close to endPts:", pipeline.endPts,
                                     ", calling notifyEndOfStream");
            this._notifyEndOfStream(pipeline);
        }

        // remove requests older than skipback buffer
        this._pruneRequests(pipeline, pts);

        if (config.pruneRequestsFromNative)
        {
            // this is needed for cadmium, since recalculateCompleteBuffer() is part of
            // _pruneRequests() and Cadmium is not calling _pruneRequests();
            pipeline.recalculateCompleteBuffer(pts);
        }

        // find request that is playing
        var bitrate;
        var mediaRequest = pipeline.requestManager.findRequestByPts(pts);
        if (mediaRequest)
        {
            // update playback bitrate
            bitrate = mediaRequest.bitrate;

            streamId = mediaRequest.streamId;
            if (streamId != pipeline.lastStreamPresented)
            {
                pipeline.lastStreamPresented = streamId;

                // announce new stream
                stream = pipeline.streamMap[streamId];
                this._notifyStreamPresenting(
                    pipeline, mediaRequest.ptsStart, stream.manifestIndex,
                    stream.absoluteTrackIndex, stream.streamIndex);
            }
        }

        if (!_.isUndefined(bitrate) && (bitrate != pipeline.playbackBitrate))
        {
            pipeline.playbackBitrate = bitrate;
            DEBUG && pipeline._trace("updated playback bitrate:" + bitrate);
        }
    }.bind(this));

    this._pipelinesPaused = false;

    // check for more work to do
    this._schedulePipelines();
};

//////////////////////////////////////
// Data pumping
//////////////////////////////////////

Session.prototype._schedulePipelines = function _schedulePipelines()
{
    // ignore if pipeline hasn't finished starting yet
    if (!this._pipelinesStarted || this._pipelinesPaused)
    {
        DEBUG && this._trace("pipeline's not fully started or paused, ignoring schedule");
        return;
    }

    if (this._pipelineTimeout)
    {
        DEBUG && this._trace("pipeline already scheduled");
        return;
    }

    if (this._streamingFailureReported)
    {
        DEBUG && this._trace("streaming failure reported");
        return;
    }

    this._pipelineTimeout = setTimeout(
        function()
        {
            DEBUG && this._trace("pipeline schedule timeout");

            clearTimeout(this._pipelineTimeout);
            delete this._pipelineTimeout;

            this._drivePipelines();

        }.bind(this), config.pipelineScheduleTimeoutMs);

    if ( config.enableAdaptiveParallelStreaming )
    {
        // Adapt the number of parallel connections the pipeline uses
        if (this._adaptiveParallelTimeout)
        {
            DEBUG && this._trace("parallel adapting logic is already scheduled");
            return;
        }

        this._adaptiveParallelTimeout = setTimeout(
        function(){
            DEBUG && this._trace("running parallel adapting logic");
            clearTimeout(this._adaptiveParallelTimeout);
            delete this._adaptiveParallelTimeout;

            this._adaptPipelineConnectionNumbers(this._pipelines[manager.MEDIA_VIDEO]);

        }.bind(this), config.adaptiveParallelTimeoutMs);
    }
};

Session.prototype._drivePipelines = function _drivePipelines()
{
    // ignore if we are suspended
    if (this._suspended)
    {
        DEBUG && this._trace("drivePipelines ignored, suspended");
        return;
    }

    // ignore if pipelines have been shutdown
    if (this._isClosed())
    {
        DEBUG && this._trace("pipelines already shutdown");
        return;
    }

    if (this._didDrivePipelines === undefined )
    {
        this._didDrivePipelines = true;
        this._notifyStartEvent("firstDrivePipelines");
    }

    // check for looped video
    var ap = this._pipelines[manager.MEDIA_AUDIO];
    var vp = this._pipelines[manager.MEDIA_VIDEO];
    if (ap.EOS && vp.EOS)
    {
        if (this._loopVideo)
        {
            // calculate new streamingOffset from video endPts
            this._streamingOffset += vp.endPts;

            this._pipelines.forEach(function(pipeline) {
                pipeline.setStreamingPts(0);
                pipeline.EOS = false;

                // reset this as it's now looped
                delete pipeline.endPts;

                // reset the sequence in request manager
                pipeline.requestManager.resetSequence();
            }.bind(this));

            DEBUG && _trace("loopVideo: both pipelines EOS, setting streamingOffsets:",
                            this._streamingOffset);
        }
        else if (!this._headerCacheNotifiedEnd && manager._headerCache)
        {
            DEBUG && this._trace("notifying header cache of streamer end");

            // both pipelines are EOS, notify header cache
            manager._headerCache.notifyStreamerEnd();
            this._headerCacheNotifiedEnd = true;
            if (config.notifyManifestCacheEom)
            {
                var evt = {
                    'type': 'streamerend',
                    'time': platform.time.mono()
                };
                _callEventListeners(this, evt['type'], evt);
            }
        }
    }

    // drive each pipeline
    this._drivePipeline(vp, ap);
    this._drivePipeline(ap, vp);

    // get any speculative headers
    this._pipelines.forEach(function(pipeline) {
        this._speculativeHeaders(pipeline);
    }.bind(this));
};

Session.prototype._continuePipeline = function _continuePipeline(pipeline)
{
    // check shutdown
    if (this._isClosed())
    {
        DEBUG && pipeline._trace("continuePipeline (!inProgress), shutdown");
        return false;
    }

    // check playerstate
    if ((this._playerState.value == Enums.PLAYER_STATE.STOPPING) ||
        (this._playerState.value == Enums.PLAYER_STATE.STOPPED))
    {
        DEBUG && pipeline._trace("continuePipeline (!inProgress), playerState:",
                                 Enums.PLAYER_STATE.name[this._playerState.value]);
        return false;
    }

    // check if waiting for an audio track switch
    if (pipeline.waitingForAudioTrackSwitchStart)
    {
        DEBUG && pipeline._trace(
            "waiting for audioTrackSwitchStarted event (!inProgress)");
        return false;
    }

    if ( this._adoptingData )
    {
        DEBUG && pipeline._trace( "waiting for adoption to complete" );
        return false;
    }

    return true;
};

Session.prototype._drivePipeline = function _drivePipeline(pipeline, other)
{
    var nextRequest;

    // if pipeline done, noop
    if (pipeline.EOS)
    {
        DEBUG && pipeline._trace("noop, already EOS");
        return;
    }

    DEBUG && pipeline._trace("drivePipeline: " + pipeline.streamingPts +
                             " maxPts: " + this._maxPts);
    if (pipeline.streamingPts >= this._maxPts)
    {
        if (this._fastplay)
        {
            DEBUG && pipeline._trace("noop, end of fastplay stream");
        }
        else if (!pipeline.EOS)
        {
            DEBUG && pipeline._trace("noop, marking EOS at " + pipeline.streamingPts +
                                     " maxPts: " + this._maxPts);
            this._setEndOfStream(pipeline);
        }
        return;
    }

    // if pipeline is already driving, ignore
    if (pipeline.inProgress)
    {
        DEBUG && pipeline._trace("pipeline already inProgress");
        return;
    }

    if (!this._continuePipeline(pipeline))
    {
        return;
    }

    // make sure there is room in pipeline
    var pipelineVacancy = this._checkPipelineVacancy(pipeline, other);

    var streamInfo;
    var streamIndex;
    var pending;
    if (!pipelineVacancy)
    {
        // if we're not allowed to abort unsent requests, nothing to do
        if ((!config.allowCallToStreamSelector && !config.abortUnsentBlocks) ||
            (pipeline.lastStreamSelectionTime + 2000 > platform.time.mono()))

        {
            // no vacancy and we can't abort anything
            return;
        }

        DEBUG && pipeline._trace(
            "running stream selection anyway, last time was " +
            (platform.time.mono() - pipeline.lastStreamSelectionTime) + " ms ago");

        // see if we can make room by aborting some unsent requests
        // avoid doing this too often as the stream selection could cause a cpu
        // performance penalty

        // do stream selection
        pipeline.lastStreamSelectionTime = platform.time.mono();
        streamInfo = this._getStreamInfo(pipeline);
        streamIndex = streamInfo.streamIndex;
        if (_.isUndefined(streamIndex))
        {
            DEBUG && pipeline._trace("pipeline noop, streamIndex undefined");
            return;
        }

        // check whether we can abort any requests
        pending = this._checkPendingRequests(pipeline, streamIndex);
        if (pending.wait)
        {
            // there are pending requests that disallow pipeline to continue
            return;
        }

        if (!pending.aborted)
        {
            // No requests aborted, still no vacancy
            return;
        }

        // after aborting, check for vacancy again
        pipelineVacancy = this._checkPipelineVacancy(pipeline, other);
        if (!pipelineVacancy)
        {
            // still no vacancy, try again later
            return;
        }
    }

    // do stream selection if we haven't already
    if (_.isUndefined(streamInfo))
    {
        streamInfo = this._getStreamInfo(pipeline);
        streamIndex = streamInfo.streamIndex;
        if (_.isUndefined(streamIndex))
        {
            DEBUG && pipeline._trace("pipeline noop, streamIndex undefined");
            return;
        }
    }

    // update last stream selection time
    pipeline.lastStreamSelectionTime = platform.time.mono();

    // mark the pipeline as in progress
    DEBUG && pipeline._trace("marking pipeline inProgress");
    pipeline.inProgress = true;
    pipeline.seekPts = undefined;

    // process the stream-selector's choice
    var stream = pipeline.streamList[streamIndex];
    var streamId = stream.id;
    var url = stream.url;
    var location = stream.location;
    DEBUG && pipeline._trace("stream-selector requesting streamId:", streamId,
                             "bitrate:", stream.bitrate,
                             "at pts:", pipeline.streamingPts);

    // do we have this header?
    var header = pipeline.headers[streamId];
    if (header && header.fragments)
    {
        DEBUG && pipeline._trace("header available, calling makeRequest");
        this._makeRequest(pipeline, stream, header, streamInfo.continueStream );
    }
    else if (header && !header.fragments)
    {
        DEBUG && pipeline._trace(
            "headers not available yet (!inProgress), waiting streamId:", streamId);
        pipeline.inProgress = false;

        // since we're waiting for it, this request can no longer be speculative
        var headerRequest = header.request;
        if (!headerRequest)
        {
            pipeline._warn("unable to find header requestId:", header.request);

            // delete this header since the request is missing
            delete pipeline.headers[streamId];

            // fallthrough and rerequest headers
            header = null;
        }
        else if (headerRequest.speculative)
        {
            if (pipeline.speculativeHeader === streamId)
            {
                delete pipeline.speculativeHeader;
            }
            headerRequest.speculative = false;
            DEBUG && pipeline._trace(
                "clearing speculative on required requestId:", header.request);
        }
    }

    if (!header)
    {
        // request header for new stream, when header is done, it will drive the
        // pipeline again
        DEBUG && pipeline._trace(
            "need headers, (!inProgress) streamId:", streamId);
        var headerSize = pipeline.lastHeaderSize ? pipeline.lastHeaderSize :
            this._estimateHeaderSize();
        pipeline.inProgress = false;
        this._requestHeader(pipeline, {
            location: location,
            url: url,
            streamId: streamId,
            byteStart: 0,
            byteEnd: headerSize,
            lookahead: _.isUndefined( pipeline.lastHeaderSize )
        });
    }
};

Session.prototype._makeRequest = function _makeRequest(pipeline, stream, header,
                                                       lookahead)
{
    var frag;
    var p;
    var streamId = stream.id;
    var location = stream.location;
    var url = stream.url;

    // make sure the manifest hasn't changed underneath us
    if (pipeline.changedManifest)
    {
        DEBUG && pipeline._trace(
            "makeRequest detected changedManifest, can't makeRequest (!inProgress)");
        pipeline.inProgress = false;
        return;
    }

    DEBUG && pipeline._trace("making request, time: " + platform.time.mono());

    if (!this._continuePipeline(pipeline))
    {
        pipeline.inProgress = false;
        return;
    }

    // see if we have anything delayed to do
    if ( !_.isUndefined( this._processDelayedActions(pipeline) ) )
    {
        pipeline.inProgress = false;
        this._schedulePipelines();
        return;
    }

    // NRDJS-3309: Delay making audio requests until the video header has arrived.
    // This is needed in Cadmium to guarentee that the audio data preceeds video data
    if ((pipeline.mediaType === manager.MEDIA_AUDIO) &&
        _.isUndefined(this._pipelines[manager.MEDIA_VIDEO].actualStartPts))
    {
        DEBUG && pipeline._trace("delaying audio request until video header processed");
        pipeline.inProgress = false;
        return;
    }

    // if we currently don't have a download track, nothing to do
    if (!pipeline.track)
    {
        DEBUG && pipeline._trace(
            "no download track (or no track Id), can't makeRequest (!inProgress)");
        pipeline.inProgress = false;
        return;
    }

    // prior to making the request, check to see if we should abort any unsent requests
    var pending = this._checkPendingRequests(pipeline, stream.streamIndex);
    if (pending.wait)
    {
        DEBUG && pipeline._trace("pending requests delaying makeRequest (!inProgress)");
        pipeline.inProgress = false;
        return;
    }

    DEBUG && pipeline._trace("makeRequest on streamId:", streamId,
                             "location:", location, "url:", url,
                             "bufferLevelMs:", pipeline.bufferLevelMs, "(ms)");

    // log a server switch if necessary
    if (stream.server && (stream.server != pipeline.server))
    {
        DEBUG && pipeline._trace("makeRequest, selected new server:", stream.server);
        this._notifyServerSwitch(pipeline, stream.server, stream.selreason,
                                 stream.location, stream.bitrate);
        pipeline.server = stream.server;
    }

    // fields to pass to location-selector
    stream.lastLocation = stream.location;
    stream.lastServer = stream.server;

    // get the fragment we need for current pts
    try
    {
        frag = this._calculateRangeRequest(pipeline, header.fragments,
                                           pipeline.streamingPts,
                                           pipeline.nextFragmentIndex);
        if (!frag)
        {
            if (this._fastplay)
            {
                DEBUG && pipeline._trace("End of fastplay stream (!inProgress)");
            }
            else
            {
                DEBUG && pipeline._trace(
                    "Can't calculate range request, marking EOS (!inProgress)");
                this._setEndOfStream(pipeline);
            }
            pipeline.inProgress = false;
            return;
        }
    }
    catch(err)
    {
        pipeline._warn("caught error when calculatingRangeRequest:", err);
        pipeline.inProgress = false;
        return;
    }

    // count number of requests made while buffering
    if (this._isBufferingState(this._playerState.value))
        ++pipeline.bufferingRequests;

    var byteStart = frag.offset;
    var byteEnd = byteStart + frag.bytes - 1;
    var ptsStart = frag.startPts + this._streamingOffset;
    var ptsEnd = ptsStart + frag.duration;
    var lookaheadBytes = frag.lookaheadBytes;

    // detect if this is the last pts in a sequence
    var actualPtsEnd = frag.startPts + frag.duration;
    var lastRequest = (actualPtsEnd >= this._maxPts);
    DEBUG && lastRequest &&
        pipeline._trace("marking last request in sequence, ptsEnd: " + actualPtsEnd);

    // create the request
    var params = {
        location: location,
        url: url,
        byteStart: byteStart,
        byteEnd: byteEnd,
        ptsStart: ptsStart,
        ptsEnd: ptsEnd,
        ptsOffset: this._streamingOffset,
        lastRequestInSequence: lastRequest
    };
    var mediaRequest = this._createRequest(pipeline, params, pipeline.track, stream);
    DEBUG && pipeline._trace("making mediaRequest: " + mediaRequest.toString() +
                             ", ptsStart:" + ptsStart + ", ptsEnd:" + ptsEnd +
                             ", byteStart:" + byteStart + ", byteEnd:" + byteEnd +
                             ", lastRequestInSequence: " + lastRequest);

    // track how long it took to create
    var createTime = platform.time.mono();

    // open request
    if (!mediaRequest.open(
        url,
        {"start": byteStart, "end": byteEnd},
        MediaRequest.RESPONSETYPES.STREAM,
        {}, // headers
        config.enableLookaheadHints ?
            {"start": byteStart, "sizes": lookaheadBytes} : undefined, // enclosing bytes
        config.enableLookaheadHints ? lookahead : undefined ) )
    {
        pipeline._warn("MediaRequest.open error: " + mediaRequest.failureCode +
                       " native: " + mediaRequest.nativeCode);
        pipeline.inProgress = false;

        if ( mediaRequest.readyState === MediaRequest.READYSTATES.ABORTED )
        {
            DEBUG && pipeline._trace("makeRequest aborted");
            return;
        }

        pipeline._warn("makeRequest caught:", mediaRequest.failureCode );
        this.session._reportStreamingFailure(   "MediaRequest open failed (1)",
                                                "NFErr_MC_StreamingFailure" );
        return;
    }

    var delta = platform.time.mono() - createTime;
    DEBUG && pipeline._trace(
        "mediaRequest created in " + delta + " ms, " + mediaRequest.toString() +
        ", ptsStart: " + ptsStart + ", ptsEnd: " + ptsEnd +
        ", byteStart: " + byteStart + ", byteEnd: " + byteEnd);

    if (!this._continuePipeline(pipeline))
    {
        pipeline._warn("!continuePipeline in requestCreated");
    }

    // if we're seeking, don't do anything else
    if (!_.isUndefined(pipeline.seekPts))
    {
        DEBUG && pipeline._trace("pipeline seeking, not adding request to append, " +
                                 "seekPts: " + pipeline.seekPts);
    }
    else
    {
        if (config.allowReissueMediaRequestAfterAbort)
        {
            var newStreamingPts = pipeline.requestManager.getNextPtsNeedsMedia();
            if (newStreamingPts !== null){
                pipeline.streamingPts = newStreamingPts;
                if (newStreamingPts === ptsEnd - this._streamingOffset)
                {
                    pipeline.nextFragmentIndex = frag.index + 1;
                } else
                {
                    pipeline._estimateFragmentIndex(pipeline.streamingPts);
                }
            } else {
                pipeline._warn("nextPts from requestManager returns null, fall back to linear increasing streamingPts");
                pipeline.streamingPts = ptsEnd - this._streamingOffset;
                pipeline.nextFragmentIndex = frag.index + 1;
            }
        } else
        {
            // set new streamingPts from fragment data
            // Don't use the setter here, we're just incrementing not seeking
            pipeline.streamingPts = ptsEnd - this._streamingOffset;
            pipeline.nextFragmentIndex = frag.index + 1;
        }
        DEBUG && pipeline._trace("streamingPts: " + pipeline.streamingPts);
    }

    this._processDelayedActions(pipeline);

    DEBUG && pipeline._trace("makeRequest done (!inProgress), mediaRequest: " +
                             mediaRequest.toString());

    pipeline.inProgress = false;

    // continue driving pipeline if possible
    this._schedulePipelines();
};

/**
* This function is used by cadmium as well as request-manager
* When manually set a bitrate range, cadmium will go through the job queue and abort the
* requests whose stream is no longer inRange
* @param {Object} mediaRequest the mediaRequest going to be aborted
* @param {boolean} scheduleNewRequests whether we want ASE immediate schedule new
*   requests or not
**/
Session.prototype.abortRequest = function abortRequest(mediaRequest, scheduleNewRequests)
{
    var pipeline = this._pipelines[mediaRequest.mediaType];
    return this._abortRequest(pipeline, mediaRequest, scheduleNewRequests);
};

Session.prototype._abortRequest = function _abortRequest(
    pipeline, mediaRequest, scheduleNewRequests)
{
    DEBUG && pipeline._trace("aborting mediaRequest: " + mediaRequest.toString());

    var result = mediaRequest.abort();

    // cleanup the request from global map
    mediaRequest.cleanup();

    // remove any listeners
    if (mediaRequest._listenerGroup)
    {
        mediaRequest._listenerGroup.clear();
    }

    // inform submanagers
    // IF config.allowReissueMediaRequestAfterAbort SET to TRUE, we leave the aborted MediaRequest in the queue
    // RequestManager will prune the request and reset StreamingPts during the process
    if (!config.allowReissueMediaRequestAfterAbort){
        pipeline.requestManager.requestAborted(mediaRequest);
    }
    pipeline.bufferManager.requestAborted(mediaRequest);

    if (scheduleNewRequests === true)
    {
       // see if the pipelines can continue
        this._schedulePipelines();
    }

    return result;
};

Session.prototype._processDelayedActions = function _processDelayedActions(pipeline)
{
    // check for seek
    if (!_.isUndefined(pipeline.seekPts))
    {
        DEBUG && pipeline._trace("processing delayed seek to: " + pipeline.seekPts);
        return this._processSeek(pipeline, pipeline.seekPts);
    }
    return;
};

Session.prototype._processSeek = function _processSeek(pipeline, pts)
{
    DEBUG && pipeline._trace("processSeek to: " + pts);
    pipeline.setStreamingPts(pts);

    if (config.pruneRequestsFromNative)
    {
        // this is needed for cadmium, since recalculateCompleteBuffer() is part of
        // _pruneRequests() and Cadmium is not calling _pruneRequests();
        pipeline.recalculateCompleteBuffer(pts);
        this._schedulePipelines();
    }

    // if we had any adopted requests waiting for append, recreate HeaderCache tracks
    if (this._adoptedRequests && (this._adoptedRequests.length > 0))
    {
        DEBUG && _trace("aborting adopted requests on seek");

        // abort all requests
        this._adoptedRequests.forEach(function(request) {
            DEBUG && _trace("aborting adopted request: " + request.toString());
            this.abortRequest(request, false);
        }.bind(this));

        if (config.headerCacheFlushForCircularBuffer)
        {
            this._wipeHeaderCache();
        }
    }

    // destroy old track, no need to wait for confirmation
    this._destroyDownloadTrack(pipeline);

    // create new download track for this mediaType
    var downloadConfig = this._getConfigs([pipeline.mediaType]);
    DEBUG && pipeline._trace("new downloadConfig:", downloadConfig);

    var tracks = this._createDownloadTracks([downloadConfig[0]]);

    DEBUG && pipeline._trace("new downloadTrack on seek:", tracks);
    pipeline.track = tracks[0];

    return tracks;
};

Session.prototype._startAudioTrackSwitch = function _startAudioTrackSwitch(pipeline)
{
    DEBUG && pipeline._trace("startAudioTrackSwitch");

    if (_.isUndefined(pipeline.newAudioTrack))
    {
        pipeline._warn("no newAudioTrack set");
        return;
    }

    // pause the buffer manager to prevent append's while stopping, do this before sending
    // notification
    pipeline.bufferManager.pause();

    // wait for player confirmation of audio track switch start
    pipeline.waitingForAudioTrackSwitchStart = true;

    // send notification to player to begin audio track switch
    var currentIndex = this._currentTracks[manager.MEDIA_AUDIO];
    this._notifyAudioTrackSwitchStarted(
        this._manifest, currentIndex, pipeline.newAudioTrack.trackIndex);
};

Session.prototype._processTrackSwitch = function _processTrackSwitch(pipeline)
{
    var currentIndex = this._currentTracks[manager.MEDIA_AUDIO];

    this._audioTrackChange = pipeline.newAudioTrack;

    var currentPts = platform.getCurrentPts(this._ctxt);
    DEBUG && pipeline._trace(
        "processing trackSwitch:",
        currentIndex, "->", this._audioTrackChange.trackIndex,
        "at pts:", currentPts, "streamingPts:", pipeline.streamingPts);

    this._currentTracks[manager.MEDIA_AUDIO] = this._audioTrackChange.trackIndex;
    pipeline.newAudioTrack = undefined;

    // clear adopted requests of audio
    if (this._adoptedRequests && (this._adoptedRequests.length > 0))
    {
        this._adoptedRequests = this._adoptedRequests.filter(function(request) {
            // keep video requests
            if (request.mediaType === manager.MEDIA_VIDEO)
                return true;

            // abort audio requests
            DEBUG && pipeline._trace("aborting adopted audio request: " +
                                     request.toString());
            this._abortRequest(pipeline, request, false);
        }.bind(this));

        if (config.headerCacheFlushForCircularBuffer &&
            (this._adoptedRequests.length === 0))
        {
            DEBUG && this._trace("wiping header cache tracks on audio switch");
            this._wipeHeaderCache();
        }
    }

    // remove current track
    this._destroyDownloadTrack(pipeline);

    // create new track (no need to wait for old one to destroy)
    var downloadConfig = this._getConfigs([manager.MEDIA_AUDIO]);
    var tracks = this._createDownloadTracks([downloadConfig[0]]);

    DEBUG && pipeline._trace("set audio track after switch");
    pipeline.track = tracks[0];

    pipeline.firstSelectedStreamIndex = undefined;
    pipeline.lastSelectedStream = undefined;

    // reset pipeline
    this._resetPipeline(pipeline);

    // set new pts
    DEBUG && pipeline._trace("setting new streamingPts: " +
                             pipeline.streamingPts + "->" + currentPts);
    pipeline.setStreamingPts(currentPts);

    // build new stream list
    this._attributes[ manager.MEDIA_AUDIO ] = manager.getAttributes(
        this._manifest, this._currentTracks, manager.MEDIA_AUDIO )[ manager.MEDIA_AUDIO ];

    this._processManifest(this._manifest, this._currentTracks, this._fastplay,
                          manager.MEDIA_AUDIO);
};

Session.prototype._setRequestLocation = function _setRequestLocation(
    mediaRequest, location, serverId)
{
    if (_.isUndefined(location) || _.isUndefined(serverId))
    {
        DEBUG && this._trace(
            "_setRequestLocation with undefined location or undefined server");
        return;
    }
    DEBUG && this._trace("setting location: " + location +
                         ", serverId: " + serverId +
                         ", mediaRequest: " + mediaRequest.toString());
    mediaRequest.location = location;
    mediaRequest.serverId = serverId;
    manager._networkMonitor.setLocation(location);

    // set video location if needed
    if (mediaRequest.mediaType == manager.MEDIA_VIDEO)
    {
        this._videoLocation = location;
    }
};

Session.prototype._updateRequestUrls = function _updateRequestUrls()
{
    var i, request;
    var failedRequests = [];

    // Keep a reference to the location selector because the session may be
    // closed during the first iteration of the forEach and that deletes
    // this._locationSelector (NRDJS-2417)
    var locationSelector = this._locationSelector;

    DEBUG && this._trace("updateRequestUrls");
    this._pipelines.forEach(function(pipeline) {
        // call location selector to update urls
        if (!locationSelector)
        {
            pipeline._warn("location selector is gone, session has been closed");
            return;
        }

        var player = this._makePlayerInfo(pipeline);
        var streamList = pipeline.streamList;
        streamList = locationSelector.updateStreamUrlSelection(player, streamList);
        if (!streamList)
        {
            pipeline._warn("location selector returned null streamList");
            return;
        }

        // (streamMap entries are shared with streamList)
        var failed = pipeline.requestManager.updateUrls(
            pipeline.streamMap, this._setRequestLocation.bind(this));

        if (failed.length > 0)
        {
            // add to end of array
            failedRequests.push.apply(failedRequests, failed);
        }
    }.bind(this));

    // XXX - for now, if we were unable to update any requests, return failure
    // Later, we can try to recreate some requests
    if (failedRequests.length > 0)
    {
        DEBUG && this._trace("updateRequestUrls failed to update requests: " +
                             JSON.stringify(failedRequests));
        return false;
    }

    return true;
};

/**
 * This function allows for syncing between the native layer buffer and the pipeline.
 * It should be called from the native layer only.
 * The function lets us prune in situation where there are multiple contiguous parts of
 *   the buffer that have data.
 *
 * @param {{0: Object, 1: Object}} requestInNativeWithMedia -- lists of audio and video
 *   media requests that have media in the native layer
 * @param {Number} pts -- currentPts/MediaTime
 */
Session.prototype.pruneRequestsBasedOnNative = function pruneRequestsBasedOnNative(
    requestInNativeWithMedia, pts)
{
    // call the pruning for each pipeline
    this._pipelines.forEach(function(pipeline) {
        var newPts = pipeline.requestManager.pruneRequestsForNative(
            requestInNativeWithMedia[pipeline.mediaType], pts, pipeline.streamingPts);

        // set new streaming pts if set
        if (!_.isUndefined(newPts))
        {
            if (pipeline.EOS && newPts < pipeline.streamingPts)
            {
                pipeline.EOS = false;
            }
            pipeline.setStreamingPts(newPts);
        }

        // recalculate complete buffer
        pipeline.recalculateCompleteBuffer(pts);
    });
};

/**
 * @param {Object} pipeline
 * @param {number} pts
 */
Session.prototype._pruneRequests = function _pruneRequests(pipeline, pts)
{
    // prune from request manager
    var prunedPts = pipeline.requestManager.pruneRequests(pipeline.bufferManager, pts);

    if (!_.isUndefined(prunedPts))
    {
        // recalculate complete buffer info
        pipeline.recalculateCompleteBuffer(prunedPts);

        // schedule more work
        this._schedulePipelines();
    }
};

Session.prototype._speculativeHeaders = function _speculativeHeaders(pipeline)
{
    // don't get speculative while buffering
    if (this._isBufferingState(this._playerState.value))
        return;

    // noop if we have none
    if (!pipeline.desiredHeaders || (pipeline.desiredHeaders.length === 0))
    {
        // pipeline._trace("no desiredHeaders");
        return;
    }

    // ignore if we're already getting a speculative
    if (pipeline.speculativeHeader)
    {
        DEBUG && pipeline._trace("already requesting speculative header, streamId: " +
                                 pipeline.speculativeHeader);
        return;
    }

    var index = pipeline.desiredHeaders.shift();
    var stream = pipeline.streamList[index];
    var streamId = stream.id;

    // if we already have headers for this, ignore
    if (pipeline.headers[streamId])
    {
        DEBUG && pipeline._trace("already requested header for streamId: " + streamId +
                                 ", ignore speculative request");
        return;
    }

    if (!stream.isAvailable)
    {
        DEBUG && pipeline._trace("stream not available, streamId: " + streamId +
                                 ", ignore speculative request");
        return;
    }

    DEBUG && pipeline._trace("speculative request for headers, index: " + index +
                             ", streamId: " + streamId);
    pipeline.speculativeHeader = streamId;

    var headerSize = pipeline.lastHeaderSize ? pipeline.lastHeaderSize :
        this._estimateHeaderSize();
    this._requestHeader(pipeline, {
        location: stream.location,
        url: stream.url,
        streamId: streamId,
        byteStart: 0,
        byteEnd: headerSize,
        speculative: true,
        lookahead: _.isUndefined( pipeline.lastHeaderSize )
    });
};

Session.prototype._destroyPipelines = function _destroyPipelines()
{
    DEBUG && this._trace("destroyPipelines");

    if (this._pipelines.length === 0)
        return;

    var tracks = [];
    this._pipelines.forEach(function(pipeline) {
        if (!_.isUndefined(pipeline.track))
            tracks.push(pipeline.track);

        // requests will be flushed when tracks are destroyed
        pipeline.requestManager.reset();
        delete pipeline.track;
        delete pipeline.streamSelector;

        if ( pipeline.active )
        {
            // This is a logic error - we should have received this event during
            // the clean-up above
            this._error( "Destroying active pipeline!" );
            this._pipelineInactive( platform.time.mono() );
        }
    });

    this._pipelines = [];

    // make sure we destroy header track
    if (this._headerTrack)
    {
        tracks.push(this._headerTrack);
        delete this._headerTrack;
    }

    // remove download tracks
    tracks.forEach( function( track )
    {
        if ( !track.created )
        {
            --this._downloadTrackCreatesInProgress;
        }

        track.destroy();
    } );
};

//////////////////////////////////////
// Listener notifications
//////////////////////////////////////

function _callEventListeners(that, type, evt)
{
    DEBUG && (function() {
        if (type === "managerdebugevent")
        {
            _trace("managerdebugevent:", evt.message);
        }
    })();

    try
    {
        that.callEventListeners(type, evt);
    }
    catch(err)
    {
        that._warn("caught error in listener, evt: " + JSON.stringify(evt) +
                   ", err: " + err);
    }
}

Session.prototype._notifyStartEvent = function _notifyStartEvent(startEvent)
{
    var evt = {
        'type': "startEvent",
        'event': startEvent,
        'time': platform.time.mono()
    };
    DEBUG && this._trace("notifyStartEvent: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyOpenComplete = function _notifyOpenComplete()
{
    var evt = {
        'type': "openComplete"
    };
    DEBUG && this._trace("notifyOpenComplete: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

/**
 * @param {{drmType: number, source: string, contentId: string, header: Object, prk: Object, headers: Object}=} data
 * @private
 */
Session.prototype._notifyDrmHeader = function _notifyDrmHeader(data)
{
    var evt = {
        'type': "drmHeader"
    };

    if (data)
    {
        evt['drmType'] = data.drmType;
        evt['source'] = data.source;
        // For single
        evt['contentId'] = data.contentId;
        evt['header'] = data.header;
        // For PRK
        evt['prk'] = !!data.prk;
        evt['headers'] = data.headers;
    }
    else
    {
        evt['drmType'] = "none";
        evt['contentId'] = "emptyContentId";
    }
    DEBUG && this._trace("notifyDrmHeader: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyHeaderCacheHit = function _notifyHeaderCacheHit(
    movieId, streamId)
{
    var evt = {
        'type': "headerCacheHit",
        'movieId': movieId,
        'streamId': streamId
    };
    DEBUG && this._trace("notifyHeaderCacheHit: movieId: " + movieId +
                         ", streamId: " + streamId);
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyHeaderCacheDataHit = function _notifyHeaderCacheDataHit(
    movieId, audio, video)
{
    var evt = {
        'type': "headerCacheDataHit",
        'movieId': movieId,
        'audio': audio,
        'video': video
    };
    DEBUG && this._trace("notifyHeaderCacheDataHit: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyStreamingError = function _notifyStreamingError(
    errorcode, errormsg, networkErrorCode, httpCode, nativeCode)
{
    var evt = {
        'type': 'error',
        'error': errorcode,
        'errormsg': errormsg,
        'networkErrorCode': networkErrorCode,
        'httpCode': httpCode,
        'nativeCode': nativeCode
    };
    this._error("notifyStreamingError: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyStreamSelected = function _notifyStreamSelected(
    pipeline, stream)
{
    // XXX
    var rebuffer = 0;

    var bandwidth = 0;
    if (stream.statistics && stream.statistics.confidence &&
        stream.statistics.throughput) {
        bandwidth = stream.statistics.throughput.average;
    }

    var evt = {
        'type': "streamSelected",
        'nativetime': platform.time.mono(),
        'mediaType': pipeline.mediaType,
        'streamId': stream.id,
        'manifestIndex': stream.manifestIndex,
        'trackIndex': stream.absoluteTrackIndex,
        'streamIndex': stream.streamIndex,
        'movieTime': pipeline.streamingPts + this._streamingOffset,
        'bandwidth': bandwidth,
        'longtermBw': bandwidth,  // use current bandwidth as longterm
        'rebuffer': rebuffer
    };
    DEBUG && pipeline._trace("notifyStreamSelected: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyStreamPresenting = function _notifyStreamPresenting(
    pipeline, startPts, manifestIndex, absoluteTrackIndex, streamIndex)
{
    var evt = {
        'type': "streamPresenting",
        'startPts': startPts,
        'mediaType': pipeline.mediaType,
        'manifestIndex': manifestIndex,
        'trackIndex': absoluteTrackIndex,
        'streamIndex': streamIndex
    };
    DEBUG && pipeline._trace("notifyStreamPresenting: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyLocationSelected = function _notifyLocationSelected(args)
{
    DEBUG && this._trace("notifyLocationSelected: " + args);
    _callEventListeners(this, 'locationSelected', args);
};

Session.prototype._notifyServerSwitch = function _notifyServerSwitch(
    pipeline, server, selreason, location, bitrate)
{
    var mediaType = (pipeline.mediaType == manager.MEDIA_VIDEO) ? "video" : "audio";
    var statistics = manager._networkMonitor.get();
    var evt = {
        'type': "serverSwitch",
        'mediatype': mediaType,
        'server': server,
        'reason': selreason,
        'location': location,
        'bitrate': bitrate,
        'confidence': statistics.confidence
    };

    if (statistics.confidence)
        evt['throughput'] = statistics.throughput.average;

    DEBUG && pipeline._trace("_notifyServerSwitch: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyStreamingPts = function _notifyStreamingPts(
    pipeline, manifestIndex, absoluteTrackIndex, pts)
{
    var evt = {
        'type': "updateStreamingPts",
        'manifestIndex': manifestIndex,
        'trackIndex': absoluteTrackIndex,
        'movieTime': pts
    };
    DEBUG && pipeline._trace("notifyStreamingPts: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyInitialAudioTrack = function _notifyInitialAudioTrack()
{
    var currentIndex = this._currentTracks[manager.MEDIA_AUDIO];
    var audioTracks = this._manifest["audio_tracks"];
    if (currentIndex > audioTracks.length)
    {
        this._warn("audioTrackIndex:", currentIndex,
                   "over number of tracks:", audioTracks.length);
        return;
    }
    var audioTrackId = audioTracks[currentIndex]["track_id"];

    var evt = {
        'type': "initialAudioTrack",
        'trackId': audioTrackId,
        'trackIndex': currentIndex
    };
    DEBUG && this._trace("notifyInitialAudioTrack: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyAudioTrackSwitchStarted =
    function _notifyAudioTrackSwitchStarted(manifest, currentIndex, newIndex)
{
    var tracks = manifest["audio_tracks"];
    var currentTrack = tracks[currentIndex];
    var newTrack = tracks[newIndex];

    var evt = {
        'type': "audioTrackSwitchStarted",
        'oldLangCode': currentTrack["language"],
        'oldNumChannels': currentTrack["channels"],
        'newLangCode': newTrack["language"],
        'newNumChannels': newTrack["channels"]
    };
    DEBUG && this._trace("notifyAudioTrackSwitchStarted: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyAudioTrackSwitchComplete =
    function _notifyAudioTrackSwitchComplete(newAudioTrack)
{
    var evt = {
        'type': "audioTrackSwitchComplete",
        'trackId': newAudioTrack.trackId,
        'trackIndex': newAudioTrack.trackIndex
    };
    DEBUG && this._trace("notifyAudioTrackSwitchComplete: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._handleHeaderAppended = function _handleHeaderAppended(evt)
{
    DEBUG && this._trace("handleHeaderAppended: " + JSON.stringify(evt));
    var mediaType = evt['mediaType'];
    var streamId = evt['streamId'];

    var pipeline = this._pipelines[mediaType];
    var stream = pipeline.streamMap[streamId];

    pipeline.setLastSelectedStream(stream);
};

/**
 * @param {Object} pipeline
 * @param {{drmType: number, source: string, contentId: string, header: Object, prk: Object, headers: Object}=} data
 * @private
 */
Session.prototype._handleDrmHeader = function _handleDrmHeader(pipeline, data)
{
    // make sure we have either prk or both contentId and header
    if (data && !(data.prk || (data.header && data.contentId)))
    {
        DEBUG && pipeline._trace(
            "drm header, incomplete, waiting for either header or keyId");
        return;
    }

    // A header with no data is a signal that we're playing clear content
    if (data)
    {
        // if we already sent drm header, ignore
        if (pipeline.drmHeaderSent)
        {
            DEBUG && pipeline._trace("drm header already sent");
            return;
        }
        DEBUG && pipeline._trace("handleDrmHeader for " + data.contentId);
        pipeline.drmHeaderSent = true;
    }

    // send out drm head
    this._notifyDrmHeader(data);

    // try switching manifest
    this._trySwitchToDrmManifest();
};

Session.prototype._notifyBufferingStarted = function _notifyBufferingStarted()
{
    var evt = {
        'type': "bufferingStarted",
        'time': platform.time.mono(),
        'percentage': 0
    };
    DEBUG && this._trace("notifyBufferingStarted: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
    this.emit('startBuffering');

    this._lastPercentage = 0;
};

Session.prototype._notifyBuffering = function _notifyBuffering()
{
    var evt;
    var progress;

    // calculate percentage based on video pipeline, because for audio we just need
    // minPrebufSize
    var now = platform.time.mono();
    var vp = this._pipelines[manager.MEDIA_VIDEO];
    if ( vp.lowThroughput )
    {
        progress = ( now - this._bufferingStartTime ) / config.prebufferTimeLimit;
    }
    else if ( vp.progress )
    {
        progress = vp.progress;
    }
    else
    {
        progress = vp.bufferLevelMs / config.minPrebufSize;
    }

    DEBUG && this._trace("notifyBuffering[" + vp.mediaType + "]: buf: " + vp.bufferLevelMs
                            + " req: " + vp.requiredBuffer
                            + " vp.prog: " + vp.progress
                            + " low:  " + vp.lowThroughput
                            + " prog: " + progress);

    // Not that bufferLevelMs may exceed minPrebufSize and we won't declare buffering
    // complete if network conditions are not ideal, so cap the percentage at 99
    var percentage = Math.min( Math.max( Math.round( progress * 100 ),
                                         this._lastPercentage ), 99 );

    // only notify if percentage changes
    if (percentage != this._lastPercentage)
    {
        evt = {
            'type': "buffering",
            'time': now,
            'percentage': percentage
        };

        DEBUG && this._trace("notifyBuffering: " + JSON.stringify(evt));
        _callEventListeners(this, evt['type'], evt);

        this._lastPercentage = percentage;
    }
};

Session.prototype._notifyBufferingComplete = function _notifyBufferingComplete()
{
    // notify buffer levels as well
    this._notifyBufferLevel();

    // use video pipeline, pts as startpts
    var startPts = this._pipelines[manager.MEDIA_VIDEO].actualStartPts;

    // XXX
    var predictedBufferingTime = 0;
    var initialBW = 0;
    var actualBW = 0;

    var evt = {
        'type': "bufferingComplete",
        'time': platform.time.mono(),
        'actualStartPts': startPts,
        'predictedBufferingTime': predictedBufferingTime,
        'initialBW': initialBW,
        'actualBW': actualBW,
        'histBW': this._pipelines[manager.MEDIA_VIDEO].historicalThroughputValue,
        'initSelReason': this._pipelines[manager.MEDIA_VIDEO].initSelectionReason,
        'buffCompleteReason': this._pipelines[manager.MEDIA_VIDEO].buffCompleteReason
    };
    DEBUG && this._trace("notifyBufferingComplete: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);

    // Pause scheduling until playback has started
    if ( config.deferAseScheduling )
    {
        this._pipelinesPaused = true;
    }
};

Session.prototype._notifyBufferLevel = function _notifyBufferLevel()
{
    // ignore if already shutdown
    if (this._isClosed())
    {
        DEBUG && this._trace("notifyBufferLevel: pipelines already shutdown");
        return;
    }

    var ap = this._pipelines[manager.MEDIA_AUDIO];
    var vp = this._pipelines[manager.MEDIA_VIDEO];
    var minBufferLevel = Math.min(ap.bufferLevelMs, vp.bufferLevelMs);

    // notify network monitor of buffer time
    manager._networkMonitor.notifyBufferLevel(
        minBufferLevel, this._playerState.value == Enums.PLAYER_STATE.PLAYING);

    // use video for current bandwidth
    var statistics = manager._networkMonitor.get();
    var currentBandwidth = statistics.confidence ? statistics.throughput.average : 0;

    // XXX
    var predictedFutureRebuffers = 0;

    // Adding the total size of the buffers in milliseconds so cadmium can use them.
    var evt = {
        'type': "updateBufferLevel",
        'abuflbytes': ap.bufferLevelBytes,
        'totalabuflmsecs': ap.appendedBufferMs,
        'vbuflbytes': vp.bufferLevelBytes,
        'totalvbuflmsecs': vp.appendedBufferMs,
        'predictedFutureRebuffers': predictedFutureRebuffers,
        'currentBandwidth': currentBandwidth
    };
    DEBUG && this._trace("notifyBufferLevel: bufferLevel:" + minBufferLevel + " ms" +
                         ", event:" + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

/**
 * @param {Object} memoryInfo
 * @private
 */
Session.prototype._logMemoryUsage = function _logMemoryUsage(memoryInfo)
{
    if (_.isUndefined(memoryInfo))
        return;

    var total = 0;
    total += memoryInfo.fastmalloc + memoryInfo.osallocatorcommitted;
    if (_.isNumber(memoryInfo.systemallocated))
        total += memoryInfo.systemallocated;

    var memoryAlertThreshold = 4 * 1024 * 1024;

    DEBUG && this._trace("memory info: " + JSON.stringify(memoryInfo) +
                         ", total: " + total);
    if (!_.isUndefined(this._memoryInfo))
    {
        var fastMallocDelta = memoryInfo.fastmalloc - this._memoryInfo.fastmalloc;
        var jsHeapDelta = memoryInfo.heapsize - this._memoryInfo.heapsize;
        var osAllocatorDelta =
            memoryInfo.osallocatorcommitted - this._memoryInfo.osallocatorcommitted;
        if ((fastMallocDelta > memoryAlertThreshold) ||
            (osAllocatorDelta > memoryAlertThreshold))
        {
            this._warn("memoryUsage at time: " + platform.time.mono() +
                       ", fastMallocDelta: " + fastMallocDelta +
                       ", jsHeapDelta: " + jsHeapDelta +
                       ", osAllocatorDelta: " + osAllocatorDelta);
        }

        if (_.isNumber(memoryInfo.systemallocated) &&
            _.isNumber(this._memoryInfo.systemallocated))
        {
            var systemDelta =
                memoryInfo.systemallocated - this._memoryInfo.systemallocated;
            if (systemDelta > memoryAlertThreshold)
            {
                this._warn("memoryUsage at time: " + platform.time.mono(),
                           ", systemDelta: " + systemDelta);
            }
        }
    }

    this._memoryInfo = memoryInfo;
};

Session.prototype._notifyStreamingStatus = function _notifyStreamingStatus()
{
    platform.memory.getHeapSize(this._logMemoryUsage.bind(this));

    // get location info
    var statistics = manager._networkMonitor.get();
    var currentBandwidth = 0;
    var connectTime = 0;
    var responseTime = 0;
    var httpResponseTime = 0;
    if (statistics.confidence)
    {
        currentBandwidth = statistics.throughput ? statistics.throughput.average : 0;
        responseTime = statistics.responseTime ? statistics.responseTime.average : 0;
        httpResponseTime = statistics.httpResponseTime ?
            statistics.httpResponseTime.average : 0;
    }
    var location = {
        'responseTime': responseTime,
        'httpResponseTime': httpResponseTime,
        'bandwidth': currentBandwidth,
        'confidence': statistics.confidence,
        'name': this._videoLocation
    };

    // calculate pipeline stats
    var currentPts = platform.getCurrentPts(this._ctxt);
    var stats = [];
    this._pipelines.forEach(function(pipeline) {
        // calculate bytes used in pipeline
        var usedBytes = pipeline.totalBufferBytes;
        var streamingBitrate = pipeline.lastSelectedStream ?
            pipeline.lastSelectedStream.bitrate : 0;
        var incompleteBuffer =
            pipeline.requestManager.partialBuffers * pipeline.avgFragmentDurationMs;
        var stat = {
            'type': pipeline.mediaType,
            'availableMediaBuffer': manager._bufferSize[pipeline.mediaType] - usedBytes,
            'completeBuffer': pipeline.bufferLevelMs,
            'incompleteBuffer': incompleteBuffer,
            'playbackBitrate': pipeline.playbackBitrate,
            'streamingBitrate': streamingBitrate,
            'streamingTime': pipeline.streamingPts + this._streamingOffset,
            'usedMediaBuffer': usedBytes,
            'toappend': pipeline.waitingToAppend,
            'activerequests': pipeline.requestManager.activeRequests
        };
        if (pipeline.mediaType === manager.MEDIA_VIDEO &&
            config.enableAdaptiveParallelStreaming)
        {
            stat['parallelDownloadMs'] = pipeline.parallelDownloadMs;
            stat['parallelDownloadBytes'] = pipeline.parallelDownloadBytes;
            stat['singleDownloadMs'] = pipeline.singleDownloadMs;
            stat['singleDownloadBytes'] = pipeline.singleDownloadBytes;
            stat['switchFromParallelToSingle'] = pipeline.switchFromParallelToSingle;
            stat['switchFromSingleToParallel'] = pipeline.switchFromSingleToParallel;
        }
        stats.push(stat);
    });

    var evt = {
        'type': 'streamingstat',
        'playbackTime': currentPts,
        'location': location,
        'stat': stats,
        'time': platform.time.mono()
    };
    DEBUG && this._trace("notifyStreamingStat: " + JSON.stringify(evt));
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._notifyEndOfStream = function _notifyEndOfStream(pipeline)
{
    var evt;

    // ignore if we already sent notification
    if (pipeline.EOSnotified)
    {
        DEBUG && pipeline._trace("notifyEndOfStream already called");
        return;
    }

    if (this._loopVideo)
    {
        DEBUG && pipeline._trace("EOS, but loopVideo is set");

        // if we're looping, send notification on video pipeline only
        if (pipeline.mediaType === manager.MEDIA_VIDEO)
        {
            evt = {
                'type': 'loopingVideo'
            };
        }
    }
    else
    {
        // notify bridge
        pipeline.bufferManager.notifyEndOfStream();
        evt = {
            'type': 'endOfStream',
            'mediaType': pipeline.mediaType
        };
    }

    // notify listeners
    if (evt)
    {
        DEBUG && pipeline._trace("notifyEndOfStream:", evt);
        _callEventListeners(this, evt['type'], evt);
        pipeline.EOSnotified = true;
    }
};

Session.prototype._reportDebugMessage = function _reportDebugMessage(msg)
{
    var debugMessage = "@ " + platform.time.mono() + ", " + msg;
    _callEventListeners(this, 'managerdebugevent', {message: debugMessage});
};

function _DownloadTrackOnNetworkFailing()
{
    DEBUG && this.session._trace("notifyOnNetworkFailing: " + this.toString() );

    if (config.enableManagerDebugTraces)
    {
        this.session._reportDebugMessage("reportNetworkFailing: " + this.toString() );
    }

    if (this.failing)
    {
        var session = this.session;
        session._errorDirector.reportFailure(
            undefined/*httpCode*/,
            this.failureCode,
            this.nativeCode,
            this.failingDestination);

        // swap url if necessary
        var updated = session._updateRequestUrls();
        if (!updated)
        {
            this.session._reportStreamingFailure("network failing",
                                this.failureString,
                                this.failureCode,
                                0,
                                this.nativeCode);
            return;
        }
    }
}

/**
 * @param {?string} errormsg
 * @param {?string=} errorCodeStr
 * @param {?string=} networkErrorCode
 * @param {?string=} httpCode
 * @param {?string=} nativeCode
 */
Session.prototype._reportStreamingFailure = function _reportStreamingFailure(
    errormsg, errorCodeStr, networkErrorCode, httpCode, nativeCode)
{
    if (this._streamingFailureReported)
    {
        DEBUG && this._trace("streamingFailure already reported");
        return;
    }
    if (_.isUndefined(errorCodeStr))
        errorCodeStr = "NFErr_MC_StreamingFailure";
    this._streamingFailureReported = true;

    this._notifyStreamingError(errorCodeStr, errormsg, networkErrorCode, httpCode, nativeCode);
};

Session.prototype._handleStreamingFailure = function _handleStreamingFailure(event)
{
    var isPermanent = event.isPermanent;
    var errorCode = event.originalErrorCode;
    var httpCode = event.originalHttpCode;
    var nativeCode = event.originalNativeCode;
    var stateName = Enums.PLAYER_STATE.name[this._playerState.value];

    this._warn("Streaming failure, state is " + stateName +
               " is permanent: " + isPermanent +
               ", last error code: " + errorCode +
               ", last http code: " + httpCode +
               ", last native code: " + nativeCode );

    if (isPermanent)
    {
        this._warn(" > Permanent failure, done");
        this._reportStreamingFailure("Permanent failure", "NFErr_MC_StreamingFailure",
                                     errorCode, httpCode, nativeCode);
    }
    else if (this._isBufferingState(this._playerState.value))
    {
        this._warn(" > We are buffering, calling it!");
        this._reportStreamingFailure("Temporary failure while buffering",
                                     "NFErr_MC_StreamingFailure",
                                     nativeCode, httpCode, nativeCode);
    }
    else
    {
        this._warn(" > Resetting failures");
        this._errorDirector.resetFailures();
    }
};

Session.prototype._handleNetworkFailureReset = function _handleNetworkFailureReset()
{
    this._warn("Network failures reset!");

    // NRDJS-2085: The network is ok now
    this._streamingFailureReported = false;
    this._schedulePipelines();
};

//////////////////////////////////////
// MP4 header
//////////////////////////////////////
Session.prototype._parseMp4Header = function _parseMp4Header(pipeline, mediaRequest, data)
{
    // see if parsing done in native
    if (config.mp4ParsingInNative)
    {
        // !!! config.mp4ParsingInNative should always be false for NRDJS,
        // Because NRDJS DRM engine depends on the parser in ASE to trigger events
        if (!mediaRequest.fragments)
        {
            this._error(
                "ASE expect fragments parsed from Native layer, but it's undefined.");
        }

        // MP4 parsing is done at the native layer
        // add fragments (will create header and streamMap entry) into pipeline
        pipeline.addFragments(mediaRequest.streamId, mediaRequest.fragments,
                              mediaRequest.avgFragmentDurationMs);

        var ctxt = {
                     pipeline: pipeline,
                     request: mediaRequest
                    };

        // Call _mp4Done to make sure all the bookkeeping is correctly done
        var event = generateMp4DoneEvent(0 /* remaining */, ctxt);
        this._mp4Done(event);
        return;
    }

    if (!mediaRequest.parser)
    {
        DEBUG && pipeline._trace("creating MP4 parser for mediaRequest: " +
                                 mediaRequest.toString());
        var parser = new Mp4Parser(mediaRequest.url, data, this._truncateHeaders);
        parser.addEventListener('error', this._mp4Error.bind(this));
        parser.addEventListener('requestdata', this._mp4RequestData.bind(this));
        parser.addEventListener('fragments', this._mp4Fragments.bind(this));
        parser.addEventListener('drmheader', this._mp4DrmHeader.bind(this));
        parser.addEventListener('keyid', this._mp4KeyId.bind(this));
        parser.addEventListener('free', this._mp4FreeBox.bind(this));
        parser.addEventListener('done', this._mp4Done.bind(this));
        mediaRequest.parser = parser;
    }
    else
    {
        DEBUG && pipeline._trace(
            "appending additional mp4 data, mediaRequest: " + mediaRequest.toString() +
            ", streamId: " + mediaRequest.streamId + ", bytes: " + data.byteLength);
        mediaRequest.parser.newData(data);
    }

    mediaRequest.parser.parse({
        pipeline: pipeline,
        request: mediaRequest
    });
};

Session.prototype._mp4Error = function _mp4Error(evt)
{
    var errormsg = evt['errormsg'];
    var streamId = evt['ctxt'].request.streamId;
    this._warn("MP4 parsing got error on streamId: " + streamId +
               ", errormsg: ", errormsg);
    this._reportStreamingFailure(errormsg);
};

Session.prototype._mp4RequestData = function _mp4RequestData(evt)
{
    var bytes = evt['bytes'];
    var pipeline = evt['ctxt'].pipeline;
    var mediaRequest = evt['ctxt'].request;

    // ignore if we're shutting down
    if (this._isClosed())
    {
        this._warn("mp4RequestData ignored, pipelines shutdown");
        return;
    }

    DEBUG && pipeline._trace(
        "mediaRequest: " + mediaRequest.toString() + ", requested more bytes: " + bytes);

    // create a new param object from original mediaRequest
    var params = {
        streamId:          mediaRequest.streamId,
        drmHeaderRequest:  mediaRequest.drmHeaderRequest,
        firstHeader:       mediaRequest.firstHeader,
        speculative:       mediaRequest.speculative,
        url:               mediaRequest.url,
        tencOffsets:       mediaRequest.tencOffsets
    };

    // set new byte range
    params.byteStart = mediaRequest.byteEnd + 1;
    params.byteEnd = params.byteStart + bytes - 1;
    params.lookahead = false;

    this._requestHeader(pipeline, params);

    // remove parser from original request
    mediaRequest.parser = undefined;

    // remember how big the header was
    pipeline.lastHeaderSize = params.byteEnd + headerSizeFuzzy;
};

Session.prototype._mp4Fragments = function _mp4Fragments(evt)
{
    var i,len,f;
    var fragments = evt['fragments'];
    var avgDurationMs = evt['averageDurationMs'];
    var truncated = evt['truncated'];
    var pipeline = evt['ctxt'].pipeline;
    var mediaRequest = evt['ctxt'].request;
    var streamId = mediaRequest.streamId;

    DEBUG && pipeline._trace("MP4 fragments for mediaRequest: " +mediaRequest.toString() +
                             ", streamId: " + streamId +
                             ", returned " + fragments.length + " fragments" +
                             ", truncated: " + truncated +
                             ", averageDuration: " + avgDurationMs);

    if (config.debugDumpFragments)
    {
        len = fragments.length;
        pipeline._trace("fragment count:", len);
        for (i=0; i<len; ++i)
        {
            f = fragments.getFragment(i);
            pipeline._trace("fragment: " + i + ", startPts: " + f.startPts +
                            ", duration: " + f.duration + ", offset: " + f.offset);
        }
    }

    pipeline.addFragments(streamId, fragments, avgDurationMs, truncated);
};

Session.prototype._mp4DrmHeader = function _mp4DrmHeader(evt)
{
    var pipeline = evt['ctxt'].pipeline;
    var mediaRequest = evt['ctxt'].request;
    var drmType = evt['drmType'];
    var header = evt['header'];

    DEBUG && pipeline._trace("MP4 parser returned drm header: " + header.byteLength +
                             " drmType: " + drmType +
                             (mediaRequest.speculative ? ", speculative" : "") +
                             (mediaRequest.drmHeaderRequest ? ", drmHeaderRequest" : ""));

    if (!pipeline.drmHeader)
    {
        pipeline.drmHeader = {};
    }

    pipeline.drmHeader.drmType = drmType;
    pipeline.drmHeader.header = header;

    // We don't need to save this mediaRequest in the global map
    if (mediaRequest._listenerGroup)
    {
        mediaRequest._listenerGroup.clear();
    }
    mediaRequest.cleanup();

    // mark that we've seen drm headers for this request
    mediaRequest.drmHeadersSeen = true;
    pipeline.drmHeader.source = "mp4";
    this._handleDrmHeader(pipeline, pipeline.drmHeader);
};

Session.prototype._mp4KeyId = function _mp4KeyId(evt)
{
    var pipeline = evt['ctxt'].pipeline;
    var mediaRequest = evt['ctxt'].request;
    var keyId = evt['keyId'];
    var keyIdOffset = evt['offset'];
    var flipped = evt['flipped'];

    DEBUG && pipeline._trace("MP4 parser returned keyId: " + keyId +
                             (mediaRequest.speculative ? ", speculative" : ""));

    if (!pipeline.drmHeader)
    {
        pipeline.drmHeader = {};
    }

    pipeline.drmHeader.contentId = keyId;
    pipeline.drmHeader.source = "mp4";
    pipeline.drmHeader.keyIdFlipped = flipped;

    if (_.isUndefined(mediaRequest.tencOffsets)) {
        mediaRequest.tencOffsets = [keyIdOffset];
    }
    else {
        mediaRequest.tencOffsets.push(keyIdOffset);
    }

    this._handleDrmHeader(pipeline, pipeline.drmHeader);
};

Session.prototype._mp4FreeBox = function _mp4FreeBox(args)
{
    var pipeline = args['ctxt'].pipeline;

    DEBUG && pipeline._trace("Free box contained " + args['data'].byteLength + " bytes");

    var evt = {
        'type' : "filetoken",
        'filetoken' : args['data']
    };
    _callEventListeners(this, evt['type'], evt);
};

Session.prototype._mp4Done = function _mp4Done(evt)
{
    var remaining = evt['remaining'];
    var pipeline = evt['ctxt'].pipeline;
    var mediaRequest = evt['ctxt'].request;
    var streamId = mediaRequest.streamId;
    var header = pipeline.headers[streamId];
    var drmHeader = pipeline.drmHeader;
    var stream;

    DEBUG && pipeline._trace("MP4 parser done on streamId: " + streamId +
                             ", remaining: " + remaining +
                             ", mediaRequest: " + mediaRequest.toString() +
                             ", manifestIndex: " + mediaRequest.manifestIndex);

    // done with parser
    delete mediaRequest.parser;

    if (_.isUndefined(header))
    {
        DEBUG && pipeline._trace("header was removed before parsing done");
    }
    else
    {
        if (pipeline.mediaType === manager.MEDIA_VIDEO && drmHeader &&
            mediaRequest && drmHeader.keyIdFlipped)
        {
            require(53).applyFlippedKid(drmHeader.contentId,
                mediaRequest.tencOffsets, header.data);
        }

        // remember the original header length
        header.fullsize = header.data.byteLength;

        if (header.truncated)
        {
            DEBUG && pipeline._trace("truncated header, saving whole header");
            header.savedData = header.data;
        }

        if (remaining > 0)
        {
            // truncate header by remaining bytes
            header.data = header.data.slice(0, 0-remaining);
        }
        DEBUG && pipeline._trace(
            "header size = 0x" + header.data.byteLength.toString(16));

        // mark this header as received
        header.complete = true;
    }

    if (mediaRequest.drmHeaderRequest && !mediaRequest.drmHeadersSeen)
    {
        pipeline._warn("drm header MediaRequest: " + mediaRequest.toString() +
                       ", but no headers seen, marking pipeline drmReady");
        this.drmReady();

        this._handleDrmHeader(pipeline);
    }

    if (mediaRequest.speculative)
    {
        DEBUG && pipeline._trace("speculative request done, streamId: " + streamId +
                                 ", " + pipeline.speculativeHeader);
        pipeline.speculativeHeader = undefined;
    }

    // inform the buffer manager in case the header was needed to append
    pipeline.bufferManager.notifyHeaderDone();

    // After a header is parsed, we call _drivePipelines(),
    // instead of _schedulePipelines() to avoid adding timeout into playdelay
    this._drivePipelines();
};


//////////////////////////////////////
// processManifest
//////////////////////////////////////
/**
 * @param {Object} manifest
 * @param {Array} trackIndexes
 * @param {boolean} fastplay
 * @param {Object=} type
 * @private
 */
Session.prototype._processManifest = function _processManifest(
    manifest, trackIndexes, fastplay, type)
{
    var trackProperty = [ "audio_tracks", "video_tracks" ]; // AUDIO, VIDEO
    var audioTracks = manifest[trackProperty[0]].length;
    var videoTracks = manifest[trackProperty[1]].length;
    DEBUG && this._trace(
        "processManifest: audio: " + audioTracks + ", video: " + videoTracks);

    if (type == manager.MEDIA_AUDIO)
    {
        // restrict to audio tracks only
        delete trackProperty[1];
    }

    // build stream map
    trackProperty.forEach(function(property, trackType) {
        var isVideo = trackType === manager.MEDIA_VIDEO;
        var isAudio = trackType === manager.MEDIA_AUDIO;
        var pipeline = this._pipelines[trackType];
        pipeline.trackIndex = trackIndexes[trackType];
        pipeline.absoluteTrackIndex = pipeline.trackIndex +
            (isAudio ? videoTracks : 0);

        var streamList = [];
        var streamMap = {};
        var tracks = manifest[property];
        tracks.forEach(function(track, trackIndex) {
            var streams = track["streams"];
            var selectedTrack = (trackIndex == pipeline.trackIndex);

            // calculate the absoluteTrackIndex for events
            var absoluteTrackIndex = trackIndex +
                (isAudio ? videoTracks : 0);

            streams.forEach(function(stream, streamIndex) {
                var isDrm = false;
                var filter;
                var header;
                var enabled = true;
                var dlid = stream["downloadable_id"];
                var profile = stream["content_profile"];
                var bitrate = stream["bitrate"];
                var inRange = true; // assume inRange for now

                if (trackType == manager.MEDIA_VIDEO)
                {
                    // disable drm video streams on fastplay
                    isDrm = (profile.indexOf("none") == -1);
                    enabled = (fastplay && !isDrm) || (!fastplay && isDrm);

                    if (enabled && this._bitrateRanges)
                    {
                        inRange = this._applyFilters(
                            profile, bitrate, this._bitrateRanges);
                    }
                }

                var info = {
                    // fields needed for StreamSelector
                    id: dlid,
                    startPts: 0, // XXX
                    bitrate: bitrate,
                    isAvailable: enabled,
                    inRange: inRange,

                    // fields needed for mediarequest headers
                    contentProfile: profile,
                    frameRateValue: stream["framerate_value"],
                    frameRateScale: stream["framerate_scale"],

                    // needed for events
                    manifestIndex: this._manifestIndex,
                    absoluteTrackIndex: absoluteTrackIndex,
                    trackIndex: trackIndex,
                    streamIndex: streamIndex,

                    // Additional info
                    isDrm: isDrm
                };

                // copy any data from old entry
                var entry = pipeline.streamMap[dlid];
                if (entry)
                {
                    info.statistics = entry.statistics;
                    info.fragments = entry.fragments;
                }

                // add to pipeline's streamMap
                streamMap[dlid] = info;

                if (selectedTrack)
                {
                    // add stream to appropriate pipeline
                    streamList.push(info);

                    // remember attributes about this track
                    this._attributes[trackType].profile = profile;
                }
            }, this);

            if (selectedTrack)
            {
                // override any profile from streams with one from track
                this._attributes[trackType].profile = track["profile"];

                this._attributes[trackType].frameRateValue = track["max_framerate_value"];
                this._attributes[trackType].frameRateScale = track["max_framerate_scale"];
                this._attributes[trackType].maxWidth = track["maxWidth"];
                this._attributes[trackType].maxHeight = track["maxHeight"];
                this._attributes[trackType].pixelAspectX = track["pixelAspectX"];
                this._attributes[trackType].pixelAspectY = track["pixelAspectY"];

                this._attributes[trackType].channels = track["channels"];

                // currently all our content is at 48k. If this changes we'll have to
                // add this value to manifest and pull from there (unless we want to
                // parse audio headers)
                this._attributes[trackType].sampleRate = 48000;
            }
        }, this);

        pipeline.streamList = streamList;

        pipeline.highestBitrateStream = pipeline.streamList.reduce(
        function(previousStream, currentStream) {
            if( currentStream.inRange && currentStream.isAvailable &&
                !currentStream.hasFailed &&
                currentStream.bitrate > previousStream.bitrate ){
                return currentStream;
            } else {
                return previousStream;
            }
        }, streamList[0]);
        pipeline.highestBitrateStreamIndex =
            pipeline.streamList.indexOf(pipeline.highestBitrateStream);
        DEBUG && pipeline._trace(
            "pipeline's highestStream: " + pipeline.highestBitrateStream.bitrate +
            " at index " + pipeline.highestBitrateStreamIndex +
            ", stream[" + pipeline.highestBitrateStreamIndex + "]: " +
            pipeline.streamList[pipeline.highestBitrateStreamIndex].bitrate);

        pipeline.streamMap = streamMap;

        // notify buffer manager of new streamMap
        if (pipeline.bufferManager)
        {
            pipeline.bufferManager.setStreamMap(streamMap);
        }

        DEBUG && pipeline._trace("processManifest: stream list count: " +
                                 streamList.length);
        DEBUG && (function() {
            var info;
            var newList = [];
            for (var i in streamMap)
            {
                info = streamMap[i];
                newList.push({
                    id: info.id,
                    bitrate: info.bitrate,
                    contentProfile: info.contentProfile,
                    absoluteTrackIndex: info.absoluteTrackIndex,
                    manifestIndex: info.manifestIndex,
                    isAvailable: info.isAvailable,
                    inRange: info.inRange
                });
            }
            pipeline._trace("newList:", newList);
        })();

        // once we get a new streamList, remove any speculative header requests
        // as they would have pointed to old indexes
        delete pipeline.desiredHeaders;
    }, this);
};

Session.prototype._getDrmStream = function _getDrmStream(manifest, trackIndex)
{
    var tracks = manifest["video_tracks"];
    var track = tracks[trackIndex];
    var streams = track["streams"];

    var streamId;
    var url;
    streams.some(function(stream) {
        var profile = stream["content_profile"];
        var isDrm = (profile.indexOf("none") == -1);
        if (!isDrm)
            return;

        // return this stream
        streamId = stream["downloadable_id"];
        url = stream["urls"][0]["url"];

        return true;
    });

    return { streamId: streamId, url: url };
};

//////////////////////////////////////
// Export
//////////////////////////////////////
module.exports = Manager;

},{"103":103,"44":44,"47":47,"48":48,"49":49,"51":51,"53":53,"54":54,"56":56,"57":57,"61":61,"62":62,"63":63,"66":66,"84":84,"94":94}],44:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var _ = require(103);
var platform = require(61);

var Enums = require(48);

var Events = require(94);
var EventEmitter = Events.EventEmitter;

var MediaRequest = platform.MediaRequest;

var DEBUG = ("debug" !== 'release');
var config = require(47);

////////////////////
// BufferManager
////////////////////
/**
 * @constructor
 */
function BufferManager(console, mediaType, movieId, sourceBuffer, headers, streamMap)
{
    this._movieId = movieId;
    this._mediaType = mediaType;
    this._sourceBuffer = sourceBuffer;
    this._headers = headers;
    this._streamMap = streamMap;

    // console tracing
    this._console = console;
    this._error = this._console.error.bind(this._console);
    this._warn = this._console.warn.bind(this._console);
    this._trace = this._console.trace.bind(this._console);

    // add event emitter api
    this.addEventListener = EventEmitter.addEventListener;
    this.on = EventEmitter.addEventListener;
    this.removeEventListener = EventEmitter.removeEventListener;
    this.callEventListeners = EventEmitter.callEventListeners;
    this.emit = EventEmitter.callEventListeners;

    // last offset set into source buffer
    this._lastTimestampOffset = 0;

    // init the append list tracking
    this.reset();
}
BufferManager.prototype.constructor = BufferManager;

Object.defineProperties(BufferManager.prototype, {
    bufferId: {
        get: function() { return this._sourceBuffer ? this._sourceBuffer.bufferId : -1; }
    },
    waitingToAppend: { get: function() { return this._toAppend.length; } }
});

//////////
// setStreamMap
//////////
BufferManager.prototype.setStreamMap = function setStreamMap(streamMap)
{
    DEBUG && this._trace("setStreamMap");
    this._streamMap = streamMap;
};

//////////
// reset
//////////
BufferManager.prototype.reset = function reset()
{
    DEBUG && this._trace("bufferManager reset");
    this._paused = false;
    this._toAppend = [];

    this._lastHeaderAppended = undefined;

    // help in tracking down out of order request appending
    this._lastRequestIdAppended = undefined;

    // the next request we should append
    this._nextAppendPts = undefined;
};

//////////
// pause/resume
//////////
BufferManager.prototype.pause = function pause()
{
    DEBUG && this._trace("BufferManager pausing appends");
    this._paused = true;
};

BufferManager.prototype.resume = function resume()
{
    DEBUG && this._trace("BufferManager resuming appends");
    this._paused = false;

    // try appending
    this._append();
};

//////////
// attachRequest
//////////
BufferManager.prototype.attachRequest = function attachRequest(mediaRequest)
{
    // toAppend list should be ordered by startPts
    var i, existed = false;
    for (i=0; i<this._toAppend.length; ++i)
    {
        // in case the mediaRequest is already in the toAppend list,
        // which is possible for Cadmium, we should not insert the request into the list
        // again
        if (mediaRequest.ptsStart !== undefined &&
            this._toAppend[i].ptsStart === mediaRequest.ptsStart)
        {
            DEBUG && this._trace("attachRequest, same mediaRequest found at index: " + i +
                                 ", mediaRequest: " + mediaRequest.toString() +
                                 ", this._toAppend[" + i + "]: " +
                                 this._toAppend[i].toString());
            existed = true;
            break;
        }

        if (this._toAppend[i].ptsStart > mediaRequest.ptsStart)
        {
            break;
        }
    }

    if (!existed)
    {
        // if not exist, we should add the request into the toAppend list
        this._toAppend.splice(i, 0, mediaRequest);
        DEBUG && this._trace("attachRequest at index: " + i +
                             ", mediaRequest: " + mediaRequest.toString() +
                             ", appendCount: " + this._toAppend.length);
    }

    // try appending now
    this._append();
};

//////////
// requestAborted
//////////
BufferManager.prototype.requestAborted = function requestAborted(mediaRequest)
{
    var idxToAppend = this._toAppend.indexOf(mediaRequest);
    if (idxToAppend !== -1)
    {
        DEBUG && this._trace(
            "Remove aborted MediaRequest: " + mediaRequest.toString() +
            " from bufferManager's toAppend list (idx:" + idxToAppend, ")");
        this._toAppend.splice(idxToAppend, 1);
    }
};

//////////
// notifyHeaderDone
//////////
BufferManager.prototype.notifyHeaderDone = function notifyHeaderDone()
{
    // append any requests we can
    this._append();
};

//////////
// notifyEndOfStream
//////////
BufferManager.prototype.notifyEndOfStream = function notifyEndOfStram()
{
    DEBUG && this._trace("bufferManager::notifyEndOfStream");
    this._sourceBuffer.endOfStream();
};

////////////////////
// private
////////////////////

//////////
// _isRequestAppendable
//////////
BufferManager.prototype._isRequestAppendable = function _isRequestAppendable(mediaRequest)
{
    if (!config.sourceBufferInOrderAppend)
    {
        return true;
    }

    if (_.isUndefined(this._nextAppendPts))
    {
        // need to be first request in the sequence
        if (!mediaRequest.firstRequestInSequence)
        {
            DEBUG && this._trace(
                "request not ready to append, waiting for first in sequence",
                "request: ", mediaRequest);
            this._reportDebugEvent(
                ("@ " + platform.time.mono() +
                 ", isRequestAppendable: waiting for firstRequestInSequence" +
                 ", wrong request: " + mediaRequest.toString()));

            return false;
        }
        return true;
    }

    // check for correct append sequence
    if (mediaRequest.ptsStart != this._nextAppendPts)
    {
        DEBUG && this._trace("request (ID:" + mediaRequest.getRequestId() + ")" +
                             " not ready to append, next append pts: " +
                             this._nextAppendPts +
                             ", request ptsStart: " + mediaRequest.ptsStart);
        this._reportDebugEvent(
            ("@ " + platform.time.mono() +
             ", isRequestAppendable: waiting for request pts: " + this._nextAppendPts +
             ", this request: " + mediaRequest.toString()));

        return false;
    }

    return true;
};

//////////
// _append
//////////
BufferManager.prototype._append = function _append()
{
    var stream;
    DEBUG && this._trace(
        "BufferManager::_append listCount: " + this._toAppend.length +
        ", last appended streamId " + this._lastHeaderAppended);

    if (!this._toAppend.length)
    {
        return;
    }

    if (!this._sourceBuffer)
    {
        // if the sourceBuffer is not initialized, append the request next time
        DEBUG && this._trace("sourceBuffer not ready for append");
        this._reportDebugEvent(
            ("@ " + platform.time.mono() +
             ", append: not appending, sourceBuffer not ready"));
        return;
    }

    var mediaRequest = this._toAppend[0];

    // make sure bufferManager is ok to append
    if (this._paused)
    {
        DEBUG && this._trace("BufferManager paused, not appending now: ", mediaRequest);
        this._reportDebugEvent(
            ("@ " + platform.time.mono() +
             ", bufferManager _append ignored, paused" +
             ", nextRequest: " + JSON.stringify(mediaRequest)));
        return;
    }

    // see if request is ready to append
    if (mediaRequest.readyState === MediaRequest.READYSTATES.ABORTED)
    {
        this._warn("aborted MediaRequest should not appear in the toAppend list");
        this._reportDebugEvent(
            ("@ " + platform.time.mono() +
             ", append: removing aborted request from toAppend: " +
             mediaRequest.toString()));
        this._toAppend.shift();
        return;
    }

    // make sure the request is in right state to append
    if (!this._isRequestAppendable(mediaRequest))
    {
        DEBUG && this._trace("not ready to append, toAppend: " +
                             JSON.stringify(this._toAppend));
        return; // no more to append
    }

    // make sure we have the header
    var streamId = mediaRequest.streamId;
    var header = this._headers[streamId];
    if (!header || !header.data)
    {
        DEBUG && this._trace("header not yet available for streamId: ", streamId);
        return;
    }

    if (mediaRequest.streamId != this._lastHeaderAppended)
    {
        DEBUG && this._trace("mediaRequest's streamId: ", mediaRequest.streamId +
                             " is different from last appended streamid: " +
                             this._lastHeaderAppended);

        // append the header, it will call this again to append request after
        stream = this._streamMap[streamId];
        this._appendHeader(header.data, stream);
    }
    else
    {
        // append the request now
        this._toAppend.shift();
        this._appendRequest(mediaRequest);
    }
};

//////////
// _appendHeader
//////////
/**
 * @param {Object} header
 * @param {Object} stream
 * @private
 */
BufferManager.prototype._appendHeader = function _appendHeader(header, stream)
{
    var streamId = stream.id;
    var bitrate = stream.bitrate;
    DEBUG && this._trace("appendHeader for streamId: " + streamId +
                         ", bitrate: " + bitrate);


    if ( this._sourceBuffer.appendBuffer( header ) )
    {
        DEBUG && this._trace("header appended, streamId: " + streamId + ", bitrate: " + bitrate);
        this._reportDebugEvent(
                ("@" + platform.time.mono() +
                 ", header appended, streamId: " + streamId + ", bitrate: " + bitrate));

        this._lastHeaderAppended = streamId;

        // report the last appended stream
        this._reportHeaderAppended(streamId);

        // append request now that header is appended
        this._append();
    }
    else
    {
        this._warn("appendHeader error: " + this._sourceBuffer.error );
        this._reportDebugEvent(
                ("@" + platform.time.mono() +
                 ", appendHeader error: " + this._sourceBuffer.error));
        throw "appendHeaderError";
    }
};

//////////
// _appendRequest
//////////
BufferManager.prototype._appendRequest = function _appendRequest(mediaRequest)
{
    // change the source buffer's timestamp offset if necessary
    if (mediaRequest.ptsOffset != this._lastTimestampOffset)
    {
        DEBUG && this._trace("loopVideo, changing timestampOffset: " +
                             this._lastTimestampOffset + "->" + mediaRequest.ptsOffset);
        this._sourceBuffer.setTimestampOffset(mediaRequest.ptsOffset, 1000);
        this._lastTimestampOffset = mediaRequest.ptsOffset;
    }

    DEBUG && this._trace("appending mediaRequest: " + mediaRequest.toString() +
                         " for streamId: " +  mediaRequest.streamId +
                         " to source buffer: " +  JSON.stringify(this._sourceBuffer));

    if ( this._sourceBuffer.appendMediaRequest(mediaRequest) )
    {
        DEBUG && this._trace("request appended, next append pts: " + this._nextAppendPts +
                             ", mediaRequest: "+ mediaRequest.toString() +
                             ", lastRequestInSequence: " +
                             mediaRequest.lastRequestInSequence);
        this._reportDebugEvent(
                ("@" + platform.time.mono() +
                 ", request appended, streamId: " + mediaRequest.streamId +
                 ", pts: " + mediaRequest.ptsStart + "-" + mediaRequest.ptsEnd));

        if (!mediaRequest.appended)
        {
            mediaRequest.appended = true;

            if (mediaRequest.lastRequestInSequence)
            {
                DEBUG && this._trace("lastRequestInSequence, clearing nextAppendPts");
                delete this._nextAppendPts;
            }
            else
            {
                this._nextAppendPts = mediaRequest.ptsEnd;
            }

            // sanity check the append order
            var requestId = mediaRequest.getRequestId();
            if (config.sourceBufferInOrderAppend &&
                !_.isUndefined(this._lastRequestIdAppended) &&
                (this._lastRequestIdAppended > requestId))
            {
                this._error("appendRequest out of order: " + requestId +
                            " after " + this._lastRequestIdAppended);
                this._reportDebugEvent(
                    ("@ " + platform.time.mono() +
                     ", appendRequest out of order, request: " + mediaRequest.toString() +
                     ", lastAppendedId: " + this._lastRequestIdAppended));
            }

            this._lastRequestIdAppended = requestId;

            DEBUG && this._trace("toAppend: " + JSON.stringify(this._toAppend));

            // send notification
            this._reportRequestAppended(mediaRequest);
        }

        // try more requests
        this._append();
    }
    else
    {
        if (this._sourceBuffer.error == "done")
        {
            DEBUG && this._trace("appendRequest detected done");
            return;
        }

        this._warn("failure to append queued mediaRequest: " + mediaRequest.toString() +
                   "err: ", this._sourceBuffer.error);
        throw this._sourceBuffer.error;

    }
};

////////////////////
// events
////////////////////
BufferManager.prototype._reportHeaderAppended = function _reportHeaderAppended(streamId)
{
    var evt = {
        'type': "headerAppended",
        'mediaType': this._mediaType,
        'streamId': streamId
    };
    DEBUG && this._trace("reportHeaderAppended: " + JSON.stringify(evt));
    this.callEventListeners(evt['type'], evt);
};

BufferManager.prototype._reportRequestAppended = function _reportRequestAppended(request)
{
    var evt = {
        'type': "requestAppended",
        'mediaType': this._mediaType,
        'request': request
    };
    DEBUG && this._trace("reportRequestAppended: " + JSON.stringify(evt));
    this.callEventListeners(evt['type'], evt);
};

BufferManager.prototype._reportDebugEvent = function _reportDebugEvent(msg)
{
    var evt = {
        'type': "managerdebugevent",
        'message': msg
    };
    this.callEventListeners(evt['type'], evt);
};

////////////////////
// Export
////////////////////
module.exports = BufferManager;

},{"103":103,"47":47,"48":48,"61":61,"94":94}],45:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var platform = require(61),
    config = require(97),
    defaults = require(46);

//=============================================================================

config.declare(defaults);

//=============================================================================

platform.events.on("configChanged", function(data) {
    var console = new platform.Console("ASEJS", "media|asejs"),
        changes = config.set(data, true, console);
    if (changes) {
        config.dump(console, false);
    }
});

module.exports = config;


},{"46":46,"61":61,"97":97}],46:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

//=============================================================================
// These should be tuples with at least 2 items. The first item is the string
// name used for the property in the external configuration (foreign key).
// The second is the default value for the property.
//
// The third is a conversion function that will accept a string value for
// this configuration and will convert it to the type expected by the rest
// of the code. If there is a conversion problem, the function should throw
// an error.
//
// If the conversion function is omitted, a default one is used - one chosen
// based on the type of the default value (number, boolean, string, or object)
//
//=============================================================================

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_high");
var defaults = {

    //=========================================================================
    // StreamSelector
    //=========================================================================

    /*
    Lower bound on the initially selected video rate unless we have a throughput
    estimate that is less than the minimumRequiredThroughput
    */
    minInitVideoBitrate: ['minInitVideoBitrate', -Infinity],

    /*
    Lower bound on the initially selected video rate for header cache.
    */
    minHCInitVideoBitrate: ['minHCInitVideoBitrate', -Infinity],

    /*
    Upper bound on the initially selected video rate
    */
    maxInitVideoBitrate: ['maxInitVideoBitrate', Infinity],

    /*
    Lower bound on the initially selected audio rate unless we have a throughput
    estimate that is less than the minimumRequiredThroughput
    */
    minInitAudioBitrate: ['minInitAudioBitrate', -Infinity],

    /*
    Lower bound on the initially selected audio rate for header cache.
    */
    minHCInitAudioBitrate: ['minHCInitAudioBitrate', -Infinity],

    /*
    Upper bound on the initially selected audio rate
    */
    maxInitAudioBitrate: ['maxInitAudioBitrate', Infinity],

    /*
    As minInitVideoBitrate (the max of these two is used). Also used during
    streaming below unless a rebuffering happens
    */
    minAcceptableVideoBitrate: ['minAcceptableVideoBitrate', -Infinity],

    /*
    The minimum stream duration that must fit in the stream buffer for a stream to be considered
    */
    minRequiredBuffer: ['minRequiredBuffer', 30000],

    /*
    Minimum media duration for buffering
    */
    minPrebufSize: ['minPrebufSize', 5800],

    /*
    Require download at least some A/V data during buffering
    */
    requireDownloadDataAtBuffering: ['requireDownloadDataAtBuffering', false],

    /*
     * Require set up the connection before playback starts
     */
    requireSetupConnectionDuringBuffering: ['requireSetupConnectionDuringBuffering', false],


    /*
     * At rebuffering, minPrebufSize *= rebufferingFactor
     */
    rebufferingFactor: ['rebufferingFactor', 1.0],

    /*
    Target for the maximum time to be spent buffering
    */
    maxBufferingTime: ['maxBufferingTime', 2000],

    /*
    Should we have maxPrebufSize, in terms of media time.
    */
    useMaxPrebufSize: ['useMaxPrebufSize', false],

    /*
    Maximum media duration (in ms) to prebuffer at beginning of playback.
    Not valid for rebuffers.
    */
    maxPrebufSize: ['maxPrebufSize', 30000],

    /*
    Carrera curve for initial bitrate selection.
    Example config:  "[{"d" : 2000, "r" : 6000},{"d" : 5000, "r": 1050}, {"d" : 8000, "r": 560}]"
    */
    initialBitrateSelectionCurve: ['initialBitrateSelectionCurve', null],

    /*
    Controls use of a pre-selected stream with bitrate higher than the stream
    selected according to the stream selection algorithm (McQueen 2.1 Header prefetch)
    (Phase II?)
    */
    initSelectionLowerBound: ['initSelectionLowerBound', -Infinity],

    /*
    Controls use of a pre-selected stream with bitrate lower than the stream
    selected according to the stream selection algorithm (McQueen 2.1 Header prefetch)
    (Phase II?)
    */
    initSelectionUpperBound: ['initSelectionUpperBound', Infinity],

    /*
    Percentage of the throughput allocated for audio
    */
    throughputPercentForAudio: ['throughputPercentForAudio', 15],

    /*
    Discount applied to the predicted throughput in calculating the available throughput
    */
    bandwidthMargin: ['bandwidthMargin', 10],

    /*
    Variable discounts applied to predicted throughput according to buffer level.
    Example: "[{"m" : 50, "b" : 15000},{"m" : 35, "b": 30000}]"
    */
    bandwidthMarginCurve: ['bandwidthMarginCurve',
         [{"m": 25, "b": 15000}, {"m":20, "b":30000} , {"m":15, "b":60000}]
        //null
        //[{"m" : 50, "b" : 15000},{"m" : 35, "b": 30000}]
    ],

    /*
    ASE-22 (Switching Bandwidth Margin based on Average Throughput)
    When lower thorughput is measured,
    a more conservative discount (and curve) is applied to the predicted throughput in calculating the available throughput
    */
    conservBandwidthMargin: ['conservBandwidthMargin', 20],

    conservBandwidthMarginTputThreshold: ['conservBandwidthMarginTputThreshold', 2000],

    conservBandwidthMarginCurve: ['conservBandwidthMarginCurve',
         [{"m": 50, "b": 15000}, {"m":40, "b":30000} , {"m":30, "b":60000}]
    ],

    /*
    Bandwidth Margin Scaled Ratio Upper Bound.
    For ScaledMarginPredictor, bandwidthMarginScaledRatioUpperBound acts as the upper bound
    for the ratio mulplied to the bandwidthMarginCurve
    */
    bandwidthMarginScaledRatioUpperBound: ['bandwidthMarginScaledRatioUpperBound', 2],
    /*
    Max Buffer level allowed for a streaming session (bytes)
    */
    maxTotalBufferLevelPerSession: ['maxTotalBufferLevelPerSession', 0],

    /*
    Buffer level above which bandwidthMargin is reduced by a factor of two
    if bandwidthMarginCurve is not specified.
    */
    highWatermarkLevel: ['highWatermarkLevel', 30000],

    /*
    Buffer level above which the heuristic state transitions to STABLE
    */
    toStableThreshold: ['toStableThreshold', 30000],

    /*
    Buffer level below which the heuristc state transitions from STABLE to UNSTABLE, provided
    */
    toUnstableThreshold: ['toUnstableThreshold', 15000],

    /*
    Enables upswitching across multiple bitrates in one step
    */
    skipBitrateInUpswitch: ['skipBitrateInUpswitch', false],

    /*
    Buffer level below which multiple bitrate upswitch is not allowed
    */
    watermarkLevelForSkipStart: ['watermarkLevelForSkipStart', 8000],

    /*
    Simulation window for current stream
    */
    highStreamRetentionWindow: ['highStreamRetentionWindow', 90000],

    /*
    Simulation window for different stream
    */
    highStreamTransitionWindow: ['highStreamTransitionWindow', 500000],

    /*
    For bitrates greater than this, upswitch is disabled based on simple comparison
    of the stream rate with the current available throughput.
    (Deprecated)
    */
    bitrateThresholdForBufferBasedHeuristics: ['bitrateThresholdForBufferBasedHeuristics', Infinity], // deprecated

    /*
    Lowest buffer level at which upswitching is allowed
    */
    lowestBufForUpswitch: ['lowestBufForUpswitch', 9000],

    /*
    Period of time after a downswitch or after an upswitch if buffer level is
    less than lowestBufForUpswitch at which upswitching is allowed
    */
    lockPeriodAfterDownswitch: ['lockPeriodAfterDownswitch', 15000],

    /*
    Buffer level below which upswitch is not allowed, unless buffer
    level > lowestBufForUpswitch and last switch was a upswitch.
    */
    lowWatermarkLevel: ['lowWatermarkLevel', 15000],

    /*
    maximum length for the heuristics’ simulation
    */
    maxSimuLength: ['maxSimuLength', 10 /* minutes */ * 60 * 1000],

    /*
    TODO: Added by Pablo
    */
    lowestWaterMarkLevel: ['lowestWatermarkLevel', 30000],

    /*
    TODO: Added by Pablo
    */
    mediaRate: ['mediaRate', 1.5],

    /*
    maximum duration in ms of the skip-back buffer
    */
    maxTrailingBufferLen: [ 'maxTrailingBufferLen', 15000 ],

    /*
    minimum available bytes in audio buffer to restart downloading
    */
    audioBufferTargetAvailableSize: [ 'audioBufferTargetAvailableSize', 256 * 1024 ],

    /*
    minimum available bytes in video buffer to restart downloading
    */
    videoBufferTargetAvailableSize: [ 'videoBufferTargetAvailableSize', 1024 * 1024 ],


    /*
    maximum size of the video skip-back buffer
    */
    maxVideoTrailingBufferSize: [ 'maxVideoTrailingBufferSize', 8 * 1024 * 1024 ],

    /*
    maximum size of the audio skip-back buffer
    */
    maxAudioTrailingBufferSize: [ 'maxAudioTrailingBufferSize', 384 * 1024 ],

    /*
    NRDJS-1597
    If the throughput is higher than the stream's nominal rate multiplied by
    this factor, stream selector will recommend an upswitch even when there are no
    headers for the stream - it will not require a simulation before recommending
    an upswitch. To disable this behavior, set this to Infinity or some very large
    number.
    */
    fastUpswitchFactor: ['fastUpswitchFactor', 3.0],

    /* The maximum amount of media we should keep in the buffer */

    maxMediaBufferAllowed: ['maxMediaBufferAllowed', 270 * 1000],

    /*
    Whether to account for partial blocks during simulation
    */
    simulatePartialBlocks: ['simulatePartialBlocks', true],

    /*
    Whether to account for buffer full during simulation
    */
    simulateBufferFull: ['simulateBufferFull', true],

    /*
    Whether to consider TCP connect times in stream selection
    */
    considerConnectTime: ['considerConnectTime', true],

    /*
    Multiplier for standard deviations to be added to TCP connect time when considerConnectTime = true
    */
    connectTimeMultiplier: ['connectTimeMultiplier', 1.0 ],

    //=========================================================================
    // LocationSelector
    //=========================================================================

    /*
    Buffer threshold for entering the low grade mode
    */
    lowGradeModeEnterThreshold: ['lowGradeModeEnterThreshold', 120 * 1000],

    /*
    Buffer threshold for exiting the low grade mode
    */
    lowGradeModeExitThreshold: ['lowGradeModeExitThreshold',  90 * 1000],

    /*
    maximum time the player waits if it encounters network failure continuously
    */
    maxDomainFailureWaitDuration: ['maxDomainFailureWaitDuration', 30 * 1000],

    /*
    maximum consecutive network failures
    */
    maxAttemptsOnFailure: ['maxAttemptsOnFailure', 18],

    /*
    whether to fail all locations before declaring streaming failure
    */
    exhaustAllLocationsForFailure: ['exhaustAllLocationsForFailure', true],

    /*
    maximum number of network errors during buffering (These errors may not be consecutive)
    */
    maxNetworkErrorsDuringBuffering: ['maxNetworkErrorsDuringBuffering', 20],

    /*
    maximum buffering time allowed if the player has received more than maxNetworkErrorsDuringBuffering
    */
    maxBufferingTimeAllowedWithNetworkError: ['maxBufferingTimeAllowedWithNetworkError', 60 * 1000],

    /*
    fast domain selection bandwidth threshold
    */
    fastDomainSelectionBwThreshold: ['fastDomainSelectionBwThreshold', 2000],

    /*
    buffer threshold for entering the throughput probing mode
    */
    throughputProbingEnterThreshold: ['throughputProbingEnterThreshold', 40 * 1000],

    /*
    buffer threshold fo exiting the throughput probing mode
    */
    throughputProbingExitThreshold: ['throughputProbingExitThreshold', 34 * 1000],

    /*
    The maximum time the location selector spends on probing
    */
    locationProbingTimeout: ['locationProbingTimeout', 10 * 1000],

    /*
    Don’t probe other locations if the selected location’s throughput is higher than this
    */
    finalLocationSelectionBwThreshold: ['finalLocationSelectionBwThreshold', 10 * 1000],

    /*
    The location does not need more information if its throughput confidence is higher than throughputHighConfidenceLevel
    */
    throughputHighConfidenceLevel: ['throughputHighConfidenceLevel', 0.75],

    /*
    The location needs more information if its throughput confidence is lower than throughputLowConfidenceLevel
    */
    throughputLowConfidenceLevel: ['throughputLowConfidenceLevel', 0.4],

    /*
    Interval for non-current location statistics update to account for expiration
    */
    locationStatisticsUpdateInterval: ['locationStatisticsUpdateInterval', 60000 ],

    //=========================================================================
    // From streaming manager
    //=========================================================================

    // ms to wait for scheduled pipeline to run
    pipelineScheduleTimeoutMs: ['pipelineScheduleTimeoutMs', 2],

    // Max bumber of partial requests when buffering
    maxPartialBuffersAtBufferingStart: ['maxPartialBuffersAtBufferingStart', 2],

    // Min/Max partial buffer duration
    minPendingBufferLen: ['minPendingBufferLen', 3000],
    maxPendingBufferLen: ['maxPendingBufferLen', 6000],

    // Don't allow one pipeline to get too far ahead of the other
    maxStreamingSkew: ['maxStreamingSkew', 2000],

    // Percent of partial buffers allowed
    maxPendingBufferPercentage: ['maxPendingBufferPercentage', 10],

    // Max number of requests - 4 minutes with 2 seconds per buffer
    maxRequestsInBuffer: ['maxRequestsInBuffer', 120],

    // size to read for header request
    headerRequestSize: ['headerRequestSize', 4096],

    // minimum buffer length for opportunistic header downloading
    minBufferLenForHeaderDownloading: [ 'minBufferLenForHeaderDownloading', 10000 ],

    // max time of skip back buffer to hold requests for
    reserveForSkipbackBufferMs: ['reserveForSkipbackBufferMs', 15 * 1000],

    // enable / disable parallel streaming with pipelining
    pipelineEnabled: ['pipelineEnabled', true],

    // number of parallel connections
    maxParallelConnections: ['maxParallelConnections', 3],

    // default socket receive buffer size
    socketReceiveBufferSize: ['socketReceiveBufferSize', 0],

    // TODO: need to hook up with system capability
    // audio socket receive buffer size
    audioSocketReceiveBufferSize: ['audioSocketReceiveBufferSize', 32768],

    // audio socket receive buffer size
    videoSocketReceiveBufferSize: ['videoSocketReceiveBufferSize', 65536],

    // audio socket receive buffer size
    headersSocketReceiveBufferSize: ['headersSocketReceiveBufferSize', 32768],

    // interval to check for pts changes
    updatePtsIntervalMs: ['updatePtsIntervalMs', 1000],

    // interval to notify buffer levels
    bufferLevelNotifyIntervalMs: ['bufferLevelNotifyIntervalMs', 2000],

    // enable abandon testing
    enableAbortTesting: ['enableAbortTesting', false],

    // abandon's every Nth request
    abortRequestFrequency: ['abortRequestFrequency', 8],

    // interval to log streaming statistics
    streamingStatusIntervalMs: ['streamingStatusIntervalMs', 2000],

    // After this time elapses while prebuffering, start playback
    prebufferTimeLimit: ['prebufferTimeLimit', 60 * 1000],

    // Minimum video buffer level required for an audio track switch
    minBufferLevelForTrackSwitch: ['minBufferLevelForTrackSwitch', 2000],

    // Parameters to adjust buffering when encoutering long delay or network errors
    enablePenaltyForLongConnectTime: ['enablePenaltyForLongConnectTime', false],
    penaltyFactorForLongConnectTime: ['penaltyFactorForLongConnectTime', 2],
    longConnectTimeThreshold: ['longConnectTimeThreshold', 200],
    additionalBufferingLongConnectTime: ['additionalBufferingLongConnectTime', 2000],
    additionalBufferingPerFailure: ['additionalBufferingPerFailure', 8000],

    // Buffering complete rebuffer check duration
    rebufferCheckDuration: [ 'rebufferCheckDuration', 60000 ],

    // Enable lookahead hints for Open Connect
    enableLookaheadHints: [ 'enableLookaheadHints', false ],

    // Number of fragments to provide as a lookahead hint to OC
    lookaheadFragments: [ 'lookaheadFragments', 2 ],

    // Test: update drm header requests on network failure
    updateDrmRequestOnNetworkFailure: ['updateDrmRequestOnNetworkFailure', true],

    //Handling the case where Audio Stream and Video Stream has different length, the tolerable amount is different per platform.
    maxDiffAudioVideoEndPtsMs: ['maxDiffAudioVideoEndPtsMs', 1000],

    // Defer adoption of the header cache data outside the Session.open() function in ase-manager
    deferAseHeaderCache : ['deferAseHeaderCache', false],

    // Defer pipeline scheduling until playback starts when fully pre-fetches
    deferAseScheduling : ['deferAseScheduling', false],

    // time before end of movie before marking endOfStream
    timeBeforeEndOfStreamBufferMark : ['timeBeforeEndOfStreamBufferMark', 2000],

    //=========================================================================
    // Header cache
    //=========================================================================

    // default header cache size
    defaultHeaderCacheSize: ['defaultHeaderCacheSize', 4],

    // default header cache data count
    defaultHeaderCacheDataCount: ['defaultHeaderCacheDataCount', 4],

    // maximum number of pending streams when paused for data cache
    headerCacheMaxPendingData: ['headerCacheMaxPendingData', 6],

    // Limit of priority for header cache items fetched
    headerCachePriorityLimit: ['headerCachePriorityLimit', 5],

    // Flush header cache data after adoption
    headerCacheFlushForCircularBuffer: ['headerCacheFlushForCircularBuffer', true],

    // experimental config: flush everything instead of just flushing data
    headerCacheFlushEverything: ['headerCacheFlushEverything', false],

    // experimental config: must adopt both audio and video
    headerCacheAdoptBothAV: ['headerCacheAdoptBothAV', false],

    //=========================================================================
    // Adaptive Parallel Streaming (APS)
    //=========================================================================
    // The time interval that we will run our adaptiving logic
    adaptiveParallelTimeoutMs: ['adaptiveParallelTimeoutMs', 1000], //milli-second
    // Knob for whether to turn on adaptive parallel streaming
    enableAdaptiveParallelStreaming: ['enableAdaptiveParallelStreaming', false],
    // Knob to disable bitrate selection when we only use single connection
    disableBitrateSelectionOnSingleConnection: ['disableBitrateSelectionOnSingleConnection', false],
    // At this buffer level, we are comfortable enough to switch down to single connection
    // The current value is set to be the same as the high watermark
    bufferThresholdToSwitchToSingleConnMs: [ 'bufferThresholdToSwitchToSingleConnMs' , 45000], //milli-second
    // At this buffer level, we need more connections to help us avoid rebuffer
    // Note that there should be some hysteresis between two thresholds to avoid flip-flop
    bufferThresholdToSwitchToParallelConnMs: [ 'bufferThresholdToSwitchToParallelConnMs' , 35000], //milli-second

    //=========================================================================
    // Network failures
    //=========================================================================

    // How long to wait before resetting the network to a non-failed state
    // after a temporary failure
    networkFailureResetWaitMs: ['networkFailureResetWaitMs', 2 * 1000],

    // With no progress for this long, call the temporary network failure
    // permanent
    networkFailureAbandonMs: ['networkFailureAbandonMs', 60 * 1000],

    // When error directory is throttling server failures, it counts up this
    // number for each server before reporting the error to location selector
    // NRDJS-2332
    maxThrottledNetworkFailures: ['maxThrottledNetworkFailures', 3],

    // Errors that are throttled by error director and happen more frequently
    // than this for each server are suppressed
    // NRDJS-2332
    throttledNetworkFailureThresholdMs: ['throttledNetworkFailureThresholdMs', 200],

    // NRDJS-2498: enable the feature which aborts the blocks that have not started
    // NRDJS-3939: rename feature enableAbortBlocks -> abortUnsentBlocks
    // NRDJS-4759: re-enable by default after fixing regressions and A/B test
    abortUnsentBlocks: ["abortUnsentBlocks", true],

    // NRDJS-3939: limit the number of unsent blocks when abortUnsentBlocks is true
    maxUnsentBlocks: ['maxUnsentBlocks', 2],

    // a threshold to classify the player's throughput to be too low
    lowThroughputThreshold: ["lowThroughputThreshold", 400],

    // time spent at each bitrate for the round robin algorithm
    timeAtEachBitrateRoundRobin: ["timeAtEachBitrateRoundRobin", 10000],
    roundRobinDirection:         ["roundRobinDirection", 'forward'], // 'forward' or 'reverse'

    // hack for working around ambiguous https error codes
    hackForHttpsErrorCodes: ["hackForHttpsErrorCodes", false],

    httpsConnectErrorAsPerm: ["httpsConnectErrorAsPerm", false],

    // ----------------
    // Needed by Cadmium
    // ----------------
    // This should always be false for NRDJS,
    // Because NRDJS DRM engine depends on the parser in ASE to trigger events

    mp4ParsingInNative: ['mp4ParsingInNative', false],

    pruneRequestsFromNative: ["pruneRequestsFromNative", false],

    // CAD-2570
    preciseBufferLevel: ["preciseBufferLevel", false],

    // NRDJS-3425: enable to collect debug messages
    enableManagerDebugTraces: ["enableManagerDebugTraces", false],
    managerDebugMessageInterval: ["managerDebugMessageInterval", 1000],
    managerDebugMessageCount: ["managerDebugMessageCount", 20],

    // NRDJS-4273: Clean up after verifying in the field
    notifyManifestCacheEom: ["notifyManifestCacheEom", false],

    // NRDJS-4301
    enableUsingHeaderCount: ["enableUsingHeaderCount", false],

    // NRDJS must be true, cadmium should be false to support recover from StreamingFailure
    sourceBufferInOrderAppend: ["sourceBufferInOrderAppend", true],

    allowAudioToStreamPastVideo: ["allowAudioToStreamPastVideo", false],

    // This should only be used with pruneRequestsFromNative
    // When set to true, we leave the aborted MediaRequest in the _unsent/sent queue in RequestManager
    // RequestManager will prune the request and reset StreamingPts during the process of syncing from native media Buffer
    allowReissueMediaRequestAfterAbort: ["allowReissueMediaRequestAfterAbort", false],

    // When currentPts is in the middle of a chunk, NRDJS take the whole chunk into the buffer level calculation
    // However, since Cadmium's chunk can be as big as 16 seconds, this bloated calculation can be misleading when driving the pipeline
    preciseBufferCalculation: ['preciseBufferCalculation', false],

    // When this is enabled, we take gap into consideration when calculate the buffer level
    countGapInBuffer: ['countGapInBuffer', false],

    // allow calls to stream selector even when there is no pipeline vacancy
    // first use is for Cadmium to get a signal on when a bitrate becomes unfeasible
    allowCallToStreamSelector: ['allowCallToStreamSelector', false],

    // threshold below which if a stream is infeasible, ASE will signal to the native layer
    // the native layer then has the option to abort in progress requests
    bufferThresholdForAbort: ['bufferThresholdForAbort', 20000],

    //=========================================================================
    // Various command line options
    //=========================================================================

    // Choosing different stream selection algorithms
    streamSelectorAlgorithm: ['ase_stream_selector', 'optimized'],

    // Choose a different selectStarting() function within the optimized stream selector
    // Availble options: 'default', 'simplified'
    initBitrateSelectorAlgorithm: ['initBitrateSelectorAlgorithm', 'default'],

    // Failure simulation for location selector
    debugLocationSelectorFailureSimulation: ['ase_ls_failure_simulation', ''],

    // Wheter manager dumps out fragments
    debugDumpFragments: ['ase_dump_fragments', false],

    // Fake throughput in Kbps to use for location history
    debugLocationHistoryThroughput: ['ase_location_history', 0],

    // Fake throughput in Kbps to use for network monitor
    debugNetworkMonitorThroughput: ['ase_throughput', 0],

    // Whether simulation should be verbose
    debugVerboseSimulation: ['ase_simulate_verbose', false],

    // Which margin predictor we would like to use
    // 'simple' for SimpleMarginPredictor,
    // 'scaled' for ScaledMarginPredictor
    // anything else will be defaulted to use SimpleMarginPredictor
    marginPredictor: ['marginPredictor', 'simple'],

    // Whether to install a backup timer in Error Director that will fail
    // the network permanently if there is no successful data received after
    // maxBufferingTimeAllowedWithNetworkError ms have elapsed since an
    // underflow
    useBackupUnderflowTimer: ['useBackupUnderflowTimer', true],

    // Whether to look for and use DRM headers from the manifest
    useManifestDrmHeader: ['useManifestDrmHeader', true],

    // Use only DRM headers from manifests or LDLs - ignores DRM headers from the
    // header cache or content.
    useOnlyManifestDrmHeader: ["useOnlyManifestDrmHeader", true],

    logChunkLevelTput: ["logChunkLevelTput", false],

    // ASE-28: Only quickly react to throughput drop, not to throughput increase
    logOverallTputAsRef: ["logOverallTputAsRef", false],

    overallTputInterval: ['overallTputInterval', Infinity],

    maxIQRSamples: ["maxIQRSamples", 100],

    bufferBased: ["bufferBased", {}],

    // how frequently should we persist network and location history
    // 0 means do not persist periodically, just at the end of playback
    periodicHistoryPersistMs: ["periodicHistoryPersistMs", 0]
};

module.exports = defaults;

},{}],47:[function(require,module,exports){
module.exports=require(45);
},{"45":45}],48:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var enums = {

    /**
    * @const
    */
    PLAYER_STATE: {
        STARTING:   0,
        BUFFERING:  1,
        REBUFFERING: 2,
        PLAYING:    3,
        STOPPING:   4,
        STOPPED:    5,

        name: [
            'STARTING',
            'BUFFERING',
            'REBUFFERING',
            'PLAYING',
            'STOPPING',
            'STOPPED',
        ]
    },

    /**
    * @const
    */
    BUFFER_BASED_STATE: {
        STARTUP:   0,
        STEADY:  1,

        name: [
            'STARTUP',
            'STEADY',
        ]
    },

    /**
    * @const
    */
    HEURISTIC_STATE: {
        STARTING:   0,
        STABLE:     1,
        UNSTABLE:   2,

        name: [
            'STARTING',
            'STABLE',
            'UNSTABLE'
        ]
    },

    /**
    * @const
    */
    MEDIA_TYPE: {
        AUDIO:      0,
        VIDEO:      1,

        name: [
            'AUDIO',
            'VIDEO'
        ]
    },

    /**
    * @const
    */
    MEDIA_REQUEST_TYPE: {
        AUDIO:      0,
        VIDEO:      1,
        HEADERS:    2,

        name: [
            'AUDIO',
            'VIDEO',
            'HEADERS'
        ]
    },

    /**
    * @const
    */
    FAILURE_ENTITY: {
        URL:        0,
        SERVER:     1,
        LOCATION:   2,
        NETWORK:    3,

        name: [
            'URL',
            'SERVER',
            'LOCATION',
            'NETWORK'
        ]
    },

    /**
    * @const
    */
    NETWORK_CONFIDENCE: {
        HAVE_NOTHING : 0,
        HAVE_SOMETHING: 1,
        HAVE_MINIMUM : 2,
        HAVE_ENOUGH: 3,

        name: [ 'HAVE_NOTHING',
                'HAVE_SOMETHING',
                'HAVE_MINIMUM',
                'HAVE_ENOUGH' ]
    },

    /**
    * @const
    */
    PROBING_REASON: {
        STARTUP : 0,
        REBUFFER : 1,
        SEEK : 2,
        FAILURE: 3,
        PERFORMANCE: 4,

        name: [ 'startup', 'rebuffer', 'seek', 'dlfail', 'perfprobe' ]

    },

    /**
    * @const
    */
    SELECTION_REASON: {
        BANDWIDTH: 0,
        FASTSELECTION: 1,
        PREVIOUS: 2,
        NEXT: 3,
        ONLY: 4,
        TOLOWGRADE: 5,
        FROMLOWGRADE: 6,
        MCQUEEN: 7,

        name: [ 'maxweightedbw',
                'fastselection',
                'reuseprevious',
                'nextdomain',
                'onlychoice',
                'tolowgrade',
                'fromlowgrade',
                'mcqueen' ]
    },

    /**
    * @const
    */
    END_OF_STREAM_ERROR: {
        NETWORK:                    0,
        DECODE:                     1,

        name:[
            'NETWORK',
            'DECODE'
        ]

    },

};

module.exports = enums;

},{}],49:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

/* global setTimeout, clearTimeout */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

var mixin = require(95),
    EventEmitter = require(94).EventEmitter,
    _ = require(103),

    platform = require(61),
    console = new platform.Console('ASEJS_ERROR_DIRECTOR', 'asejs'),
    DEBUG = ("debug" !== 'release'),

    config = require(47),

    Enums = require(48),

    MediaRequest = platform.MediaRequest;

//=============================================================================
// Map of failure codes to entity/permanent
// Using error table in JS-ASE error handling doc
//=============================================================================

var NETWORK_TEMP    = [Enums.FAILURE_ENTITY.NETWORK, false],
    NETWORK_PERM    = [Enums.FAILURE_ENTITY.NETWORK,  true],
    SERVER_TEMP     = [Enums.FAILURE_ENTITY.SERVER,  false],
    SERVER_PERM     = [Enums.FAILURE_ENTITY.SERVER,   true],
    URL_PERM        = [Enums.FAILURE_ENTITY.URL,      true],

    IGNORE          = [],

    // Same as SERVER_TEMP, but different array
    SERVER_THROTTLE = [Enums.FAILURE_ENTITY.SERVER,  false];

var ENF = MediaRequest.ERRORCODES;

var errorMap = {};

errorMap[ENF.DNS_ERROR]                         = SERVER_TEMP;
errorMap[ENF.DNS_TIMEOUT]                       = SERVER_TEMP;
errorMap[ENF.DNS_QUERY_REFUSED]                 = SERVER_TEMP;
errorMap[ENF.DNS_NOT_FOUND]                     = SERVER_PERM;
errorMap[ENF.CONNECTION_REFUSED]                = SERVER_PERM;
errorMap[ENF.CONNECTION_TIMEOUT]                = SERVER_THROTTLE;
errorMap[ENF.CONNECTION_CLOSED]                 = SERVER_THROTTLE;
errorMap[ENF.CONNECTION_RESET]                  = IGNORE;
errorMap[ENF.CONNECTION_RESET_ON_CONNECT]       = SERVER_THROTTLE;
errorMap[ENF.CONNECTION_RESET_WHILE_RECEIVING]  = SERVER_THROTTLE;
errorMap[ENF.CONNECTION_NET_UNREACHABLE]        = SERVER_TEMP;
errorMap[ENF.CONNECTION_NO_ROUTE_TO_HOST]       = SERVER_TEMP;
errorMap[ENF.CONNECTION_NETWORK_DOWN]           = NETWORK_TEMP;
errorMap[ENF.CONNECTION_NO_ADDRESS]             = SERVER_PERM;
errorMap[ENF.CONNECTION_ERROR]                  = SERVER_THROTTLE;
errorMap[ENF.HTTP_CONNECTION_ERROR]             = SERVER_THROTTLE;
errorMap[ENF.HTTP_CONNECTION_TIMEOUT]           = SERVER_THROTTLE;
errorMap[ENF.HTTP_CONNECTION_STALL]             = SERVER_THROTTLE;
errorMap[ENF.HTTPS_CONNECTION_ERROR]            = config.httpsConnectErrorAsPerm ? SERVER_PERM : SERVER_THROTTLE;
errorMap[ENF.HTTPS_CONNECTION_TIMEOUT]          = SERVER_THROTTLE;
errorMap[ENF.HTTPS_CONNECTION_REDIRECT_TO_HTTP] = URL_PERM;
errorMap[ENF.HTTP_PROTOCOL_ERROR]               = SERVER_PERM;
errorMap[ENF.HTTP_RESPONSE_4XX]                 = URL_PERM;
errorMap[ENF.HTTP_RESPONSE_420]                 = NETWORK_PERM;
errorMap[ENF.HTTP_RESPONSE_5XX]                 = SERVER_PERM;
errorMap[ENF.HTTP_TOO_MANY_REDIRECTS]           = URL_PERM;
errorMap[ENF.HTTP_TRANSACTION_TIMEOUT]          = SERVER_THROTTLE;
errorMap[ENF.HTTP_MESSAGE_LENGTH_ERROR]         = SERVER_PERM;
errorMap[ENF.HTTP_HEADER_LENGTH_ERROR]          = SERVER_PERM;

//------------------------------------------------------------------------------
// Unsure about these. See NRDJS-3139

errorMap[ENF.DNS_BAD_FAMILY]                    = SERVER_TEMP;
errorMap[ENF.DNS_BAD_FLAGS]                     = SERVER_TEMP;
errorMap[ENF.DNS_BAD_HINTS]                     = SERVER_TEMP;
errorMap[ENF.DNS_BAD_NAME]                      = SERVER_TEMP;
errorMap[ENF.DNS_BAD_STRING]                    = SERVER_TEMP;
errorMap[ENF.DNS_CANCELLED]                     = SERVER_TEMP;
errorMap[ENF.DNS_CHANNEL_DESTROYED]             = SERVER_TEMP;
errorMap[ENF.DNS_CONNECTION_REFUSED]            = SERVER_TEMP;
errorMap[ENF.DNS_EOF]                           = SERVER_TEMP;
errorMap[ENF.DNS_FILE]                          = SERVER_TEMP;
errorMap[ENF.DNS_FORMAT_ERROR]                  = SERVER_TEMP;
errorMap[ENF.DNS_NOT_IMPLEMENTED]               = SERVER_TEMP;
errorMap[ENF.DNS_NOT_INITIALIZED]               = SERVER_TEMP;
errorMap[ENF.DNS_NO_DATA]                       = SERVER_TEMP;
errorMap[ENF.DNS_NO_MEMORY]                     = SERVER_TEMP;
errorMap[ENF.DNS_NO_NAME]                       = SERVER_TEMP;
errorMap[ENF.DNS_QUERY_MALFORMED]               = SERVER_TEMP;
errorMap[ENF.DNS_RESPONSE_MALFORMED]            = SERVER_TEMP;
errorMap[ENF.DNS_SERVER_FAILURE]                = SERVER_TEMP;

errorMap[ENF.SOCKET_ERROR]                      = SERVER_THROTTLE;
errorMap[ENF.TIMEOUT]                           = NETWORK_TEMP;

//------------------------------------------------------------------------------

var criticalMap = {};

criticalMap[ENF.CONNECTION_TIMEOUT]             = true;
criticalMap[ENF.HTTP_CONNECTION_TIMEOUT]        = true;
criticalMap[ENF.HTTP_CONNECTION_STALL]          = true;
criticalMap[ENF.HTTPS_CONNECTION_TIMEOUT]       = true;
criticalMap[ENF.DNS_TIMEOUT]                    = true;

//=============================================================================
// ErrorDirector
//=============================================================================

function ErrorDirector(events, locationSelector) {

    this.locationSelector = locationSelector;

    // Events from LS
    this.locationSelector.on('networkFailed', this.handleNetworkFailed.bind(this));

    // Set our last success time
    this.lastSuccessMono = platform.time.mono();

    // counter for critical network errors during buffering
    this.criticalNetworkErrorCount = 0;

    // Attach to incoming events from manager
    var updateLastSuccess = this.updateLastSuccess.bind(this);
    var onBufferingStarted = this.onBufferingStarted.bind(this);
    events.on('underflow', this.onUnderflow.bind(this));
    events.on('requestProgress', updateLastSuccess);
    events.on('requestComplete', updateLastSuccess);
    events.on('startBuffering', onBufferingStarted);

    this.throttledServerErrors = {};

    // Initialize failure simulation
    this.initFailureSimulation();
}

mixin(EventEmitter, ErrorDirector.prototype);

//=============================================================================
// SM reports errors into here
//=============================================================================

ErrorDirector.prototype.reportFailure = function reportFailure( httpCode, failureCode, nativeCode, affected) {
    var failureName = MediaRequest.ERRORCODES.name[failureCode],
        tuple = errorMap[failureCode],
        entity,
        permanent,
        servers,
        locationSelector = this.locationSelector;

    console.warn("Failure " + failureName +
        " on " + JSON.stringify(affected)  +
        " : critical error count = " + this.criticalNetworkErrorCount);

    this.lastFailure = {
        httpCode: httpCode,
        failureCode: failureCode,
        failureName: failureName,
        nativeCode: nativeCode
    };

    if (criticalMap[failureCode]) {
        ++this.criticalNetworkErrorCount;
    }

    if (!_.isArray(tuple)) {
        console.error("Unmapped failure code in JSASE error director : " + failureCode);
        return;
    }

    if (tuple === IGNORE) {
        return;
    }

    // See what is affected by this error: it could be just a single URL or,
    // a host/port combination that we need to map

    if (affected.url) {
        servers = {};
        servers[locationSelector.serverForUrl(affected.url)] = [affected.url];
    } else if (affected.host) {
        servers = locationSelector.serversForHost(affected.host, affected.port);
    } else {
        console.error("Invalid affected for network failure");
        return;
    }

    // What our error map says to do with it

    entity = tuple[0];
    permanent = tuple[1];

    // Iterate over all the servers and their urls

    _.forEach(servers, function(urls, server) {

        // If it is a throttled error, we see whether it should be forwarded
        // to location selector or simply noted here. If it needs to be reported
        // we fall through to reporting it on each URL

        if (tuple === SERVER_THROTTLE && !this.reportServerThrottledFailure(server)) {
            return;
        }

        // Now iterate over all the URLs for this server

        urls.some(function(url) {

            // Report the error to location selector

            locationSelector.reportFailure(entity, permanent, url);

            // If the entity is a server, we don't need to report the error for
            // all of its URLs, just one will do, because the failure will
            // count against its server.

            return entity === Enums.FAILURE_ENTITY.SERVER;
        });
    }, this);
};

//=============================================================================
// Decide whether a throttled error should be reported. Returns true if so
//=============================================================================

ErrorDirector.prototype.reportServerThrottledFailure = function reportServerThrottledFailure(server) {

    var now = platform.time.mono(),
        state;

    state = this.throttledServerErrors[server];

    // First error for this server
    if (!state) {
        this.throttledServerErrors[server] = {last: now, count: 1};
        DEBUG && console.trace('New throttled error for server ' + server);
        return;
    }

    // If we got some data since the last error, we reset the count
    if (state.last < this.lastSuccessMono) {
        state.last = now;
        state.count = 1;
        DEBUG && console.trace('Reset throttled error count for server ' + server);
        // handled
        return;
    }

    // If the last error took place a short time ago, we suppress it
    if (state.last >= (now - config.throttledNetworkFailureThresholdMs)) {
        DEBUG && console.trace('Suppressing error for server ' + server);
        return;
    }

    // We already reported this
    if (state.reported) {
        DEBUG && console.trace('Error already reported for server ' + server);
        return;
    }

    // Last failure is now, and increment the failure count
    state.last = now;
    ++state.count;

    DEBUG && console.trace('Error count is now ' + state.count + ' for server ' + server);

    // Have not reached the max
    if (state.count < config.maxThrottledNetworkFailures) {
        return;
    }

    // Reached the max errors, we need to report it
    DEBUG && console.log('Reached max throttled errors for server ' + server);
    state.reported = true;
    return true;
};

//=============================================================================
// Event about network failure from LS
//=============================================================================

ErrorDirector.prototype.handleNetworkFailed = function handleNetworkFailed(isPermanent) {

    var mono = platform.time.mono(),
        msSinceLastSuccess = mono - this.lastSuccessMono,
        streamingFailure = isPermanent,
        lastFailureCode,
        lastHttpCode,
        lastNativeCode;

    console.warn('Network has failed ' + (isPermanent ? 'permanently' : 'temporarily') +
        ' last success was ' + msSinceLastSuccess + ' ms ago');

    // A temporary failure but it has been a long time since we got a success
    // from SM, so we emit a streamingFailure event and let SM decide whether
    // it wants to reset or call it
    if (!isPermanent && msSinceLastSuccess > config.networkFailureAbandonMs) {
        console.warn('Past abandon time (' + config.networkFailureAbandonMs + '), giving up!');
        streamingFailure = true;
    }

    // Clear pending reset, if any, and emit streamingFailure
    if (streamingFailure) {
        if (this.resetPending) {
            clearTimeout(this.resetPending);
            delete this.resetPending;
        }
        // Clear underflow timeout, if any
        this.clearUnderflowTimeout();

        console.warn("Emitting streaming failure, last error was : " + JSON.stringify(this.lastFailure));
        if (this.lastFailure) {
            lastFailureCode = this.lastFailure.failureCode;
            lastHttpCode = this.lastFailure.httpCode;
            lastNativeCode = this.lastFailure.nativeCode;
        }
        this.emit('streamingFailure', {
            isPermanent: isPermanent,
            originalErrorCode: lastFailureCode,
            originalHttpCode: lastHttpCode,
            originalNativeCode: lastNativeCode
        });
        return;
    }

    // If we get here, it means that we want to reset the failure state automatically
    // If we have a reset pending, there is no need to do so
    if (this.resetPending) {
        DEBUG && console.log('Reset pending, skipping');
        return;
    }

    // No reset pending, so we schedule one
    DEBUG && console.trace('Resetting network failure state in ' + config.networkFailureResetWaitMs + ' ms');

    this.resetPending = setTimeout((function() {

        delete this.resetPending;
        this.resetFailures();

    }).bind(this), config.networkFailureResetWaitMs);
};

//=============================================================================
/**
* @param {boolean=} resetPerm whether or not we should reset permanent failure, default is false
*/
ErrorDirector.prototype.resetFailures = function resetFailures(resetPerm) {
    if (!this.resetPending) {
        DEBUG && console.trace('Resetting network failure state now');
        this.locationSelector.resetFailures(!!resetPerm);
        this.throttledServerErrors = {};
        this.emit('networkFailureReset');
    }
};

//=============================================================================

ErrorDirector.prototype.updateLastSuccess = function updateLastSuccess(timestamp) {
    this.lastSuccessMono = Math.max(timestamp || platform.time.mono(),
        this.lastSuccessMono);
    this.clearUnderflowTimeout();
};

ErrorDirector.prototype.onBufferingStarted = function onBufferingStarted() {
    DEBUG && console.trace('onBufferingStarted: reset criticalNetworkErrorCount');
    this.criticalNetworkErrorCount = 0;
};

ErrorDirector.prototype.onUnderflow = function onUnderflow(timestamp) {
    var ms = config.maxBufferingTimeAllowedWithNetworkError;
    this.lastSuccessMono = Math.max(timestamp || platform.time.mono(),
        this.lastSuccessMono);
    if (config.useBackupUnderflowTimer && !this.underflowTimeout) {
        console.warn("Setting underflow timeout in " + ms + "ms");
        this.underflowTimeout = setTimeout((function() {
            console.warn("Forcing permanent network failure after " + ms + "ms, since underflow with no success");
            delete this.underflowTimeout;
            this.locationSelector.reportFailure(Enums.FAILURE_ENTITY.NETWORK, true);
        }).bind(this), ms);
    }
};

ErrorDirector.prototype.clearUnderflowTimeout = function clearUnderflowTimeout() {
    if (this.underflowTimeout) {
        clearTimeout(this.underflowTimeout);
        delete this.underflowTimeout;
        console.warn("Cleared underflow timeout");
    }
};

//=============================================================================
// Failure simulation
//=============================================================================

ErrorDirector.prototype.initFailureSimulation = function initFailureSimulation() {

    // TODO: should consider compiling this out in production

    var ls = this.locationSelector,
        ed = this,
        simulationName = config.debugLocationSelectorFailureSimulation,
        ctx = {};

    function shuffle(array) {
        var m = array.length, t, i;
        while (m) {
            i = Math.floor(Math.random() * m--);
            t = array[m];
            array[m] = array[i];
            array[i] = t;
        }
        return array;
    }

    switch (simulationName) {
        case '1':
            ls.on('manifestAdded', function() {
                var urls = [];
                ctx.n = ctx.n || 0;
                ls.forEachUrl(function (location, server, stream, url) {
                    if (!ctx[url.id]) {
                        ctx[url.id] = true;
                        urls.push(url.id);
                    }
                });
                shuffle(urls).forEach(function(url) {
                    setTimeout(function() {
                        ed.reportFailure( MediaRequest.ERRORCODES.HTTP_RESPONSE_5XX, {url: url});
                    }, 4000 + ctx.n);
                    ctx.n += 1000;
                });
            });
            break;

        case '2':
            ls.on('manifestAdded', function() {
                var urls = [],
                    n = 0;
                ls.forEachUrl(function (location, server, stream, url) {
                    if (!ctx[url.id]) {
                        ctx[url.id] = true;
                        urls.push({bitrate: stream.bitrate, url: url.id});
                    }
                });
                urls.sort(function(a, b) {
                    return b.bitrate - a.bitrate;
                })
                .map(function(item) {
                    return item.url;
                })
                .forEach(function(url) {
                    setTimeout(function() {
                        if (!ls.failed()) {
                            //ed.reportFailure( MediaRequest.ERRORCODES.HTTP_CONNECTION_ERROR, {url: url});
                            ed.reportFailure( MediaRequest.ERRORCODES.HTTP_RESPONSE_4XX, {url: url});

                        }
                    }, Math.random() * 5000);
                    n += 1000;
                });
            });
            break;

        default:
            return;
    }

    console.warn('Initialized network failure simulation "' + simulationName + '"');
};

//=============================================================================

module.exports = ErrorDirector;


},{"103":103,"47":47,"48":48,"61":61,"94":94,"95":95}],50:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights. Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var BYTES_PER_FRAGMENT = 16;
var MAX_UINT_VALUE = Math.pow(2, 32);

/**
 * @constructor
 */
function Fragment(view, index) {
    this.view = view;
    this.start = BYTES_PER_FRAGMENT * index;
    this.bytes = view.getUint32(this.start);
    this.duration = view.getUint16(this.start + 14);
    this.index = index;
}
Fragment.BYTES_PER_FRAGMENT = BYTES_PER_FRAGMENT;

////////////////////
// Fragment Format:
// [size] 4 bytes
// [startPts] 4 bytes
// [offset] 6 bytes
// [duration] 2 bytes
//
// NOTE: Data is written to this format directly by the optimized parser in mp4.js, the set
//       methods below are not used. Changes to this format need to be implemented in that
//       parser as well.
////////////////////
Object.defineProperties(Fragment.prototype, {

	startPts: { get: function() { return this.view.getUint32(this.start + 4); } },

    offset: { get: function() {
    							var higher = this.view.getUint32(this.start + 8);
    							var lower = this.view.getUint16(this.start + 12);
    							return higher * 0x10000 + lower;
                            }
			}
});

Fragment.prototype.constructor = Fragment;
/**
 * @constructor
 */
function FragmentListView(buffer) {
    this.view = new DataView(buffer, 0);
    this.length = buffer.byteLength / Fragment.BYTES_PER_FRAGMENT;
    this.endPts = this.getFragmentStart( this.length - 1 ) + this.getFragmentDuration( this.length - 1 );
}

FragmentListView.prototype.constructor = FragmentListView;

FragmentListView.prototype.getFragment = function getFragment(index) {
    return new Fragment(this.view, index);
};
FragmentListView.prototype.getFragmentDuration = function getFragmentDuration(index) {
    return this.view.getUint16(BYTES_PER_FRAGMENT * index + 14);
};
FragmentListView.prototype.getFragmentStart = function getFragmentStart(index) {
    return this.view.getUint32(BYTES_PER_FRAGMENT * index + 4);
};
FragmentListView.prototype.getFragmentSize = function getFragmentSize(index) {
    return this.view.getUint32(BYTES_PER_FRAGMENT * index);
};
FragmentListView.prototype.getFragments = function getFragments( index, count ) {
    return new DataView( this.view.buffer, index * Fragment.BYTES_PER_FRAGMENT, count * Fragment.BYTES_PER_FRAGMENT );
};
FragmentListView.prototype.getFragmentsArray = function getFragments( index, count ) {
    return new Uint8Array( this.view.buffer, index * Fragment.BYTES_PER_FRAGMENT, count * Fragment.BYTES_PER_FRAGMENT );
};
FragmentListView.prototype.find = function find( pts ) {
    var l = 0, h = this.length - 1, m;
    var start, duration;

    while( h >= l ) {
        m = l + ( ( h - l ) >> 1 );
        start = this.getFragmentStart(m);

        if ( pts < start ) {
            h = m - 1;
        } else {
            duration = this.getFragmentDuration(m);
            if ( pts >= (start+duration) ) {
                l = m + 1;
            } else {
                return m;
            }
        }
    }

    return -1;
};
FragmentListView.prototype.toString = function toString(){
	return "fragment length: " + this.length;
};
FragmentListView.prototype.toJSON = FragmentListView.prototype.toString;

//////////////////////////////////////
// Export
//////////////////////////////////////
module.exports = {
                    Fragment: Fragment,
                    FragmentListView: FragmentListView
                 };

},{}],51:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */
("clear" === 'obfuscate') && jscrambler &&
    jscrambler("jscrambler ignore_transformations_@ jscrambler_high");
var _ = require(103);

var platform = require(61);
var MediaRequest = platform.MediaRequest;
var Promise = platform.Promise;
var console = new platform.Console('HEADERCACHE', 'media|asejs');
var DEBUG = ("debug" !== 'release');

var Events = require(94);
var EventEmitter = Events.EventEmitter;
var EventListenerGroup = Events.EventListenerGroup;

var config = require(47);

var Enums = require(48);
var Mp4Parser = require(56).Mp4Parser;
var LocationSelector = require(54);
var Predictor;
if ( config.marginPredictor === 'scaled' ){
    Predictor = require(62).ScaledMarginPredictor;
} else {
    Predictor = require(62).SimpleMarginPredictor;
}
var StreamSelector = require(66);
var DownloadTrack = platform.DownloadTrack;

// import some util functions
var concatBuffers = require(84).concatBuffers;

var VERBOSE;

////////////////////
// Utilities
////////////////////

var _trace = console.trace.bind(console);
var _warn = console.warn.bind(console);
var _error = console.error.bind(console);

////////////////////
// Utils
////////////////////

// don't really care about abort's callback
var ignoreAbortCallback = {
    onabort: function() {},
    onerror: function() {}
};

function priorityCompare(a, b)
{
    return b.priority - a.priority;  // higher number at lower index
}

// call locationSelector for each streamList
function callLocationSelector(selectors, sourceList, isVideo)
{
    var streamList = selectors.location.updateStreamUrlSelection(
        selectors.player, sourceList);
    if (!streamList)
    {
        _warn("updateStreamSelection returned null list");
        return;
    }

    // call streamSelector
    var predictor = new Predictor();
    var predictorfn;
    var streamSelector;
    if (isVideo)
    {
        predictorfn = predictor.predictVideo;
        streamSelector = selectors.stream[1];
    }
    else
    {
        predictorfn = predictor.predictAudio;
        streamSelector = selectors.stream[0];
    }

    var result = streamSelector.selectStream(
        selectors.player, streamList, undefined, predictorfn);

    if (!result)
    {
        _warn("selectStream returned null");
        return;
    }

    var resultIndex = result.selectedStreamIndex;
    var resultStream = streamList[resultIndex];

    return {
        streamId: resultStream.id,
        mediaType: isVideo ? Enums.MEDIA_TYPE.VIDEO : Enums.MEDIA_TYPE.AUDIO,
        profile: resultStream.profile,
        bitrate: resultStream.bitrate,
        url: resultStream.url,
        location: resultStream.location,
        server: resultStream.server
    };
}

/**
 * @param {Object} selectors
 * @param {Object} track
 * @param {boolean} isVideo
 * @param {boolean} fastplay
 */
function getInfosFromTrack(selectors, track, isVideo, fastplay)
{
    // build streamList for track
    var clearStreamList = [];
    var drmStreamList = [];
    var streams = track["streams"];
    streams.forEach(function(stream) {
        var profile = stream["content_profile"];
        var bitrate = stream["bitrate"];
        var info = {
            profile: profile,

            // fields needed for StreamSelector
            id: stream["downloadable_id"],
            startPts: 0,
            bitrate: bitrate,
            isAvailable: true,
            inRange: true
        };

        var isDrm = (profile.indexOf("none") === -1);
        if (isDrm)
            drmStreamList.push(info);
        else
            clearStreamList.push(info);
    });

    //_trace("clearStreams:", clearStreamList);
    //_trace("drmStreams:", drmStreamList);

    var infos = [];
    var info;
    if (fastplay && (clearStreamList.length !== 0))
    {
        info = callLocationSelector(selectors, clearStreamList, isVideo);
        if (info)
            infos.push(info);
    }

    // add drm streams if we haven't pushed clear streams
    if (!info)
    {
        info = callLocationSelector(selectors, drmStreamList, isVideo);
        if (info)
            infos.push(info);
    }

    //_trace("infos from track:", infos);

    return infos;
}

function getInfosFromManifest(selectors, manifest, audioTrackId, fastplay)
{
    // get video url
    var vtracks = manifest["video_tracks"];
    var vinfos;
    vtracks.some(function(track) {
        if (!track["stereo"]) // ignore 3D tracks
        {
            // add fastplay track
            vinfos = getInfosFromTrack(selectors, track, true, fastplay);
            return true;
        }
    });
    if (_.isUndefined(vinfos))
    {
        _warn("Unable to find video track in manifest");
        return;
    }

    // get audio url
    var atracks = manifest["audio_tracks"];
    var ainfos;
    atracks.some(function(track) {
        if (track["track_id"] == audioTrackId)
        {
            ainfos = getInfosFromTrack(selectors, track, false, fastplay);
            return true;
        }
    });
    if (_.isUndefined(ainfos))
    {
        _warn("Unable to find audio track in manifest:", audioTrackId);
        return;
    }

    var infos = vinfos.concat(ainfos);

    DEBUG && _trace("using manifest streams:", infos);

    return infos;
}

////////////////////
// HeaderCache
////////////////////

/**
* @param {Object} manager
* @constructor
*/
function HeaderCache(manager)
{
    // this creates a circular ref but both are singleton's so shouldn't be a big deal
    this._manager = manager;

    // header requests in progress
    this._headerRequests = Object.create(null);

    // headers indexed by streamId
    this._cache = Object.create(null);
    this._cacheSize = 0;

    // headers in priority order (low priority->high priority), 0 is highest priority
    this._queue = [];

    this._maxCacheSize = config.defaultHeaderCacheSize;
    this._tracks = [];

    // count of number of ase streamers active
    this._streamerCount = 0;

    // data requests paused and queue of pending requests received whilst paused
    this._dataPaused = false;
    this._dataPending = [ ];

    // add event emitter api
    this.addEventListener = EventEmitter.addEventListener;
    this.on = EventEmitter.addEventListener;
    this.removeEventListener = EventEmitter.removeEventListener;
    this.callEventListeners = EventEmitter.callEventListeners;
    this.emit = EventEmitter.callEventListeners;
}

HeaderCache.prototype.constructor = HeaderCache;

Object.defineProperties(HeaderCache.prototype, {
    cache: {
        get: function() { return this._cache; }
    }
});

HeaderCache.prototype.requestAuditCounts = function requestAuditCounts()
{
    return this._tracks.map( function( track ) { return track.requestAuditCounts(); } );
};

HeaderCache.prototype.init = function init(ctxt)
{
    this._ctxt = ctxt;

    if (this._tracks.length === 0)
    {
        DEBUG && _trace("init creating download tracks");

        // create download tracks
        var configs = [
            {
                "type" : this._manager.MEDIA_AUDIO,
                "openRange": false,
                "pipeline": false,
                "connections": 1
            },
            {
                "type" : this._manager.MEDIA_VIDEO,
                "openRange": false,
                "pipeline": false,
                "connections": 1
            }
        ];

        DEBUG && _trace("Creating headerCache download track, config:", configs);

        this._tracks = configs.map( function( config )
        {
            var track = new DownloadTrack( config );

            // Register event handlers
            track._headerCacheListenerGroup = new EventListenerGroup();

            // The error event occurs on create or reconfigure failure.
            // XXX Properly handle create failure
            track._headerCacheListenerGroup.on( track, 'error', function() {} );

            return track;
        } );

        this._makePendingRequests();
    }
};

HeaderCache.prototype._destroyTracks = function _destroyTracks()
{
    var tracks = this._tracks;

    this._tracks = [];

    tracks.forEach(function(track) {
        DEBUG && _trace("destroying headerCache download track:", track);
        track.destroy();
        track._headerCacheListenerGroup.clear();
    });
};

HeaderCache.prototype.destroy = function destroy()
{
    this._destroyTracks();
    this.flush();
};

HeaderCache.prototype.recreateDownloadTracks = function recreateDownloadTracks()
{
    // regardless if tracks are recreated, we should flush the data before destroy
    if (config.headerCacheFlushEverything)
    {
        this.flush();
    }
    else
    {
        this.flushData();
    }

    DEBUG && _trace("recreateDownloadTracks");

    // destroy old tracks
    this._destroyTracks();

    // create new tracks
    this.init(this._ctxt);
};

HeaderCache.prototype.notifyStreamerStart = function notifyStreamerStart()
{
    // increment streamer count
    ++this._streamerCount;

    // pause data
    this._dataPaused = true;

    DEBUG && _trace("streamerStart, count:", this._streamerCount);
};

HeaderCache.prototype.notifyStreamerEnd = function notifyStreamerEnd()
{
    --this._streamerCount;
    DEBUG && _trace("streamerEnd, count:", this._streamerCount,
                    "requests:", this._dataPending.length);

    if (this._streamerCount === 0)
    {
        this._dataPaused = false;

        // if we have tracks, make the pending requests
        if (this._tracks.length > 0)
        {
            this._makePendingRequests();
        }
        else
        {
            // we're not already recreating the tracks, do it now
            DEBUG && _trace("recreating tracks on streamerEnd");

            this.init(this._ctxt);
            // init will call makePendingRequests once the tracks are created
        }
    }
};

HeaderCache.prototype._makePendingRequests = function _makePendingRequests()
{
    if (!this._dataPaused && (this._dataPending.length > 0) &&
        (this._tracks.length !== 0))
    {
        DEBUG && _trace("making pending requests: " + this._dataPending.length);

        // Issue all the pending requests
        // they will be serialized by the download track
        this._dataPending.forEach(function(hdr) {
            this._requestData(hdr.headerRequest, hdr.pts);
        }.bind(this));

        this._dataPending = [];
    }
};

HeaderCache.prototype.prepareP = function prepareP(manager, args)
{
    var movieId = args.movieId;
    var priority = args.priority;
    var pts = args.pts;

    this.setMaxSize(config.defaultHeaderCacheSize);
    DEBUG && _trace("HeaderCache.prepareP maxCacheSize: ", this._maxCacheSize);

    // if tracks were destroyed, recreate them
    if (this._tracks.length === 0)
    {
        DEBUG && _trace("recreating tracks on prepareP");
        this.init(this._ctxt);
    }

    // update priority if already in cache
    var entry = this._cache[movieId];
    if (!_.isUndefined(entry) &&
        ((entry.headerCount >= 2) || !config.enableUsingHeaderCount) )
    {
        DEBUG && _trace("updating existing entry for: " + movieId +
                        " priority: " + entry.priority + "->" + priority);
        entry.priority = priority;

        // resort priority list
        this._queue.sort(priorityCompare);
        VERBOSE && _trace("update priority list:", this._queue);

        // see if we need to request data for this movie
        if (!_.isUndefined(pts))
        {
            if ( entry.data === undefined )
            {
                entry.stats.prebuffstarted = undefined;
            }
            // request data for these entries
            for (var streamId in entry.headers)
            {
                if ( entry.data === undefined || entry.data[streamId] === undefined ||
                     entry.data[streamId].length < config.defaultHeaderCacheDataCount )
                {
                    DEBUG && _trace("requesting data for streamId: ", streamId);
                    this._requestData(entry.headers[streamId], pts);
                }
            }
        }

        return Promise.resolve();
    }

    // ignore if priority is too low
    if (priority > config.headerCachePriorityLimit)
    {
        DEBUG && _trace("ignoring prepare, movieId: " + movieId +
                        " priority: " + priority +
                        " against config limit: " + config.headerCachePriorityLimit);
        return Promise.reject();
    }

    // check priority of new item against existing cache if at limit
    if (((this._cacheSize + 1) > this._maxCacheSize) &&
        (priority > this._queue[0].priority))
    {
        DEBUG && _trace("ignoring prepare, movieId: " + movieId +
                        " priority: " + priority +
                        " against queue[0]: " + this._queue[0].priority);
        return Promise.reject();
    }

    // now request from the manifest
    return this._requestHeader(manager, args);
};

HeaderCache.prototype._requestHeader = function _requestHeader(manager, args)
{
    var movieId = args.movieId;
    var priority = args.priority;
    var pts = args.pts;

    // now we need the manifest and starting track information
    var info = args.getManifestInfo();
    var manifest = info.manifest;
    var fastplay = info.fastplay;
    var audioTrackId = info.audioTrackId;

    DEBUG && _trace("requestHeader priority: " + priority + " movieId: " + movieId +
                    " pts: " + pts + " fastplay: " + fastplay +
                    " audioTrack: " + audioTrackId);

    // create selectors for new manifest
    var selectors = {
        stream: [ new StreamSelector(undefined, undefined, 'selectaudio') /* selector for audio */,
                  new StreamSelector(undefined, undefined, config.streamSelectorAlgorithm) /* selector for video */],
        location: new LocationSelector(
            null, manager._networkMonitor, manager._locationHistory),
        player: {
            state: Enums.PLAYER_STATE.STARTING,
            isHeaderCache: true,
            buffer: {
                capacity: manager._bufferSize[manager.MEDIA_VIDEO],
                startPts: 0,
                currentPts: 0,
                streamingPts: 0,
                completePts: 0,
                partialBytes: 0,
                fragments: []
            }
        }
    };
    selectors.location.addManifest(manifest);

    // get a url from the manifest
    var infos = getInfosFromManifest(selectors, manifest, audioTrackId, fastplay);
    if (!infos)
    {
        DEBUG && _trace("not caching anything for movieId:", movieId);
        return Promise.reject();
    }

    // get movieEntry
    var movieEntry = this._cache[movieId];
    if (!movieEntry)
    {
        // create a new movie entry
        movieEntry = {
            priority: priority,
            movieId: movieId,
            headers: Object.create(null),
            headerCount: 0,
            dataRequestCount: 0,
            data: undefined,
            stats: {}
        };

        this._cache[movieId] = movieEntry;

        // insert item into priority queue
        this._queue.push(movieEntry);
        this._queue.sort(priorityCompare);

        VERBOSE && _trace("add priority list:", this._queue);
    }

    var promiseList = [];
    var byteStart = 0;
    var byteEnd = config.headerRequestSize-1;
    infos.forEach(function(info) {
        // NRDJS-4301
        if (config.enableUsingHeaderCount)
        {
            // ignore if we already have an entry
            if (movieEntry.headers[info.streamId])
            {
                DEBUG && _trace("already have header for streamId: " + info.streamId);
                return;
            }
        }

        var params = {
            movieId: movieId,
            streamId: info.streamId,
            bitrate: info.bitrate,
            url: info.url,
            location: info.location,
            serverId: info.server,
            mediaType: info.mediaType
        };
        var p = this._requestHeaderP(params, byteStart, byteEnd, pts, true);
        promiseList.push(p);
    }.bind(this));

    return Promise.all(promiseList).then(function (results) {
        DEBUG && _trace("all header requests done:", results);

        // find latest time
        var lastCompleteTime = Math.max.apply(Math, results);

        // return a stats object
        return {
            'firstheadersent': movieEntry.stats.headersent,
            'lastheadercomplete': lastCompleteTime
        };
    });
};

HeaderCache.prototype.flush = function flush()
{
    var request;
    DEBUG && _trace("flush");

    // flush any data in the cache
    this.flushData();

    // flushData will call abort on any data request. Additionally, recreating the
    // download tracks will also abort any requests

    // abort any inprogress header request
    for (var streamId in this._headerRequests)
    {
        request = this._headerRequests[streamId];
        DEBUG && _trace("flush aborting header request:", request);
        request.abort(ignoreAbortCallback);
    }

    this._cache = {};
    this._cacheSize = 0;
    this._queue = [];

    if (config.enableManagerDebugTraces)
    {
        var debugMessage = "@ " + platform.time.mono() +
            ", headerCache flush: ";
        this.callEventListeners('managerdebugevent', {message: debugMessage});
    }
};

HeaderCache.prototype.list = function list()
{
    DEBUG && _trace("list");

    return this._queue;
};

HeaderCache.prototype.setMaxSize = function setMaxSize(maxItems)
{
    if ( this._maxCacheSize != maxItems )
    {
        DEBUG && _trace("setMaxSize:", maxItems);
        this._maxCacheSize = maxItems;
        this._checkCacheSize();
    }
};

HeaderCache.prototype.lookupBitrate = function lookupBitrate(movieId, mediaType, drm)
{
    DEBUG && _trace("lookupBitrates: movieId:", movieId, "mediaType:", mediaType,
                    "drm:", drm);

    var entry = this._cache[movieId];
    if (!entry || !entry.data)
    {
        DEBUG && _trace("lookupBitrate: no entry or data for movieId:", movieId);
        return;
    }

    // look for matching data
    for (var streamId in entry.data)
    {
        // check mediaType and drm
        var header = entry.headers[streamId];
        var hasDrm = !!(header.drmHeader || header.nflxHeader);
        if ((header.mediaType === mediaType) &&
            ((drm && hasDrm) || (!drm && !hasDrm)))
        {
            DEBUG && _trace("lookupBitrate returns", header.bitrate);
            return header.bitrate;
        }
    }
};

HeaderCache.prototype.lookupHeader = function lookupHeader(movieId, streamId)
{
    DEBUG && _trace("lookupHeader: movieId:" + movieId + ", streamId:" + streamId);

    var movieEntry = this._cache[movieId];
    if (!movieEntry)
    {
        DEBUG && _trace("lookupHeader: no movieEntry for movieId:" + movieId);
        return;
    }

    var header = movieEntry.headers[streamId];
    if (!header)
    {
        DEBUG && _trace("lookupHeader, no headers for streamId:" + streamId);
        return;
    }

    DEBUG && _trace("lookupHeader, found headers for streamId:" + streamId);
    return header;
};

HeaderCache.prototype.lookupData = function lookupData(movieId)
{
    var result = [];
    var streamId;
    var dataArray;
    var mediaRequest;
    DEBUG && _trace("lookupData: movieId:" + movieId);

    var movieEntry = this._cache[movieId];
    if (!movieEntry)
    {
        DEBUG && _trace("lookupData: no movieEntry for movieId:", movieId);
        return;
    }

    // find an entry that has data
    if (movieEntry.data)
    {
        for (streamId in movieEntry.data)
        {
            DEBUG && _trace("lookupData found data, streamId:", streamId);
            dataArray = movieEntry.data[streamId];
            if ( dataArray.length > 0 )
            {
                result[dataArray[0].mediaType] = {
                    streamId: streamId,
                    header: movieEntry.headers[streamId],
                    data: dataArray
                };
            }
        }
        return result;
    }
};

/**
 * @param {number=} mediaType
 * @param {number=} adoptedStreamId
*/
HeaderCache.prototype.flushData = function flushData(mediaType, adoptedStreamId)
{
    var abortedBytes = 0;

    DEBUG && _trace("flushData mediaType: " + mediaType +
                    ", adopted streamId: " + adoptedStreamId);

    function removeListeners(request)
    {
        DEBUG && _trace("removing listeners for request: " + request);
        request._headerCacheListenerGroup.clear();
    }

    function abortRequests(entry, streamId)
    {
        var data = entry.data[streamId];
        data.forEach(function(request) {
            DEBUG && _trace("aborting movieId: " + entry.movieId +
                            ", streamId: " + streamId + " request: " + request);
            request.abort(ignoreAbortCallback);

            abortedBytes += request.bytesReceived;
        });
    }

    // remove data from entries of this mediaType, aborting if not adopted
    var skipped;
    var entry;
    for (var movieId in this._cache)
    {
        DEBUG && _trace("flushData, for movieId: " + movieId);
        entry = this._cache[movieId];
        if (entry.data)
        {
            skipped = false;
            for (var streamId in entry.data)
            {
                DEBUG && _trace("flushData, checking streamId: " + streamId +
                                ", mediaType: " + entry.headers[streamId].mediaType);

                // check the streamId's mediaType
                if (_.isUndefined(mediaType) ||
                    (entry.headers[streamId].mediaType === mediaType))
                {
                    DEBUG && _trace("flushData, mediaType matches, streamId " + streamId);
                    if (_.isUndefined(adoptedStreamId) || (streamId != adoptedStreamId))
                    {
                        // abort stream's not adopted
                        abortRequests(entry, streamId);
                    }

                    // remove listeners for these requests
                    entry.data[streamId].forEach(removeListeners);

                    // remove these requests
                    delete entry.data[streamId];
                }
                else
                {
                    skipped = true;
                }
            }

            // if data has no more keys, delete it
            if (!skipped)
            {
                // delete the data
                DEBUG && _trace("flushData, deleting entry.data for movieId: " + movieId);
                delete entry.data;
            }
        }
        else
        {
            DEBUG && _trace("flushData, no data for movieId: " + movieId);
        }
    }

    // report the amount of data flushed
    this._reportFlushedBytes(abortedBytes);
};

////////////////////
// private
////////////////////

/**
 * @param {Object} params
 * @param {number} byteStart
 * @param {number} byteEnd
 * @param {number=} ptsStart
 * @param {number=} ptsEnd
 * @private
 */
HeaderCache.prototype._createRequest = function _createRequest(
    params, byteStart, byteEnd, ptsStart, ptsEnd)
{
    // create a new request
    var mediaType = params.mediaType;
    var label = "unknown";

    if ( _.isUndefined( ptsStart ) )
    {
        label = "(cache) " + params.streamId + " header";
    }
    else
    {
        label = "(cache) " + params.streamId + " pts " + ptsStart + "-" + ptsEnd;
    }

    var mediaRequest = new platform.MediaRequest(this._tracks[mediaType],label);

    mediaRequest._headerCacheListenerGroup = new EventListenerGroup();
    mediaRequest._headerCacheListenerGroup.on(
        mediaRequest, MediaRequest.EVENTS.ONLOADSTART,
        _MediaRequestOnLoadStart );
    mediaRequest._headerCacheListenerGroup.on(
        mediaRequest, MediaRequest.EVENTS.ONERROR,
        _MediaRequestOnError );

    mediaRequest.mediaType = mediaType;
    mediaRequest.movieId = params.movieId;
    mediaRequest.streamId = params.streamId;
    mediaRequest.bitrate = params.bitrate;
    mediaRequest.location = params.location;
    mediaRequest.serverId = params.serverId;

    mediaRequest.byteStart = byteStart;
    mediaRequest.byteEnd = byteEnd;
    mediaRequest.ptsStart = ptsStart;
    mediaRequest.ptsEnd = ptsEnd;
    mediaRequest.ptsOffset = 0;

    mediaRequest.isHeader = _.isUndefined(ptsStart);

    // copy in progress data from old request (may not be there)
    mediaRequest.parser = params.parser;
    mediaRequest.headerData = params.headerData;
    mediaRequest.drmHeader = params.drmHeader;
    mediaRequest.nflxHeader = params.nflxHeader;

    mediaRequest.timeCreated = platform.time.mono();
    mediaRequest.headerCache = this;

    return mediaRequest;
};

HeaderCache.prototype._cleanupRequest = function _cleanupRequest(mediaRequest)
{
    // remove from in progress header requests
    if (mediaRequest.isHeader)
    {
        delete this._headerRequests[mediaRequest.streamId];
    }

    // cleanup the request
    DEBUG && _trace("cleanupRequest: " + mediaRequest.toString());
    delete mediaRequest.response;
    mediaRequest._headerCacheListenerGroup.clear();
    mediaRequest.cleanup();
};

HeaderCache.prototype._requestHeaderP = function _requestHeaderP(
    params, byteStart, byteEnd, requestPts, lookahead )
{
    if (this._tracks.length < 2)
    {
        _warn("No track or trackId, can't makeRequest in HeaderCache");
        return Promise.reject();
    }

    // create a new request
    // Note: don't use requestPts as ptsStart as that would indicate a data mediarequest
    var mediaRequest = this._createRequest(params, byteStart, byteEnd);
    mediaRequest.responseType = MediaRequest.RESPONSETYPES.ARRAYBUFFER;
    mediaRequest.requestPts = requestPts;
    DEBUG && _trace("header request, mediaRequest: " + mediaRequest.toString() +
                    ", for streamId: " + params.streamId +
                    ", bytes: " + mediaRequest.byteStart + "-" + mediaRequest.byteEnd +
                    ", url: " + params.url + ", pts: " + requestPts);

    mediaRequest._headerCacheListenerGroup.on(
        mediaRequest,
        MediaRequest.EVENTS.ONCOMPLETE,
        _MediaRequestOnCompleteHeader );

    if (!mediaRequest.open(params.url,
                           {"start": mediaRequest.byteStart, "end": mediaRequest.byteEnd},
                           MediaRequest.RESPONSETYPES.ARRAYBUFFER,
                           {}, // headers
                           undefined,  // enclosing byte range
                           config.enableLookaheadHints ? lookahead : undefined ) )
    {
        return Promise.reject();
    }

    // track the inprogress header requests
    this._headerRequests[mediaRequest.streamId] = mediaRequest;

    return new Promise(function(resolve) {
        mediaRequest.headerCompletionCallback = resolve;
    });
};

HeaderCache.prototype._requestData = function _requestData(headerRequest, pts)
{
    var movieId = headerRequest.movieId;
    var streamId = headerRequest.streamId;
    var url = headerRequest.url;
    var mediaType = headerRequest.mediaType;

    // if tracks were destroyed and not already creating them, recreate them
    if (this._tracks.length === 0)
    {
        DEBUG && _trace("recreating tracks on requestData");
        this.init(this._ctxt);
    }

    // if we're paused or don't have download tracks, queue the data for later requesting
    if (this._dataPaused || (this._tracks.length === 0))
    {
        DEBUG && _trace("queued request data for movieId: " + movieId +
                        ", streamId: " + streamId +
                        ", at pts: " + pts + " whilst paused");

        this._dataPending.push({
            headerRequest: headerRequest,
            pts: pts
        });

        while (this._dataPending.length > config.headerCacheMaxPendingData)
        {
            this._dataPending.shift();
        }

        return;
    }

    DEBUG && _trace("request data for movieId: " + movieId + ", streamId: " + streamId +
                    " at pts: " + pts);

    var movieEntry = this._cache[movieId];
    if (!movieEntry)
    {
        DEBUG && _trace("ignoring data request, movieEntry not found");
        return;
    }

    var fragments = headerRequest.fragments;
    var fragIndex;
    if (headerRequest.mediaType === Enums.MEDIA_TYPE.VIDEO)
    {
        // determine which fragment to start at
        fragIndex = fragments.find(pts);
    }
    else
    {
        // do we have actual startPts?
        if (!_.isUndefined(movieEntry.actualStartPts))
        {
            DEBUG && _trace("using actualStartPts:", movieEntry.actualStartPts);
            fragIndex = fragments.find(movieEntry.actualStartPts);
        }
        else
        {
            // if not, need to wait for it
            DEBUG && _trace("delaying audio data request until after video");
            movieEntry.delayedAudioHeader = headerRequest;
            return;
        }
    }

    if (fragIndex === -1)
    {
        _warn("no proper fragment found to request data at pts", pts);
        return;
    }

    if (config.enableManagerDebugTraces)
    {
        var debugMessage = "@ " + platform.time.mono() +
            ", headerCache requestData: movieId: " + movieId +
            ", streamId: " + streamId +
            ", pts: " + pts;
        this.callEventListeners('managerdebugevent', {message: debugMessage});
    }

    var fragment;
    var mediaRequest;
    var byteStart, byteEnd;
    var ptsStart, ptsEnd;
    var dataArray;
    var mediaRequests = [ ];

    // add mediaRequest to the cache entry
    if ( movieEntry.data === undefined )
    {
        movieEntry.data = Object.create(null);
    }

    if ( movieEntry.data[streamId] === undefined )
    {
        movieEntry.data[streamId] = [ ];
    }

    dataArray = movieEntry.data[streamId];

    while( dataArray.length < config.defaultHeaderCacheDataCount )
    {
        // create next request
        DEBUG && _trace("using fragment: " + (fragIndex) +
                        ", pts: " + ptsStart + "-" + ptsEnd);

        fragment = fragments.getFragment(fragIndex++);
        byteStart = fragment.offset;
        byteEnd = byteStart + fragment.bytes - 1;
        ptsStart = fragment.startPts;
        ptsEnd = ptsStart + fragment.duration;

        // record actual start pts if not there
        if (_.isUndefined(movieEntry.actualStartPts))
        {
            movieEntry.actualStartPts = ptsStart;
        }

        mediaRequest = this._createRequest(headerRequest, byteStart, byteEnd,
                                           ptsStart, ptsEnd);

        DEBUG && _trace("data request, mediaRequest: " + mediaRequest.toString() +
                        ", for streamId: " + streamId +
                        ", pts: " + ptsStart + "-" + ptsEnd +
                        ", byte: " + byteStart + "-" + byteEnd +
                        ", url: " + url);

        mediaRequest._headerCacheListenerGroup.on(  mediaRequest,
                                                    MediaRequest.EVENTS.ONCOMPLETE,
                                                    _MediaRequestOnCompleteData );

        mediaRequests.push( { start: byteStart, end: byteEnd, req: mediaRequest } );

        ++movieEntry.dataRequestCount;

        dataArray.push(mediaRequest);
    }

    if ( mediaRequests.length > 0 )
    {
        var enclosingByteRange;
        if ( config.enableLookaheadHints )
        {
            var blockSizes = mediaRequests.map(function (mr) {
                return mr["end"] - mr["start"] + 1;
            });
            enclosingByteRange = {
                "start" : mediaRequests[ 0 ].start,
                "sizes" : blockSizes
            };
        }

        mediaRequests.forEach( function( mr )
        {
            mr.req.open(    url,
                            { "start" : mr.start, "end" : mr.end },
                            MediaRequest.RESPONSETYPES.STREAM,
                            {},
                            enclosingByteRange,
                            config.enableLookaheadHints ? false : undefined );
        } );
    }

    // check for delayed audio request
    if (movieEntry.delayedAudioHeader)
    {
        DEBUG && _trace("handling delayed audio data request: " +
                        movieEntry.actualStartPts);
        var delayedRequest = movieEntry.delayedAudioHeader;
        delete movieEntry.delayedAudioHeader;

        this._requestData(delayedRequest, movieEntry.actualStartPts);
    }
};

HeaderCache.prototype._addEntry = function _addEntry(mediaRequest)
{
    var movieId = mediaRequest.movieId;
    var streamId = mediaRequest.streamId;
    var mediaType = mediaRequest.mediaType;
    DEBUG && _trace("adding cache entry for movieId: " + movieId +
                    ", streamId: " + streamId +
                    ", mediaType: " + mediaType +
                    ", hasDrm: " + !!(mediaRequest.drmHeader || mediaRequest.nflxHeader));

    var movieEntry = this._cache[movieId];
    if (!movieEntry)
    {
        DEBUG && _trace("addEntry: no movieEntry for " + movieId);
        return;
    }

    if (!movieEntry.addedToCache)
    {
        DEBUG && _trace("entry added to cache, movieId: " + movieId +
                        " priority: " + movieEntry.priority);
        movieEntry.addedToCache = true;
        ++this._cacheSize;
    }

    var headerEntry = {
        // fields needed by possible _requestData
        movieId: movieId,
        streamId: streamId,
        bitrate: mediaRequest.bitrate,
        location: mediaRequest.location,
        server: mediaRequest.serverId,
        url: mediaRequest.url,
        mediaType: mediaType,
        fragments: mediaRequest.fragments,

        headerData: mediaRequest.headerData,
        avgFragmentDurationMs: mediaRequest.avgFragmentDurationMs,
        drmHeader: mediaRequest.drmHeader,
        nflxHeader: mediaRequest.nflxHeader,

        // marked by Cadmium, since it doesn't provide drmHeader
        drmProtected: mediaRequest.drmProtected
    };

    // add headerEntry to movieEntry
    movieEntry.headers[streamId] = headerEntry;
    if (config.enableUsingHeaderCount)
    {
        ++movieEntry.headerCount;
    }

    // make sure we don't go over max size
    this._checkCacheSize();
};

HeaderCache.prototype._checkCacheSize = function _checkCacheSize()
{
    var movieId, movieEntry;
    var abortedBytes = 0;

    if (this._cacheSize <= this._maxCacheSize)
        return;

    DEBUG && _trace("cache exceeds max size: " +
                    this._cacheSize + " > " + this._maxCacheSize);

    function abortRequest(mediaRequest)
    {
        DEBUG && _trace("aborting mediaRequest, " + mediaRequest.toString());
        mediaRequest.abort();

        // remove its listeners
        mediaRequest._headerCacheListenerGroup.clear();

        abortedBytes += mediaRequest.bytesReceived;
    }

    function abortRequestArray(array)
    {
        array.forEach(abortRequest);
    }

    while (this._cacheSize > this._maxCacheSize)
    {
        VERBOSE && _trace("remove priority list:", this._queue);

        // get lowest priority entry from queue
        movieEntry = this._queue.shift();
        if (movieEntry)
        {
            movieId = movieEntry.movieId;
            DEBUG && _trace("removing movieId: " + movieId +
                            " priority: " + movieEntry.priority);

            if (movieEntry.data)
            {
                // abort any requests in this entry
                for (var streamId in movieEntry.data)
                {
                    abortRequestArray(movieEntry.data[streamId]);

                    // remove these requests
                    delete movieEntry.data[streamId];
                }
            }

            delete this._cache[movieId];
            --this._cacheSize;
        }
    }

    // report the amount of data discarded
    this._reportDiscardedBytes(abortedBytes);
};

HeaderCache.prototype._reportDiscardedBytes = function _reportDiscardedBytes(bytes)
{
    if (bytes === 0)
        return;

    DEBUG && _trace("discardedBytes, bytes: " + bytes);
    var evt = {
        'type': "discardedBytes",
        'bytes': bytes
    };
    this.callEventListeners(evt['type'], evt);
};

/**
@param {number} bytes
@param {Object=} reason
*/
HeaderCache.prototype._reportFlushedBytes = function _reportFlushedBytes(bytes, reason)
{
    if (bytes === 0)
        return;

    DEBUG && _trace("flushedBytes, bytes: " + bytes);
    var evt = {
        'type': "flushedBytes",
        'bytes': bytes
    };
    this.callEventListeners(evt['type'], evt);
};

////////////////////
// Event handlers
////////////////////
function _MediaRequestOnLoadStart()
{
    // 'this' is the MediaRequest
    DEBUG && _trace("onLoadStart: ", this );

    var headerCache = this.headerCache,
        movieEntry = headerCache._cache[this.movieId];
    if (!movieEntry)
    {
        DEBUG && _trace("onLoadStart: no movieEntry for " + this.movieId);
        return;
    }

    if (this.isHeader)
    {
        // set the header start time if we haven't already
        if (_.isUndefined(movieEntry.stats.headersent))
        {
            movieEntry.stats.headersent = this.loadTime;
        }
    }
    else
    {
        // set the data start time if we haven't already
        if (_.isUndefined(movieEntry.stats.prebuffstarted))
        {
            movieEntry.stats.prebuffstarted = this.loadTime;
        }
    }
}

function _MediaRequestOnCompleteHeader()
{
    // 'this' is the MediaRequest
    DEBUG && _trace("header request complete, MediaRequest: " + this.toString());
    var headerCache = this.headerCache;

    // record the time complete
    this.timeComplete = this.lastEventTime;

    // save the data prior to cleanup
    var data = this.response;

    // cleanup the request
    headerCache._cleanupRequest(this);

    if (data)
    {
        if (!this.headerData)
        {
            this.headerData = data;
        }
        else
        {
            // append data
            var newData = concatBuffers(this.headerData, data);
            this.headerData = newData;
        }

        DEBUG && _trace("parsing mp4 header for MediaRequest: " + this.toString() +
                        ", dataLength:" + data.byteLength);
        if (config.mp4ParsingInNative)
        {
            // !!! config.mp4ParsingInNative should always be false for NRDJS,
            // Because NRDJS DRM engine depends on the parser in ASE to trigger events
            if (!this.fragments)
            {
                _error(
                    "ASE expect fragments parsed from Native layer, but it's undefined!");
            }

            // MP4 parsing is done at the native layer
            headerCache._addEntry(this);
            this.headerCompletionCallback(this.timeComplete);
        }
        else
        {
            // parse the data
            headerCache._parseMp4Header(this);
        }
    }
}

function _MediaRequestOnCompleteData()
{
    // 'this' is the MediaRequest object
    DEBUG && _trace("onDataComplete:", this );
    var movieId = this.movieId,
        headerCache = this.headerCache;

    var movieEntry = headerCache._cache[movieId];
    if (!movieEntry)
    {
        DEBUG && _trace("onDataComplete, no movieEntry for " + movieId);
        return;
    }

    DEBUG && _trace("data request complete, MediaRequest: " + this.toString() +
                    ", count: " + movieEntry.dataRequestCount);

    if (config.enableManagerDebugTraces)
    {
        var debugMessage = "@ " + platform.time.mono() +
            ", headerCache dataComplete: movieId: " + movieId +
            ", streamId: " + this.streamId +
            ", pts: " + this.ptsStart +
            ", remaining: " + (movieEntry.dataRequestCount-1);
        headerCache.callEventListeners('managerdebugevent', {message: debugMessage});
    }

    // are all data requests done for this movie?
    if (--movieEntry.dataRequestCount === 0)
    {
        // all data requests done, send notification
        var stats = {
            'prebuffstarted': movieEntry.stats.prebuffstarted,
            'prebuffcomplete': this.lastEventTime
        };
        var notifyevt = {
            'type': "prebuffstats",
            'movieId': movieId,
            'streamId': this.streamId,
            'stats': stats
        };
        DEBUG && _trace("prebuffstats:", notifyevt );
        headerCache.callEventListeners(notifyevt['type'], notifyevt);
    }

    // cleanup
    headerCache._cleanupRequest(this);
}

function _MediaRequestOnError()
{
    _warn("_onError: ", this );

    var headerCache = this.headerCache;
    headerCache._cleanupRequest(this);
}

////////////////////
// MP4 parsing
////////////////////
HeaderCache.prototype._parseMp4Header = function _parseMp4Header(mediaRequest)
{
    if (!mediaRequest.parser)
    {
        DEBUG && _trace("creating MP4 parser for request:" + mediaRequest.toString() +
                        ", data length: " + mediaRequest.headerData.byteLength);
        var parser = new Mp4Parser(mediaRequest.url, mediaRequest.headerData);
        parser.addEventListener('error', this._mp4Error.bind(this));
        parser.addEventListener('requestdata', this._mp4RequestData.bind(this));
        parser.addEventListener('fragments', this._mp4Fragments.bind(this));
        parser.addEventListener('drmheader', this._mp4DrmHeader.bind(this));
        parser.addEventListener('nflxheader', this._mp4NflxHeader.bind(this));
        parser.addEventListener('keyid', this._mp4KeyId.bind(this));
        parser.addEventListener('done', this._mp4Done.bind(this));
        parser.addEventListener('done', function(evt) {
            mediaRequest.headerCompletionCallback(mediaRequest.timeComplete);
        });

        mediaRequest.parser = parser;
    }
    else
    {
        DEBUG && _trace("appending additional mp4 data");
        mediaRequest.parser.newData(mediaRequest.headerData);
    }

    mediaRequest.parser.parse({request: mediaRequest});
};

HeaderCache.prototype._mp4Error = function _mp4Error(evt)
{
    var error = evt['error'];
    _warn("MP4 parsing got error:", error);
};

HeaderCache.prototype._mp4RequestData = function _mp4RequestData(evt)
{
    var bytes = evt['bytes'];
    var mediaRequest = evt['ctxt'].request;

    DEBUG && _trace("mediaRequest: " + mediaRequest.toString() +
                    "requested more bytes: " + bytes);

    var byteStart = mediaRequest.byteEnd + 1;
    var byteEnd = byteStart + bytes - 1;

    this._requestHeaderP(mediaRequest, byteStart, byteEnd, mediaRequest.requestPts,
                         false);
};

HeaderCache.prototype._mp4Fragments = function _mp4Fragments(evt)
{
    var fragments = evt['fragments'];
    var avgDurationMs = evt['averageDurationMs'];
    var mediaRequest = evt['ctxt'].request;

    DEBUG && _trace("MP4 parser for MediaRequest: " + mediaRequest.toString() +
                    ", returned " + fragments.length + " fragments, " +
                    " averageDuration: " + avgDurationMs);

    mediaRequest.fragments = fragments;
    mediaRequest.avgFragmentDurationMs = avgDurationMs;
};

HeaderCache.prototype._mp4DrmHeader = function _mp4DrmHeader(evt)
{
    var mediaRequest = evt['ctxt'].request;
    var drmType = evt['drmType'];
    var header = evt['header'];

    DEBUG && _trace("MP4 parser returned drm header: " + header.byteLength);

    if (!mediaRequest.drmHeader)
        mediaRequest.drmHeader = {};
    mediaRequest.drmHeader.drmType = drmType;
    mediaRequest.drmHeader.header = header;
};

HeaderCache.prototype._mp4NflxHeader = function _mp4NflxHeader(evt)
{
    var mediaRequest = evt['ctxt'].request;
    var header = evt['header'];

    DEBUG && _trace("MP4 parser returned nflx header: " + header.byteLength);

    mediaRequest.nflxHeader = header;
};

HeaderCache.prototype._mp4KeyId = function _mp4KeyId(evt)
{
    var mediaRequest = evt['ctxt'].request;
    var keyId = evt['keyId'];
    var keyIdOffset = evt['offset'];
    var flipped = evt['flipped'];

    DEBUG && _trace("MP4 paser returned keyId: " + keyId);

    if (!mediaRequest.drmHeader)
        mediaRequest.drmHeader = {};
    mediaRequest.drmHeader.contentId = keyId;
    mediaRequest.drmHeader.keyIdOffsets = (mediaRequest.drmHeader.keyIdOffsets || [])
        .concat(keyIdOffset);
    mediaRequest.drmHeader.keyIdFlipped = flipped;
};

HeaderCache.prototype._mp4Done = function _mp4Done(evt)
{
    var remaining = evt['remaining'];
    var mediaRequest = evt['ctxt'].request;
    var streamId = mediaRequest.streamId;
    var drmHeader = mediaRequest.drmHeader;

    DEBUG && _trace("MP4 Parser done on streamId: " + streamId +
                    " remaining " + remaining);

    // done with parser
    delete mediaRequest.parser;

    // flip KIDS
    if (mediaRequest.mediaType === this._manager.MEDIA_VIDEO && drmHeader) {
        require(53).applyFlippedKid(drmHeader.contentId,
            drmHeader.keyIdOffsets, mediaRequest.headerData);
    }

    // truncate header by remaining bytes
    if (remaining > 0)
        mediaRequest.headerData = mediaRequest.headerData.slice(0, 0-remaining);
    DEBUG && _trace("new header size = " + mediaRequest.headerData.byteLength);

    // add an entry to header cache
    this._addEntry(mediaRequest);

    // request data
    DEBUG && _trace("requestPts: " + mediaRequest.requestPts);
    if (!_.isUndefined(mediaRequest.requestPts))
    {
        this._requestData(mediaRequest, mediaRequest.requestPts);
    }
};

////////////////////
// Export
////////////////////

module.exports = HeaderCache;

},{"103":103,"47":47,"48":48,"53":53,"54":54,"56":56,"61":61,"62":62,"66":66,"84":84,"94":94}],52:[function(require,module,exports){
module.exports = function(platformImplementation, disableHeaderCache) {
    var platform = require(61);
    platform.implement(platformImplementation);
    var AseManager = require(43);
	return new AseManager(disableHeaderCache);
}

},{"43":43,"61":61}],53:[function(require,module,exports){

var _ = require(103);
var config = require(47);

config.declare({
    flipTrackEncryptionBoxKidOrder: ["flipTrackEncryptionBoxKidOrder", false]
});

function swap(view, a, b) {
    var byte = view.getUint8(a);
    view.setUint8(a, view.getUint8(b));
    view.setUint8(b, byte);
}

function flipKid(kid) {
    var view;
    if (config.flipTrackEncryptionBoxKidOrder && kid &&
        (kid instanceof ArrayBuffer) && (kid.byteLength === 16)) {
        view = new DataView(kid);
        swap(view, 0, 3);
        swap(view, 1, 2);
        swap(view, 4, 5);
        swap(view, 6, 7);
        return true;
    }
    return false;
}

function applyFlippedKid(kid, offsets, data) {
    var view;
    if (config.flipTrackEncryptionBoxKidOrder && kid && offsets && data &&
        (kid instanceof ArrayBuffer) && (_.isArray(offsets)) &&
        (data instanceof ArrayBuffer) && (kid.byteLength === 16)) {
        view = new Uint8Array(data);
        return offsets.every(function(offset) {
            if (offset + 16 <= data.byteLength) {
                view.set(new Uint8Array(kid), offset, 16);
                return true;
            }
        });
    }
    return false;
}

module.exports = {
    flipKid: flipKid,
    applyFlippedKid: applyFlippedKid
};
},{"103":103,"47":47}],54:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

module.exports = require(55);

},{"55":55}],55:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_high");

var _ = require(103),
    mixin = require(95),
    EventEmitter = require(94).EventEmitter,

    platform = require(61),
    console = new platform.Console('ASEJS_LOCATION_SELECTOR', 'media|asejs'),
    DEBUG = ("debug" !== 'release'),

    Enums = require(48),
    config = require(47);

//=============================================================================

// It is IMPORTANT that these remain in order:
//
// FAILURE_STATE_PERMANENT > FAILURE_STATE_TEMPORARY > FAILURE_STATE_OK

var FAILURE_STATE_OK            = 0,
    FAILURE_STATE_TEMPORARY     = 1,
    FAILURE_STATE_PERMANENT     = 2;

var SELECTION_MODE_ORIGINAL     = 0,
    SELECTION_MODE_CONTINUOUS   = 1;

//=============================================================================

function hasFailed(thing) {
    return thing.failureState != FAILURE_STATE_OK;
}

function calculateWeightedThroughput( location ) {
    location.weightedThroughput =
        ( location.statistics.confidence >= Enums.NETWORK_CONFIDENCE.HAVE_SOMETHING ) && !location.statistics.failed
            ? location.statistics.throughput.average * location.weight
            : 0;
}

//=============================================================================
// LocationSelector
//=============================================================================

function LocationSelector(events, monitor, history, probingAllowed) {

    this.events = events || mixin(EventEmitter, {});
    this.config = config;

    this.networkMonitor = monitor;
    this.locationHistory = history;

    // Initial state
    this.mode = SELECTION_MODE_ORIGINAL;
    this.probingAllowed = probingAllowed;
    this.probingReason = Enums.PROBING_REASON.STARTUP;
    this.lowgradeAllowed = false;

    DEBUG && console.log('Creating LocationSelector, probingAllowed(' + this.probingAllowed + ')');

    // Locations by location id
    this.locations = {};
    // Servers by server id
    this.servers = {};
    // Urls by url
    this.urls = {};
    // Streams by stream id
    this.streams = {};

    // The network parent node
    // locations are kept in order from best to worst
    var locations = [];
    this.network = {
        id:             'network',
        entity:         Enums.FAILURE_ENTITY.NETWORK,
        failureState:   FAILURE_STATE_OK,
        didFail:        false,
        locations:      locations,
        children:       locations
    };

    this._locationStatisticsUpdateTime = null;

    this.selectedLocations = null;

    // Add event listeners

    this.events.on('underflow', (function() {
        this.reprobe(Enums.PROBING_REASON.REBUFFER);
    }).bind(this));

    this.events.on('close', (function() {
        this.persistFailures();
    }).bind(this));
}

mixin(EventEmitter, LocationSelector.prototype);

LocationSelector.prototype.addManifest = function( manifest ) {

    //-------------------------------------------------------------------------
    // Populate locations
    //-------------------------------------------------------------------------

    manifest['locations'].forEach(function(manifestLocation) {

        var locationId = manifestLocation['key'];

        if ( !_.has( this.locations, locationId ) ) {

            var servers = [],
                statistics = this.locationHistory.get( locationId ),
                location = {
                    id:             locationId,
                    rank:           manifestLocation['rank'],
                    level:          manifestLocation['level'],
                    weight:         manifestLocation['weight'],

                    entity:         Enums.FAILURE_ENTITY.LOCATION,
                    failureState:   FAILURE_STATE_OK,
                    parent:         this.network,
                    servers:        servers,
                    children:       servers,

                    // Map of stream id to stream
                    // Can be used to check if a stream id is available at
                    // this location
                    streams:                {},

                    // State
                    probingNeeded:          false,
                    probingDone:            false,
                    statistics:             statistics,
                    weightedThroughput:     null
                };

            if (statistics.failed) {
                console.warn("Location", locationId, "had a persisted failure we will ignore");
            }
            
            if ( ( statistics.confidence >= Enums.NETWORK_CONFIDENCE.HAVE_SOMETHING ) && ( statistics.throughput === null ) )
            {
                console.warn("Location " + locationId + " has bad statistics: " + JSON.stringify( statistics ) );
            }

            this.locations[location.id] = location;

            location.parent.children.push(location);

            calculateWeightedThroughput( location );
        }

    }, this);

    this._locationStatisticsUpdateTime = platform.time.mono();

    // Sort order: by level in ascending order then by rank in
    // ascending order

    this.network.locations.sort(function(a,b) {
        return (a.level - b.level) || (a.rank - b.rank);
    });

    //-------------------------------------------------------------------------
    // Populate servers and location.servers
    //-------------------------------------------------------------------------

    manifest['servers'].forEach(function(manifestServer) {

        if ( !_.has( this.servers, manifestServer['id'] ) ) {

            var location = this.locations[manifestServer['key']],
                urls = [],
                server = {
                    id:             manifestServer['id'],
                    name:           manifestServer['name'],
                    type:           manifestServer['type'],
                    rank:           manifestServer['rank'],
                    lowgrade:       manifestServer['lowgrade'],

                    entity:         Enums.FAILURE_ENTITY.SERVER,
                    failureState:   FAILURE_STATE_OK,
                    parent:         location,
                    location:       location,
                    urls:           urls,
                    children:       urls
                };
            this.servers[server.id] = server;
            server.parent.children.push(server);
        }
    }, this);

    //-------------------------------------------------------------------------
    // Streams and URLs
    //-------------------------------------------------------------------------
    manifest['audio_tracks'].forEach(function(track) {
        this.processManifestTrack(track);
    }, this);

    manifest['video_tracks'].forEach(function(track) {
        this.processManifestTrack(track);
    }, this);

    //-------------------------------------------------------------------------

    //console.log(JSON.stringify(manifest, null, '   '));
    //this.dump();

    //-------------------------------------------------------------------------
    // Prune locations that have no URLs
    //-------------------------------------------------------------------------

    var locations = this.network.locations.filter(function(location) {
        var empty = location.servers.every(function(server) {
            return server.urls.length === 0;
        });
        if (empty) {
            // Delete all the servers by id from the server map
            location.servers.forEach(function(server) {
                DEBUG && console.log('Dropping server with no URLs : server ' + server.id + ' "' + server.name + '" from location ' + location.id);
                delete this.servers[server.id];
            }, this);
            // Delete the location by id from the location map
            delete this.locations[location.id];
            // Now cut its tentacles
            delete location.parent;
            delete location.servers;
            delete location.children;
            delete location.streams;
        }
        return !empty;
    }, this);

    // Sort the servers by rank
    locations.forEach( function( location ) {

        location.servers.sort( function( a, b ) { return a.rank - b.rank; } );

    } );

    // Fix up the network node
    this.network.locations = locations;
    this.network.children = locations;

    // Let others know

    this.emit('manifestAdded');

    this.dump();
};

LocationSelector.prototype.processManifestTrack = function processManifestTrack(track) {
    track['streams'].forEach(function(manifestStream) {

        var stream = this.streams[ manifestStream['downloadable_id'] ];
        if ( _.isUndefined( stream) ) {
            stream = {
                id:             manifestStream['downloadable_id'],
                bitrate:        manifestStream['bitrate'],
                type:           manifestStream['type'],
                profile:        manifestStream['content_profile'],
                clear:          manifestStream['content_profile'].indexOf("none-") === 0,

                // Simple array of URLs
                urls:           [],

                // Maps location id to an array of urls
                urlsByLocation: {}
            };
            this.streams[stream.id] = stream;
        }

        manifestStream['urls'].forEach(function(manifestUrl) {

            var url = this.urls[ manifestUrl['url'] ];
            if ( _.isUndefined( url ) ) {

                var server = this.servers[manifestUrl['cdn_id']],
                    location = server.location;
                url = {
                    id:             manifestUrl['url'],
                    url:            manifestUrl['url'],

                    entity:         Enums.FAILURE_ENTITY.URL,
                    failureState:   FAILURE_STATE_OK,
                    parent:         server,
                    server:         server,
                    stream:         stream
                };
                this.urls[url.url] = url;
                url.parent.children.push(url);
                stream.urls.push(url);
                location.streams[stream.id] = stream;

                var locationList = stream.urlsByLocation[location.id];
                if (!locationList) {
                    stream.urlsByLocation[location.id] = [url];
                } else {
                    locationList.push(url);
                }
            }
        }, this);

        _.each( stream.urlsByLocation, function( urls, location ) {
            urls.sort( function( a, b ) { return a.server.rank - b.server.rank; } );
        } );

    }, this);
};

LocationSelector.prototype.permanentlyFailed = function permanentlyFailed() {
    return ( this.network.failureState == FAILURE_STATE_PERMANENT );
};

LocationSelector.prototype.failed = function failed() {
    return hasFailed(this.network);
};

//=============================================================================
// updateUrlStreamSelection
// ------------------------
// Choose URL and locationId for each stream in a list
//=============================================================================

function clearStreamLocationInformation(stream) {
    delete stream.url;
    delete stream.location;
    delete stream.server;
    delete stream.statistics;
    delete stream.throughput;
}

LocationSelector.prototype.updateStreamUrlSelection = function updateStreamUrlSelection(player, streams ) {


    // If someone else sets the stream as unavailable, we won't know that it was them, and
    // we could over-write their choice

    var currentPrediction = this.networkMonitor.get(),
        currentLocationId = this.networkMonitor.location,
        locations,
        probingAllowed = this.probingAllowed,
        reported = {},
        streamsFound = 0,
        config = this.config,
        buffer = player.buffer,
        bufferLevel = buffer.completePts - buffer.currentPts;

    //--------------------------------------------------------------------------
    if (platform.createFilteredVideoStreamList) {
        //engage the mediaStreamFilter, currently only used by Cadmium
        platform.createFilteredVideoStreamList();
    }

    if (hasFailed(this.network)) {
        console.warn('Network has failed, not updating stream selection');
        return null;
    }

    // Update the statistics for the current location
    if ( this.networkMonitor.location && currentPrediction.confidence >= Enums.NETWORK_CONFIDENCE.HAVE_MINIMUM ) {

        var location = this.locations[ this.networkMonitor.location ];

        if (!location) {
            console.warn('Network monitor has "' + this.networkMonitor.location +
                '" as its current location. I have ' +
                JSON.stringify(Object.keys(this.locations)));
        } else {
        
            if ( ( currentPrediction.confidence >= Enums.NETWORK_CONFIDENCE.HAVE_SOMETHING ) && ( currentPrediction.throughput === null ) )
            {
                console.warn("Current location " + this.networkMonitor.location + " has bad statistics: " + JSON.stringify( currentPrediction ) );
            }
        
            location.statistics = currentPrediction;
            calculateWeightedThroughput( location );
        }
    }

    // Decide on lowgrade mode
    var lowgrade =  (bufferLevel < config.lowGradeModeExitThreshold) ? false :
                    (bufferLevel > config.lowGradeModeEnterThreshold) ? true : this.lowgrade;

    // Perform location selection if necessary
    if ( _.isNull( this.selectedLocations )
            || probingAllowed
            || lowgrade != this.lowgrade )
    {
        this.lowgrade = lowgrade;

        // Updated, ordered list of locations, excluding failed ones. If all are failed,
        // we will get a null
        // XXX If this.selectedLocations is defined, we could choose to do this only every second
        // say, to reduce CPU load during probing.
        this.selectedLocations = this.updateLocations(player);
    }

    locations = this.selectedLocations;

    if (!locations) {
        console.warn('All locations have failed, not updating stream URLs');
        // Not much we can do, so mark the network as failed if it has not failed already
        this.reportFailure(Enums.FAILURE_ENTITY.NETWORK, false);
        return null;
    }

    if (!locations.length) {
        console.warn('There are no locations to choose from, not updating stream URLs');
        this.reportFailure(Enums.FAILURE_ENTITY.NETWORK, false);
        return null;
    }

    // Iterate over each stream in the list
    streams.forEach(function(streamFromList, streamFromListIndex) {

        var streamId = streamFromList.id,
            found;

        DEBUG && console.log('Selecting location for [' + streamFromListIndex + '] ' +
            streamId + ' (' + streamFromList.bitrate + ' Kbps) ' +
            (streamFromList.isAvailable ? '' : 'n/a'));

        if (!streamFromList.inRange) {
            DEBUG && console.log('  Stream is not in range');
            clearStreamLocationInformation(streamFromList);
            return;
        }

        found = locations.some(function(location, locationIndex) {

            var stream = location.streams[streamId],
                urls;

            DEBUG && console.log('  Trying location [' + (locationIndex + 1) + '/' + locations.length + '] ' + location.id);

            // This location does not have this stream, skip it
            if (!stream) {
                DEBUG && console.log('  Stream not available at this location');
                return false;
            }

            // The location is good and has this stream, get all the
            // URLs for it

            urls = stream.urlsByLocation[location.id];

            if (urls.length > 1) {
                DEBUG && console.log('  Have ' + urls.length + ' URLs at this location');
            }

            return urls.some(function(url) {
                // The server has failed
                if (hasFailed(url.server)) {
                    DEBUG && console.log('  Server ' + url.server.name + ' has failed');
                    if (url.server.failureState === FAILURE_STATE_TEMPORARY)
                    {
                        streamFromList.failureState = FAILURE_STATE_TEMPORARY;
                    }
                    return false;
                }

                // The url has failed
                if (hasFailed(url)) {
                    DEBUG && console.log('  URL has failed : ' + url.url);
                    return false;
                }

                // selection reason for serversel = probe|probedone|performance|bitrate|serverfailover|locationfailover|probeaborted|tolowgrade|fromlowgrade|unknown
                var selreason;

                DEBUG && console.log('  Selected location=' + location.id +
                ' : server=' + url.server.id + '/' + url.server.name +
                ' : url=' + url.url);

                if (streamFromList.location != location.id) {
                    DEBUG && console.log('  Location changed from ' + streamFromList.location + ' to ' + location.id);

                    if ( location !== locations[ 0 ] ) {
                        selreason = "bitrate";
                    } else if ( streamFromList.location === undefined ){
                        selreason = "init";
                    } else if ( probingAllowed ) {
                        selreason = "probe";
                    } else if ( !_.isUndefined( streamFromList.lastLocation ) && ( streamFromList.lastLocation != location.id ) ) {
                        selreason = "locationfailover";
                    } else if ( !_.isUndefined( streamFromList.lastServer ) && ( streamFromList.lastServer != url.server.id ) ) {
                        selreason = "serverfailover";
                    } else {
                        selreason = "performance";
                    }

                    streamFromList.location = location.id;
                    streamFromList.selreason = selreason;
                }

                streamFromList.url = url.url;
                streamFromList.server = url.server.id;

                streamFromList.statistics =
                    ( currentPrediction.confidence == Enums.NETWORK_CONFIDENCE.HAVE_NOTHING ||
                      location.statistics.confidence >= Enums.NETWORK_CONFIDENCE.HAVE_MINIMUM )
                        ? location.statistics
                        : currentPrediction;

                if (DEBUG && player.state == Enums.PLAYER_STATE.STARTING && !reported[location.id]) {
                    reported[location.id] = true;
                    DEBUG && console.log('LOCATION ' + location.id
                        + ' HISTORY (' + location.statistics.confidence + ',' + JSON.stringify(location.statistics.throughput) + ')'
                        + ' CURRENT ' + currentLocationId + ' (' + currentPrediction.confidence + ',' + JSON.stringify(currentPrediction.throughput) + ')');
                }

                return true;
            });
        });

        if (found) {

            delete streamFromList.hasFailed;
            delete streamFromList.failureState;

            // Only increment the counter when the stream is available
            if (streamFromList.isAvailable) {
                ++streamsFound;
            }
        } else {
            if ( streamFromList.failureState && (streamFromList.failureState === FAILURE_STATE_TEMPORARY)) {
                // unequalized stream selection case: set the network to be temporarily failed when one of the streams is temporarily failed
                this.network.failureState = FAILURE_STATE_TEMPORARY;
            } else if (!streamFromList.hasFailed) {
                console.warn('Failing stream [' + streamFromListIndex + '] ' + streamId + ' (' + streamFromList.bitrate + ' Kbps)');
                clearStreamLocationInformation(streamFromList);
                streamFromList.hasFailed = true;
            }
        }
    }, this);

    if (hasFailed(this.network)) {
        console.warn('Network has failed, not updating stream selection');
        this.network.didFail = true;
        this.emit('networkFailed', this.network.failureState == FAILURE_STATE_PERMANENT);
        return null;
    }

    if (!streamsFound) {
        console.warn('Did not find a URL for ANY stream...' +
            (!streams.length ? '(empty stream list)' : ''));
        this.reportFailure(Enums.FAILURE_ENTITY.NETWORK, true);
        return null;
    }

    return streams;
};

//=============================================================================
// updateLocations
// ---------------
// Updates and sorts the network's location list. Returns null if all locations
// have failed. Otherwise, it returns an ordered array of locations with failed
// and unwanted locations excluded. This array is possibly empty.
//=============================================================================

LocationSelector.prototype.updateLocations = function updateLocations(player) {

    var self = this,
        locations,
        selectedLocation,
        config = this.config,
        buffer = player.buffer,
        bufferLevel = buffer.completePts - buffer.currentPts;

    // Find the locations in play
    locations = this.network.locations.filter( function( location ) {
        return !hasFailed(location) && ( location.level !== 0 || this.lowgrade );
    } );

    // If we did not find a good location, bail - all locations have failed
    if (locations.length === 0) {
        return null;
    }

    selectedLocation = selectedLocation || locations[ 0 ];

    // Update the location statistics for the non-current locations to account for history expiring
    if ( _.isNull( this._locationStatisticsUpdateTime )
                    || ( this._locationStatisticsUpdateTime + config.locationStatisticsUpdateInterval
                            < platform.time.mono() ) ) {

        locations.forEach( function( location ) {
            if ( location.id !== this.networkMonitor.location ) {

                location.statistics = this.locationHistory.get( location.id );
            }
        }, this );

        this._locationStatisticsUpdateTime = platform.time.mono();
    }

    // Decide whether to continue allowing probing
    var selectionreason = null;

    if ( this.probingAllowed ) {

        // Decide probing needed for each location
        locations.forEach(function(location) {

            if ( location.statistics.confidence >= Enums.NETWORK_CONFIDENCE.HAVE_MINIMUM ) {
                location.probingDone = location.probingDone || location.probingNeeded;
                location.probingNeeded = false;
                location.confidenceOrder = Enums.NETWORK_CONFIDENCE.HAVE_MINIMUM;
            } else {
                location.probingNeeded = true;
                location.confidenceOrder = location.statistics.confidence;
            }

        }, this);

        var level = null;

        if ( locations.every(function(location) {

            if ( _.isNull( level ) ) {
                level = location.level;
            }

            if ( level != location.level ) {
                this.probingAllowed = false;

                selectionreason = Enums.SELECTION_REASON.BANDWIDTH;

                DEBUG && console.log( "Probing complete: all locations at lowest level have sufficient data." );

                return false;
            }

            if ( location.statistics.confidence < Enums.NETWORK_CONFIDENCE.HAVE_MINIMUM ) {
                return false; // exit without changing probing allowed
            }

            if ( location.statistics.throughput.average > config.fastDomainSelectionBwThreshold ) {
                // Fast selection criteria
                this.probingAllowed = false;

                selectionreason = Enums.SELECTION_REASON.FASTSELECTION;

                DEBUG && console.log( "Probing complete: " + location.id + " has throughput above fast selection threshold (" + config.fastDomainSelectionBwThreshold + ")" );

                return false;
            }

            return true;

        }, this ) ) {
            this.probingAllowed = false;

            selectionreason = Enums.SELECTION_REASON.BANDWIDTH;

            DEBUG && console.log( "Probing complete: all locations have sufficient data." );
        }

    } else {

        // If we start out without probing allowed, this is a McQueen playback

        selectionreason = Enums.SELECTION_REASON.MCQUEEN;

        if ( this.mode == SELECTION_MODE_CONTINUOUS ) {

            // XXX likely need an additional degraded performance criteria to re-enter probing allowed
            this.probingAllowed = bufferLevel > config.throughputProbingEnterThreshold;
        }
    }


    // Sort all locations, including failed and lowgrade ones (skip)
    // The skipped ones will go to the back (worst)

    locations.sort(function(a, b) {

        return (
            // lowest level first
            (a.level - b.level) ||
            // probing needed first
            (self.probingAllowed && a.probingNeeded && !b.probingNeeded ? -1 : 0 ) ||
            (self.probingAllowed && b.probingNeeded && !a.probingNeeded ? 1 : 0 ) ||
            // if probing is allowed and needed, then do it in rank order
            (self.probingAllowed && a.probingNeeded && b.probingNeeded ? a.rank - b.rank : 0 ) ||
            // highest confidence first
            (b.confidenceOrder - a.confidenceOrder) ||
            // highest weighted throughput first
            (b.weightedThroughput - a.weightedThroughput) ||
            // lowest rank first
            (a.rank - b.rank)
        );
    });

    if ( DEBUG ) {

        locations.forEach(function( location , index ) {

            DEBUG && console.log( '[' + index + '] '
                + location.id
                + ": canprobe(" + ( this.probingAllowed ? "yes" : "no" )
                + ") probe(" + ( location.probingNeeded ? "yes" : "no" )
                + ") conf(" + location.statistics.confidence
                + ") cord(" + location.confidenceOrder
                + ") tp(" + ( ( location.statistics.throughput && !location.statistics.failed )? location.statistics.throughput.average : 'unknown' )
                + ") wtp(" + location.weightedThroughput
                + ") rank(" + location.rank + ")" );
        }, this);
    }

    if ( !this.locationSelected && !_.isNull( selectionreason ) ) {
        this.notifyLocationSelected( locations[ 0 ], this.probingReason, selectionreason );
        this.locationSelected = true;
    }

    return locations;
};

//=============================================================================
// reprobe
// -------
// NRDJS-1416
//=============================================================================

LocationSelector.prototype.reprobe = function reprobe(reason) {

    DEBUG && console.log('reprobe called with reason ' + Enums.PROBING_REASON.name[reason]);

    var currentLocationId = this.networkMonitor.location;

    this.locationSelected = false;
    this.probingAllowed = true;
    this.probingReason = reason;
    this.network.locations.forEach(function(location) {
        if (location.id != currentLocationId
                && location.statistics
                && location.statistics.confidence > Enums.NETWORK_CONFIDENCE.HAVE_SOMETHING) {
            location.statistics.confidence = Enums.NETWORK_CONFIDENCE.HAVE_SOMETHING;
        }
    });
};

//=============================================================================
// Failure states and propagation
//=============================================================================

function propagateFailure(node) {

    var parent = node.parent,
        children = parent ? parent.children : null,
        propagate = false,
        failed = {};

    if (!parent || !children) {
        return;
    }

    // We will sort the children into these buckets in one pass
    failed[FAILURE_STATE_OK] = [];
    failed[FAILURE_STATE_PERMANENT] = [];
    failed[FAILURE_STATE_TEMPORARY] = [];

    children.forEach(function(child) {
        failed[child.failureState].push(child);
    });

    // Some of the children are still OK, so we don't need to do anything
    if (failed[FAILURE_STATE_OK].length > 0) {
        return;
    }

    if (failed[FAILURE_STATE_PERMANENT].length == children.length) {
        // All children failed permanently
        // The parent fails permanently and we propagate up
        if (parent.failureState != FAILURE_STATE_PERMANENT) {
            parent.failureState = FAILURE_STATE_PERMANENT;
            console.error('PERM failing :' , Enums.FAILURE_ENTITY.name[parent.entity] + ' ' + parent.id);
            propagate = true;
        }
    } else {
        // All the children failed either way
        // The parent is temporarily failed, unless it is already failed
        if (parent.failureState == FAILURE_STATE_OK) {
            parent.failureState = FAILURE_STATE_TEMPORARY;
            console.error('TEMP failing :' , Enums.FAILURE_ENTITY.name[parent.entity] + ' ' + parent.id);
            propagate = true;
        }
        // Reset all temporarily failed children
        failed[FAILURE_STATE_TEMPORARY].forEach(function(child) {
            child.failureState = FAILURE_STATE_OK;
        });
    }

    if (propagate) {
        propagateFailure(parent);
    }
}

//=============================================================================
// Failure reporting
//=============================================================================

function nodePath(node) {
    var p,
        s = [];
    for (p = node; p; p = p.parent) {
        switch (p.entity) {
            case Enums.FAILURE_ENTITY.SERVER:
                s.unshift(p.id + '(' + p.name + ')');
                break;
            case Enums.FAILURE_ENTITY.LOCATION:
                s.unshift(p.id);
                break;
            case Enums.FAILURE_ENTITY.URL:
                s.unshift('<url for ' + p.stream.bitrate + '>');
                break;
        }
    }
    return s.length ? '/' + s.join('/') : '';
}

LocationSelector.prototype.serverForUrl = function serverForUrl(url) {
    var node = this.urls[url];
    if (node) {
        return node.parent.id;
    }
};

// Returns an object with servers as keys and an array of matching URLs for each

LocationSelector.prototype.serversForHost = function serversForHost(host, port) {
    // The key will be the server id, the value will be the first URL that matched
    var servers = {};
    // Pattern to extract 1) the s in https, 2) the host and 3) the port
    var pattern = /^http(s?):\/\/([^\/:]+):?([0-9]*)/;

    _.forEach(this.urls, function(node, url) {
        var server = node.parent.id;
        var urls = servers[server];
        // Extract https, host and port from candidate URL
        var match = url.match(pattern);
        if (match && match.length === 4) {
            var candidateIsHttps = (match[1] === "s");
            var candidateHost = match[2];
            var candidatePort = match[3];

            if (_.isString(candidateHost) && _.isString(candidatePort)) {
                // Default port
                if (!candidatePort.length) {
                    candidatePort = candidateIsHttps ? "443" : "80";
                }
                // Check to see if the candidate matches the inputs
                if (candidateHost == host && candidatePort == port) {
                    // If it does, add this url to the list of urls for
                    // this server
                    if (!urls) {
                        servers[server] = [url];
                    } else {
                        urls.push(url);
                    }
                }
            }
        }
    });

    return servers;
};

LocationSelector.prototype.reportFailure = function reportFailure(entity, permanent, url) {

    // Start with the given URL and climb up the tree until we match the
    // entity passed in or run out.
    var node = (entity == Enums.FAILURE_ENTITY.NETWORK ? this.network : this.urls[url]),
        oldNetworkFailureState = this.network.failureState,
        newNetworkFailureState,
        newFailureState = permanent ? FAILURE_STATE_PERMANENT : FAILURE_STATE_TEMPORARY;

    while (node && node.entity != entity) {
        node = node.parent;
    }

    if (!node) {
        console.warn('Unable to find failure entity for URL ' + url);
        return;
    }

    if (newFailureState == node.failureState) {
        DEBUG && console.log('  New failure state is the same as existing failure state, skipping');
        return;
    }

    console.warn((permanent ? 'PERM' : 'TEMP') +
        ' failure reported for ' + Enums.FAILURE_ENTITY.name[entity] +
        ' at ' + nodePath(node) + ' : was ' + failureStateName(node.failureState));

    switch (node.failureState) {

        case FAILURE_STATE_PERMANENT:
            DEBUG && console.log('  Already PERM failed, skipping');
            return;

        case FAILURE_STATE_TEMPORARY:
            DEBUG && console.log('  Was already TEMP failed, going to PERM failure');
            break;

        case FAILURE_STATE_OK:
            break;

        default:
            throw new Error('Invalid failure state');
    }

    // Mark the affected entity accordingly
    node.failureState = newFailureState;

    // Propagate
    propagateFailure(node);

    // Track whether it has ever failed
    this.network.didFail = this.network.didFail || hasFailed( this.network );

    // Now see if the network went from not failed to failed,
    // or from a temporary failure to a permanent failure
    newNetworkFailureState = this.network.failureState;
    if (newNetworkFailureState > oldNetworkFailureState) {
        console.warn("Emitting networkFailed, permanent =", newNetworkFailureState == FAILURE_STATE_PERMANENT);
        this.emit('networkFailed', newNetworkFailureState == FAILURE_STATE_PERMANENT);
    }

    // Force location reselection
    this.selectedLocations = null;

    this.dump();
};

//=============================================================================

function reset(node, permanent) {
    if (node.failureState == FAILURE_STATE_TEMPORARY ||
        (node.failureState == FAILURE_STATE_PERMANENT && permanent)) {
        node.failureState = FAILURE_STATE_OK;
    }
    if (node.children) {
        node.children.forEach(function(child) {
            reset(child, permanent);
        });
    }
}

LocationSelector.prototype.resetFailures = function resetFailures(permanent) {
    reset(this.network, permanent);
};

//=============================================================================
// Failure persistence
//=============================================================================

LocationSelector.prototype.persistFailures = function persistFailures() {

    if ( !this.network.didFail ) {
        this.network.locations.forEach(function(location) {

            if ( location.failureState == FAILURE_STATE_TEMPORARY ) {
                this.locationHistory.fail( location.id, platform.time.mono() );
            }

        }, this );
    }

};

//=============================================================================
// Events
//=============================================================================

LocationSelector.prototype.notifyLocationSelected = function notifyLocationSelected(    location,
                                                                                        testreason,
                                                                                        selreason ) {

    var probedata = this.network.locations
                        .filter( function( location ) { return location.probingDone; } )
                        .map( function( location ) {
                            var result =  { 'id' : location.id, 'locid' : location.id };
                            if ( location.statistics ) {
                                if ( location.statistics.throughput )
                                    result['bw'] = location.statistics.throughput.average;
                                if ( location.statistics.responseTime )
                                    result['rtt'] = location.statistics.responseTime.average;
                            }

                            return result;
                        } );

    var serverbw = (location.statistics && location.statistics.throughput) ?
        location.statistics.throughput.average : 0;

    var args = {    'type' : "locationSelected",
                    'location' : location.id,
                    'serverid' : location.servers[ 0 ].id,
                    'servername' : location.servers[ 0 ].name,
                    'serverrtt' : 0 /*location.statistics.connectTime.average*/,
                    'serverbw' : serverbw,
                    'probedata' : probedata,
                    'testreason' : Enums.PROBING_REASON.name[ testreason ],
                    'selreason' : Enums.SELECTION_REASON.name[ selreason ],
                    'fastselthreshold' : config.fastDomainSelectionBwThreshold
                };

    this.callEventListeners( "locationSelected", args );
};

//=============================================================================
// Dumping state
//=============================================================================

function failureStateName(thing) {
    if (thing && _.isObject(thing) && _.isNumber(thing.failureState))
        return failureStateName(thing.failureState);
    switch (thing) {
        case FAILURE_STATE_OK: return 'OK';
        case FAILURE_STATE_PERMANENT: return 'FAILED PERMANENTLY';
        case FAILURE_STATE_TEMPORARY: return 'FAILED TEMPORARILY';
        default: return 'INVALID';
    }
}

LocationSelector.prototype.dump = function dump(level) {

    if (DEBUG) {

        DEBUG && console.trace('NETWORK (' + failureStateName(this.network) + ') '
            + ' probingAllowed=' + this.probingAllowed);

        if (_.isNumber(level) && level <= 0)
            return;

        this.network.locations.forEach(function(location, index) {

            var confidence = location.statistics ? location.statistics.confidence : 'unknown',
                throughput = ( location.statistics && location.statistics.throughput )
                                ? location.statistics.throughput : 'unknown';

            DEBUG && console.trace('   LOCATION [' + (index + 1) + '] (' + failureStateName(location) + ') '
                + '"' + location.id + '"'
                + ' l=' + location.level
                + ' r=' + location.rank
                + ' w=' + location.weight
                + ' throughput=' + JSON.stringify(throughput)
                + ' weightedThroughput=' + location.weightedThroughput
                + ' confidence=' + confidence
                + ' probingNeeded=' + location.probingNeeded
                + ' confidenceOrder=' + location.confidenceOrder);

            if (_.isNumber(level) && level <= 1)
                return;

            location.servers.forEach(function(server, index) {
                DEBUG && console.trace('      SERVER [' + (index + 1) + '] (' + failureStateName(server) + ') '
                    + '"' + server.id + '"'
                    + ' name=' + server.name
                    + ' type=' + server.type
                    + ' rank=' + server.rank
                    + ' lowgrade=' + server.lowgrade);

                if (_.isNumber(level) && level <= 2)
                    return;

                server.urls.forEach(function(url, index) {
                    DEBUG && console.trace('          URL [' + (index + 1) + '] (' + failureStateName(url) + ') '
                        + ' stream=' + url.stream.id
                        + ' bitrate=' + url.stream.bitrate
                        + " (" + (url.stream.clear ? "clear" : "drm") + ")"
                        + ' ' + url.url);
                });
            });
        });
    }
};

//=============================================================================
// Iterate over all URLs
//=============================================================================

LocationSelector.prototype.forEachUrl = function forEachUrl(fn) {
    var urls = this.urls,
        fnb;
    if (fn) {
        fnb = fn.bind(this);
        _.forEach(this.urls, function(url) {
            var stream = url.stream,
                server = url.server,
                location = server.location;
            fnb(location, server, stream, url);
        });
    }
};

//=============================================================================

module.exports = LocationSelector;

},{"103":103,"47":47,"48":48,"61":61,"94":94,"95":95}],56:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var _ = require(103);
var EventEmitter = require(94).EventEmitter;
var platform = require(61);
var console = new platform.Console('MP4', 'media|asejs');
var DEBUG = ("debug" !== 'release');
var Fragment = require(50).Fragment;
var FragmentListView = require(50).FragmentListView;
var TIME_TO_TRUNCATE = 120000;   // 2 minutes of fastplay
var VERBOSE = false;

//////////////////////////////////////
// utilities
//////////////////////////////////////

var _trace = console.trace.bind(console);
var _warn = console.warn.bind(console);

function _traceLevel(level, msg)
{
    var levelstr = level;
    if (_.isUndefined(level))
        levelstr = "";
    _trace("MP4." + levelstr + ": " + msg);
}

function _convertNumToAscii(num)
{
    if (!_.isNumber(num))
    {
        _warn("trying to convert non-number: " + num);
        return 0;
    }
    var a = [];
    while (num !== 0)
    {
        a.unshift(String.fromCharCode(num & 0xff));
        num = num >> 8;
    }
    return a.join("");
}

function _convertTimeToMs(time, timescale)
{
    return Math.floor(time * 1000 / timescale);
}

//////////////////////////////////////
// Box
//////////////////////////////////////
/**
 *
 * @param {Object=} parser
 * @param {Object=} type
 * @param {number=} startOffset
 * @param {number=} length
 * @constructor
 */
function Box(parser, type, startOffset, length)
{
    this.parser = parser;
    if (parser)
        this.level = parser.level;
    this.type = type;
    this.startOffset = startOffset;
    this.length = length;
    if (VERBOSE && startOffset && length)
    {
        _traceLevel(this.level, "offset of " + type + " = 0x" + startOffset.toString(16) +
                    " length 0x" + length.toString(16));
    }
}
Box.prototype.constructor = Box;

Box.prototype.readFullHeader = function readFullHeader()
{
    // 8 bit version
    this.version = this.parser._read8();

    // 24 bits of flags
    var flag1 = this.parser._read8();
    var flag2 = this.parser._read8();
    var flag3 = this.parser._read8();
    this.flags = (flag1 << 16) | (flag2 << 8) | flag3;

    VERBOSE && _traceLevel(this.level, "version = " + this.version + " flags = 0x" +
                           this.flags.toString(16));
};

Box.prototype.parse = function parse(ctxt)
{
    return true;
};

Box.prototype.forwardEvent = function forwardEvent(evt)
{
    // forward to parent parser
    this.parser.callEventListeners(evt['type'], evt);
};

Box.prototype.ignoreRequestData = function ignoreRequestData(ctxt)
{
    VERBOSE && _traceLevel(this.level, "ignoring subparser request for more data");
};

Box.prototype.createSubParser = function createSubParser(ctxt)
{
    // create a sub parser for this box
    var startOffset = this.parser.offset;
    var length = this.length - (startOffset - this.startOffset);
    var subparser = new Mp4Parser(
        this.parser.url, this.parser.data, this.parser.truncate, startOffset, length,
        this.level+1);

    VERBOSE && _traceLevel(this.level,
                           "subparser startOffset: 0x" + startOffset.toString(16) +
                           " endOffset: 0x" + (startOffset+length).toString(16));

    // parse the whole box
    subparser.requiredBoxes = undefined;

    VERBOSE && _traceLevel(this.level, "created sub parser at offset = 0x" +
                           startOffset.toString(16) +
                           " length = 0x" + length.toString(16));

    subparser.addEventListener('error', this.forwardEvent.bind(this));
    subparser.addEventListener('drmheader', this.forwardEvent.bind(this));
    subparser.addEventListener('nflxheader', this.forwardEvent.bind(this));
    subparser.addEventListener('keyid', this.forwardEvent.bind(this));
    subparser.addEventListener('requestdata', this.ignoreRequestData.bind(this));
    // ignore other events

    subparser.parse(ctxt);

    // XXX consider subparser success if it ends at 0 bytes
    return true;
};

//////////////////////////////////////
// container box
//////////////////////////////////////
/**
 *
 * @constructor
 * @extends Box
 */
function ContainerBox(parser, type, startOffset, length)
{
    this.base = Box;
    this.base.call(this, parser, type, startOffset, length);
}
ContainerBox.prototype = new Box();
ContainerBox.prototype.constructor = ContainerBox;

ContainerBox.prototype.parse = function parse(ctxt)
{
    // create a sub parser for this box
    return this.createSubParser(ctxt);
};

//////////////////////////////////////
// moov box
//////////////////////////////////////
/**
 *
 * @extends Box
 * @constructor
 */
function MoovBox(parser, type, startOffset, length)
{
    this.base = Box;
    this.base.call(this, parser, type, startOffset, length);
}
MoovBox.prototype = new Box();
MoovBox.prototype.constructor = MoovBox;

MoovBox.prototype.parse = function parse(ctxt)
{
    // create a sub parser for this box
    var ret = this.createSubParser(ctxt);

    // mark the offset of end of moov box
    var offset = this.startOffset + this.length;
    _traceLevel(this.level, "marking end of moov: 0x" + offset.toString(16));
    this.parser.moovEnd = offset;

    return ret;
};

//////////////////////////////////////
// free box
//////////////////////////////////////
/**
 *
 * @extends Box
 * @constructor
 */
function FreeBox(parser, type, startOffset, length)
{
    this.base = Box;
    this.base.call(this, parser, type, startOffset, length);
}
FreeBox.prototype = new Box();
FreeBox.prototype.constructor = FreeBox;

FreeBox.prototype.parse = function parse(ctxt)
{
    // extract out the specific data
    var data = this.parser.data.slice(this.parser.offset,
                                      this.parser.offset + this.length - 8);

    var evt = {
        'type' : 'free',
        'ctxt' : ctxt,
        'data' : data
    };

    // notify caller
    this.parser.callEventListeners(evt['type'], evt);

    return true;
};

//////////////////////////////////////
// sidx box
//////////////////////////////////////
/**
 *
 * @extends Box
 * @constructor
 */
function SidxBox(parser, type, startOffset, length)
{
    this.base = Box;
    this.base.call(this, parser, type, startOffset, length);
}
SidxBox.prototype = new Box();
SidxBox.prototype.constructor = SidxBox;

SidxBox.prototype._parseHeader = function _parseHeader()
{
    // read full box header
    this.readFullHeader();

    // read sidx specific fields
    this.referenceID = this.parser._read32();
    this.timescale = this.parser._read32();

    if (this.version === 0)
    {
        this.earliestPresentationTime = this.parser._read32();
        this.firstOffset = this.parser._read32();
    }
    else
    {
        this.earliestPresentationTime = this.parser._read64();
        this.firstOffset = this.parser._read64();
    }

    this.reserved = this.parser._read16();
    this.referenceCount = this.parser._read16();

    _traceLevel(this.level, "referenceID = " + this.referenceID +
                " timescale = " + this.timescale +
                " earliestPresentationTime = " + this.earliestPresentationTime +
                " firstOffset = " + this.firstOffset +
                " referenceCount = " + this.referenceCount);
};

// Sidx format
// [size] 4 bytes (1 bit type, 31 bits size )
// [duration] 4 bytes
// [sap information] 4 bytes
//
// Fragment Format:
// [size] 4 bytes
// [startPts] 4 bytes
// [offset] 6 bytes
// [duration] 2 bytes

SidxBox.prototype.parse = function parse()
{
    if ( platform.parseSegmentIndex )
    {
        _traceLevel(this.level,"using platform segment index parser");

        var data = this.parser._readData( this.length - 8 ),
        result = platform.parseSegmentIndex( data, this.startOffset + this.length,
                                             this.parser.url );

        if ( !result || !result["success"] )
            return false;

        this.parser._provideFragments( new FragmentListView( result["data"] ), result["avdur"], false );
    }
    else
    {
        // parse the header
        this._parseHeader();

        var anchor = this.startOffset + this.length,
            timescale = this.timescale,
            startPts = this.earliestPresentationTime,
            startPtsMs = _convertTimeToMs( startPts, timescale ),
            nextPts = 0,
            nextPtsMs = 0,
            size = 0,
            offset = anchor + this.firstOffset,
            truncate = this.parser.truncate && ( this.referenceCount > 60 ),
            fragments = truncate ? 60 : this.referenceCount,
            inView = this.parser._readData( fragments * 12 ),
            inOff = 0,
            outOff = 0,
            outArr = new ArrayBuffer(Fragment.BYTES_PER_FRAGMENT * fragments),
            outView = new DataView( outArr );

        for (var i = 0; i < fragments; ++i)
        {
            size = inView.getUint32( inOff );
            nextPts = startPts + inView.getUint32( inOff + 4 );
            nextPtsMs = ( nextPts * 1000 / timescale ) | 0;

            outView.setUint32( outOff, size & 0x7fffffff );             // size
            outView.setUint32( outOff + 4, startPtsMs );                // startPts
            outView.setUint32( outOff + 8, offset / 0x10000 );          // offset high 32 bits (setUint32 uses lower 32 bits of value)
            outView.setUint32( outOff + 12, ( ( offset & 0xffff ) << 16 ) + ( nextPtsMs - startPtsMs ) ); // offset high 16 bits and duration in ms

            offset += size;
            startPts = nextPts;
            startPtsMs = nextPtsMs;

            inOff += 12;
            outOff += 16;
        }

        var totalDuration = _convertTimeToMs( startPts - this.earliestPresentationTime, timescale ),
            averageFragmentDuration = Math.floor( totalDuration / fragments );

        this.parser._provideFragments( new FragmentListView( outArr ), averageFragmentDuration, truncate );
    }

    return true;
};

//////////////////////////////////////
// pssh box
//////////////////////////////////////
/**
 *
 * @extends Box
 * @constructor
 */
function PsshBox(parser, type, startOffset, length)
{
    this.base = Box;
    this.base.call(this, parser, type, startOffset, length);
}
PsshBox.prototype = new Box();
PsshBox.prototype.constructor = PsshBox;

Object.defineProperties(PsshBox.prototype, {
    NETFLIX_PSSH:   { get: function() { return "e41f7029-c73c-344a-8c5b-ae90c7439a47"; }},
    PLAYREADY_PSSH: { get: function() { return "79f0049a-4098-8642-ab92-e65be0885f95"; }}
});

PsshBox.prototype.parse = function parse(ctxt)
{
    // read full box header
    this.readFullHeader();

    // read the systemID
    var systemId = this.parser._readUUID();
    _traceLevel(this.level, "parsing pssh box ID = " + systemId);

    // read size
    var size = this.parser._read32();
    _traceLevel(this.level, "pssh size = 0x" + size.toString(16));

    // extract out the specific data
    var data = this.parser.data.slice(this.parser.offset, this.parser.offset + size);

    // build drm event
    var evt = {
        'ctxt': ctxt,
        'header': data
    };

    if (systemId == this.PLAYREADY_PSSH)
    {
        evt['type'] = "drmheader";
        evt['drmType'] = "PlayReady"; // follow naming convention in DataTypes.h
    }
    else if (systemId == this.NETFLIX_PSSH)
        evt['type'] = "nflxheader";
    else
    {
        _traceLevel(this.level, "Unrecognized pssh systemID: " + systemId);
        return true;
    }

    _traceLevel(this.level, "Handling pssh type: " + evt['type']);

    // notify caller
    this.parser.callEventListeners(evt['type'], evt);

    return true;
};

//////////////////////////////////////
// stsd box
//////////////////////////////////////
/**
 *
 * @extends Box
 * @constructor
 */
function StsdBox(parser, type, startOffset, length)
{
    this.base = Box;
    this.base.call(this, parser, type, startOffset, length);
}
StsdBox.prototype = new Box();
StsdBox.prototype.constructor = StsdBox;

StsdBox.prototype.parse = function parse(ctxt)
{
    // read full box header
    this.readFullHeader();

    // read sample count
    var numSamples = this.parser._read32();
    VERBOSE && _traceLevel(this.level, "samples in stsd: " + numSamples);

    // create a sub parser for samples
    return this.createSubParser(ctxt);
};

//////////////////////////////////////
// encv box
//////////////////////////////////////
/**
 *
 * @extends Box
 * @constructor
 */
function EncvBox(parser, type, startOffset, length)
{
    this.base = Box;
    this.base.call(this, parser, type, startOffset, length);
}
EncvBox.prototype = new Box();
EncvBox.prototype.constructor = EncvBox;

EncvBox.prototype.parse = function parse(ctxt)
{
    // skip over SampleEntry base
    this.parser.offset += 8;

    // skip predefined and reserved bytes
    this.parser.offset += 16;

    var width = this.parser._read16();
    var height = this.parser._read16();
    VERBOSE && _traceLevel(this.level, "encv size: " + width + " x " + height);

    // skip resolution, reserved, frame count
    this.parser.offset += 14;

    // skip compressorname
    this.parser.offset += 32;

    // skip depth, predefined
    this.parser.offset += 4;

    // create subparser for rest
    return this.createSubParser(ctxt);
};

function keyIdToString() {
    var view = new DataView(this),
        str = "",
        digit;
    for (var i=0; i<this.byteLength; i++)
    {
        digit = view.getUint8(i);
        str += ("00" + digit.toString(16)).slice(-2);
    }
    return str;
}

function readKeyId(ctxt) {
    // extract 16 byte keyId
    var offset = this.parser.offset,
        keyId = this.parser.data.slice(offset, offset + 16),
        flipped,
        evt;

    // stick a toString() method on the keyId
    keyId.toString = keyIdToString;

    // Will flip it in place and return true if it did
    flipped = require(53).flipKid(keyId);

    // read keyId as hex string
    _traceLevel(this.level, "read KID: " + keyId.toString() + (flipped ? " (FLIPPED)" : ""));

    // send event
    evt = {
        'type': 'keyid',
        'ctxt': ctxt,
        'keyId': keyId,
        'offset': offset,
        'flipped': flipped
    };
    this.parser.callEventListeners(evt['type'], evt);
}

//////////////////////////////////////
// tenc box
//////////////////////////////////////
/**
 *
 * @extends Box
 * @constructor
 */
function TencBox(parser, type, startOffset, length)
{
    this.base = Box;
    this.base.call(this, parser, type, startOffset, length);
}
TencBox.prototype = new Box();
TencBox.prototype.constructor = TencBox;

TencBox.prototype.parse = function parse(ctxt)
{
    // read full box header
    this.readFullHeader();

    // ignore first 32 bytes
    this.parser.offset += 4;
    readKeyId.call(this, ctxt);

    return true;
};

//////////////////////////////////////
// uuid box
//////////////////////////////////////
/**
 * @extends Box
 * @constructor
 */

function UuidBox(parser, type, startOffset, length)
{
    this.base = Box;
    this.base.call(this, parser, type, startOffset, length);
}
UuidBox.prototype = new Box();
UuidBox.prototype.constructor = UuidBox;

Object.defineProperties(UuidBox.prototype, {
    TENC_UUID:   { get: function() { return "cedb7489-e77b-514c-84f9-7148f9882554"; } }
});

UuidBox.prototype.parse = function parse(ctxt)
{
    // read the UUID
    var uuid = this.parser._readUUID();
    VERBOSE && _traceLevel(this.level, "reading UUID = " + uuid);

    if (uuid == this.TENC_UUID)
    {
        // Move past the next 8 bytes to the KID
        this.parser.offset += 8;
        readKeyId.call(this, ctxt);
    }

    return true;
};

//////////////////////////////////////
// createBox factory
//////////////////////////////////////

var boxMap = {
    'encv': EncvBox,
    'free': FreeBox,
    'mdia': ContainerBox,
    'minf': ContainerBox,
    'moov': MoovBox,
    'pssh': PsshBox,
    'schi': ContainerBox,
    'sidx': SidxBox,
    'sinf': ContainerBox,
    'stbl': ContainerBox,
    'stsd': StsdBox,
    'tenc': TencBox,
    'trak': ContainerBox,
    'uuid': UuidBox
};

function createBox(parser, type, startOffset, length)
{
    var ctor = boxMap[type];
    if (!ctor)
        return undefined;

    return new ctor(parser, type, startOffset, length);
}

//////////////////////////////////////
// Mp4Parser
//////////////////////////////////////

/**
 * @param {string} url
 * @param {Array} data
 * @param {boolean} truncate
 * @param {number} offset
 * @param {number} length
 * @param {number} level
 * @constructor
 */
function Mp4Parser(url, data, truncate, offset, length, level)
{
    this.url = url;
    this.truncate = truncate;
    this.level = level || 0;
    this.offset = offset || 0;
    this.parserStart = this.offset;
    this.requiredBoxes = ['moov', 'sidx'];

    this.newData(data, offset, length);
}
Mp4Parser.prototype = EventEmitter;
Mp4Parser.prototype.constructor = Mp4Parser;

Mp4Parser.prototype.newData = function newData(data, offset, length)
{
    this.data = data;
    this.dataLength = length || data.byteLength; // use passed in length or data length
    this.parserEnd = this.parserStart + this.dataLength;
    this.view = new DataView(data);
};

Mp4Parser.prototype.parse = function parse(ctxt)
{
    var boxStart;
    this._ctxt = ctxt;

    while(1)
    {
        boxStart = this.offset;
        VERBOSE && _traceLevel(this.level, "box start = 0x" + boxStart.toString(16));

        // make sure we have enough to read the header
        if (this.parserEnd - boxStart < 8)
        {
            this._requestMoreData();
            break;
        }

        // get length && box type
        var length = this._read32();
        VERBOSE && _traceLevel(this.level, "box length = 0x" + length.toString(16));
        if (length === 0)
        {
            this._parseError("MP4: invalid zero length box");
            break;
        }

        var type = _convertNumToAscii(this._read32());
        VERBOSE && _traceLevel(this.level, "box type = " + type);

        // make sure we have enough data
        var needed = boxStart + length;
        if (needed > this.parserEnd)
        {
            _traceLevel(this.level, "more data needed: " +
                        needed + " > " + this.parserEnd);
            var more = needed - this.parserEnd;
            this._requestMoreData(type, more);
            break;
        }

        // if this is a box we're looking for, parse it
        var box = createBox(this, type, boxStart, length);
        if (box)
        {
            var ok = box.parse(ctxt);
            if (!ok)
            {
                _traceLevel(this.level, "box parser failed: " + type);
                break;
            }
        }

        if (this.requiredBoxes)
        {
            // see if it was a required box
            var idx = this.requiredBoxes.indexOf(type);
            if (idx != -1)
            {
                _traceLevel(this.level, "required box " + type +
                            " found at offset: 0x" + boxStart.toString(16));
                this.requiredBoxes.splice(idx, 1);
            }

            // if no more required, we're done
            if (this.requiredBoxes.length === 0)
            {
                // report leftOver bytes as everything past moov
                var leftOver;
                if (_.isUndefined(this.moovEnd))
                {
                    leftOver = this.parserEnd - (boxStart + length);
                    _traceLevel(this.level,
                                "all required boxes seen, left over bytes = 0x" +
                                leftOver.toString(16));
                }
                else
                {
                    leftOver = this.parserEnd - this.moovEnd;
                    _traceLevel(this.level, "leftover bytes after moov: 0x" +
                                leftOver.toString(16));
                }

                // report done
                this._parseDone(leftOver);
                return true;
            }
        }

        // move past this box
        this.offset = boxStart + length;
        VERBOSE && _traceLevel(this.level, "next box at 0x" + boxStart.toString(16) +
                               " + 0x" + length.toString(16) +
                               " = 0x" + this.offset.toString(16));
    }

    // if we get here, we haven't finished parsing, reset parser to beginning of
    // current box
    this.offset = boxStart;
    return false;
};

/**
 *
 * @param {Object=} type
 * @param {number=} bytes
 * @private
 */
Mp4Parser.prototype._requestMoreData = function _requestMoreData(type, bytes)
{
    if (!type)
    {
        // don't have enough even for header, request 4k
        VERBOSE && _traceLevel(this.level, "not enough for header, requesting 4k");
        this._parseMore(4096);
        return;
    }

    // last required box?
    if (this.requiredBoxes)
    {
        var required = (this.requiredBoxes.indexOf(type) != -1);
        if (required && (this.requiredBoxes.length == 1))
        {
            // just request rest of this box
            _traceLevel(this.level, "requesting last required box: " + bytes);
            this._parseMore(bytes);
            return;
        }
    }

    // request this box + 4k
    _traceLevel(this.level, "requesting default 4k + box: " + bytes);
    this._parseMore(bytes + 4096);
    return;
};

Mp4Parser.prototype._parseError = function _parseError(errmsg)
{
    _warn("MP4: ERROR: " + errmsg);
    var evt = {
        'type': "error",
        'ctxt': this._ctxt,
        'errormsg': errmsg
    };
    this.callEventListeners(evt['type'], evt);
};

Mp4Parser.prototype._parseDone = function _parseDone(remaining)
{
    // Generate events through the generateDoneEvent()
    // This is because when Cadmium bypass the MP4Parse,
    // it also needs to generate the mp4Done event to continue the control flow
    var evt = generateMp4DoneEvent(remaining, this._ctxt);

    this.callEventListeners(evt['type'], evt);
};

Mp4Parser.prototype._parseMore = function _parseMore(bytes)
{
    var evt = {
        'type': "requestdata",
        'ctxt': this._ctxt,
        'bytes': bytes
    };
    this.callEventListeners(evt['type'], evt);
};

Mp4Parser.prototype._provideFragments = function _provideFragments(
    fragments, durationMs, truncated)
{
    var evt = {
        'type': "fragments",
        'ctxt': this._ctxt,
        'fragments': fragments,
        'averageDurationMs': durationMs,
        'truncated': truncated
    };
    this.callEventListeners(evt['type'], evt);
};

//////////////////////////////////////
// Helper Function
//////////////////////////////////////
function generateMp4DoneEvent(remaining, ctxt)
{
    return {
        'type': "done",
        'ctxt': ctxt,
        'remaining': remaining
    };
}

//////////////////////////////////////
// raw data readers
//////////////////////////////////////
Mp4Parser.prototype._read8 = function _read8()
{
    var data = this.view.getUint8(this.offset);
    this.offset += 1;
    return data;
};

/**
 *
 * @param {boolean=} little
 * @private
 */
Mp4Parser.prototype._read16 = function _read16(little)
{
    var data = this.view.getUint16(this.offset, little);
    this.offset += 2;
    return data;
};

/**
 *
 * @param {boolean=} little
 * @private
 */
Mp4Parser.prototype._read32 = function _read32(little)
{
    var data = this.view.getUint32(this.offset, little);
    this.offset += 4;
    return data;
};

/**
 *
 * @param {boolean=} little
 * @private
 */
Mp4Parser.prototype._read64 = function _read64(little)
{
    var data1 = this.view.getUint32(this.offset);
    this.offset += 4;
    var data2 = this.view.getUint32(this.offset);
    this.offset += 4;
    if (data1 !== 0)
        _warn("Warning: read value > 64 bits");
    return data1 << 32 | data2;
};

Mp4Parser.prototype._readUUID = function _readUUID()
{
    var u1 = this._read32(true); // 4
    var u2 = this._read16(true); // 2
    var u3 = this._read16(true); // 2

    var u4 = this._read16(); // 2

    // normally the last field is 48 bits but since I can't shift more than 32 bits max,
    // let's just read this as 16 and 32
    var u5 = this._read16(); // 2
    var u6 = this._read32(); // 4
    var uuid = u1.toString(16) + "-" + u2.toString(16) + "-" + u3.toString(16) +
        "-" + u4.toString(16) + "-" + u5.toString(16) + u6.toString(16);

    return uuid;
};

Mp4Parser.prototype._readData = function readData( length )
{
    var data = new DataView( this.data, this.offset, length );
    this.offset += length;
    return data;

};

//////////////////////////////////////
// Export
//////////////////////////////////////

module.exports = {
                    Mp4Parser: Mp4Parser,
                    generateMp4DoneEvent: generateMp4DoneEvent
                 };


},{"103":103,"50":50,"53":53,"61":61,"94":94}],57:[function(require,module,exports){
module.exports = {  LocationHistory : require(58),
                    NetworkMonitor : require(60),
                    NetworkHistory : require(59) };
},{"58":58,"59":59,"60":60}],58:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

/* IDL:

enum NetworkConfidence {
    HAVE_NOTHING = 0,           // no data available
    HAVE_SOMETHING = 1,         // some data available, more probing *required*
    HAVE_MINIMUM = 2,           // some data available, more proving *desired*
    HAVE_ENOUGH = 3             // enough data available, no more probing
};

dictionary Statistics {
    unsigned long average;
    unsigned long variance;
};

dictionary NetworkStatistics {
    NetworkConfidenceState  confidence;
    Statistics              throughput;
    Statistics?             responseTime;
    Statistics?             httpResponseTime;
    function                throughputPpf;        // kbit/s
    function                responseTimePpf;       // ms
    function                httpResponseTimesPpf;     // ms
};



interface LocationHistory {

    // Save the state to storage
    void save();

    // Set the current location
    void setLocation( DOMString location );

    // Set the current network interface
    void setCurrentInterface( DOMString interface );

    // Set the current local ip address
    void setCurrentClientIp( DOMString ip );

    // Methods for providing status updates for the current location
    void addThroughput( unsigned long throughput, NetworkConfidence confidence );      // kbit/s

    // Add report of total response time (DNS+TCP+HTTP)
    void addHttpResponseTime( unsigned long responseTimeMs );

    // Add report of HTTP response time
    void addHttpResponseTime( unsigned long httpResponseTimeMs );

    // Indicate that a location is temporarily failed
    void fail( DOMString location );

    // Get the specified percentiles of the historical throughput, connect time and response time
    // for the specified location assuming current interface, current ip and current time of day.
    HistoricalStatistics? get( DOMString location );
};

partial interface Nrdp {

    attribute LocationHistory lochist;

};

// State object JTON description

state = { "#any" : locationState };             // key is the location name
locationState = { "#any" : interfaceState };    // key is the interface name
interfaceState = {  "#mandatory" : [ "g", "h" ],
                    "g" : historyState,         // history independent of time-of-day
                    "h" : [ historyState ],     // history for each period of time-of-day
                    "f" : "uint64"              // last failure time (ms since epoch)
                 }
historyState = { "#mandatory" : [ "c", "t" ],
                 "c" : "uint32",                // confidence
                 "t" : "uint64",                // time last observed (ms since epoch)
                 "tp" : ewma,                   // throughput statistics
                 "rt" : ewma,                   // response time statistics
                 "hrt" : ewma                   // http response time statistics
                  }
ewma = { "#mandatory" : [ "a", "s" ],
         "a" : "uint64",                        // average value
         "s" : "uint64",                        // average of squares
         "c" : "uint64"                         // number of values observed
       }

*/

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

var _ = require(103),
    Enums = require(48),
    util = require(84),
    config = require(47),
    platform = require(61),
    DiscreteEwmav = util.ewma.DiscreteEwmav,
    Gaussian = util.Gaussian,
    console = new platform.Console('ASEJS_LOCATION_HISTORY', 'media|asejs'),
    DEBUG = ("debug" !== 'release');

var LocationMonitorConfig = config.declare({
    _fastHistoryExpirationTime:         [ 'fastHistoricBandwidthExpirationTime' , 10 * 60 ],
    _historyExpirationTime:             [ 'bandwidthExpirationTime', 7 * 24 * 3600 ],
    _failureExpirationTime:             [ 'failureExpirationTime',  1 * 24 * 3600 ],
    _periods:                           [ 'historyTimeOfDayGranularity' ,  4 ],
    _historicThroughputHalflife:        [ 'historicThroughputHalflife' ,  8 * 3600 / 2 ],
    _historicResponseTimeHalflife:      [ 'historicResponseTimeHalflife' ,  100 ],
    _historicHttpResponseTimeHalflife:  [ 'historicHttpResponseTimeHalflife' ,  100 ]
});

var NULL_STATS = { confidence: Enums.NETWORK_CONFIDENCE.HAVE_NOTHING };

/* Location history for a specific location, interface, local ip and time of day/week

    [Constructor( unsigned long tphalflife, unsigned long cthalflife, unsigned long rthalflife )]
    interface LocationHistory {
        void addThroughput( unsigned long throughput );      // kbit/s
        void addResponseTime( unsigned long connectTime );    // TCP connect time ms
        void addHttpResponseTime( unisgned long responseTime );  // HTTP response time ms
        void fail();                                         // indicate location failed

        object getState();
        void setState( object state );

        NetworkStatistics? get();
    };
*/

function ageAsString( age ) {
    var result;
    age = Math.floor( age / 1000 );
    result = ( age % 60 ) + ' seconds';
    age = Math.floor( age / 60 );
    if ( age > 0 ) result = ( age % 60 ) + ' minutes ' + result;
    age = Math.floor( age / 60 );
    if ( age > 0 ) result = ( age % 24 ) + ' hours ' + result;
    age = Math.floor( age / 24 );
    if ( age > 0 ) result = age + ' days ' + result;
    return result;
}

/**
 *
 * @param {number} tphalflife
 * @param {number} rthalflife
 * @param {number} hrthalflife
 * @constructor
 */
function SingleLocationHistory( tphalflife, rthalflife, hrthalflife ) {

    this._confidence = Enums.NETWORK_CONFIDENCE.HAVE_NOTHING;
    this._throughput = new DiscreteEwmav( tphalflife, tphalflife / 4 );
    this._responseTime = new DiscreteEwmav( rthalflife, rthalflife / 4 );
    this._httpResponseTime = new DiscreteEwmav( hrthalflife, hrthalflife / 4 );
    this._time = null;
}

SingleLocationHistory.prototype.addThroughput = function( throughput, confidence ) {

    this._confidence = confidence;
    this._throughput.add( throughput );
    this._time = platform.time.mono();
};

SingleLocationHistory.prototype.addResponseTime = function( responseTime ) {

    this._responseTime.add( responseTime );
};

SingleLocationHistory.prototype.addHttpResponseTime = function( httpResponseTime ) {

    this._httpResponseTime.add( httpResponseTime );
};

SingleLocationHistory.prototype.getState = function() {
    var tp = this._throughput.getState(),
        rt = this._responseTime.getState(),
        hrt = this._httpResponseTime.getState();

    if ( _.isNull( tp ) && _.isNull( rt ) && _.isNull( hrt ) ) return null;

    var state = {   "c" : this._confidence,
                    "t" : platform.time.monotonow( this._time ) };

    if ( !_.isNull( tp ) ) state["tp"] = tp;
    if ( !_.isNull( rt ) ) state["rt"] = rt;
    if ( !_.isNull( hrt ) ) state["hrt"] = hrt;

    return state;
};

SingleLocationHistory.prototype.setState = function( state ) {

    var now = platform.time.now();

    if ( !state ||
            !_.has( state, "c" ) ||
            !_.has( state, "t" ) ||
            !_.has( state, "tp" ) ||
            !_.isFinite( state["c"] ) ||
            !_.isFinite( state["t"] ) ||
            state["c"] < 0 || state["c"] > Enums.NETWORK_CONFIDENCE.HAVE_ENOUGH ||
            state["t"] > now ||
            !this._throughput.setState( state["tp"] ) ) {
        this._confidence = Enums.NETWORK_CONFIDENCE.HAVE_NOTHING;
        this._time = null;
        this._failtime = null;
        this._throughput.setState( null );
        this._responseTime.setState( null );
        this._httpResponseTime.setState( null );

        return false;
    }

    this._confidence =  state["c"];
    this._time = platform.time.nowtomono( state["t"] );
    this._responseTime.setState( _.has( state, "rt" ) ? state["rt"] : null );
    this._httpResponseTime.setState( _.has( state, "hrt" ) ? state["hrt"] : null );

    return true;
};

SingleLocationHistory.prototype.get = function() {

    if ( _.isNull( this._time ) ) {
        return NULL_STATS;
    }

    var age = ( platform.time.mono() - this._time) / 1000;

    if ( age > LocationMonitorConfig._historyExpirationTime ) {
        this._confidence = Enums.NETWORK_CONFIDENCE.HAVE_NOTHING;
    } else if ( age > LocationMonitorConfig._fastHistoryExpirationTime ) {
        this._confidence = Math.min( this._confidence, Enums.NETWORK_CONFIDENCE.HAVE_SOMETHING );
    }

    var tp = this._throughput.get(),
        rt = this._responseTime.get(),
        hrt = this._httpResponseTime.get(),
        result = {  confidence :        this._confidence,
                    throughput :        tp,
                    responseTime :      rt,
                    httpResponseTime :  hrt };

    if ( tp ) {
        result.throughputPpf = Gaussian.prototype.ppf.bind( tp );
    }

    if ( rt ) {
        result.responseTimePpf = Gaussian.prototype.ppf.bind( rt );
    }

    if ( hrt ) {
        result.httpResponseTimePpf = Gaussian.prototype.ppf.bind( hrt );
    }

    return result;
};

SingleLocationHistory.prototype.time = function() { return this._time; };

SingleLocationHistory.prototype._debug = function( prefix ) {
    var value = this.get(),
        age = platform.time.mono() - this._time;
    DEBUG && console.log( prefix + ': ' + value.confidence
                                + ', ' + JSON.stringify( value.throughput )
                                + ', ' + ageAsString( age ) );
};

/* Location history for a specific location, interface, local ip

    [Constructor( unsigned long tphalflife, unsigned long cthalflife, unsigned long rthalflife, unsigned long periods )]
    interface LocationHistory {

        object getState();
        void setState( object state );

        void addThroughput( unsigned long throughput );      // kbit/s
        void addResponseTime( unsigned long connectTime );    // TCP connect time ms
        void addHttpResponseTime( unisgned long responseTime );  // HTTP response time ms
        void failed();

        HistoricalStatistics? get();
    };
*/
/**
 *
 * @param {number} tphalflife
 * @param {number} rthalflife
 * @param {number} hrthalflife
 * @param {number} periods
 * @constructor
 */
function DailyLocationHistory( tphalflife, rthalflife, hrthalflife, periods ) {
    this._global = new SingleLocationHistory( tphalflife, rthalflife, hrthalflife );
    this._timed = [ ];
    this._failtime = null;

    for( var i = 0; i < periods; ++i ) {
        this._timed.push( new SingleLocationHistory( tphalflife, rthalflife, hrthalflife ) );
    }
}

DailyLocationHistory.prototype._index = function() {
    return ( ( new Date() ).getHours() / ( 24 / this._timed.length ) ) | 0;
};

DailyLocationHistory.prototype.getState = function() {
    var state =  {  "g" : this._global.getState(),
                    "h" : this._timed.map( function( x ) { return x.getState(); } ) };

    if ( !_.isNull( this._failtime ) ) state["f"] = platform.time.monotonow( this._failtime );

    return state;
};

DailyLocationHistory.prototype.setState = function( state ) {

    if ( !this._global.setState( state["g"] ) )
        return false;

    var periods = this._timed.length;

    var failed = false;

    this._timed.forEach( function( o, i ) {
        var j = ( i * state["h"].length / periods ) | 0;
        failed = !o.setState( state["h"][ j ] ) || failed;
    } );

    this._failtime = _.has( state, "f" ) ? platform.time.nowtomono( state["f"] ) : null;

    return failed;
};

DailyLocationHistory.prototype.addThroughput = function( throughput, confidence ) {
    this._global.addThroughput( throughput, confidence );

    this._timed[ this._index() ].addThroughput( throughput, confidence );

    this._failtime = null;
};

DailyLocationHistory.prototype.addResponseTime = function( responseTime ) {
    this._global.addResponseTime( responseTime );

    this._timed[ this._index() ].addResponseTime( responseTime );
};

DailyLocationHistory.prototype.addHttpResponseTime = function( httpResponseTime ) {
    this._global.addHttpResponseTime( httpResponseTime );

    this._timed[ this._index() ].addHttpResponseTime( httpResponseTime );
};

DailyLocationHistory.prototype.fail = function( time ) {
    this._failtime = time;
};

DailyLocationHistory.prototype.get = function() {

    if ( !_.isNull( this._failtime ) ) {

        var age = ( platform.time.mono() - this._failtime ) / 1000;

        if ( age < LocationMonitorConfig._failureExpirationTime )
            return { confidence: Enums.NETWORK_CONFIDENCE.HAVE_NOTHING, failed: true };

        this._failtime = null;
    }

    var timed = this._timed[ this._index() ].get(),
        global = this._global.get(),
        result = timed.confidence >= global.confidence ? timed : global;

    result.failed = false;

    return result;
};

DailyLocationHistory.prototype.time = function() { return this._global.time(); };

DailyLocationHistory.prototype._debug = function( prefix ) {
    this._global._debug( prefix + ': global' );
    this._timed.forEach( function( o, i, a ) {
        if ( !_.isNull( o.time() ) ) {
            var h = ( i * 24 / a.length );
            h = ( h < 10 ? '0' : '' ) + h + '00';
            o._debug( prefix + ':  ' + h + 'h' );
        }
    } );
};

function setDefault( o, p, d ) {
    return _.has( o, p ) ? o[ p ] : ( o[ p ] = d );
}

function LocationHistory() {

    this.erase();
    this._load();

    //-------------------------------------------------------------------------
    // Overriding output with a command line option
    var fake = config.debugLocationHistoryThroughput;
    if (fake) {
        DEBUG && console.log('Using fake location history: ' + fake);
        fake = {
            confidence: Enums.NETWORK_CONFIDENCE.HAVE_ENOUGH,
            throughput: {average: parseInt(fake, 10), variance: 0},
            responseTime: {average: 0, variance: 0},
            httpResponseTime: {average: 0, variance: 0}
        };
        this.get = function() { return fake; };
    }
    //-------------------------------------------------------------------------
}

LocationHistory.prototype._getHistory = function( location, intf ) {

    var loc = setDefault( this._history, location, {} ),
        net = setDefault( loc, intf,
                new DailyLocationHistory(   LocationMonitorConfig._historicThroughputHalflife,
                                            LocationMonitorConfig._historicResponseTimeHalflife,
                                            LocationMonitorConfig._historicHttpResponseTimeHalflife,
                                            LocationMonitorConfig._periods ) );

    return net;
};

LocationHistory.prototype._load = function() {
    var state = platform.storage.get( "lh" );

    if ( state ) this._setState( state );
    
    DEBUG && this._debug();

};

LocationHistory.prototype._getState = function() {

    var state = { };

    _.each( this._history, function( locationHistory, location ) {

        _.each( locationHistory,  function( interfaceHistory, intf ) {

            setDefault( state, location, {} )[ intf ] = interfaceHistory.getState();

        }, this );
    }, this );

    return state;
};

LocationHistory.prototype._setState = function( state ) {

    var success = null;

    _.each( state, function( locationState, location ) {
        _.each( locationState, function( interfaceState, intf ) {

            var history = new DailyLocationHistory( LocationMonitorConfig._historicThroughputHalflife,
                                                    LocationMonitorConfig._historicResponseTimeHalflife,
                                                    LocationMonitorConfig._historicHttpResponseTimeHalflife,
                                                    LocationMonitorConfig._periods );

            if ( history.setState( interfaceState ) ) {

                setDefault( this._history, location, {} )[ intf ] = history;

                success = true;

            } else if ( _.isNull( success ) ) {

                success = false;
            }
        }, this );
    }, this );

    return _.isNull( success ) ? true : success;
};

LocationHistory.prototype.save = function() {

    var state = this._getState();

    DEBUG && console.log( 'saving state: ' + JSON.stringify( state ) );
    
    //DEBUG && this._debug();

    platform.storage.set( "lh", state );
};

LocationHistory.prototype.erase = function( location ) {

    if ( location ) {

        DEBUG && console.log("Erasing in-memory location history for '" + location + "'");
        if ( _.has( this._history, location ) ) {
            delete this._history[ location ];
        }

        if ( this._currentLocation == location ) {
            this._currentLocation = '';
            this._currentInterface = '';
            this._locationHistory = null;
        }

    } else {

        DEBUG && console.log("Erasing all in-memory location history");
        this._history = {};
        this._currentLocation = '';
        this._currentInterface = '';
        this._locationHistory = null;

    }
};

LocationHistory.prototype.setLocation = function( loc ) {

    DEBUG && console.log( 'location=' + loc );

    this._currentLocation = loc;
    this._locationHistory = null;
};

LocationHistory.prototype.setCurrentInterface = function( net ) {
    this._currentInterface = net;
    this._locationHistory = null;
};

LocationHistory.prototype._getLocationHistory = function() {
    if ( _.isNull( this._locationHistory ) ) {

        this._locationHistory = this._getHistory( this._currentLocation, this._currentInterface );
    }

    return this._locationHistory;
};

LocationHistory.prototype.addThroughput = function( throughput, confidence ) {

    DEBUG && console.log( this._currentInterface + ':' + this._currentLocation + ', throughput=' + throughput + ', confidence=' + confidence );

    this._getLocationHistory().addThroughput( throughput, confidence );
};

LocationHistory.prototype.addResponseTime = function( responseTime ) {
    this._getLocationHistory().addResponseTime( responseTime );
};

LocationHistory.prototype.addHttpResponseTime = function( httpResponseTime ) {
    this._getLocationHistory().addHttpResponseTime( httpResponseTime );
};

LocationHistory.prototype.fail = function( location, time ) {
    this._getHistory( location, this._currentInterface ).fail( time );
};

LocationHistory.prototype.get = function( loc, fallback ) {
    var lochist = this._history[ loc ],
        nethist = lochist ? lochist[ this._currentInterface ] : null,
        statistics = null;

    if ( nethist ) {
        statistics = nethist.get();
        
        DEBUG && console.log( 'Query history for ' + loc + ' on ' + this._currentInterface + ' returns ' + JSON.stringify( statistics ) );
        
        if ( statistics.confidence > Enums.NETWORK_CONFIDENCE.HAVE_NOTHING )
            return statistics;
    }

    if ( fallback === false )
        return NULL_STATS;

    // Use the location which is highest if sorted by ( uses current interface, confidence, age )
    statistics = null;
    var confidence = null, currentinterface = false, besttime = null;
    _.each( this._history, function( interfaces, location ) {
        _.each( interfaces, function( history, iface ) {
            if ( !currentinterface || iface == this._currentInterface ) {

                var stats = history.get();

                if ( stats && ( !confidence || confidence <= stats.confidence ) ) {
                    if ( !besttime || ( confidence < stats.confidence ) || ( besttime < history.time() ) ) {
                        confidence = stats.confidence;
                        currentinterface = ( iface == this._currentInterface );
                        besttime = history.time();
                        statistics = stats;
                    }
                }
            }
        }, this );
    }, this );
    
    DEBUG && console.log( 'Fallback history for ' + loc + ' on ' + this._currentInterface + ' returns ' + JSON.stringify( statistics ) );

    return statistics ? statistics : NULL_STATS;
};

LocationHistory.prototype._debug = function() {

    _.each( this._history, function( interfaces, location ) {
        _.each( interfaces, function( history, iface ) {
            history._debug( location + ':' + iface );
        } );
    } );

};

module.exports = LocationHistory;

},{"103":103,"47":47,"48":48,"61":61,"84":84}],59:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

/* Network Monitor persistent state
 *
 * {    "t" : integer,          // platform.time.now() at end of last streaming session
 *      "s" : integer,          // stream time (s) corresponding to t
 *      "i" : [ interruption ]  // observed interruptions
 * };
 *
 * interruption = [ integer, integer ]  // stream time (s) and duration (ms) of interruption in ms
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

var _ = require(103),
    config = require(47),
    platform = require(61),
    console = new platform.Console('ASEJS_NETWORK_HISTORY', 'media|asejs'),
    DEBUG = ("debug" !== 'release');

var NetworkHistoryConfig = config.declare({
    networkInteruptionStorageWindow:    [ 'netIntrStoreWindow' , 36000 ],
    networkInterruptionDuration:        [ 'minNetIntrDuration', 8000 ]
});

function NetworkHistory()
{
    this._load();
}

NetworkHistory.prototype.save = function save()
{
    var state = this.getState();

    platform.storage.set( "nh", state );

    DEBUG && console.log( "saving state: " + JSON.stringify( state ) );
};

NetworkHistory.prototype.startStreaming = function startStreaming()
{
    if ( !this._streaming )
    {
        this._streaming = true;
        this._realTime = platform.time.mono();

        DEBUG && console.log( "streamingStart" );
    }
};

NetworkHistory.prototype.stopStreaming = function stopStreaming()
{
    if ( this._streaming )
    {
        var mono = platform.time.mono();

        this._streamTime += ( mono - this._realTime );
        this._realTime = mono;

        this._streaming = false;
        this._lastInterruptionEnd = null;

        DEBUG && console.log( "streamingStop" );
    }
};

NetworkHistory.prototype.interruption = function interruption( start, end )
{
    if ( this._streaming )
    {
        if ( end > this._realTime )
        {
            this._streamTime += end - this._realTime;
            this._realTime = end;
        }

        if ( this._lastInterruptionEnd === null || start > this._lastInterruptionEnd )
        {
            var duration = ( end - start );

            this._interruptions.push( [ this._streamTime - duration, duration ] );

            this._trim();

            this._lastInterruptionEnd = end;

            DEBUG && console.log( "interruption: " + duration + "ms @ " + start + "ms" );
        }
    }
};

NetworkHistory.prototype.interruptionRate = function interruptionRate( window )
{
    if ( this._streaming )
    {
        var mono = platform.time.mono();

        this._streamTime += ( mono - this._realTime );
        this._realTime = mono;
    }

    var cutoff = this._streamTime - ( window * 1000 );
    return this._interruptions.filter( function( i ) { return i[0] > cutoff && i[1] >= config.networkInterruptionDuration; } ).length / ( window / 3600.0 );
};

NetworkHistory.prototype._trim = function _trim()
{
    var cutoff = this._streamTime - NetworkHistoryConfig.networkInteruptionStorageWindow;
    this._interruptions =
        this._interruptions
            .filter( function( i ) { return i[0] > cutoff; } );
};

NetworkHistory.prototype._load = function _load()
{
    var state = platform.storage.get( "nh" );
    if ( !this._setState( state ) )
    {
        // Initialise with defaults
        this._realTime = platform.time.mono();
        this._streamTime = 0;
        this._streaming = false;
        this._lastInterruptionEnd = null;
        this._interruptions = [];

        DEBUG && console.log( "initialized without stored state." );
    }
    else
    {
        DEBUG && console.log( "loaded state: " + JSON.stringify( state ) );
        DEBUG && console.log( "interruption rate (last hour): " + this.interruptionRate( 3600 ) + " interruptions / hour" );
    }
};

NetworkHistory.prototype._setState = function _setState( state )
{
    if ( !state
            || !_.has( state, "t" )
            || !_.has( state, "s" )
            || !_.has( state, "i" )
            || !_.isNumber( state["t"] )
            || !_.isNumber( state["s"] )
            || !_.isArray( state["i"] ) )
    {
        return false;
    }

    this._realTime = platform.time.nowtomono( state["t"] * 1000 );
    this._streamTime = state["s"] * 1000;
    this._streaming = false;
    this._interruptions = state["i"].map( function( i ) { return [ i[0] * 1000, i[1] ]; } );
    this._lastInterruptionEnd = null;

    return true;
};

NetworkHistory.prototype.getState = function _getState()
{
    if ( this._streaming )
    {
        return  {   "t" : ( platform.time.now() / 1000 ) | 0,
                    "s" : ( ( this._streamTime + ( platform.time.mono() - this._realTime ) ) / 1000 ) | 0 ,
                    "i" : this._interruptions.map( function( i ) { return [ ( i[0] / 1000 ) | 0, i[1] ]; } )
                };
    }
    else
    {
        return  {   "t" : ( platform.time.monotonow( this._realTime ) / 1000 ) | 0,
                    "s" : ( this._streamTime / 1000 ) | 0,
                    "i" : this._interruptions.map( function( i ) { return [ ( i[0] / 1000 ) | 0, i[1] ]; } )
                };
    }
};

module.exports = NetworkHistory;


},{"103":103,"47":47,"61":61}],60:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

/* network-monitor.js - real-time network performance monitor */

/* IDL:

enum NetworkConfidenceState {
    HAVE_NOTHING = 0,           // no data available
    HAVE_SOMETHING = 1,         // some data available, more probing *required*
    HAVE_MINIMUM = 2,           // some data available, more proving *desired*
    HAVE_ENOUGH = 3             // enough data available, no more probing
};

dictionary Statistics {
    unsigned long average;
    unsigned long variance;
};

dictionary NetworkStatistics {
    NetworkConfidenceState  confidence;
    Statistics              throughput;
    Statistics?             responseTime;
    Statistics?             httpResponseTime;
    function                throughputPpf;        // kbit/s
    function                responseTimePpf;       // ms
    function                httpResponseTimesPpf;     // ms
};

[Constructor( LocationHistory history )]
interface NetworkMonitor {

    // The current location
    readonly attribute DOMString location;

    // Set the current location
    void setLocation( DOMString? location );

    // Set the current network interface
    void setCurrentNetwork( DOMString network );

    // Set the current local ip address
    void setCurrentLocalIp( DOMString ip );

    // Notify the current buffer level
    void notifyBufferLevel( unsigned long bufferLevelMs );

    // Add report of data received
    void addDataReceived( unsigned long bytes, unsigned long start, unsigned long end );

    // Add report of total response time (DNS+TCP+HTTP)
    void addResponseTime( unsigned long responseTimeMs );

    // Add report of HTTP response time
    void addHttpResponseTime( unsigned long httpResponseTimeMs );

    // Indicate that data reception has been deliberately stopped
    void stop( t );

    // Indicate complete network failure
    void fail();

    // Get the current values
    NetworkStatistics  get();

};

*/

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

/* global clearInterval, setInterval */

var _ = require(103),
    config = require(47),
    platform = require(61),
    Enums = require(48),
    util = require(84),
    Gaussian = util.Gaussian,
    DiscreteEwmav = util.ewma.DiscreteEwmav,
    DiscontiguousEwmav = util.ewma.DiscontiguousEwmav,
    DiscontiguousSlidingWindow = util.slidingwindow.DiscontiguousSlidingWindow,
    HoltWinters = util.holtwinters.HoltWinters,
    BucketSlidingWindow = util.BucketSlidingWindow,
    BucketHoltWinters = util.BucketHoltWinters,
    BucketInterQuartileRange = util.BucketInterQuartileRange,
    console = new platform.Console('ASEJS_NETWORK_MONITOR', 'media|asejs'),
    DEBUG = ("debug" !== 'release');

var NetworkMonitorConfig = config.declare({
    _expandDownloadTime:       [ 'expandDownloadTime', true],
    _minimumMeasurementTime:   [ 'minimumMeasurementTime', 500 ],
    _minimumMeasurementBytes:  [ 'minimumMeasurementBytes', 131072 ],
    _probingMeasurementTime:   [ 'throughputMeasurementTimeout' , 2000 ],
    _probingMeasurementBytes:  [ 'initThroughputMeasureDataSize' , 256 * 1024 ],
    _throughputInterval:       [ 'throughputMeasureWindow' , 5000 ],
    _throughputIQRInterval:    [ 'throughputIQRMeasureWindow', 5000 ],
    _responseTimeHalfLife:     [ 'connectTimeHalflife' , 10 ],
    _httpResponseTimeHalfLife: [ 'responseTimeHalflife' , 10 ],
    _locationHistoryUpdateInterval:    [ 'historicBandwidthUpdateInterval' , 2000 ],
    _throughputIntervalCurve:  [ 'throughputMeasurementWindowCurve' , null ],
    _throughputWarmupTime:     [ 'throughputWarmupTime' , 5000 ],
    _throughputWarmupMode:     [ 'throughputWarmupMode', 'initialize' ],
    _minimumBufferToStopProbing: [ 'minimumBufferToStopProbing', 10000 ],
    _enableDecayInThroughputEstimate: [ 'enableDecayInThroughputEstimate', true],
    _throughputPredictor:      [ 'throughputPredictor', 'ewma' ],
    _holtWintersDiscretizeInterval: ['holtWintersDiscretizeInterval', 500], //ms
    _holtWintersHalfLifeAlpha: ['holtWintersHalfLifeAlpha', 2000 ], // halfLife in ms
    _holtWintersHalfLifeGamma: ['holtWintersHalfLifeGamma', 14000 ], // halfLife in ms
    _holtWintersInitialCounts: ['holtWintersInitialCounts', 3],
    _holtWintersMinInitialCounts: ['holtWintersMinInitialCounts', 3],
    _holtWintersHalfLifeCurveEnabled:  ['holtWintersHalfLifeCurveEnabled', false],
    _holtWintersUpperBoundEnabled:  ['holtWintersUpperBoundEnabled', false],
    _networkInterruptionDuration: [ 'minReportedNetIntrDuration', 4000 ],
    _throughputBucketMs:        [ 'throughputBucketMs', 500 ],
    _bucketHoltWintersWindow:        [ 'bucketHoltWintersWindow', 2000 ],
});

var _updateHistory = function( self ) {
    if ( !self._updateHistoryStopped ) {
        self._locationHistory.addThroughput( self._throughput.get( platform.time.mono() ).average, self._confidence );
        if ( !_.isNull( self._stop ) ) {
            self._updateHistoryStopped = true;
        }
    }
};

var _getThroughputInterval = function( self, buffer ) {
    var curve = NetworkMonitorConfig._throughputIntervalCurve;
    if ( !curve || !curve.length ) return NetworkMonitorConfig._throughputInterval;

    for( var i = 0; i < curve.length; ++i ) {
        if ( curve[ i ][ "b" ] > buffer )
            return curve[ i ][ "w" ];
    }

    DEBUG && console.trace("interval curve: " + JSON.stringify(curve));
    return curve[ curve.length - 1 ][ "w" ];
};

function NetworkMonitor( networkhistory, locationhistory ) {

    this.reset();

    this._networkHistory = networkhistory;
    this._locationHistory = locationhistory;

    this._interfaceName = platform.network.name();
    this._locationHistory.setCurrentInterface( this._interfaceName );

    platform.events.on('networkchange', ( function( netname ) {

        DEBUG && console.log('Network interface changed to ' + netname );
        this._interfaceName = netname;
        this._locationHistory.setCurrentInterface( netname );

    } ).bind( this ) );

    //-------------------------------------------------------------------------
    // Overriding output with a command line option
    var fake = config.debugNetworkMonitorThroughput;
    if (fake) {
        DEBUG && console.log('Using fake throughput: ' + fake);
        fake = {
            confidence: Enums.NETWORK_CONFIDENCE.HAVE_ENOUGH,
            throughput: {average: parseInt(fake, 10), variance: 0},
            responseTime: {avergae: 0, variance: 0},
            httpResponseTime: {avergae: 0, variance: 0}
        };
        this.get = function() { return fake; };
    }
    //-------------------------------------------------------------------------
}

NetworkMonitor.prototype.reset = function() {

    this.location = null;

    var throughputInterval = _getThroughputInterval( this, 0 );

    switch( NetworkMonitorConfig._throughputPredictor ) {

        case 'holtwinters':
            this._throughput = new HoltWinters( NetworkMonitorConfig._holtWintersHalfLifeAlpha,
                                                NetworkMonitorConfig._holtWintersHalfLifeGamma,
                                                NetworkMonitorConfig._holtWintersDiscretizeInterval,
                                                NetworkMonitorConfig._holtWintersInitialCounts,
                                                NetworkMonitorConfig._holtWintersMinInitialCounts,
                                                NetworkMonitorConfig._holtWintersHalfLifeCurveEnabled,
                                                NetworkMonitorConfig._holtWintersUpperBoundEnabled );
            if (config.logChunkLevelTput){
                this._clThroughput = new HoltWinters( NetworkMonitorConfig._holtWintersHalfLifeAlpha,
                                                NetworkMonitorConfig._holtWintersHalfLifeGamma,
                                                NetworkMonitorConfig._holtWintersDiscretizeInterval,
                                                NetworkMonitorConfig._holtWintersInitialCounts,
                                                NetworkMonitorConfig._holtWintersMinInitialCounts,
                                                NetworkMonitorConfig._holtWintersHalfLifeCurveEnabled,
                                                NetworkMonitorConfig._holtWintersUpperBoundEnabled );
            }
            break;
        case 'slidingwindow' :
            this._throughput = new DiscontiguousSlidingWindow( throughputInterval );
            if (config.logChunkLevelTput){
                this._clThroughput = new DiscontiguousSlidingWindow( throughputInterval );
            }
            break;

        case 'ewma' :

            this._throughput = new DiscontiguousEwmav(  throughputInterval,
                                                        NetworkMonitorConfig._throughputWarmupTime,
                                                        NetworkMonitorConfig._enableDecayInThroughputEstimate,
                                                        NetworkMonitorConfig._throughputWarmupMode);
            this._iqr = new BucketInterQuartileRange( config.maxIQRSamples,
                                                        NetworkMonitorConfig._throughputIQRInterval,
                                                        NetworkMonitorConfig._throughputIQRInterval * 3, false);
            if (config.logChunkLevelTput){
                this._clThroughput = new DiscontiguousEwmav(  throughputInterval,
                                                        NetworkMonitorConfig._throughputWarmupTime,
                                                        NetworkMonitorConfig._enableDecayInThroughputEstimate,
                                                        NetworkMonitorConfig._throughputWarmupMode);
                this._clIQR = new BucketInterQuartileRange( config.maxIQRSamples,
                                                        NetworkMonitorConfig._throughputIQRInterval,
                                                        NetworkMonitorConfig._throughputIQRInterval * 3, false);
            }

            if (config.logOverallTputAsRef) {
                this._avtp = new DiscontiguousSlidingWindow( config.overallTputInterval );
            }
            break;

        case 'bsw' :
            this._throughput = new BucketSlidingWindow( throughputInterval,
                                                        NetworkMonitorConfig._throughputBucketMs );
            if (config.logChunkLevelTput){
                this._clThroughput = new BucketSlidingWindow( throughputInterval,
                                                        NetworkMonitorConfig._throughputBucketMs );
            }
            break;

        case 'bhw' :

            DEBUG && console.log( 'Initializing bhw with (' + NetworkMonitorConfig._holtWintersHalfLifeAlpha
                                            + ',' + NetworkMonitorConfig._holtWintersHalfLifeGamma
                                            + ',' + NetworkMonitorConfig._bucketHoltWintersWindow
                                            + ',' + NetworkMonitorConfig._throughputBucketMs + ')' );

            this._throughput = new BucketHoltWinters(   NetworkMonitorConfig._holtWintersHalfLifeAlpha,
                                                        NetworkMonitorConfig._holtWintersHalfLifeGamma,
                                                        NetworkMonitorConfig._bucketHoltWintersWindow,
                                                        NetworkMonitorConfig._throughputBucketMs );
            if (config.logChunkLevelTput){
                this._clThroughput = new BucketHoltWinters(   NetworkMonitorConfig._holtWintersHalfLifeAlpha,
                                                        NetworkMonitorConfig._holtWintersHalfLifeGamma,
                                                        NetworkMonitorConfig._bucketHoltWintersWindow,
                                                        NetworkMonitorConfig._throughputBucketMs );
            }
            break;

        default:
            this._throughput = new DiscontiguousEwmav(  throughputInterval,
                                                        NetworkMonitorConfig._throughputWarmupTime,
                                                        NetworkMonitorConfig._enableDecayInThroughputEstimate,
                                                        NetworkMonitorConfig._throughputWarmupMode);
            this._iqr = new BucketInterQuartileRange( config.maxIQRSamples,
                                                        NetworkMonitorConfig._throughputIQRInterval,
                                                        NetworkMonitorConfig._throughputIQRInterval * 3, false);
            if (config.logChunkLevelTput){
                this._clThroughput = new DiscontiguousEwmav(  throughputInterval,
                                                        NetworkMonitorConfig._throughputWarmupTime,
                                                        NetworkMonitorConfig._enableDecayInThroughputEstimate,
                                                        NetworkMonitorConfig._throughputWarmupMode);
                this._clIQR = new BucketInterQuartileRange( config.maxIQRSamples,
                                                        NetworkMonitorConfig._throughputIQRInterval,
                                                        NetworkMonitorConfig._throughputIQRInterval * 3, false);
            }
    }

    this._responseTime = new DiscreteEwmav( NetworkMonitorConfig._responseTimeHalfLife, NetworkMonitorConfig._responseTimeHalfLife );
    this._httpResponseTime = new DiscreteEwmav( NetworkMonitorConfig._httpResponseTimeHalfLife, NetworkMonitorConfig._httpResponseTimeHalfLife );
    this._confidence = Enums.NETWORK_CONFIDENCE.HAVE_NOTHING;

    this._updateHistoryCb = ( function() { _updateHistory( this ); } ).bind( this );
    this._updateHistoryIntervalId = undefined;

    this._start = null;
    this._stop = null;
    this._bytes = null;
    this._last = null;

    this._totaltime = 0;
    this._totalbytes = 0;

    this._buffer = 0;
    this._playing = false;

    DEBUG && console.log( 'Initialized with network = ' + this._interfaceName
                + ', throughput predictor = ' + this._throughput.toString()
                + ', throughput interval curve = ' + NetworkMonitorConfig._throughputIntervalCurve );
};

NetworkMonitor.prototype.setLocation = function( location ) {

    if ( location === this.location ) return;

    if ( !_.isUndefined( this._updateHistoryIntervalId ) ) {
        clearInterval( this._updateHistoryIntervalId );
        this._updateHistoryIntervalId = undefined;
    }

    if ( _.isNull( this.location ) ) {
        this._totaltime = 0;
        this._totalbytes = 0;
        this._start = null;
    }

    if ( !_.isNull( location ) ) {
        this._confidence = Enums.NETWORK_CONFIDENCE.HAVE_NOTHING;
        this._throughput.reset();
        if (config.logOverallTputAsRef) {
            this._avtp.reset();
        }
        this._responseTime.reset();
        this._httpResponseTime.reset();
    }

    if ( !_.isNull( this._start ) ) {
        this._totaltime += ( ( _.isNull( this._stop ) ? platform.time.mono() : this._stop ) - this._start );
        this._totalbytes += this._bytes;
    }

    this._start = null;
    this._stop = null;
    this._bytes = 0;

    this.location = location;
    this._locationHistory.setLocation( location );
};

NetworkMonitor.prototype.setCurrentInterface = function( intf ) {
    this._locationHistory.setCurrentInterface( intf );
};

NetworkMonitor.prototype.setCurrentClientIp = function( clientIp ) {
    this._locationHistory.setCurrentClientIp( clientIp );
};

NetworkMonitor.prototype.notifyBufferLevel = function( buffer, playing ) {

    DEBUG && console.log(  this._interfaceName + ':' + this.location + ':notifyBufferLevel: ' + buffer + 'ms, playing: ' + playing );
    this._buffer = buffer;
    this._playing = playing;
    var throughputInternal = _getThroughputInterval( this, buffer );
    this._throughput.setInterval( throughputInternal );
    if (config.logChunkLevelTput){
        this._clThroughput.setInterval( throughputInternal );
    }

};

NetworkMonitor.prototype.addChunkReceived = function( pipeline, url, bytes, byteRange, readyState, start, end ) {
    // Only called upon onComplete event when config.logChunkLevelTput is set
    if (!this._clThroughput){
        return;
    }

    if ( NetworkMonitorConfig._expandDownloadTime &&
         end - start < 10){

        // @TODO: log suspiciously short download,
        // the pipeline & url are passed in for this purposes
        pipeline.requestManager._shortDownloads.push({
            'url': url,
            'duration': (end - start),
            'bytes': bytes,
            'byteStart': byteRange["start"],
            'byteEnd': byteRange["end"],
            'readyState': readyState
        });
        start = end - 10;
    }

    this._clThroughput.add( bytes, start, end );

    if (!this._clIQR){
        return;
    }
    this._clIQR.add(bytes, start, end);
    // @TODO: add online IQR calculation here
};

NetworkMonitor.prototype.addDataReceived = function( bytes, start, end ) {

    var confidence = this._confidence;

    if ( _.isUndefined( start ) ) {
        console.warn( "addDataReceived called with undefined start time" );
        return;
    }

    if ( NetworkMonitorConfig._expandDownloadTime &&
         end - start < 10){
        // The reason for that check is that NRDP often reports very short reception times
        // when in fact it was just reading from the TCP socket buffer,
        // 10ms was just an arbitrary choice to avoid excessively high measurements
        // Cadmium should not need this check
        start = end - 10;
    } else if (end - start === 0) {
        // A safe guard to prevent throughput become infinite
        start = end - 1;
    }



    this._throughput.add( bytes, start, end );
    if ( config.logOverallTputAsRef ) {
        this._avtp.add(bytes,start,end)
    }
    this._iqr.add(bytes, start, end);
    this._confidence = Math.max( this._confidence, Enums.NETWORK_CONFIDENCE.HAVE_SOMETHING );

    if ( _.isNull( this._start ) ) {
        this._start = start;
        this._stop = null;
        this._updateHistoryStopped = false;
        this._bytes = 0;
    }

    if ( !_.isNull( this._stop ) ) {
        if ( start > this._stop )
            this._start += ( start - this._stop );
        this._stop = null;
        this._updateHistoryStopped = false;
    }

    this._bytes += bytes;

    if ( this._confidence < Enums.NETWORK_CONFIDENCE.HAVE_MINIMUM )
    {
        if ( ( end - this._start > NetworkMonitorConfig._minimumMeasurementTime ||
              this._bytes > NetworkMonitorConfig._minimumMeasurementBytes ) )
        {
            this._confidence = Enums.NETWORK_CONFIDENCE.HAVE_MINIMUM;
        }
    }

    if ( this._confidence < Enums.NETWORK_CONFIDENCE.HAVE_ENOUGH ) {

        if ( ( end - this._start > NetworkMonitorConfig._probingMeasurementTime ||
             this._bytes > NetworkMonitorConfig._probingMeasurementBytes )
             && ( !this._playing || this._buffer > NetworkMonitorConfig._minimumBufferToStopProbing ) ) {

            this._confidence = Enums.NETWORK_CONFIDENCE.HAVE_ENOUGH;

            _updateHistory( this );

            this._updateHistoryIntervalId = setInterval( this._updateHistoryCb, NetworkMonitorConfig._locationHistoryUpdateInterval );
        }
    }

    if ( !_.isNull( this._last ) )
    {
        if ( start - this._last > NetworkMonitorConfig._networkInterruptionDuration )
        {
            // This is the case of a data received event starting long after the end of the last one
            DEBUG && console.log( this._interfaceName + ':' + this.location + ': interruption based on progress gap of ' + ( start - this._last ) + 'ms' );
            this._networkHistory.interruption( this._last, start );
        }
        else if ( end - start > NetworkMonitorConfig._networkInterruptionDuration )
        {
            // This is the case of a long-duration reception event - which can only occur due to an interruption since
            // during active reception we receive events every 500ms
            DEBUG && console.log( this._interfaceName + ':' + this.location + ': interruption based on long progress of ' + ( end - start ) + 'ms' );
            this._networkHistory.interruption( start, end );
        }
    }

    this._last = Math.max( end, this._last );

    DEBUG && console.log( this._interfaceName + ':' + this.location + ': ' + bytes + ' bytes in [' + start + ',' + end + '], throughput (' + this._confidence + ') at ' + platform.time.mono() + ' is ' + JSON.stringify( this._throughput.get( platform.time.mono() ) ) + ' rt: ' + JSON.stringify( this._responseTime.get() ) + ' hrt: ' +  JSON.stringify( this._httpResponseTime.get() ) );

    DEBUG && ( this._confidence > confidence ) && console.log( this._interfaceName + ':' + this.location + ': Upgraded confidence to ' + this._confidence + ' (' + (end - this._start) + 'ms,' + this._bytes + 'bytes):' + this._throughput.get( platform.time.mono() ).average + 'kbit/s filtered, ' + ( this._bytes * 8 / ( end - this._start ) ) + 'kbit/s average' );
};

NetworkMonitor.prototype.addResponseTime = function( responseTimeMs ) {
    this._responseTime.add( responseTimeMs );
    this._locationHistory.addResponseTime( responseTimeMs );
};

NetworkMonitor.prototype.addHttpResponseTime = function( httpResponseTimeMs ) {

    var h = this._httpResponseTime.get();

    this._httpResponseTime.add( httpResponseTimeMs );

    this._locationHistory.addHttpResponseTime( httpResponseTimeMs );
};

NetworkMonitor.prototype.start = function start( t )
{
    DEBUG && console.log(  this._interfaceName + ':' + this.location + ': start at ' + t );
    if ( _.isNull( this._last ) && !_.isNull( this._stop ) )
    {
        this._last = t;
    }
};

NetworkMonitor.prototype.stop = function( t ) {
    DEBUG && console.log(  this._interfaceName + ':' + this.location + ': stop at ' + t );
    this._throughput.stop( t );
    if (config.logChunkLevelTput){
        this._clThroughput.stop(t);
    }
    if (config.logOverallTputAsRef){
        this._avtp.stop( t );
    }
    this._stop = _.isNull( this._stop ) ? t : Math.min( this._stop, t );
    this._last = null;
};

NetworkMonitor.prototype.fail = function() {
    this._start = null;
};

NetworkMonitor.prototype.get = function( ) {

    //function normal_percentiles( mean, variance, pcts ) {
    //    return mean === null ? null : ( new Gaussian( mean, variance ) ).ppfs( pcts );
    //}

    var tp = this._throughput.get( platform.time.mono() ),
        rt = this._responseTime.get(),
        hrt = this._httpResponseTime.get();

    if ( config.logOverallTputAsRef && this._avtp) {
        var avtp = this._avtp.get( platform.time.mono() );
        tp = !Number.isNaN(tp.average) && !Number.isNaN(avtp.average) && tp.average > avtp.average ? avtp : tp;
    }

    var result = {  confidence :        this._confidence,
                    throughput :        tp,
                    responseTime :      rt,
                    httpResponseTime :  hrt };

    if ( tp )
        result.throughputPpf = Gaussian.prototype.ppf.bind( tp );

    if ( rt )
        result.responseTimePpf = Gaussian.prototype.ppf.bind( rt );

    if ( hrt )
        result.httpResponseTimePpf = Gaussian.prototype.ppf.bind( hrt );

    if ( this._clThroughput ){
        result.clThroughput = this._clThroughput.get(platform.time.mono());
        if (this._clIQR && this._clIQR.getSampleSize() > 3) {
            result.clIQR = {percentiles: this._clIQR.getPercentiles()};
        }
    }

    if (this._iqr && this._iqr.getSampleSize() > 3){
        result.iqr = {percentiles: this._iqr.getPercentiles()};
    }
    return result;
};

NetworkMonitor.prototype.getAggregateStatistics = function( ) {

    var time = this._totaltime + !_.isNull( this._start ) ? ( ( _.isNull( this._stop ) ? platform.time.mono() : this._stop ) - this._start ) : 0,
        bytes = this._totalbytes + this._bytes,
        avtp = Math.floor( ( bytes * 8.0 ) / time );

    DEBUG && console.log(  this._interfaceName + ':' + this.location + ': getAggregateStatistics(): total time = ' + this._totaltime +
                                ', total bytes = ' + this._totalbytes +
                                ', start = ' + this._start +
                                ', stop = ' + this._stop +
                                ', bytes = ' + this._bytes +
                                ', avtp = ' + avtp );

    return { avtp : avtp, hist: this._networkHistory.getState() };
};

module.exports = NetworkMonitor;




},{"103":103,"47":47,"48":48,"61":61,"84":84}],61:[function(require,module,exports){
var platform,
	basePlatform;

function implement(implementation) {
    for (var api in implementation) {
        if (implementation.hasOwnProperty(api)) {
            platform[api] = implementation[api];
        }
    }
}

function reset() {
	platform = basePlatform;
}

basePlatform = {
	implement: implement,
	reset: reset
};

platform = basePlatform;

module.exports = platform;
},{}],62:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_high");

var _ = require(103),
    config = require(47),
    Enums = require(48);

var PredictorConfig = config;

var platform = require(61),
    console = new platform.Console('ASEJS_PREDICTOR', 'media|asejs'),
    DEBUG = ("debug" !== 'release');

var SimpleMarginPredictor = function() {

    this._audioRate = null;

    this.predictAudio = ( function( s , b ) { return this._predictAudio( s , b ); } ).bind( this );
    this.predictVideo = ( function( s , b ) { return this._predictVideo( s , b ); } ).bind( this );

    DEBUG && console.trace( "SimpleMarginPredictor: curve: " + JSON.stringify( PredictorConfig.bandwidthMarginCurve ) );
};

SimpleMarginPredictor.prototype._getBandwidthMargin = function( buffer, isConserv ) {

    // By default, we use this value
    var result = PredictorConfig.bandwidthMargin,
        curve = PredictorConfig.bandwidthMarginCurve,
        level;

    if (isConserv){
        result = PredictorConfig.conservBandwidthMargin;
        curve = PredictorConfig.conservBandwidthMarginCurve;
    }

    // If we have a curve configured
    if ( _.isArray( curve ) ) {
        level = buffer.completePts - buffer.currentPts;
        curve.some( function( point ) {
            // Use this margin - and if our level is less than 'b', we are done
            result = point['m'];
            return ( level <= point['b'] );
        });
    }

    return result;
};

SimpleMarginPredictor.prototype._predictAudio = function( statistics , buffer ) {

    var throughput = statistics.throughput ? statistics.throughput.average : 0;
    return throughput * PredictorConfig.throughputPercentForAudio / 100;
};

SimpleMarginPredictor.prototype._predictVideo = function( statistics , buffer ) {

    var conservBandwidthMarginTputThreshold = PredictorConfig.conservBandwidthMarginTputThreshold,
        isConserv = (statistics.throughput && statistics.throughput.average < conservBandwidthMarginTputThreshold)?
                    true: false,
        throughput = statistics.throughput
        ? ( statistics.throughput.average * ( 100 - this._getBandwidthMargin( buffer, isConserv ) ) / 100 ) | 0
        : 0;

    return _.isNull( this._audioRate )
            ? throughput * ( 100 - PredictorConfig.throughputPercentForAudio ) / 100
            : ( throughput < 2 * this._audioRate ? throughput / 2 : throughput - this._audioRate );
};

SimpleMarginPredictor.prototype.setAudioRate = function( rate ) {
    this._audioRate = rate;
};

var ScaledMarginPredictor = function() {
    this._audioRate = null;
    this.predictAudio = ( function( s , b ) { return this._predictAudio( s , b ); } ).bind( this );
    this.predictVideo = ( function( s , b ) { return this._predictVideo( s , b ); } ).bind( this );
};
ScaledMarginPredictor.prototype.setAudioRate = SimpleMarginPredictor.prototype.setAudioRate;
ScaledMarginPredictor.prototype._getBandwidthMargin = SimpleMarginPredictor.prototype._getBandwidthMargin;
ScaledMarginPredictor.prototype._getScaledRatio = function ( statistics ){
    var cv = statistics.throughput
        ? Math.sqrt(statistics.throughput.variance) / statistics.throughput.average | 0
        : 0;
    DEBUG && console.trace("coef variance: " + cv + ", upperbound: " + PredictorConfig.bandwidthMarginScaledRatioUpperBound);
    // Coeffient of Variance (CV) is calculated as: cv = standard deviation / average
    // A distribution is considered with high variance when cv > 1 and low variance when cv < 1
    // Watch-Out: When mean is close to 0, cv goes to infinite.
    if ( cv <= 0 ){
        //variance can be 0 during the bootstrapping, during which we use the default curve
        return 1;
    } else if ( cv > PredictorConfig.bandwidthMarginScaledRatioUpperBound ){
        //CV can become very big when mean is very small, let's give it an upper bound at 2
        return PredictorConfig.bandwidthMarginScaledRatioUpperBound;
    }
    DEBUG && console.trace("coef variance (adjusted): " + cv);
    return cv;
};

ScaledMarginPredictor.prototype._predictAudio = function( statistics , buffer ) {
    var ratio = this._getScaledRatio( statistics );
    var margin = this._getBandwidthMargin( buffer ) * ratio;
    margin = margin > 99 ? 99 : margin;
    var throughput = statistics.throughput
        ? ( statistics.throughput.average * ( 100 - margin ) / 100 ) | 0
        : 0;

    DEBUG && console.trace("audioRate: " + this._audioRate + ", ratio: " + ratio + ", BandwidthMargin: " + this._getBandwidthMargin( buffer ) + ", margin: " + margin + ", throughput: " + statistics.throughput.average + ", audio prediction:" + throughput);
    return _.isNull( this._audioRate )
            ? throughput * PredictorConfig.throughputPercentForAudio / 100
            : ( throughput < 2 * this._audioRate ? throughput / 2 : this._audioRate );
};
ScaledMarginPredictor.prototype._predictVideo = function( statistics , buffer ) {
    var ratio = this._getScaledRatio( statistics );
    var margin = this._getBandwidthMargin( buffer ) * ratio;
    margin = margin > 99 ? 99 : margin;
    var throughput = statistics.throughput
        ? ( statistics.throughput.average * ( 100 - margin ) / 100 ) | 0
        : 0;

    DEBUG && console.trace("ratio: " + ratio + ", BandwidthMargin: " + this._getBandwidthMargin( buffer ) + ", margin: " + margin + " throughput: " + statistics.throughput.average + ", video prediction:" + throughput);
    return _.isNull( this._audioRate )
            ? throughput * ( 100 - PredictorConfig.throughputPercentForAudio ) / 100
            : ( throughput < 2 * this._audioRate ? throughput / 2 : throughput - this._audioRate );
};


module.exports = { SimpleMarginPredictor : SimpleMarginPredictor,
                   ScaledMarginPredictor : ScaledMarginPredictor
                 };

},{"103":103,"47":47,"48":48,"61":61}],63:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var _ = require(103);
var config = require(47);
var platform = require(61);
var Enums = require(48);
var MediaRequest = platform.MediaRequest;

var Events = require(94);
var EventEmitter = Events.EventEmitter;

var DEBUG = ("debug" !== 'release');
var VERBOSE = false;

////////////////////
// RequestManager
////////////////////
/**
 * @constructor
 */
function RequestManager(console, mediaType)
{
    this._mediaType = mediaType;

    // console tracing
    this._console = console;
    this._error = this._console.error.bind(this._console);
    this._warn = this._console.warn.bind(this._console);
    this._trace = this._console.trace.bind(this._console);
    this._log = this._console.log.bind(this._console);

    // add event emitter api
    this.addEventListener = EventEmitter.addEventListener;
    this.on = EventEmitter.addEventListener;
    this.removeEventListener = EventEmitter.removeEventListener;
    this.callEventListeners = EventEmitter.callEventListeners;
    this.emit = EventEmitter.callEventListeners;

    this._resetVars();
}
RequestManager.prototype.constructor = RequestManager;

Object.defineProperties(RequestManager.prototype, {
    requestCount: {
        get: function() { return this._unsentData.length + this._sentData.length; }
    },
    unsentRequests: { get: function() { return this._unsentData.length; } },
    activeRequests: { get: function() { return this._activeRequests; } },
    partialBuffers: { get: function() { return this._partialBuffers; } },
    active: { get: function() { return this._activeRequests > 0; } }
});

//////////
// reset
//////////
RequestManager.prototype.reset = function reset()
{
    // cleanup header and data requests
    this._headerRequests = this._headerRequests.forEach(this._cleanupRequest.bind(this));
    this._unsentData = this._unsentData.forEach(this._cleanupRequest.bind(this));
    this._sentData = this._sentData.forEach(this._cleanupRequest.bind(this));
    this._headerRequests = [];
    this._unsentData = [];
    this._sentData = [];
    this._shortDownloads = [];

    this._latestCompletedIndex = -1;

    this._firstRequestMarked = false;
};

RequestManager.prototype.resetSequence = function resetSequence()
{
    DEBUG && this._trace("resetting sequence");
    this._firstRequestMarked = false;
};

RequestManager.prototype.resetSequence = function resetSequence()
{
    DEBUG && this._trace("resetting sequence");
    this._firstRequestMarked = false;
};

RequestManager.prototype._resetVars = function _resetVars()
{
    DEBUG && this._trace("Request Manager resetVars");
    // array of Request's in time/requested order
    this._unsentData = [];
    this._sentData = [];
    // for logging purposes - record suspiciously short download (clean up is needed afterwards)
    this._shortDownloads = [];

    // array of header requests
    this._headerRequests = [];

    if ( this._activeRequests !== 0 )
    {
        this._activeRequests = 0;
        this.emit( "inactive", platform.time.mono() );
    }

    this._partialBuffers = 0;

    this._latestCompletedIndex = -1;

    this._firstRequestMarked = false;
};

//////////
// addRequest
//////////
RequestManager.prototype.addRequest = function addRequest(mediaRequest)
{
    var i;
    var request;

    if (mediaRequest.isHeader)
    {
        this._headerRequests.push(mediaRequest);
        DEBUG && this._trace("addHeaderRequest, count: " + this._headerRequests.length);
    }
    else
    {
        var idx = this._unsentData.indexOf(mediaRequest);
        if (idx === -1)
        {
            if ( config.allowReissueMediaRequestAfterAbort ){
                // add it to unSent array in pts order
                for (i=0; i<this._unsentData.length; ++i)
                {
                    if (this._unsentData[i].ptsStart > mediaRequest.ptsStart)
                    {
                        // found where to splice
                        break;
                    }
                }
                this._unsentData.splice(i, 0, mediaRequest);
            } else {
                this._unsentData.push(mediaRequest);
            }

            if (!config.abortUnsentBlocks)
            {
                // count partial data requests
                mediaRequest.partial = true;
                ++this._partialBuffers;
            }

            DEBUG && this._trace("addRequest (ID: " + mediaRequest.getRequestId() + ")" +
                                 ", unsent: " + this._unsentData.length +
                                 ", partials: " + this._partialBuffers);

            // mark first request if we haven't already
            if (!this._firstRequestMarked)
            {
                mediaRequest.firstRequestInSequence = true;
                this._firstRequestMarked = true;

                DEBUG && this._trace(
                    "marking first request in sequence: " + mediaRequest);
            }
            else
            {
                mediaRequest.firstRequestInSequence = false;
            }
        }
        else
        {
            DEBUG && this._trace("Duplicate request (ID: " + mediaRequest.getRequestId() +
                                 "), not adding into unsent array. Unsent:" +
                                 this._unsentData.length +
                                 ", partials:" + this._partialBuffers);
        }
    }

    if ( mediaRequest.readyState === MediaRequest.READYSTATES.SENT ||
         mediaRequest.readyState === MediaRequest.READYSTATES.RECEIVING )
    {
        mediaRequest.active = true;
        if ( ++this._activeRequests === 1 )
        {
            this.emit( "active", mediaRequest.loadTime );
        }
    }
    else
    {
        mediaRequest.active = false;
    }
};

//////////
// addCompleteRequest
//////////
RequestManager.prototype.addCompleteRequest = function addCompleteRequest( mediaRequest, currentPts)
{
    this._sentData.push( mediaRequest );

    // mark first request if we haven't already
    if (!this._firstRequestMarked)
    {
        mediaRequest.firstRequestInSequence = true;
        this._firstRequestMarked = true;

        DEBUG && this._trace("marking first request in sequence: ", mediaRequest);
    }
    else
    {
        mediaRequest.firstRequestInSequence = false;
    }

    return this._dataComplete(mediaRequest, currentPts);
};

//////////
// setSelectedBitrate
//////////
RequestManager.prototype.setSelectedBitrate = function setSelectedBitrate(
    manifestIndex, bitrate, onabort)
{
    DEBUG && this._trace("requestManager, setSelectedBitrate: " + bitrate +
                         ", requests: " + this._unsentData.length);

    // nothing to do if no unsent
    if (this._unsentData.length === 0)
    {
        return;
    }

    // For debugging, abort unsent requests a bit more often
    if ( DEBUG && config.enableAbortTesting && this._unsentData[0].bitrate === bitrate )
    {
        if ( _.isUndefined( this._abortTestCount ) )
        {
            this._abortTestCount = 0;
        }

        if ( (this._abortTestCount++) % config.abortRequestFrequency === 0 )
        {
            this._trace("abort unsent blocks test");

            this.abortUnsentRequests(manifestIndex, onabort);

            return;
        }
    }

    // check to see if the bitrate is same as unsent
    if (this._unsentData[0].bitrate === bitrate)
    {
        DEBUG && this._trace("setSelectedBitrate noop, same bitrate");
        return;
    }

    // log a debug message
    if (config.enableManagerDebugTraces)
    {
        this._reportDebugMessage("setSelectedBitrate new bitrate: " + bitrate);
    }

    this.abortUnsentRequests(manifestIndex, onabort);
};

//////////
// abortUnsentRequests
//////////
/**
 * @param {Number} manifestIndex
 * @param {Function=} onabort
 */
RequestManager.prototype.abortUnsentRequests = function abortUnsentRequests(
    manifestIndex, onabort)
{
    // nothing to do if no unsent
    if (this._unsentData.length === 0)
    {
        return;
    }

    DEBUG && this._trace("abortUnsentRequests, currentManifest: " + manifestIndex +
                         " count: " + this._unsentData.length +
                         " onabort: " + (typeof onabort == "function"));

    var i;
    for( i = this._unsentData.length-1; i >= 0; --i )
    {
        var request = this._unsentData[ i ];

        // Don't abort requests that were on previous manifest
        if (request.manifestIndex !== manifestIndex)
        {
            DEBUG && this._trace("keeping request, different manifest: " + manifestIndex +
                                 " request: " + request.toString());
            break;
        }

        // Don't abort request that are the last in sequence as it causes a headache
        // trying to recreate it as the request-manager and ase-manager states are
        // difficult to rewind - NRDJS-4783
        if (request.lastRequestInSequence)
        {
            DEBUG && this._trace("keeping request, lastRequestInSequnce: " + request);
            break;
        }

        DEBUG && this._trace("aborting request: " + request.toString() +
                             " manifestIndex: " + request.manifestIndex);
        if ( !request.abort() )
        {
            DEBUG && this._trace("...failed to abort request: " + request.toString() );
            break;
        }

        if ( request.firstRequestInSequence )
        {
            this._firstRequestMarked = false;
        }

        this._cleanupRequest( request );
    }

    ++i;
    if ( i < this._unsentData.length )
    {
        var aborted = this._unsentData.splice( i, this._unsentData.length - i );

        if (typeof onabort == "function")
        {
            onabort( aborted );
        }
    }
};

//////////
// requestAborted
//////////
RequestManager.prototype.requestAborted = function requestAborted(mediaRequest)
{
    DEBUG && this._trace("requestAborted: " + mediaRequest.toString());
    var idx = this._unsentData.indexOf(mediaRequest);
    if (idx !== -1)
    {
        // remove from array
        DEBUG && this._trace("requestAborted, removed from unsent array");
        this._unsentData.splice(idx, 1);
    }
    else
    {
        idx = this._sentData.indexOf(mediaRequest);
        if (idx !== -1)
        {
            // remove from array
            DEBUG && this._trace("requestAborted, removed from sent array");
            this._sentData.splice(idx, 1);
        }
        else
        {
            this._warn("requestAborted: unknown mediaRequest: " +
                       mediaRequest.toString());
            return;
        }
    }

    // cleanup request
    this._cleanupRequest(mediaRequest);
};

//////////
// pruneRequests
//////////
/**
 * @param {Object} bufferManager
 * @param {number} pts
 */
RequestManager.prototype.pruneRequests = function pruneRequests(bufferManager, pts)
{
    var count;

    // determine pts to prune from
    var prunePts;
    if (pts > config.reserveForSkipbackBufferMs)
    {
        // hold some back for the skipback buffer
        prunePts = pts - config.reserveForSkipbackBufferMs;
    }
    else
    {
        DEBUG && this._trace("skipping pruneRequests, pts: " + pts +
                             " less than reserveForSkipback: " +
                             config.reserveForSkipbackBufferMs);
        return;
    }

    DEBUG && this._trace("pruneRequests to pts: " + pts +
                         ", skipback: " + config.reserveForSkipbackBufferMs +
                         ", prunePts: " + prunePts +
                         ", unsent: " + this._unsentData.length +
                         ", sent: " + this._sentData.length);

    var pruneArray = function pruneArray(requestArray)
    {
        var i;
        var idx;
        var mediaRequest;
        for (i=0; i < requestArray.length; ++i)
        {
            mediaRequest = requestArray[i];
            if (prunePts < mediaRequest.ptsEnd)
            {
                DEBUG && this._trace("keeping mediaRequest: " + mediaRequest.toString());
                break;
            }

            DEBUG && this._trace("pruneRequests, mediaRequest: " +
                                 mediaRequest.toString());

            // mark this to be removed
            idx = i;

            // if request was not appended, need to abort it
            if (!mediaRequest.appended)
            {
                this._warn("pruning unappended request: ", mediaRequest);

                if (config.enableManagerDebugTraces)
                {
                    this._reportDebugMessage("prune pts:" + prunePts +
                                             ", prune unappended request: " +
                                             JSON.stringify(mediaRequest));
                }

                // abort this request
                if ( !mediaRequest.abort() )
                {
                    this._error("MediaRequest.abort error: " + mediaRequest.failureCode );
                }
                else
                {
                    DEBUG && this._trace("aborted mediaRequest: ", mediaRequest );
                }

                bufferManager.requestAborted(mediaRequest);
            }

            // cleanup request
            this._cleanupRequest(mediaRequest);
        }

        if (!_.isUndefined(idx))
        {
            requestArray.splice(0, idx+1); // +1 to remove idx as well
            return idx+1;
        }

        return 0;
    }.bind(this);

    // prune requests
    count = pruneArray(this._unsentData);
    DEBUG && this._trace("pruneRequests, removed " + count + " from unsent, remaining: " +
                         this._unsentData.length);
    count = pruneArray(this._sentData);
    DEBUG && this._trace("pruneRequests, removed " + count + " from sent, remaining: " +
                         this._sentData.length);

    return prunePts;
};

//////////
// pruneRequestsForNative
//////////
RequestManager.prototype.pruneRequestsForNative = function pruneRequestsForNative(
    requestInNativeWithMedia, pts, streamingPts)
{
    var newStreamingPts;
    var lastPts = null;
    var processedIndex = [];


    var pruneArray = function pruneArray(requestArray, debugstr)
    {
        var r;
        var i = 0;
        var mediaRequest;
        var index;
        var shouldPrune;
        var toPrune = [];
        var isInNative;
        var filtered;

        var requestPtsStr;
        if (DEBUG) {
            requestPtsStr = JSON.stringify(requestArray.map(function(r) {
                if (r.chunk)
                {
                    return r.ptsStart + " (ID: "+ r._requestId + ", chunk: " +
                        r.chunk.index + ")";
                }
                else
                {
                    return r.ptsStart + " (ID: "+ r._requestId + ")";
                }
            }));
            this._trace("array: " + debugstr +
                           " before pruning, there are " + requestArray.length +
                           " requests in the ASE pipeline, including: " + requestPtsStr);
        }

        for (i=0; i < requestArray.length; ++i)
        {
            mediaRequest = requestArray[i];
            if ( lastPts === null ||
                 lastPts < (mediaRequest.ptsStart + mediaRequest.durationMs))
            {
                lastPts = mediaRequest.ptsStart + mediaRequest.durationMs;
            }
            shouldPrune = false;
            index = requestInNativeWithMedia.indexOf(mediaRequest.getRequestId());
            isInNative = (index === -1) ? false : true;

            // Case 1: The current media request does not have media data in the native
            // layer buffer
            if (!isInNative)
            {
                //  (A) The media request is DONE
                if (mediaRequest.readyState === MediaRequest.READYSTATES.DONE)
                {
                    // (a.1) MediaRequest is done and has been appended => prune it
                    if (mediaRequest.appendCompleted)
                    {
                        shouldPrune = true;
                        DEBUG && this._trace(
                            "remove mediaRequest that is done and not in native anymore: " +
                            mediaRequest.toString() + ", requestInNativeWithMedia:" + requestInNativeWithMedia);
                    }
                    // (a.2) MediaRequest is done but not yet appended (and that's the
                    // reason why it's not in native) => keep until it is appended
                    else
                    {
                        DEBUG && this._trace(
                            "keeping mediaRequest that is done, but not yet appended:" +
                            mediaRequest.toString() + ", pts:" + mediaRequest.ptsStart);
                    }
                }
                // (B) The media request is OPENED, SENT, RECEIVING, or PAUSED
                else if (mediaRequest.readyState < MediaRequest.READYSTATES.DONE)
                {
                    // (b.1) MediaRequest is in progress but in the past => prune it
                    if ((mediaRequest.ptsStart + mediaRequest.durationMs) < pts)
                    {
                        shouldPrune = true;
                    }
                    // (b.2) MediaRequest is in progress and in the future => keep it
                    else
                    {
                        DEBUG && this._trace(
                            "keeping mediaRequest that are in progress:" + mediaRequest.toString() +
                            ", pts:" + mediaRequest.ptsStart);
                    }
                }
                // (C) MediaRequest was aborted, separate ASE code will remove
                // it from the request array
                else if (mediaRequest.readyState === MediaRequest.READYSTATES.ABORTED)
                {
                    DEBUG && this._trace(
                        "Found ABORTED request during pipeline pruning." +
                        "MediaRequest ID:" + mediaRequest.getRequestId() +
                        ", state:" + mediaRequest.readyState,
                        ", chunk:" + mediaRequest.chunk.index);
                    // This is acting as a safeguard, since ASE cleans up pipeline in
                    // _abortRequestP()
                    // However, due to timing issues, we might still have aborted requests
                    // when we call this function
                    shouldPrune = true;
                }

                // do the pruning, if the request was marked
                if (shouldPrune)
                {
                    // this request is not in the native buffer, clean it up
                    DEBUG && this._log("pruneRequests, mediaRequest:" + mediaRequest.toString() +
                                       ", pts:" + mediaRequest.ptsStart);

                    // cleanup request
                    this._cleanupRequest(mediaRequest);

                    // mark the request to be pruned
                    toPrune.push(mediaRequest.getRequestId());

                    // if the mediaRequest (MR) that we are pruning:
                    // (i) its start time is larger than the current PTS
                    // (ii) our streamingPts (nextToDownload) is pointing at a time larger
                    //      than its start time
                    // we are going to have a gap as shown below:
                    //
                    // -----|-------------|xxxxxxxxx|-------------|----------------> time
                    // mediaTime (pts)  MR.pts    MR.end    streamingPts(nextToDownload)
                    if (mediaRequest.ptsStart > pts &&
                        mediaRequest.ptsStart < streamingPts &&
                        !mediaRequest.chunk.media)
                    {
                        // native pruned it due to lack of space, we should download it
                        // again
                        if( newStreamingPts === undefined ||
                            newStreamingPts > mediaRequest.ptsStart )
                        {
                            newStreamingPts = mediaRequest.ptsStart;
                            DEBUG && this._trace(
                                "resetting streamingPts from " + streamingPts +
                                " to " + newStreamingPts);
                        }
                    }
                }
            }
            else
            {
                DEBUG && this._log("keeping mediaRequest(native):" + mediaRequest.toString() +
                                   ", pts:" + mediaRequest.ptsStart);
                if (processedIndex.indexOf(mediaRequest.getRequestId()) === -1) {
                    processedIndex.push(mediaRequest.getRequestId());
                }
            }
        }

        // do the actual splicing of the requests in the array
        // cleaner to do outside of all the other logic
        filtered = (toPrune.length === 0) ? requestArray :
            requestArray.filter(function(request) {
            // true to keep the request, false to filter out
            return toPrune.indexOf(request.getRequestId()) === -1;
        }.bind(this));

        if (DEBUG){
            requestPtsStr = JSON.stringify(filtered.map(function(r) {
                return r.ptsStart + " (ID: " + r.getRequestId() +
                    ", chunk: " + r.chunk.index + ")";
            }));
            this._trace("array: " + debugstr +
                        " after pruning, there are " + filtered.length +
                        " requests in the ASE pipeline, including:" + requestPtsStr);
        }
        return filtered;
    }.bind(this);
    // prune both unsent/sent requests
    this._unsentData = pruneArray(this._unsentData, "unsent");
    this._sentData = pruneArray(this._sentData, "sent");

    DEBUG && lastPts &&
        this._trace("lastPts: " + lastPts + ", streamingPts: " + streamingPts +
                    ", newStreamingPts: " + newStreamingPts);

    if (lastPts !== null && lastPts < streamingPts)
    {
        DEBUG && this._trace(
            "There is a gap between last Pts in unsent/sent array " + lastPts +
            " and streamingPts " + newStreamingPts);
        if (!newStreamingPts)
        {
            newStreamingPts = lastPts;
            DEBUG && this._trace("resetting streamingPts to " + newStreamingPts);
        }
        else if ( lastPts < newStreamingPts)
        {
            newStreamingPts = lastPts;
            DEBUG && this._trace(
                "newStreamingPts does not cover the gap, resetting newStreamingPts to " +
                    newStreamingPts);
        }
        DEBUG && this._trace(
            "newStreamingPts already covers the gap, keep newStreamingPts: " +
            newStreamingPts);
    }

    // Case 2: The current media request is in the native buffer, but not in the
    // pipeline.
    // This should not happen, and the list of requests with media should be empty at
    // this point.
    // Show a warning if there is anything left in native that is not in the pipeline.
    var j = 0;
    for (j=0; j < processedIndex.length; j++){
        // remove the request from the native list, since we have processed it
        var idx = requestInNativeWithMedia.indexOf(processedIndex[j]);
        if(idx !== -1){
            requestInNativeWithMedia.splice(idx, 1);
        }
    }

    DEBUG && (function () {
        for (j=0; j < requestInNativeWithMedia.length; j++)
        {
            this._warn("Request ("+ requestInNativeWithMedia[j] + ") that has data at the native layer, " +
                       "but is not in the pipeline");
        }
    }.bind(this))();

    return newStreamingPts;
};

//////////
// getLatestCompletedRequest
//////////
RequestManager.prototype.getLatestCompletedRequest = function getLatestCompletedRequest()
{
    if (this._latestCompletedIndex < 0)
        return;

    return this._sentData[this._latestCompletedIndex];
};

//////////
// getRequestPtsStarts
//////////
RequestManager.prototype.getRequestPtsStarts = function getRequestPtsStarts()
{
    function getPtsStarts(mediaRequest)
    {
        return mediaRequest.ptsStart;
    }

    var unsent = this._unsentData.map(getPtsStarts);
    var sent = this._sentData.map(getPtsStarts);
    return unsent.concat(sent);
};

//////////
// getNextPtsNeedsMedia
//////////
RequestManager.prototype.getNextPtsNeedsMedia = function getNextPtsNeedsMedia(){
    var nextPtsNeedsMedia = null;
    function processArray(mediaRequest, index){
        if (nextPtsNeedsMedia === null ||
            nextPtsNeedsMedia === mediaRequest.ptsStart)
        {
            nextPtsNeedsMedia = mediaRequest.ptsStart + mediaRequest.durationMs;
        }
        if (mediaRequest.ptsStart > nextPtsNeedsMedia)
        {
            //found gap, stop here
            return true;
        }
        return false;
    }
    this._sentData.some(processArray);
    if (this._unsentData.length > 0) {
        this._unsentData.some(processArray);
    }
    return nextPtsNeedsMedia;
};

//////////
// getRequestBufferInfo
//////////
RequestManager.prototype.getRequestBufferInfo = function getRequestBufferInfo()
{
    var request;

    // data to return
    var streamingPts = null;
    var startPts = null;
    var partialBytes = 0;
    var fragments = [];

    function processArray(mediaRequest, index)
    {
        // Stop at the first incomplete request unless simulatePartialBlocks
        if (!config.simulatePartialBlocks &&
            (mediaRequest.readyState !== MediaRequest.READYSTATES.DONE))
        {
            return true;
        }

        if (startPts === null)
        {
            // remember the first pts seen
            startPts = mediaRequest.ptsStart;
        }

        // update buffer's streamingPts
        streamingPts = (mediaRequest.ptsStart + mediaRequest.durationMs);

        // count partialBytes in buffer
        partialBytes += (mediaRequest.totalBytes - mediaRequest.bytesReceived);

        fragments.push({
            requestId: mediaRequest.getRequestId(),
            duration: mediaRequest.durationMs,
            bytes: mediaRequest.totalBytes,
            startPts: mediaRequest.ptsStart,
            bitrate: mediaRequest.bitrate,
            readyState: mediaRequest.readyState,
            streamId: mediaRequest.streamId
        });

        return false;
    }

    // walk our requests, filling out the info
    this._sentData.some(processArray);

    // if not abortUnsentBlocks, process the unsent array as well
    if (!config.abortUnsentBlocks && (this._unsentData.length > 0))
    {
        this._unsentData.some(processArray);
    }

    return {
        streamingPts: streamingPts,
        startPts: startPts,
        partialBytes: partialBytes,
        fragments: fragments
    };
};

//////////
// findRequestByPts
//////////
RequestManager.prototype.findRequestByPts = function findRequestByPts(pts)
{
    var found = false;
    this._sentData.some(function(mediaRequest) {
        if ((pts >= mediaRequest.ptsStart) &&
            (pts < mediaRequest.ptsStart + mediaRequest.durationMs))
        {
            found = mediaRequest;
            return true;
        }
    });
    return found;
};

//////////
// updateUrls
//////////
RequestManager.prototype.updateUrls = function updateUrls(streamMap, updateLocationCB)
{
    var failedRequests = [];

    var updateRequestUrl = function updateRequestUrl(mediaRequest)
    {
        // ignore completed requests
        if (mediaRequest.readyState === MediaRequest.READYSTATES.DONE)
            return;

        var streamId = mediaRequest.streamId;

        // look up entry in streamMap
        var stream = streamMap[streamId];
        if (!stream)
        {
            this._warn("missing stream for streamId:", streamId,
                       "mediaRequest:", mediaRequest,
                       "streamMap:", streamMap);
            failedRequests.push(mediaRequest);
            return;
        }
        if (!stream.url)
        {
            this._warn("missing url for streamId:", streamId,
                       "mediaRequest:", mediaRequest.toString(),
                       "stream:", stream);
            failedRequests.push(mediaRequest);
            return;
        }

        if (mediaRequest.url != stream.url)
        {
            DEBUG && this._trace("detected url change, mediaRequest:", mediaRequest,
                                 "url:", mediaRequest.url, "->", stream.url);

            // set new location for request, this needs to be set before swapUrl
            // Cadmium depends on mediaRequest.location to set CDN
            updateLocationCB(mediaRequest, stream.location, stream.server);

            if (!mediaRequest.swapUrl(stream.url))
            {
                this._warn("swapUrl failed: ", mediaRequest.failureString);

                this._reportStreamingFailure("swapUrl failure");
            }
        }
        else
        {
            DEBUG && this._trace("updateUrls: no change for mediaRequest:", mediaRequest,
                                 "url:", mediaRequest.url);
        }
    }.bind(this);

    // update header and data requests
    this._headerRequests.forEach(updateRequestUrl);
    this._unsentData.forEach(updateRequestUrl);
    this._sentData.forEach(updateRequestUrl);

    return failedRequests;
};

//////////
// updateDrmUrls
//////////
RequestManager.prototype.updateDrmUrls = function updateDrmUrls(updateLocationCB)
{
    this._headerRequests.forEach(function(request) {
        if (request.drmHeaderRequest)
        {
            updateLocationCB(request);
        }
    });
};

//////////
// calculateCompleteBuffer
//////////
RequestManager.prototype.calculateCompleteBuffer = function calculateCompleteBuffer(pts)
{
    var duration;

    // This function should only be called, when the played requests are not in the
    // pipeline. Otherwise, we will also add the requests that are already played
    var bufferLevelMs = 0;
    var bufferLevelBytes = 0;
    var appendedBufferMs = 0;
    var appendedBufferBytes = 0;
    var totalBufferMs = 0;
    var totalBufferBytes = 0;
    var partialBuffers = 0;
    var incompleteSeen = false;
    var continuousBufferEndPts;
    DEBUG && this._trace("calculateCompleteBuffer, pts: " + pts +
                         ", length: " + this._sentData.length);
    var request;
    var startIndex = 0;

    if (config.preciseBufferLevel) {
        //find the first chunk that contains the pts
        for (startIndex = 0; startIndex < this._sentData.length; ++startIndex) {
            request = this._sentData[startIndex];
            if (request.ptsStart > pts ){
                // even the first chunk in the buffer doesn't cover the currentPts
                return {
                        bufferLevelMs: bufferLevelMs,
                        bufferLevelBytes: bufferLevelBytes,
                        appendedBufferMs: appendedBufferMs,
                        appendedBufferBytes: appendedBufferBytes,
                        totalBufferMs: totalBufferMs,
                        totalBufferBytes: totalBufferBytes
                };
            }

            if(request.ptsStart <= pts && pts <= (request.ptsStart + request.durationMs)){
                break;
            }
        }
    }

    for (var i= startIndex; i<this._sentData.length; ++i)
    {
        request = this._sentData[i];

        // check and see if there is an gap
        if ( !_.isUndefined(continuousBufferEndPts) &&
            request.ptsStart > continuousBufferEndPts)
        {
            this._warn("Gap found in _sentData");
            if (config.countGapInBuffer)
            {
                incompleteSeen = true;
            }
        }

        if (request.readyState === MediaRequest.READYSTATES.DONE)
        {
            // calculate amount of duration to be added for this request
            // Note the duration would be negative if pts >
            // (request.ptsStart + request.durationMs)
            duration = (pts < request.ptsStart) ?
                request.durationMs : (request.durationMs - (pts - request.ptsStart));

            // count any appended towards total
            if (request.appended && duration > 0)
            {
                appendedBufferMs += duration;
                appendedBufferBytes += request.bytesReceived;
            }

            if (!incompleteSeen)
            {
                // remember this index as furthest continguous complete buffer
                this._latestCompletedIndex = i;

                // if in future, count towards bufferLevel
                if (!_.isUndefined(pts) && (request.ptsStart + request.durationMs >= pts))
                {
                    bufferLevelMs += duration;
                    bufferLevelBytes += request.bytesReceived;
                }
            }

            // count total buffer
            if (duration > 0){
                totalBufferMs += duration;
                totalBufferBytes += request.bytesReceived;
            }
        }
        else
        {
            incompleteSeen = true;
        }

        // count the partial buffers
        if (request.partial)
        {
            ++partialBuffers;
        }

        if (continuousBufferEndPts === undefined ||
            request.ptsStart === continuousBufferEndPts)
        {
            continuousBufferEndPts = request.ptsStart + request.durationMs;
        }
    }

    if (!config.abortUnsentBlocks)
    {
        // include unsent requests as partial buffers
        partialBuffers += this._unsentData.length;
    }
    DEBUG && this._trace("calculateCompleteBuffer, reset partial buffer from " +
                         this._partialBuffers + " to " + partialBuffers);
    this._partialBuffers = partialBuffers;

    DEBUG && this._trace("recalculated bufferLevelMs: " + bufferLevelMs +
                         ", bufferLevelBytes: " + bufferLevelBytes +
                         ", appendedBufferMs: " + appendedBufferMs +
                         ", appendedBufferBytes: " + appendedBufferBytes +
                         ", totalBufferMs: " + totalBufferMs +
                         ", totalBufferBytes: " + totalBufferBytes +
                         ", latestCompletedIndex: " + this._latestCompletedIndex +
                         ", partials: " + partialBuffers);

    // The values returned here are:
    // bufferLevelMs: time until rebuffer if no further data arrives
    // bufferLevelBytes: bytes to be consumed until rebuffer if no further data arrives
    // appendedBufferMs/Bytes: amount of buffer appended to media source
    // totalBufferMs/Bytes: total buffer allocated (including data in the past)
    return {
        bufferLevelMs: bufferLevelMs,
        bufferLevelBytes: bufferLevelBytes,
        appendedBufferMs: appendedBufferMs,
        appendedBufferBytes: appendedBufferBytes,
        totalBufferMs: totalBufferMs,
        totalBufferBytes: totalBufferBytes
    };
};

////////////////////
// Request utils
////////////////////

RequestManager.prototype._cleanupRequest = function _cleanupRequest(mediaRequest)
{
    DEBUG && this._trace("cleanupRequest: " + mediaRequest.toString());

    // adjust counters
    if (mediaRequest.partial)
    {
        mediaRequest.partial = false;
        --this._partialBuffers;
    }
    if (mediaRequest.active)
    {
        mediaRequest.active = false;
        if ( --this._activeRequests === 0 )
        {
            this.emit( "inactive", platform.time.mono() );
        }
    }

    // cleanup any listeners
    if (mediaRequest._listenerGroup)
    {
        mediaRequest._listenerGroup.clear();
    }

    // clean it up
    mediaRequest.cleanup();
};

////////////////////
// MediaRequest events
////////////////////
RequestManager.prototype.onloadstart = function onloadstart(mediaRequest)
{
    var i, existed = false;

    if ( !mediaRequest.active ){
        // there might be multiple retry job ongoing for the same mediaRequest

        // request is now active
        mediaRequest.active = true;
        if ( ++this._activeRequests === 1 )
        {
            // XXX Change the time to the time from the mediaRequst in NRDJS-4105 branch
            this.emit( "active", mediaRequest.loadTime );
        }
    }

    // ignore header requests
    if (mediaRequest.isHeader)
        return;

    // remove request from unsent
    var idx = this._unsentData.indexOf(mediaRequest);
    if (idx === -1)
    {
        this._warn("onloadstart, mediaRequest not found in unsent: " +
                   mediaRequest.toString());
    }
    else
    {
        this._unsentData.splice(idx, 1);
    }

    // add it to sent array in pts order
    for (i=0; i<this._sentData.length; ++i)
    {
        if (mediaRequest.ptsStart !== undefined &&
            this._sentData[i].ptsStart === mediaRequest.ptsStart )
        {
            DEBUG && this._trace("same mediaRequest found at index: " + i +
                                 ", mediaRequest: " + mediaRequest.toString() +
                                 ", this._sentData[" + i + "]: " +
                                 this._sentData[i].toString());
            existed = true;
            break;
        }
        if (this._sentData[i].ptsStart > mediaRequest.ptsStart)
        {
            // found where to splice
            break;
        }
    }

    if (!existed)
    {
        this._sentData.splice(i, 0, mediaRequest);
        if (config.abortUnsentBlocks)
        {
            // now it counts as a partial buffer
            mediaRequest.partial = true;
            ++this._partialBuffers;
        }
    }

    DEBUG && this._trace("onloadstart, moved request to sent array, sent: " +
                         this._sentData.length + ", partials: " + this._partialBuffers +
                         ", mediaRequest: " + mediaRequest.toString());
};

RequestManager.prototype.onfirstbyte = function onfirstbyte(mediaRequest)
{

};

RequestManager.prototype.oncomplete = function oncomplete(mediaRequest, currentPts)
{
    if ( mediaRequest.active)
    {
        // there might be multiple retry job ongoing for the same mediaRequest
        // request is no longer active
        mediaRequest.active = false;
        if ( --this._activeRequests === 0 )
        {
            // XXX Change the time to the time from the event in the NRDJS-4105 branch
            this.emit( "inactive", mediaRequest.lastEventTime );
        }
    }

    if (!mediaRequest.isHeader)
    {
        return this._dataComplete(mediaRequest, currentPts);
    }
};

//////////
// _dataComplete
//////////
RequestManager.prototype._dataComplete = function _dataComplete(mediaRequest, currentPts)
{
    var r, lastPts, duration;

    // make sure we know of this request
    var idx = this._sentData.indexOf(mediaRequest);
    if (idx == -1)
    {
        DEBUG && this._trace("Request done, mediaRequest: " + mediaRequest.toString() +
                             " but unknown");
        return;
    }

    var completePts = mediaRequest.ptsStart + mediaRequest.durationMs;
    if (mediaRequest.partial)
    {
        mediaRequest.partial = false;
        --this._partialBuffers;
    }
    DEBUG && this._trace("Request done, idx: " + idx +
                         ", MediaRequest: " + mediaRequest.toString() +
                         ", pts: " + mediaRequest.ptsStart +
                         ", partials: " + this._partialBuffers +
                         ", completePts: " + completePts);

    // update the last completed request
    var addedMs = 0;
    var addedBytes = 0;
    for (var i = this._latestCompletedIndex+1; i < this._sentData.length; ++i)
    {
        r = this._sentData[i];

        if (r.readyState == MediaRequest.READYSTATES.DONE)
        {
            this._latestCompletedIndex = i;

            if (config.preciseBufferCalculation){
                duration = (currentPts < r.ptsStart) ? r.durationMs : (r.durationMs - (currentPts - r.ptsStart));
                if (duration > 0) {
                    addedMs += duration;
                }
            } else {
                addedMs += r.durationMs;
            }
            addedBytes += r.bytesReceived;
        }
        else
        {
            break; // found first incomplete request
        }
    }

    // find the end pts of the latest completed request
    if (this._latestCompletedIndex >= 0)
    {
        r = this._sentData[this._latestCompletedIndex];
        if (r)
        {
            lastPts = r.ptsStart + r.durationMs;
        }
    }

    DEBUG && this._trace("latestCompletedIndex: " + this._latestCompletedIndex +
                         ", addedMs: " + addedMs + ", addedBytes: " + addedBytes +
                         ", lastPts: " + lastPts);

    // return added data
    return {
        addedMs: addedMs,
        addedBytes: addedBytes,
        lastPts: lastPts
    };
};

//////////
// events
//////////
RequestManager.prototype._reportStreamingFailure = function _reportStreamingFailure(msg)
{
    var evt = {
        'type': "streamingFailure",
        'msg': msg
    };
    this.callEventListeners(evt['type'], evt);
};

RequestManager.prototype._reportDebugMessage = function _reportDebugMessage(msg)
{
    var debugMessage = "@ " + platform.time.mono() + ", " + msg;
    var evt = {
        'type': "managerdebugevent",
        'message': debugMessage
    };
    this.callEventListeners(evt['type'], evt);
};

//////////
// dumpRequests
//////////
RequestManager.prototype.dumpRequests = function dumpRequests()
{
    function requestInfo(mediaRequest)
    {
        return {
            request: mediaRequest,
            streamId: mediaRequest.streamId,
            isHeader: mediaRequest.isHeader,
            readyState: mediaRequest.readyState,
            pts: mediaRequest.ptsStart,
            byteStart: mediaRequest.byteStart,
            byteEnd: mediaRequest.byteEnd
        };
    }

    DEBUG && this._trace("unsent: " + this._unsentData.map(requestInfo));
    DEBUG && this._trace("sent: " + this._sentData.map(requestInfo));
};

////////////////////
// Export
////////////////////
module.exports = RequestManager;

},{"103":103,"47":47,"48":48,"61":61,"94":94}],64:[function(require,module,exports){
/*
 * (c) 1997-2014 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */
("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_high");

var _ = require(103),

    Enums = require(48),

    common = require(65),
    config = require(47),
    console = common.console,
    DEBUG = ("debug" !== 'release'),
    assert = common.assert;

function checkBufferingComplete(player, stream, maxPreBuffer) {

    var buffer = player.buffer,
        bufferLevel = player.bufferLevelMs || (buffer.completePts - buffer.currentPts),
        rebuffering = ( player.state === Enums.PLAYER_STATE.REBUFFERING ),
        throughput = stream.throughput || 0,
        requiredBuffer = 0,
        reason = 'default';

    if ( bufferLevel >= maxPreBuffer ) {
        DEBUG && console.log('  Buffering complete based on maximum prebuffer amount');
        return { complete: true, reason: 'maxsize' };
    }

    if ( throughput <= config.lowThroughputThreshold )
    {
        // The player spends prebufferTimeLimit in buffering when the throughput is too low
        DEBUG && console.log('Continue buffering because the throughput is too low at ' + throughput + ' kbps');
        return { complete: false, lowThroughput : true };
    }

    // Calculate the required buffer level
    requiredBuffer = config.minPrebufSize * ( rebuffering ? 1.0 : config.rebufferingFactor);

    // Add factors for long connect / response time
    if ( config.enablePenaltyForLongConnectTime 
            && stream.statistics
            && stream.statistics.responseTime
            && stream.statistics.responseTime.average > config.longConnectTimeThreshold )
    {
        requiredBuffer += config.additionalBufferingLongConnectTime
                            + stream.statistics.responseTime.average * config.penaltyFactorForLongConnectTime;
    }

    // Additional factor for errors
    if (this.errorDirector) {
        requiredBuffer += this.errorDirector.criticalNetworkErrorCount * config.additionalBufferingPerFailure;
    }

    requiredBuffer = Math.min( maxPreBuffer, requiredBuffer );

    DEBUG && console.log('checkBufferingComplete, adjusted required buffering len: ' + requiredBuffer );

    if ( !throughput )
    {
        return { complete: false, requiredBuffer : requiredBuffer };
    }

    // Calculate the total bytes to reach the streaming pts
    var bytesToStreamingPts = 0;
    buffer.fragments.forEach( function( fragment ) {
        bytesToStreamingPts += ( fragment.startPts + fragment.duration > buffer.currentPts ? fragment.bytes : 0 );
    });

    // At the start and if we switch bitrate during buffering, we can be without stream data
    if ( !stream.fragments || !stream.fragments.length )
    {
        // Adjust required buffer for low throughput, so that we can stream a further 60 seconds
        if ( throughput < stream.bitrate )
        {
            requiredBuffer = Math.min( maxPreBuffer, Math.max( config.rebufferCheckDuration * ( stream.bitrate / throughput - 1.0 ), requiredBuffer ) );
        }

        var additionalBuffer = ( requiredBuffer - ( buffer.streamingPts - buffer.currentPts ) ),
            fraction = ( bytesToStreamingPts - buffer.partialBytes ) /
                            ( bytesToStreamingPts + additionalBuffer * stream.bitrate / 8 );

        DEBUG && console.log('Waiting for headers: buffer bytes: ' + bytesToStreamingPts
                                    + ' partial bytes: ' + buffer.partialBytes
                                    + ' required buffer: ' + requiredBuffer
                                    + ' current pts: ' + buffer.currentPts
                                    + ' streaming pts: ' + buffer.streamingPts
                                    + ' additional buffer: ' + additionalBuffer
                                    + ' fraction: ' + fraction );


        return { complete: false, requiredBuffer : requiredBuffer, progress : fraction };
    }

    var streamingIndex = stream.fragments.find( buffer.streamingPts );
    if (streamingIndex === -1)
    {
        DEBUG && console.log("checkBufferingComplete, pts: " + buffer.streamingPts +
                             " outside of fragment range, returing complete");
        return { complete: true, reason: 'outofrange' };
    }

    var streamingOffset = stream.fragments.getFragment( streamingIndex ).offset;

    // Function to calculate the progress in terms of bytes
    function progress( requiredBuffer ) {

        var requiredIndex = stream.fragments.find( buffer.currentPts + requiredBuffer ),
            requiredFragment = stream.fragments.getFragment( requiredIndex >= 0 ? requiredIndex : stream.fragments.length - 1 ),
            requiredOffset = requiredFragment.offset + requiredFragment.bytes,
            fraction = ( bytesToStreamingPts - buffer.partialBytes ) /
                                    ( bytesToStreamingPts + requiredOffset - streamingOffset );

        DEBUG && console.log('Calculating progress: buffer bytes: ' + bytesToStreamingPts
                                    + ' partial bytes: ' + buffer.partialBytes
                                    + ' required buffer: ' + requiredBuffer
                                    + ' current pts: ' + buffer.currentPts
                                    + ' streaming offset: ' + streamingOffset
                                    + ' required index: ' + requiredIndex
                                    + ' required fragment offset: ' + requiredFragment.offset
                                    + ' required fragment bytes: ' + requiredFragment.bytes
                                    + ' required offset: ' + requiredOffset
                                    + ' fraction: ' + fraction );

        return fraction;
    }

    if (bufferLevel >= requiredBuffer ) {

        DEBUG && console.log('Checking to see if we can stop buffering -----------------------------------------');
        DEBUG && console.log('  Bitrate is ' + stream.bitrate + ' Kbps and throughput is ' + throughput + ' Kbps');

        if ( throughput > stream.bitrate * config.fastUpswitchFactor ) {
            DEBUG && console.log('  Buffering complete based on high throughput');
            return { complete: true, reason: 'hightp' };
        }

        // Perform a quick check for rebuffers at the current stream / throughput
        var fragmentDuration = stream.fragments.getFragmentDuration( streamingIndex ),
            checkFragmentsCount = Math.floor( config.rebufferCheckDuration / fragmentDuration ),
            index = Math.min( streamingIndex + checkFragmentsCount, stream.fragments.length - 1),
            offset = stream.fragments.getFragment( index ).offset,
            constant = streamingOffset * 8 / throughput - buffer.currentPts,
            fragment;

        --index;

        for( ; index > streamingIndex; --index ) {
            fragment = stream.fragments.getFragment( index );
            // ( ( offset - streamingOffset ) * 8 > ( fragment.startPts - buffer.currentPts ) * throughput )
            // offset * 8 / throughput - ( streamingOffset * 8 / throughput + fragment.startPts - buffer.currentPts ) > 0
            // offset * 8 / throughput - fragment.startPts - ( streamingOffset * 8 / throughput - buffer.currentPts ) > 0
            var bufferUnderrun = offset * 8 / throughput - fragment.startPts - constant;
            if ( bufferUnderrun > 0 ) {

                // Calculate the predicted buffer level that would be needed to avoid the rebuffer
                requiredBuffer = Math.min( maxPreBuffer, bufferLevel + bufferUnderrun );

                DEBUG && console.log( '  Predict rebuffer before ' + ( fragment.startPts - buffer.currentPts ) +'ms, '
                                        + requiredBuffer + 'ms needed to complete buffering'
                                        + ', have ' + bufferLevel + 'ms');

                return { complete: false, requiredBuffer: requiredBuffer, progress: progress( requiredBuffer ) };
            }
            offset = fragment.offset;
        }

        DEBUG && console.log( '  No predicted rebuffers: Buffering complete' );
        return { complete: true, reason: 'norebuff' };
    }

    // Adjust required buffer for low throughput to calculate more accurate progress
    if ( throughput > 0 && throughput < stream.bitrate )
    {
        requiredBuffer = Math.min( maxPreBuffer, Math.max( config.rebufferCheckDuration * ( stream.bitrate / throughput - 1.0 ), requiredBuffer ) );
    }

    return { complete: false, requiredBuffer : requiredBuffer, progress: progress( requiredBuffer ) };
}

//=========================================================================
// Export functions

module.exports = {  'checkBuffering'    : checkBufferingComplete };

},{"103":103,"47":47,"48":48,"65":65}],65:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var _ = require(103),
    platform = require(61),
    console = new platform.Console('ASEJS_STREAM_SELECTOR', 'media|asejs'),
    DEBUG = ("debug" === 'true');

//=============================================================================

function assert(exp, msg) {
    var s;
    if (!exp) {
        s = msg ? ' : ' + msg : '';
        console.error('Assertion failed' + s);
        throw new Error('ASEJS_STREAM_SELECTOR assertion failed' + s);
    }
}

//=============================================================================
// This is the stream selector's notion of availability which also takes into
// account whether the stream has failed.

function isStreamUsable(stream) {
    return stream && stream.isAvailable && stream.inRange && !stream.hasFailed;
}

//=============================================================================
// Test is a stream is the higest bitrate available
function isHighestBitrate( streams, index )
{
    return !streams.slice( index + 1 ).some( isStreamUsable );
}

//=============================================================================
// Checks all below startIndex and then all above startIndex for
// usability - returning the index of the first one found or -1
// if none are found. If you pass null or undefined for startIndex, it will check between
// 0 and length - 1 in ascending order. If you pass filter, then it must be
// a function and the stream will only be chosen if the filter function returns
// something truthy.
// startIndex can also be an array that can have 2 or three numbers. In this case,
// you want to check only a slice of the streams passed in: the first number is
// the lower bound and the second number is the upper bound. The last number, if there,
// is the starting index. If not, it will start at the lower bound.

function clamp(n, min, max) {
    if (!_.isNumber(n))
        return min;
    if (n < min)
        return min;
    if (n > max)
        return max;
    return n;
}

function firstAvailableStream(streams, startIndex, filter) {
    var length = streams.length,
        lower = 0,
        upper = length,
        start = startIndex,
        index,
        i;

    function isAvailable(i) {
        var stream = streams[i];

        if (!stream.isAvailable) {
            DEBUG && console.log('Stream [' + i + '] ' + stream.id + ' (' + stream.bitrate + ' Kbps): Not available');
            return false;
        }
        if (!stream.inRange) {
            DEBUG && console.log('Stream [' + i + '] ' + stream.id + ' (' + stream.bitrate + ' Kbps): Not in range');
            return false;
        }
        if (stream.hasFailed) {
            DEBUG && console.log('Stream [' + i + '] ' + stream.id + ' (' + stream.bitrate + ' Kbps): Failed');
            return false;
        }
        if (filter && !filter(stream, i)) {
            return false;
        }
        index = i;
        DEBUG && console.log('Stream [' + i + '] ' + stream.id + ' (' + stream.bitrate + ' Kbps): Available');
        return true;
    }

    if (_.isArray(start)) {
        lower = clamp(start[0], 0, length);
        upper = clamp(start[1], 0, length);
        start = start[2];
    }

    start = clamp(start, lower - 1, upper);

    // Search lower bitrates first
    for (i = start - 1; i >= lower; --i) {
        if (isAvailable(i)) {
            return index;
        }
    }
    // Search higher bitrates next
    for (i = start + 1; i < upper; ++i) {
        if (isAvailable(i)) {
            return index;
        }
    }
    DEBUG && console.log('Found no available streams');
    return -1;
}

//=============================================================================
// How long (in ms) it will take to download the given number of bytes at the
// given birate (in Kbps)
//
// Trying to be clear to the reader, not efficient

function msForBytesOfBitrate(bytes, bitrateKbps) {
    return Math.floor((bytes  / (bitrateKbps * (1000 / 8)) * 1000));
}

//=============================================================================
// How many bytes do we need to have the given ms at the given bitrate

function bytesForMsOfBitrate(ms, bitrateKbps) {
    return Math.ceil((bitrateKbps * (1000 / 8)) * (ms / 1000));
}

//=============================================================================

function forEachReverse(array, callback, thisArg) {
    var i = array.length - 1,
        cb = thisArg ? callback.bind(thisArg) : callback;
    for (; i >= 0; --i) {
        cb(array[i], i, array);
    }
}

//=============================================================================
/**
 *
 * @param {number} selectedStreamIndex
 * @constructor
 */
function SelectionResult(selectedStreamIndex) {
    if (!(this instanceof SelectionResult)) {
        return new SelectionResult(selectedStreamIndex);
    }
    this.selectedStreamIndex = _.isNumber(selectedStreamIndex) ?
        selectedStreamIndex : undefined;
    this.requiredBufferingLengthMs = 0;
    this.numberOfPredictedRebuffers = 0;
}


//=============================================================================
// What we export

module.exports = {
    console: console,
    debug: DEBUG,
    assert: assert,

    isStreamUsable: isStreamUsable,
    firstAvailableStream: firstAvailableStream,
    msForBytesOfBitrate: msForBytesOfBitrate,
    bytesForMsOfBitrate: bytesForMsOfBitrate,
    forEachReverse: forEachReverse,
    isHighestBitrate: isHighestBitrate,
    SelectionResult: SelectionResult
};

},{"103":103,"61":61}],66:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

module.exports = require(74);

},{"74":74}],67:[function(require,module,exports){
/*
 * (c) 1997-2014 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var _ = require(103),

    Enums = require(48),

    common = require(65),
    console = common.console,
    DEBUG = common.debug,
    assert = common.assert,
    isStreamUsable = common.isStreamUsable,
    SelectionResult = common.SelectionResult;

//=============================================================================

function getStreamThroughput(stream) {
    return stream.throughput || 0;
}

//=============================================================================
// STARTING
//=============================================================================

function selectStarting(config, player, streams, selectedStreamIndex) {

    var result = new SelectionResult(),
        stream,
        index;

    function isFeasible(stream, index) {
        var streamId = stream.id,
            bitrate = stream.bitrate,
            minimumBitrate,

            availableThroughputKbps = getStreamThroughput(stream),
            haveThroughputHistory = !!availableThroughputKbps;

        DEBUG && console.log('Checking feasibility of [' + index + '] ' + streamId + ' (' + bitrate + ' Kbps)');

        // Not available
        if (!stream.isAvailable) {
            DEBUG && console.log('  Not available');
            return false;
        }

        if (!stream.inRange) {
            DEBUG && console.log('  Not in range');
            return false;
        }

        // Failed
        if (stream.hasFailed) {
            DEBUG && console.log('  Failed');
            return false;
        }

        if (bitrate > config.maxInitAudioBitrate) {
            DEBUG && console.log('  Above maxInitAudioBitrate (' + config.maxInitAudioBitrate + ' Kbps)');
            return false;
        }

        if (haveThroughputHistory){
            DEBUG && console.log('  Have throughput history = ' + haveThroughputHistory +
            ' : available throughput = ' + availableThroughputKbps + ' Kbps');

            // When we have throughput history,
            // we should pick the audio stream that required less than what we have
            if ( bitrate < availableThroughputKbps ) {
                DEBUG && console.log(' +FEASIBLE: bitrate less than available throughput');
                return true;
            }
            DEBUG && console.log(' bitrate requires more than available throughput');
            return false;
        }

        // If no throughput history available, we have two scenario:
        // (a) we have config for minimum audio bitrate
        // (b) we do not have config

        // For (a), we should pick the one that is highest under minimum bitrate
        minimumBitrate = config.minInitAudioBitrate;
        if (player.isHeaderCache) {
            minimumBitrate = Math.max(minimumBitrate, config.minHCInitAudioBitrate);
        }
        if (bitrate <= minimumBitrate) {
            DEBUG && console.log('  Bitrate is less than max of minInitAudioBitrate (' + config.minInitVideoBitrate +
                ' Kbps) '+ (player.isHeaderCache ? ' and also minHCInitVideoBitrate (' + config.minHCInitVideoBitrate +
                    ' Kbps)' : ''));
            DEBUG && console.log('  +FEASIBLE: no throughput history and has minimum bitrate configured');
            return true;
        }

        // For (b) we should be conservative and prefer the lowest bitrate
        if ( !haveThroughputHistory ){
            DEBUG && console.log('  No throughput history');
            return false;
        }

        return false;
    }

    // Backwards looking for the first feasible one, and storing the
    // lowest usable if none are feasible

    for (index = streams.length - 1; index >= 0; --index) {
        stream = streams[index];
        if (isFeasible(stream, index)) {
            result.selectedStreamIndex = index;
            break;
        }
        if (isStreamUsable(stream)) {
            result.selectedStreamIndex = index;
        }
    }

    return result;
}

//=============================================================================
// BUFFERING
//=============================================================================

function selectBuffering(config, player, streams, selectedStreamIndex) {

    assert(!_.isUndefined(selectedStreamIndex), 'Must have at lease one selected stream');
    return new SelectionResult(selectedStreamIndex);
}

//=============================================================================
// PLAYING
//=============================================================================

function selectPlaying(config, player, streams, selectedStreamIndex) {

    assert(!_.isUndefined(selectedStreamIndex), 'Must have at lease one selected stream');
    return new SelectionResult(selectedStreamIndex);
}

//=========================================================================
// Export our functions

module.exports = {  'STARTING' :   selectStarting,
                    'BUFFERING' :  selectBuffering,
                    'REBUFFERING': selectBuffering,
                    'PLAYING' :    selectPlaying   };



},{"103":103,"48":48,"65":65}],68:[function(require,module,exports){
/*
 * (c) 1997-2014 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */
("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_high");

var _ = require(103),

    Enums = require(48),
    platform = require(61),
    common = require(65),
    config = require(47),
    console = common.console,
    DEBUG = ("debug" !== 'release'),
    assert = common.assert,
    isStreamUsable = common.isStreamUsable,
    firstAvailableStream = common.firstAvailableStream,
    msForBytesOfBitrate = common.msForBytesOfBitrate,
    bytesForMsOfBitrate = common.bytesForMsOfBitrate,
    isHighestBitrate = common.isHighestBitrate,
    SelectionResult = common.SelectionResult;

    /** @const */
    var BYTEtoBITS = 8;

//=============================================================================

function getStreamThroughput(stream) {
    return stream.throughput || 0;
}

function getStreamResponseTime(stream) {
    var statistics = stream.statistics;
    if ( statistics
                && statistics.responseTime
                && statistics.responseTime.average )
    {
        return statistics.responseTime.average
                    + config.connectTimeMultiplier *
                    ( statistics.responseTime.variance ? Math.sqrt( statistics.responseTime.variance ) : 0 );
    }

    return 0;
}


//=============================================================================
// STARTING (Depends on history)
//=============================================================================

function selectStarting(config, player, streams, selectedStreamIndex) {

    // BufferBased
    var result = new SelectionResult(),
        stream,
        minimumBitrateResult = _getMinStream(player, streams, true /*isInitial*/),
        minimumBitrate = minimumBitrateResult.minBitrate,
        minimumBitrateStreamIndex = minimumBitrateResult.minIndex,
        index;

    function isFeasible(stream, index) {
        var streamId = stream.id,
            bitrate = stream.bitrate,

            availableThroughputKbps = getStreamThroughput(stream),
            haveThroughputHistory = !!availableThroughputKbps,

            bytesToDownload,
            predictedBufferingTimeMs,
            maxBufferingTimeMs;

        DEBUG && console.log('Buffer-Based: Checking feasibility of [' + index + '] ' + streamId + ' (' + bitrate + ' Kbps)');

        // Not available
        if (!stream.isAvailable) {
            DEBUG && console.log('  Not available');
            return false;
        }

        if (!stream.inRange) {
            DEBUG && console.log('  Not in range');
            return false;
        }

        // Failed
        if (stream.hasFailed) {
            DEBUG && console.log('  Failed');
            return false;
        }

        // Bit rates above the max are infeasible
        if (bitrate > config.maxInitVideoBitrate) {
            DEBUG && console.log('  Above maxInitVideoBitrate (' + config.maxInitVideoBitrate + ' Kbps)');
            return false;
        }

        // See if the buffer can hold enough
        if (msForBytesOfBitrate(player.buffer.capacity, bitrate) < config.minRequiredBuffer) {
            DEBUG && console.log('  Video buffer too small to hold minRequiredBuffer (' + config.minRequiredBuffer + ' ms)');
            return false;
        }

        DEBUG && console.log('  Have throughput history = ' + haveThroughputHistory +
            ' : available throughput = ' + availableThroughputKbps + ' Kbps');

        if (!haveThroughputHistory) {
            // If no throughput history available, we should pick the lowest one above the configured bitrate

            // current algorithm uses the highest bitrate below the config, so we should make the behavior equivalent during the testing
            // we should clean the condition up once NRDJS-4791 got resolved
            if (index < minimumBitrateStreamIndex ) {
                DEBUG && console.log('  +FEASIBLE: no throughput history, but this is the lowest bitrate above the configured minimumBitrate (' + bitrate +')');
                return true;
            }
            DEBUG && console.log('  No throughput history');
            return false;
        } else if (bitrate <= minimumBitrate) {
            DEBUG && console.log('  Have throughput history = ' + haveThroughputHistory +
            ' : available throughput = ' + availableThroughputKbps + ' Kbps');

            // When we have throughput history, and no streams above the minimumBitrate is feasible
            // we should pick the stream that required less than what we had in history
            if ( bitrate > availableThroughputKbps ) {
                DEBUG && console.log(' bitrate ' + bitrate + ' requires more than available throughput');
                return false;
            }
        }

        // Calculate predicted buffering time

        // To get config.minPrebufSize ms of this stream, we have to download
        // this many bytes, given config.mediaRate
        bytesToDownload = bytesForMsOfBitrate(config.minPrebufSize, bitrate * config.mediaRate);

        // And this is how long it will take to download those bytes given
        // the available Throughput
        predictedBufferingTimeMs = msForBytesOfBitrate(bytesToDownload, availableThroughputKbps);

        DEBUG && console.log('  Predicted buffering time = ' + predictedBufferingTimeMs + ' ms for minPrebufSize (' + config.minPrebufSize + ' ms)');

        maxBufferingTimeMs = config.maxBufferingTime;

        if (config.initialBitrateSelectionCurve) {
            // TODO: recalculate maxBufferingTimeMs using this curve
            DEBUG && console.log('  Using initialBitrateSelectionCurve', config.initialBitrateSelectionCurve);
            maxBufferingTimeMs = lookupMaxBufferingTime(bitrate, config.initialBitrateSelectionCurve);
        }

        // Finally, this stream is feasible if its predicted buffering time is less
        // than the maximum desired buffer time.
        if (predictedBufferingTimeMs <= maxBufferingTimeMs) {
            DEBUG && console.log(' +FEASIBLE: predicted buffering time <= maxBufferingTime (' + maxBufferingTimeMs + ' ms)');
            return true;
        }

        DEBUG && console.log('  Predicted buffering time > maxBufferingTime (' + maxBufferingTimeMs + ' ms)');
        return false;
    }

    function lookupMaxBufferingTime(bitrate, bitrateSelectionCurve)
    {
        var indx;
        var maxBufferingTime = 0;
        for (indx = 0; indx < bitrateSelectionCurve.length; ++indx)
        {
            maxBufferingTime = bitrateSelectionCurve[indx]['d'];
            if (bitrate <= bitrateSelectionCurve[indx]['r'])
            {
                break;
            }
        }
        return maxBufferingTime;
    }

    // Backwards looking for the first feasible one, and storing the
    // lowest usable if none are feasible

    for (index = streams.length - 1; index >= 0; --index) {
        stream = streams[index];
        if (isFeasible(stream, index)) {
            result.selectedStreamIndex = index;
            break;
        }
        if (isStreamUsable(stream)) {
            result.selectedStreamIndex = index;
        }
    }

    return result;
}


function _getMinStream(player, streams, isInitial){
    var minimumBitrate = config.minAcceptableVideoBitrate,
        minimumBitrateStreamIndex = 0;
    var stream;

    if (isInitial){
        minimumBitrate = Math.max(config.minInitVideoBitrate, config.minAcceptableVideoBitrate);
        // Bound the search for feasible bitrate to be above minimumBitrate
        if (player.isHeaderCache) {
            minimumBitrate = Math.max(minimumBitrate, config.minHCInitVideoBitrate);
        }
    }

    if (_.isNumber(minimumBitrate)){
        for (minimumBitrateStreamIndex = 0; minimumBitrateStreamIndex <= streams.length - 1; ++minimumBitrateStreamIndex){
            stream = streams[minimumBitrateStreamIndex];
            if (stream.bitrate >= minimumBitrate){
                break;
            }
        }
    }

    return { minIndex: minimumBitrateStreamIndex,
             minBitrate: minimumBitrate};
}
//=============================================================================
// BUFFERING (Prebuffering / Seeking)
//=============================================================================

function selectBuffering(config, player, streams, selectedStreamIndex) {

    assert(_.isNumber(selectedStreamIndex), 'Must have at lease one selected stream');
    var selectedStream = streams[selectedStreamIndex],
        currentBufferLevel,
        bufferLevelDiff,
        timeDiff;

    if (!isStreamUsable(selectedStream)) {
        DEBUG && console.log('Selected stream is no longer usable');
        selectedStreamIndex = firstAvailableStream(streams, selectedStreamIndex);
        if (selectedStreamIndex < 0) {
            // There is no stream at all...
            return null;
        }
        selectedStream = streams[selectedStreamIndex];
    }

    if (_.isUndefined(this._initialBufferLevel)){
        //Only update the timestamp when buffer is changed
        this._initialBufferLevel = player.bufferLevelMs || player.buffer.completePts - player.buffer.currentPts;
        this._initialTimestamp = platform.time.mono();
    } else {
        // Switch down a bitrate if the time spent on downloading a fragment is more than the fragment's duration
        currentBufferLevel = player.bufferLevelMs? Math.min(player.bufferLevelMs, (player.buffer.completePts - player.buffer.currentPts))
                                                 : (player.buffer.completePts - player.buffer.currentPts);
        bufferLevelDiff = currentBufferLevel - this._initialBufferLevel;
        timeDiff = platform.time.mono() - this._initialTimestamp;
        if ( bufferLevelDiff > 0 &&
             timeDiff > bufferLevelDiff &&
             selectedStreamIndex > 0 ) {
            selectedStreamIndex = selectedStreamIndex - 1;
            selectedStream = streams[selectedStreamIndex];
        }
    }

    return new SelectionResult(selectedStreamIndex);
}

//=============================================================================
// REBUFFERING
//=============================================================================

function selectRebuffering(config, player, streams, selectedStreamIndex) {

    assert(_.isNumber(selectedStreamIndex), 'Must have at lease one selected stream');

    var minimumBitrateResult = _getMinStream(player, streams, false /*isInitial*/),
        minimumBitrate = minimumBitrateResult.minBitrate,
        minimumBitrateStreamIndex = minimumBitrateResult.minIndex;

    // Since we seperate rebuffer from other buffering (initial, seek),
    // we only get to this state when we retrieved from higher bitrate
    // Thus, we should get the minimum bitrate
    if (selectedStreamIndex > minimumBitrateStreamIndex || !_.isNumber(selectedStreamIndex)) {
        selectedStreamIndex = minimumBitrateStreamIndex;
    }

    var selectedStream = streams[selectedStreamIndex],
        index,
        lowestIndex = -1;

    if (!isStreamUsable(selectedStream)) {
        DEBUG && console.log('Selected stream is no longer usable');
        selectedStreamIndex = firstAvailableStream(streams, selectedStreamIndex);
        if (selectedStreamIndex < 0) {
            // There is no stream at all...
            return null;
        }
        selectedStream = streams[selectedStreamIndex];
    }

    return new SelectionResult(selectedStreamIndex);
}

//=============================================================================
// PLAYING
//=============================================================================
/**
* Detailed description can be found in Section 5.1 Reservoir Calculation in the SIGCOMM Submission
* http://yuba.stanford.edu/~huangty/sigc040-huang.pdf
*
* The purpose of Reservoir: the accumulate enough buffer so that we are able to continue to play at R_min even if C(t) = R_min
* To find out the right size for reservoir, we look at the chunk maps and decide how much buffer we need to accomodate buffer variation at R_min.
*/
function _getReservoirCalculationFromFragments(stream, streamingIndex) {
    var _bbconfig = config.bufferBased;
    //configurable QoE nobs
    var _maxReservoirSizeMilliseconds = _bbconfig.maxReservoirSizeMilliseconds,
        _minReservoirSizeMilliseconds = _bbconfig.minReservoirSizeMilliseconds,
        _reservoirLookAheadChunks = _bbconfig.reservoirLookAheadChunks,
        _maxBufferSizeMilliseconds = _bbconfig.maxBufferSizeMilliseconds;

    var fragments = stream.fragments;

    var minReservoirSizeMilliseconds = _minReservoirSizeMilliseconds,
        reservoirSizeMilliseconds = 0;

    if (!fragments) {
        DEBUG && console.warn("Header information is not available for stream (" + stream.bitrate + ")");
        return _maxReservoirSizeMilliseconds;
    }

    var lastChunkIndex = Math.min(fragments.length, (streamingIndex + _reservoirLookAheadChunks));
    var cumulativeDiff = 0;
    for (var index = streamingIndex; index < lastChunkIndex; index++) {
        // assuming throughput is equal to stream's average bitrate,
        // calculate the needed download time for each chunk
        var downloadTimeMilliseconds = fragments.getFragment(index).bytes * BYTEtoBITS / stream.bitrate; // bits / kbps = ms
        // add up the difference
        cumulativeDiff += downloadTimeMilliseconds - fragments.getFragmentDuration(index);
        if (reservoirSizeMilliseconds < cumulativeDiff) {
            //Store the worst possible reservoir size we need.
            reservoirSizeMilliseconds = cumulativeDiff;
        }
    }

    if (reservoirSizeMilliseconds < _minReservoirSizeMilliseconds) {
        reservoirSizeMilliseconds = _minReservoirSizeMilliseconds;
    } else if (reservoirSizeMilliseconds > Math.min(_maxBufferSizeMilliseconds, _maxReservoirSizeMilliseconds)) {
        //This should never happen, but just in case of the configuration error
        reservoirSizeMilliseconds = Math.min(_maxBufferSizeMilliseconds, _maxReservoirSizeMilliseconds);
    }

    DEBUG && console.trace("reservoir size :" + reservoirSizeMilliseconds);
    return reservoirSizeMilliseconds;
}

/**
* Max Cushion size is defined as 90% of the buffer size.
* Why 90%, but not 100%?
* (1) We need to be able to step up to the highest rate before the buffer is full.
* (2) Being at full buffer can make us not fully utilize the available capacity (we become application-limited).
*/
function _getMaxCushionSizeInMilliseconds(map) {
    var _bbconfig = config.bufferBased,
        reservoirSizeMilliseconds = map.reservoir,
        outageProtectionMilliseconds = map.outage,
        maxCushionSize = _bbconfig.maxBufferSizeMilliseconds * _bbconfig.maxCushionSizeInBufferPercentage/100 - reservoirSizeMilliseconds - outageProtectionMilliseconds;
    return maxCushionSize;
}

/**
* Find the desirable chunk size from the curve (given bufferLevel as the input)
*/
function _getSuggestedChunkSizeFromMap(lowestUsableStream, highestFeasibleStream, player, map) {

    var avgChunkSizeInLowestRate = lowestUsableStream.bitrate * player.averageFragmentDuration / BYTEtoBITS,
        avgChunkSizeInHighestRate = highestFeasibleStream.bitrate * player.averageFragmentDuration / BYTEtoBITS,
        currentVideoBufferLevelMilliseconds = player.bufferLevelMs || player.buffer.completePts - player.buffer.currentPts,
        algoAllowableChunkSize,
        cushionSizeMilliseconds = map.cushion,
        reservoirSizeMilliseconds = map.reservoir,
        outageProtectionMilliseconds = map.outage;

    //Calculate the mapped chunk size from buffer occupancy
    algoAllowableChunkSize = (currentVideoBufferLevelMilliseconds - reservoirSizeMilliseconds - outageProtectionMilliseconds) / cushionSizeMilliseconds * (avgChunkSizeInHighestRate - avgChunkSizeInLowestRate) + avgChunkSizeInLowestRate;
    algoAllowableChunkSize = Math.max(0, algoAllowableChunkSize);
    return algoAllowableChunkSize;
}

function _getAverageChunkSize(stream, streamingIndex, numOfFragments) {
    var avgFragSize = 0,
        startIndex = streamingIndex || 0, //if startChunkIndex is not defined, use 0
        fragments = stream.fragments,
        endIndex = Math.min((stream.fragments.length - 1), (startIndex+numOfFragments)); //the remaining number of chunks
    var sum = 0;

    for (var index = startIndex; index <= endIndex; index++){
        sum = sum + fragments.getFragmentSize(index);
    }

    if (sum === 0){
        // if startIndex is beyond the last chunk, return the size of the last chunk
        return fragments.getFragmentSize(stream.fragments.length - 1);
    }

    avgFragSize = sum / numOfFragments;
    return avgFragSize;
}

/**
* Select a rate based on the "desirable chunk size" suggested by the curve.
* To mitigate rate oscillation, We will prefer to stay at the current rate.
* We will only step up when the "desirable chunk size" is larger than the next "numLookAhead" chunk of the next highest rate.
* On the other hand, we will only step down if the "desirable chunk size" is smaller than the next "numLookAhead" chunk of the next lowest rate.
* However, if the next chunk of the current rate is larger than the maximum allowable rate,
* that is, there is a possiblility for us to rebuffer during the next chunk download,
* we don't care about rate oscillation anymore, and jump directly to the lowest safe rate whose next chunk size is smaller than the maximum allowable rate.
*/
function _getVideoRateFromChunkMap(streams, selectedStreamIndex, streamingIndex, player, map) {
    var nextLowestVideoStreamWithHeader,
        nextHighestVideoStreamWithHeader,
        lowestVideoStreamWithHeader,
        suggestedChunkSizeFromMap,
        currentVideoBufferLevelMilliseconds = player.bufferLevelMs || player.buffer.completePts - player.buffer.currentPts,
        cushionSizeMilliseconds = map.cushion,
        reservoirSizeMilliseconds = map.reservoir,
        outageProtectionMilliseconds = map.outage,
        numLookAhead,
        nextFragSize,
        candidateVideoStreamIndex,
        candidateVideoStream,
        candidateChunkSize,
        // by default, keep the current stream
        selectedStream = streams[selectedStreamIndex];

    var minimumBitrateResult = _getMinStream(player, streams, false /*isInitial*/),
        minimumBitrate = minimumBitrateResult.minBitrate,
        minimumBitrateStreamIndex = minimumBitrateResult.minIndex;

    var nextLowestRateAvgChunkSize,
        nextHighestRateAvgChunkSize;


    var lowestVideoStreamWithHeaderIndex = firstAvailableStream(streams, -1, function(stream, index){
        if (stream.fragments && stream.fragments.length > 0 && stream.bitrate >= minimumBitrate){
            return true;
        }
        return false;
    });

    if (streamingIndex > (selectedStream.fragments.length-1)) {
        DEBUG && console.trace("requesting a chunk that is beyond the boundary");
        streamingIndex = Math.min(streamingIndex, selectedStream.fragments.length-1);
    }

    if (lowestVideoStreamWithHeaderIndex === -1) {
        // if there is no bitrate above minimumBitrate is available, find the lowest one that has header
        lowestVideoStreamWithHeaderIndex = firstAvailableStream(streams, -1, function(stream, index){
            if (stream.fragments && stream.fragments.length > 0){
                return true;
            }
            return false;
        });
    }

    var highestStreamIndexConsideredInMap = -1;
    if (selectedStream.statistics &&
        selectedStream.statistics.confidence >= Enums.NETWORK_CONFIDENCE.HAVE_ENOUGH){
        // find the highest bitrate that is feasiable according to the stream throughput
        var highestFeasibleStreamWithHeaderIndex = firstAvailableStream(streams, streams.length, function(stream, index){
            if (stream.fragments && stream.fragments.length > 0 && getStreamThroughput(stream) >= stream.bitrate){
                return true;
            }
            return false;
        });

        if (highestFeasibleStreamWithHeaderIndex < streams.length - 1 ){
            // find the next highest avaiable stream as the top stream considered in the chunk map
            highestStreamIndexConsideredInMap = firstAvailableStream(streams, highestFeasibleStreamWithHeaderIndex, function(stream, index){
                if (stream.fragments && stream.fragments.length > 0 && index > highestFeasibleStreamWithHeaderIndex){
                    return true;
                }
                return false;
            });

            if (highestStreamIndexConsideredInMap < highestFeasibleStreamWithHeaderIndex){
                // If there is no such stream available, we stick with the highestFeasibleStreamWithHeaderIndex
                highestStreamIndexConsideredInMap = highestFeasibleStreamWithHeaderIndex;
            }
        } else {
            // the highest feasible stream is also the highest available stream
            highestStreamIndexConsideredInMap = highestFeasibleStreamWithHeaderIndex;
        }

    } else {
        highestStreamIndexConsideredInMap = firstAvailableStream(streams, streams.length, function(stream, index){
            if (stream.fragments && stream.fragments.length > 0){
                return true;
            }
            return false;
        });
    }
    assert(lowestVideoStreamWithHeaderIndex >=0 , 'invalid lowest video bitrate');
    assert(highestStreamIndexConsideredInMap >=0 , 'invalid highest video bitrate to be considered in the chunk map');
    lowestVideoStreamWithHeader = streams[lowestVideoStreamWithHeaderIndex];
    DEBUG && console.trace("lowest stream with header: " + lowestVideoStreamWithHeader.bitrate + "(" + lowestVideoStreamWithHeaderIndex + ")");
    DEBUG && console.trace("highest stream considered: " + streams[highestStreamIndexConsideredInMap].bitrate + "(" + highestStreamIndexConsideredInMap + ")");
    //Bounded by zero and the maximum allowable chunk size
    suggestedChunkSizeFromMap = _getSuggestedChunkSizeFromMap(lowestVideoStreamWithHeader, streams[highestStreamIndexConsideredInMap], player, map);

    numLookAhead = Math.floor((currentVideoBufferLevelMilliseconds - reservoirSizeMilliseconds - outageProtectionMilliseconds) / player.averageFragmentDuration);
    numLookAhead = numLookAhead < 1 ? 1 : numLookAhead;


    //Find out the average chunksize for the next lower rate
    var nextLowestVideoStreamWithHeaderIndex = firstAvailableStream(streams, selectedStreamIndex, function(stream, index){
        if (stream.fragments && stream.fragments.length > 0 && stream.bitrate < streams[selectedStreamIndex].bitrate){
            return true;
        }
        return false;
    });
    if (nextLowestVideoStreamWithHeaderIndex !== -1) {
        nextLowestVideoStreamWithHeader = streams[nextLowestVideoStreamWithHeaderIndex];
        //the average chunk size for the next "numLookAhead" chunks
        //if numLookAhead = 1, then we are just looking at the size of the next chunk
        //if we are using Rate Map, the AverageChunkSize() will return the overall average chunk size in the downloadable
        nextLowestRateAvgChunkSize = _getAverageChunkSize(nextLowestVideoStreamWithHeader, streamingIndex, numLookAhead);
        if (numLookAhead > 1) {
            //take the max of the size of very next chunk and the average size of the next "numLookAhead" chunks
            nextFragSize = nextLowestVideoStreamWithHeader.fragments.getFragmentSize(streamingIndex);
            nextLowestRateAvgChunkSize = Math.max(nextLowestRateAvgChunkSize, nextFragSize);
        }
    }

    //Find out the average chunksize for the next higher rate
    var nextHighestVideoStreamWithHeaderIndex = firstAvailableStream(streams, selectedStreamIndex, function(stream, index){
        if (stream.fragments && stream.fragments.length > 0 && stream.bitrate > streams[selectedStreamIndex].bitrate){
            return true;
        }
        return false;
    });
    if (nextHighestVideoStreamWithHeaderIndex !== -1) {
        nextHighestVideoStreamWithHeader = streams[nextHighestVideoStreamWithHeaderIndex];
        //the average chunk size for the next "numLookAhead" chunks
        //if numLookAhead = 1, then we are just looking at the size of the next chunk
        //if we are using Rate Map, the AverageChunkSize() will return the overall average chunk size in the downloadable
        nextHighestRateAvgChunkSize = _getAverageChunkSize(nextHighestVideoStreamWithHeader, streamingIndex, numLookAhead);
        if (numLookAhead > 1) {
            //take the max of the size of very next chunk and the average size of the next "numLookAhead" chunks
            nextFragSize = nextHighestVideoStreamWithHeader.fragments.getFragmentSize(streamingIndex);
            nextHighestRateAvgChunkSize = Math.max(nextHighestRateAvgChunkSize, nextFragSize);
        }
    }

    //if the chunker for the next highest rate is available (nextHighestRateAvgChunkSize > 0),
    //Check if f(B) is larger then chunk size in the next highest rate.
    if (nextHighestRateAvgChunkSize && nextHighestRateAvgChunkSize > 0 && suggestedChunkSizeFromMap > nextHighestRateAvgChunkSize) {
        //switch to a higher bitrate, one bit rate at a time
        selectedStream = nextHighestVideoStreamWithHeader;
        selectedStreamIndex = nextHighestVideoStreamWithHeaderIndex;
    } else if (nextLowestRateAvgChunkSize && nextLowestRateAvgChunkSize > 0 && suggestedChunkSizeFromMap < nextLowestRateAvgChunkSize) {

        //Loop over the lower bitrates and see how many bitrates we need to step down
        DEBUG && console.trace("lower the bitrate, because suggestedChunkSizeFromMap is: " + suggestedChunkSizeFromMap +
            "( "+ suggestedChunkSizeFromMap / 4004 + "kb/s), while nextLowestRateAvgChunkSize is " +
            nextLowestRateAvgChunkSize + "( "+ nextLowestRateAvgChunkSize / 4004 + "kb/s)");

        candidateVideoStream = nextLowestVideoStreamWithHeader;
        candidateVideoStreamIndex =nextLowestVideoStreamWithHeaderIndex;
        candidateChunkSize = nextLowestRateAvgChunkSize;

        var streamFilter = function(stream, index){
                if (stream.fragments && stream.fragments.length > 0 && stream.bitrate < selectedStream.bitrate){
                    return true;
                }
                return false;
        };


        while (candidateChunkSize > suggestedChunkSizeFromMap) {
            DEBUG && console.trace("current bitrate: " + selectedStream.bitrate + ", candidate bitrate: " + candidateVideoStream.bitrate);
            DEBUG && console.trace("lower the bitrate, because suggestedChunkSizeFromMap is: " + suggestedChunkSizeFromMap +
            "( "+ suggestedChunkSizeFromMap * 8 / 4004 + "kb/s), while candidateChunkSize is " +
            candidateChunkSize + "( "+ candidateChunkSize * 8 / 4004 + "kb/s)");
            selectedStream = candidateVideoStream;
            selectedStreamIndex = candidateVideoStreamIndex;
            candidateVideoStreamIndex = firstAvailableStream(streams, selectedStreamIndex, streamFilter);

            if (candidateVideoStreamIndex == -1) {
                break;
            }
            if (candidateVideoStream.bitrate <= lowestVideoStreamWithHeader.bitrate) {
                break;
            }
            candidateVideoStream = streams[candidateVideoStreamIndex];
            candidateChunkSize = _getAverageChunkSize(candidateVideoStream, streamingIndex, numLookAhead);
            if (numLookAhead > 1) {
                nextFragSize = candidateVideoStream.fragments.getFragmentSize(streamingIndex);
                candidateChunkSize = Math.max(candidateChunkSize, nextFragSize);
            }
        }
    }
    return selectedStreamIndex;
}


/**
* The main function of the Buffer-Based algorithm
*/
function _getVideoStreamRecommendationBasedOnBuffer(streams, selectedStreamIndex, streamingIndex, player) {
    var _bbconfig = config.bufferBased;
    //configurable QoE nobs
    var _maxReservoirSizeMilliseconds = _bbconfig.maxReservoirSizeMilliseconds,
        _minReservoirSizeMilliseconds = _bbconfig.minReservoirSizeMilliseconds,
        _reservoirLookAheadChunks = _bbconfig.reservoirLookAheadChunks,
        _outageProtectionMilliseconds = 0,
        _maxBufferSizeMilliseconds = _bbconfig.maxBufferSizeMilliseconds;

    var _reservoirSizeMilliseconds = _minReservoirSizeMilliseconds,
        _upperReservoirSizeMilliseconds,
        _cushionSizeMilliseconds;

    var map,
        selectedStream = streams[selectedStreamIndex],
        recStreamFromMap,
        recStreamIndexFromMap,
        currentBufferLevel,
        bufferLevelDiff,
        timeDiff,
        updatedReservoir;


    // --- Begin Reservoir Calculation (Section 5.1 in the SIGCOMM submission) ---
    updatedReservoir = _getReservoirCalculationFromFragments(streams[selectedStreamIndex], streamingIndex);
    // We only allow reservoir to increase, not decrease to avoid rate osillation
    if (_reservoirSizeMilliseconds < updatedReservoir) {
        _reservoirSizeMilliseconds = updatedReservoir;
    }
    // --- End Reservoir Calculation ----

    map = {
        reservoir: _reservoirSizeMilliseconds,
        outage: _outageProtectionMilliseconds
    };
    // --- Begin Cushion Calculation ---
    var maxCushion = _getMaxCushionSizeInMilliseconds(map);
    if (!_bbconfig.isCushionManualSet) {
        _cushionSizeMilliseconds = maxCushion;
    } else {
        _cushionSizeMilliseconds = _bbconfig.manualCushionMilliseconds;

        if (_cushionSizeMilliseconds > maxCushion) {
            _cushionSizeMilliseconds = maxCushion;
        }
    }
    // --- End Cushion Calculation ---
    map.cushion =  _cushionSizeMilliseconds;

    recStreamIndexFromMap = _getVideoRateFromChunkMap(streams, selectedStreamIndex, streamingIndex, player, map);
    if (recStreamIndexFromMap > 0) {
        DEBUG && console.trace('Buffer-Based: Feasable stream found from chunk map', recStreamIndexFromMap);
    } else {
        recStreamIndexFromMap = firstAvailableStream(streams, -1, function(stream, index){
            if (stream.fragments && stream.fragments.length > 0){
                return true;
            }
            return false;
        });
        DEBUG && console.trace('No feasable streams found, using lowest that has a header', recStreamIndexFromMap);
    }
    recStreamFromMap = streams[recStreamIndexFromMap];

    //Get the desirable chunk size from the curve
    if (this._bufferBasedState == Enums.BUFFER_BASED_STATE.STARTUP) {
        // Continue to build up buffer until the start-up bitrate (based on historical) until:
        // either (i) rate map suggests a higher rate, or (ii) buffer is decreasing

        // (i) rate map suggests a higher rate
        if (recStreamFromMap.bitrate > selectedStream.bitrate){
            selectedStream = recStreamFromMap;
            selectedStreamIndex = recStreamIndexFromMap;
            this._bufferBasedState = Enums.BUFFER_BASED_STATE.STEADY;
            DEBUG && console.trace("STEADY STATE (suggested a higher bitrate: " + recStreamFromMap.bitrate + " kb/s )");
        }

        // (ii) buffer is decreasing
        if (_.isUndefined(this._initialBufferLevel)){
            //Only update the timestamp when buffer is changed
            this._initialBufferLevel = player.bufferLevelMs || player.buffer.completePts - player.buffer.currentPts;
            this._initialTimestamp = platform.time.mono();
        } else {
            // Switch down a bitrate if the time spent on downloading fragment(s) is more than the fragment's total duration
            currentBufferLevel = player.bufferLevelMs || player.buffer.completePts - player.buffer.currentPts;
            bufferLevelDiff = currentBufferLevel - this._initialBufferLevel;
            timeDiff = platform.time.mono() - this._initialTimestamp;
            if ( timeDiff > player.averageFragmentDuration &&
                 timeDiff > bufferLevelDiff &&
                 selectedStream.bitrate > recStreamFromMap.bitrate ) {
                // if the buffer is decreasing (observation started after we downloaded at least one chunk)
                // i.e., the time spend on downloading is more than the added video time in buffer
                // it's time for us to step down
                selectedStream = recStreamFromMap;
                selectedStreamIndex = recStreamIndexFromMap;
                this._bufferBasedState = Enums.BUFFER_BASED_STATE.STEADY;
                DEBUG && console.trace("STEADY STATE (suggested a lower bitrate: " + recStreamFromMap.bitrate + " kb/s )");
            }
        }
    } else {
        selectedStream = recStreamFromMap;
        selectedStreamIndex = recStreamIndexFromMap;
    }
    return selectedStreamIndex;
}

/**
@param {Object} config
@param {Object} player
@param {Object} streams
@param {Object} selectedStreamIndex
@param {Object=} predictor
@param {Object=} pipeline
*/
function selectPlaying(config, player, streams, selectedStreamIndex, predictor, pipeline) {

    assert(!_.isUndefined(selectedStreamIndex), 'Must have at lease one selected stream');
    assert(_.isNumber(player.streamingIndex), 'player missing streamingIndex');

    var selectedStream = streams[selectedStreamIndex],
        streamingIndex = player.streamingIndex,
        candidateStreamIndex = _getVideoStreamRecommendationBasedOnBuffer(streams, selectedStreamIndex, streamingIndex, player),
        candidateStream = streams[candidateStreamIndex],
        desiredStreamHeaders = {},
        result = new SelectionResult(selectedStreamIndex);

    DEBUG && console.log('Playback stream selection');
    result.selectedStreamIndex = candidateStreamIndex;
    // Currently selected stream is no longer usable, we have to search for
    // another one starting with lower bitrates
    if (!isStreamUsable(candidateStream)) {
        DEBUG && console.log('Selected stream is no longer usable');
        candidateStreamIndex = firstAvailableStream(streams, candidateStreamIndex);
        if (candidateStreamIndex < 0) {
            return null;
        }
        result.selectedStreamIndex = candidateStreamIndex;
    }

    // Ask for headers if we need them
    if ( !candidateStream.fragments || !candidateStream.fragments.length ) {
        desiredStreamHeaders[ candidateStreamIndex ] = true;
        candidateStreamIndex = firstAvailableStream(streams, candidateStreamIndex, function(stream, index){
            if (stream.fragments && stream.fragments.length > 0){
                return true;
            }
            return false;
        });
        if (candidateStreamIndex < 0){
            return null;
        }
        result.selectedStreamIndex = candidateStreamIndex;
    }

    result.continueStream = ( selectedStreamIndex === candidateStreamIndex );
    result.currentStreamInfeasible = false;

    if (candidateStreamIndex < selectedStreamIndex) {
        // check if we have enough buffer to finish the current ongoing requests
        var currentVideoBufferLevelMilliseconds = player.bufferLevelMs || player.buffer.completePts - player.buffer.currentPts;
        var avgChunkSizeInSelectedStream = selectedStream.bitrate * player.averageFragmentDuration / BYTEtoBITS;
        var throughput = getStreamThroughput(selectedStream);
        if ( throughput && selectedStream.statistics.confidence >= Enums.NETWORK_CONFIDENCE.HAVE_MINIMUM) {
            var downloadTime = msForBytesOfBitrate(avgChunkSizeInSelectedStream, throughput);
            if (downloadTime > currentVideoBufferLevelMilliseconds){
                result.currentStreamInfeasible = true;
            }
        }
    }

    return result;
}

//=========================================================================
// Export functions

module.exports = {  'STARTING'          : selectStarting,
                    'BUFFERING'         : selectBuffering,
                    'REBUFFERING'       : selectRebuffering,
                    'PLAYING'           : selectPlaying };



},{"103":103,"47":47,"48":48,"61":61,"65":65}],69:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var _ = require(103),

    Enums = require(48),

    common = require(65),
    console = common.console,
    DEBUG = ("debug" !== 'release'),
    firstAvailableStream = common.firstAvailableStream,
    isStreamUsable = common.isStreamUsable,
    SelectionResult = common.SelectionResult;

//====================================================================================

function selectStream(config, player, streams, selectedStreamIndex)
{
    var index;

    DEBUG && console.log('Using "select first available" algorithm');

    if (_.isUndefined(selectedStreamIndex)) {
        index = firstAvailableStream(streams);
    } else if (isStreamUsable(streams[selectedStreamIndex])) {
        index = selectedStreamIndex;
    } else {
        DEBUG && console.log('Currently selected stream [' + selectedStreamIndex + '] is no longer usable');
        index = firstAvailableStream(streams, selectedStreamIndex);
        if (index < 0) {
            return null;
        }
    }

    return new SelectionResult(index);
}

module.exports = {  'STARTING' :   selectStream,
                    'BUFFERING' :  selectStream,
                    'REBUFFERING' :  selectStream,
                    'PLAYING' :    selectStream   };

},{"103":103,"48":48,"65":65}],70:[function(require,module,exports){
/*
 * (c) 1997-2014 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */
("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_high");

var _ = require(103),

    Enums = require(48),

    common = require(65),
    config = require(47),
    console = common.console,
    DEBUG = ("debug" !== 'release'),
    assert = common.assert,
    isStreamUsable = common.isStreamUsable,
    firstAvailableStream = common.firstAvailableStream,
    msForBytesOfBitrate = common.msForBytesOfBitrate,
    bytesForMsOfBitrate = common.bytesForMsOfBitrate,
    isHighestBitrate = common.isHighestBitrate,
    SelectionResult = common.SelectionResult;

//=============================================================================

function getStreamThroughput(stream) {
    return stream.throughput || 0;
}

function getStreamResponseTime(stream) {
    var statistics = stream.statistics;
    if ( statistics
                && statistics.responseTime
                && statistics.responseTime.average )
    {
        return statistics.responseTime.average
                    + config.connectTimeMultiplier *
                    ( statistics.responseTime.variance ? Math.sqrt( statistics.responseTime.variance ) : 0 );
    }
    
    return 0;
}

//=============================================================================
// STARTING
//=============================================================================

function selectStarting(config, player, streams, selectedStreamIndex) {

    var result = new SelectionResult(),
        stream,
        index,
        reason = 'default',
        histBw = -1;

    function isFeasible(stream, index) {
        var streamId = stream.id,
            bitrate = stream.bitrate,

            availableThroughputKbps = getStreamThroughput(stream),
            haveThroughputHistory = !!availableThroughputKbps,

            bytesToDownload,
            predictedBufferingTimeMs,
            maxBufferingTimeMs,
            minimumBitrate;

        DEBUG && console.log('Checking feasibility of [' + index + '] ' + streamId + ' (' + bitrate + ' Kbps)');

        // Not available
        if (!stream.isAvailable) {
            DEBUG && console.log('  Not available');
            return false;
        }

        if (!stream.inRange) {
            DEBUG && console.log('  Not in range');
            return false;
        }

        // Failed
        if (stream.hasFailed) {
            DEBUG && console.log('  Failed');
            return false;
        }

        // Bit rates above the max are infeasible
        if (bitrate > config.maxInitVideoBitrate) {
            DEBUG && console.log('  Above maxInitVideoBitrate (' + config.maxInitVideoBitrate + ' Kbps)');
            return false;
        }

        // See if the buffer can hold enough
        if (msForBytesOfBitrate(player.buffer.capacity, bitrate) < config.minRequiredBuffer) {
            DEBUG && console.log('  Video buffer too small to hold minRequiredBuffer (' + config.minRequiredBuffer + ' ms)');
            return false;
        }

        DEBUG && console.log('  Have throughput history = ' + haveThroughputHistory +
            ' : available throughput = ' + availableThroughputKbps + ' Kbps');

        if (haveThroughputHistory) {
            histBw = availableThroughputKbps;
        }

        // If it is below the minimums
        minimumBitrate = Math.max(config.minInitVideoBitrate, config.minAcceptableVideoBitrate);
        if (player.isHeaderCache) {
            minimumBitrate = Math.max(minimumBitrate, config.minHCInitVideoBitrate);
        }
        if (bitrate <= minimumBitrate) {
            DEBUG && console.log('  Bitrate is less than max of minInitVideoBitrate (' + config.minInitVideoBitrate +
                ' Kbps) and minAcceptableVideoBitrate (' + config.minAcceptableVideoBitrate + ' Kbps)' +
                (player.isHeaderCache ? ' and also minHCInitVideoBitrate (' + config.minHCInitVideoBitrate +
                    ' Kbps)' : ''));
            if (bitrate < availableThroughputKbps) {
                DEBUG && console.log(' +FEASIBLE: bitrate less than available throughput');
                reason = 'lt_hist_lte_minbitrate';
                return true;
            } else if (!haveThroughputHistory) {
                DEBUG && console.log('  +FEASIBLE: no throughput history');
                reason = 'no_historical_lte_minbitrate';
                return true;
            }
            DEBUG && console.log('  Bitrate above available throughput');
            return false;
        }

        // At this point, we need throughput history to calculate buffering
        // time. So, if we don't have it, we call this stream infeasible
        if (!haveThroughputHistory) {
            DEBUG && console.log('  No throughput history');
            return false;
        }

        // Calculate predicted buffering time

        // To get config.minPrebufSize ms of this stream, we have to download
        // this many bytes, given config.mediaRate
        bytesToDownload = bytesForMsOfBitrate(config.minPrebufSize, bitrate * config.mediaRate);

        // And this is how long it will take to download those bytes given
        // the available Throughput
        predictedBufferingTimeMs = msForBytesOfBitrate(bytesToDownload, availableThroughputKbps);

        DEBUG && console.log('  Predicted buffering time = ' + predictedBufferingTimeMs + ' ms for minPrebufSize (' + config.minPrebufSize + ' ms)');

        maxBufferingTimeMs = config.maxBufferingTime;

        if (config.initialBitrateSelectionCurve) {
            // TODO: recalculate maxBufferingTimeMs using this curve
            DEBUG && console.log('  Using initialBitrateSelectionCurve', config.initialBitrateSelectionCurve);
            maxBufferingTimeMs = lookupMaxBufferingTime(bitrate, config.initialBitrateSelectionCurve);
        }

        // Finally, this stream is feasible if its predicted buffering time is less
        // than the maximum desired buffer time.
        if (predictedBufferingTimeMs <= maxBufferingTimeMs) {
            DEBUG && console.log(' +FEASIBLE: predicted buffering time <= maxBufferingTime (' + maxBufferingTimeMs + ' ms)');
            reason = 'hist_bufftime';
            return true;
        }

        DEBUG && console.log('  Predicted buffering time > maxBufferingTime (' + maxBufferingTimeMs + ' ms)');
        return false;
    }

    function lookupMaxBufferingTime(bitrate, bitrateSelectionCurve)
    {
        var indx;
        var maxBufferingTime = 0;
        for (indx = 0; indx < bitrateSelectionCurve.length; ++indx)
        {
            maxBufferingTime = bitrateSelectionCurve[indx]['d'];
            if (bitrate <= bitrateSelectionCurve[indx]['r'])
            {
                break;
            }
        }
        return maxBufferingTime;
    }

    // Backwards looking for the first feasible one, and storing the
    // lowest usable if none are feasible

    for (index = streams.length - 1; index >= 0; --index) {
        stream = streams[index];
        if (isFeasible(stream, index)) {
            result.selectedStreamIndex = index;
            break;
        }
        if (isStreamUsable(stream)) {
            result.selectedStreamIndex = index;
        }
    }

    // record the reason for picking the initial video stream and the historical bandwidth (if any, else -1)
    result.reason = reason;
    result.histBw = histBw;

    return result;
}

//=============================================================================
// STARTING - simplified
//=============================================================================
function selectStartingSimplified(config, player, streams, selectedStreamIndex) {
    var result = new SelectionResult(),
        stream,
        index,
        reason = 'default',
        histBw = -1;

    function isFeasible(stream, index) {
        var streamId = stream.id,
            bitrate = stream.bitrate,

            availableThroughputKbps = getStreamThroughput(stream),
            haveThroughputHistory = !!availableThroughputKbps,

            predictedBufferingTimeMs,
            maxBufferingTimeMs,
            minimumBitrate;

        DEBUG && console.log('Checking feasibility of [' + index + '] ' + streamId + ' (' + bitrate + ' Kbps)');

        // check whether stream is available, in range, and has not failed
        if (!isStreamUsable(stream)) {
            return false;
        }

        // Bit rates above the max are infeasible
        if (bitrate > config.maxInitVideoBitrate) {
            DEBUG && console.log('  Above maxInitVideoBitrate (' + config.maxInitVideoBitrate + ' Kbps)');
            return false;
        }

        // See if the buffer can hold enough
        if (msForBytesOfBitrate(player.buffer.capacity, bitrate) < config.minRequiredBuffer) {
            DEBUG && console.log('  Video buffer too small to hold minRequiredBuffer (' + config.minRequiredBuffer + ' ms)');
            return false;
        }

        if (haveThroughputHistory) {
            histBw = availableThroughputKbps;
        }

        DEBUG && console.log('  Have throughput history = ' + haveThroughputHistory +
            ' : available throughput = ' + availableThroughputKbps + ' Kbps');

        // determine minimum bitrate
        minimumBitrate = Math.max(config.minInitVideoBitrate, config.minAcceptableVideoBitrate);
        if (player.isHeaderCache) {
            minimumBitrate = Math.max(minimumBitrate, config.minHCInitVideoBitrate);
        }

        // if no hisotry, them choose the first bitrate below the minimum
        if (bitrate <= minimumBitrate && !haveThroughputHistory) {
            DEBUG && console.log('  +FEASIBLE: no throughput history');
            reason = 'no_historical';
            return true;
        }

        // At this point, we need throughput history to calculate buffering
        // time. So, if we don't have it, we call this stream infeasible
        if (!haveThroughputHistory) {
            DEBUG && console.log('  No throughput history');
            return false;
        }

        // Calculate predicted buffering time
        predictedBufferingTimeMs = bitrate * config.minPrebufSize / availableThroughputKbps;

        DEBUG && console.log('  Predicted buffering time = ' + predictedBufferingTimeMs + ' ms for minPrebufSize (' + config.minPrebufSize + ' ms)');

        maxBufferingTimeMs = config.maxBufferingTime;

        if (config.initialBitrateSelectionCurve) {
            // TODO: recalculate maxBufferingTimeMs using this curve
            DEBUG && console.log('  Using initialBitrateSelectionCurve', config.initialBitrateSelectionCurve);
            maxBufferingTimeMs = lookupMaxBufferingTime(bitrate, config.initialBitrateSelectionCurve);
        }

        // Finally, this stream is feasible if its predicted buffering time is less
        // than the maximum desired buffer time.
        if (predictedBufferingTimeMs <= maxBufferingTimeMs) {
            DEBUG && console.log(' +FEASIBLE: predicted buffering time <= maxBufferingTime (' + maxBufferingTimeMs + ' ms)');
            reason = 'hist_bufftime';
            return true;
        }

        DEBUG && console.log('  Predicted buffering time > maxBufferingTime (' + maxBufferingTimeMs + ' ms)');
        return false;
    }

    function lookupMaxBufferingTime(bitrate, bitrateSelectionCurve)
    {
        var indx;
        var maxBufferingTime = 0;
        for (indx = 0; indx < bitrateSelectionCurve.length; ++indx)
        {
            maxBufferingTime = bitrateSelectionCurve[indx]['d'];
            if (bitrate <= bitrateSelectionCurve[indx]['r'])
            {
                break;
            }
        }
        return maxBufferingTime;
    }

    // Backwards looking for the first feasible one, and storing the
    // lowest usable if none are feasible

    for (index = streams.length - 1; index >= 0; --index) {
        stream = streams[index];
        if (isFeasible(stream, index)) {
            result.selectedStreamIndex = index;
            break;
        }
        if (isStreamUsable(stream)) {
            result.selectedStreamIndex = index;
        }
    }

    // record the reason for picking the initial video stream and the historical bandwidth (if any, else -1)
    result.reason = reason;
    result.histBw = histBw;

    return result;
}

//=============================================================================
// BUFFERING
//=============================================================================

function selectBuffering(config, player, streams, selectedStreamIndex) {

    assert(!_.isUndefined(selectedStreamIndex), 'Must have at lease one selected stream');

    var selectedStream = streams[selectedStreamIndex],
        index,
        lowestIndex = -1;

    if (!isStreamUsable(selectedStream)) {
        DEBUG && console.log('Selected stream is no longer usable');
        selectedStreamIndex = firstAvailableStream(streams, selectedStreamIndex);
        if (selectedStreamIndex < 0) {
            // There is no stream at all...
            return null;
        }
        selectedStream = streams[selectedStreamIndex];
    }

    function filter(stream, i) {
        var throughput = getStreamThroughput(stream);
        lowestIndex = i;
        if (!throughput) {
            DEBUG && console.log('  Does not have throughput history');
            return false;
        }
        if (stream.bitrate > throughput) {
            DEBUG && console.log('  Bitrate (' + stream.bitrate + 'Kbps) is higher than available throughput (' + throughput + ' Kbps)');
            return false;
        }
        DEBUG && console.log(' +FEASIBLE: Bitrate (' + stream.bitrate + 'Kbps) is <= available throughput (' + throughput + ' Kbps)');
        return true;
    }

    // If the selected stream has history, we check others
    if (getStreamThroughput(selectedStream)) {
        DEBUG && console.log('Selected stream has throughput history, will consider other streams');

        // Select down - starting with currently selected one.
        index = firstAvailableStream(streams, [0, selectedStreamIndex + 1, selectedStreamIndex + 1], filter);

        if (index >= 0) {
            selectedStreamIndex = index;
        } else if (lowestIndex >= 0) {
            console.warn('Dropping to lowest usable rate, because no other stream was feasible');
            selectedStreamIndex = lowestIndex;
        }
    }

    return new SelectionResult(selectedStreamIndex);
}

//=============================================================================
// PLAYING
//=============================================================================

function isFeasible(    config,
                        firstStream,
                        secondStream,
                        fragments,
                        currentPts,             // relative to buffer start
                        skipBackMs,
                        completePts,            // relative to buffer start
                        streamingPts,           // relative to buffer start
                        streamingIndex,
                        bufferedBlocks,
                        partialBytes,
                        freeBytes,
                        firstStreamBlocks,
                        secondStreamBlocks,
                        lowestWatermarkLevel,
                        drainingBytes,
                        loop ) {
    var result,
        fragmentsArray,
        availableThroughputKbps = getStreamThroughput(firstStream),
        bufferLevel = completePts - currentPts,
        fragmentsCount = fragments.byteLength / 16,
        haveFirstStreamFragments = firstStream.fragments && firstStream.fragments.length,
        haveSecondStreamFragments = secondStream.fragments && secondStream.fragments.length;

    assert( firstStream, 'First stream undefined' );
    assert( secondStream, 'Secons stewam undefined' );

    DEBUG && console.log('Checking feasibility of ' + firstStream.id + ' (' + firstStream.bitrate + ' Kbps) then ' + secondStream.id + ' (' + secondStream.bitrate + ' Kbps) ' );

    if (!availableThroughputKbps) {
        DEBUG && console.log('  No throughput in network statistics, unfeasible');
        return false;
    }

    if (!firstStream.isAvailable) {
        DEBUG && console.log('  First stream not available');
        return false;
    }

    if (!firstStream.inRange) {
        DEBUG && console.log('  First stream not in range');
        return false;
    }

    if (firstStream.hasFailed) {
        DEBUG && console.log('  First stream has failed');
        return false;
    }

    if (!availableThroughputKbps) {
        DEBUG && console.log('  No throughput in network statistics, unfeasible');
        return false;
    }

    if (!secondStream.isAvailable) {
        DEBUG && console.log('  Second stream not available');
        secondStream = firstStream;
    }
    else if (!secondStream.inRange) {
        DEBUG && console.log('  Second stream not in range');
        secondStream = firstStream;
    }
    else if (secondStream.hasFailed) {
        DEBUG && console.log('  Second stream has failed');
        secondStream = firstStream;
    }
    else if (!haveSecondStreamFragments) {
        DEBUG && console.log('  Second stream has no fragments');
        secondStream = firstStream;
    }

    DEBUG && console.log('  Throughput is ' + availableThroughputKbps + ' Kbps and initial buffer level is ' + bufferLevel + ' ms');

    if (availableThroughputKbps < firstStream.bitrate / 2 ) {
        DEBUG && console.log(' Throughput too low for first stream');
        return false;
    }

    if ( !haveFirstStreamFragments ) {
        DEBUG && console.log('  Missing stream fragments, cannot simulate ' + firstStream.id + ' (' + firstStream.bitrate + ' Kbps)');
        return false;
    }

    fragmentsArray = new Uint8Array( fragments.buffer );

    if ( !loop ) {

        firstStreamBlocks = Math.min( firstStreamBlocks, firstStream.fragments.length - streamingIndex, fragmentsCount - bufferedBlocks ),
        secondStreamBlocks = Math.min( secondStreamBlocks, firstStream.fragments.length - streamingIndex - firstStreamBlocks, fragmentsCount - bufferedBlocks - firstStreamBlocks );

        DEBUG && console.log('  Simulating from fragment ' + streamingIndex + ' with ' + firstStreamBlocks + ' fragments then ' + secondStreamBlocks + ' fragments' );

        fragmentsArray.set( firstStream.fragments.getFragmentsArray( streamingIndex, firstStreamBlocks ), bufferedBlocks * 16 );
        fragmentsArray.set( secondStream.fragments.getFragmentsArray( streamingIndex + firstStreamBlocks, secondStreamBlocks ), ( bufferedBlocks + firstStreamBlocks ) * 16 );

    } else {
        // looping - fill out the array by cycling around the streams
        DEBUG && console.log('  Simulating looping from fragment ' + streamingIndex + ' with ' + firstStreamBlocks + ' fragments then ' + secondStreamBlocks + ' fragments' );

        var i = firstStreamBlocks, j = streamingIndex, p = bufferedBlocks, b;
        while( i > 0 && p < fragmentsCount )
        {
            b = Math.min( i, firstStream.fragments.length - j, fragmentsCount - p );
            DEBUG && console.log('   ' + b + ' fragments starting at ' + j + ' from first stream' );
            fragmentsArray.set( firstStream.fragments.getFragmentsArray( j, b ), p * 16 );
            i -= b;
            p += b;
            j += b;
            if  ( j >= firstStream.fragments.length ) { j = 0; }
        }

        i = secondStreamBlocks;
        while( i > 0 && p < fragmentsCount )
        {
            b = Math.min( i, secondStream.fragments.length - j, fragmentsCount - p );
            DEBUG && console.log('   ' + b + ' fragments starting at ' + j + ' from second stream' );
            fragmentsArray.set( secondStream.fragments.getFragmentsArray( j, b ), p * 16 );
            i -= b;
            p += b;
            j += b;
            if  ( j >= secondStream.fragments.length ) { j = 0; }
        }
    }

    result = simulate(      config,
                            fragments,
                            bufferedBlocks + firstStreamBlocks + secondStreamBlocks,
                            currentPts,
                            completePts,
                            skipBackMs,
                            partialBytes,
                            streamingPts,
                            bufferedBlocks,                         // index of the first block to stream
                            bufferedBlocks + firstStreamBlocks,     // index at which to terminate if buffer has increased overall
                            drainingBytes,
                            freeBytes,
                            availableThroughputKbps,
                            lowestWatermarkLevel );

    DEBUG && console.log( result.result ? ' +FEASIBLE' : '  Not feasible' );

    return result;
}

/**
@param {Object} config
@param {Object} player
@param {Object} streams
@param {Object} selectedStreamIndex
@param {Object=} predictor
@param {Object=} pipeline
*/
function selectPlaying(config, player, streams, selectedStreamIndex, predictor, pipeline) {

    assert(!_.isUndefined(selectedStreamIndex), 'Must have at lease one selected stream');
    assert(_.isNumber(player.streamingIndex), 'player missing streamingIndex');

    DEBUG && console.log('Playback stream selection');

    var result = new SelectionResult(selectedStreamIndex),
        startPts = player.buffer.startPts,                  // global start PTS
        currentPts = player.buffer.currentPts,              // global
        streamingPts = player.buffer.streamingPts,          // global
        completePts = player.buffer.completePts,            // global
        streamingIndex = player.streamingIndex,
        bufferLevel = completePts - currentPts,
        bufferedFragments = player.buffer.fragments,
        fragments,
        fragmentsCount = bufferedFragments.length + config.maxSimuLength / 2000,
        freeBytes,
        heuristicState = this._heuristicState || Enums.HEURISTIC_STATE.STARTING,
        minAcceptableBitrate = this._minAcceptableBitrate,
        selectedStream = streams[selectedStreamIndex],
        nextStreamIndex,
        nextStream,

        i,
        offset,
        fragment,
        feasible,
        self = this,
        desiredStreamHeaders = {},
        secondStreamIndex,
        skipBackMs = config.maxTrailingBufferLen,   // XXX Needs to depend also on whether skip-back enabled
        highStreamRetentionBlocks = ( config.highStreamRetentionWindow / player.averageFragmentDuration ) | 0,
        highStreamTransitionBlocks = ( config.highStreamTransitionWindow / player.averageFragmentDuration ) | 0,
        maxSimulationBlocks = ( config.maxSimuLength / player.averageFragmentDuration ) | 0,
        lowestWatermarkLevel = config.lowestWaterMarkLevel ? config.lowestWaterMarkLevel : 1000,
        responseTime,
        continueStream,
        currentStreamInfeasible = false; // is the current stream marked as infeasible by the simulation

    // Currently selected stream is no longer usable, we have to search for
    // another one starting with lower bitrates
    if (!isStreamUsable(selectedStream)) {
        DEBUG && console.log('Selected stream is no longer usable');
        selectedStreamIndex = firstAvailableStream(streams, selectedStreamIndex);
        if (selectedStreamIndex < 0) {
            return null;
        }
        selectedStream = streams[selectedStreamIndex];
        result.selectedStreamIndex = selectedStreamIndex;
    }

    // Ask for headers if we need them
    if ( !selectedStream.fragments || !selectedStream.fragments.length ) {
        desiredStreamHeaders[ selectedStreamIndex ] = true;
    }

    // Figure out our minimumAcceptableRate
    minAcceptableBitrate = this._minAcceptableBitrate;
    if (!minAcceptableBitrate) {
        this._minAcceptableBitrate = Math.min(selectedStream.bitrate, config.minAcceptableVideoBitrate);
        minAcceptableBitrate = this._minAcceptableBitrate;
        DEBUG && console.log('Min acceptable bitrate set to ' + minAcceptableBitrate + ' Kbps');
    }

    // Make a decision for the unstable case
    if (heuristicState == Enums.HEURISTIC_STATE.UNSTABLE) {
        DEBUG && console.log('Heuristic state is UNSTABLE');
        selectedStreamIndex = firstAvailableStream(streams, null, function(stream, index) {
            if (stream.bitrate < minAcceptableBitrate) {
                DEBUG && console.log('  Below minimum acceptable bitrate of ' + minAcceptableBitrate + ' Kbps');
                return false;
            }
            return true;
        });
        if (selectedStreamIndex < 0) {
            DEBUG && console.log('No stream is available above min acceptable bitrate, choosing highest available');
            selectedStreamIndex = firstAvailableStream(streams, streams.length);
        }
        if (selectedStreamIndex < 0) {
            return null;
        }

        // XXX Looks like we do not return the desired stream headers in this case
        //     when it is possible that a stream became unavailable and we need the
        //     headers for that stream
        result.selectedStreamIndex = selectedStreamIndex;
        result.continueStream = true;         // we will likely continue with this stream
        return result;
    }

    // Phase II for multiple bitrate upswitch

    // Construct the ArrayBuffer we will use for simulations
    freeBytes = player.buffer.capacity;
    fragments = new DataView( new ArrayBuffer( fragmentsCount * 16 ) );

    for( i = 0; i < bufferedFragments.length; ++i ) {

        offset = i * 16;

        fragment = bufferedFragments[ i ];
        fragments.setUint32( offset, fragment.bytes );
        //fragments.setUint32( offset + 4, fragment.startPts );
        fragments.setUint16( offset + 14, fragment.duration );

        freeBytes -= fragment.bytes;
    }

    if (config.skipBitrateInUpswitch && bufferLevel > config.watermarkLevelForSkipStart) {
        DEBUG && console.log('Can skip bitrates in upswitch, but not yet implemented, carrying on');
    }

    // See if the currently selected stream is feasible
    if ( getStreamThroughput(selectedStream) >= selectedStream.bitrate * config.fastUpswitchFactor ) {
        DEBUG && console.log('Selected stream feasible based on high throughput (' + getStreamThroughput(selectedStream) + 'kbps vs bitrate ' + selectedStream.bitrate+ 'kbps)');
        feasible = { result: true };
        continueStream = isHighestBitrate( streams, selectedStream );
    } else {

        for (secondStreamIndex = selectedStreamIndex - 1; secondStreamIndex >= 0; --secondStreamIndex) {
            if (isStreamUsable(streams[secondStreamIndex]))
                break;
        }

        feasible = isFeasible(  config,
                                selectedStream,
                                streams[ secondStreamIndex >= 0 ? secondStreamIndex : selectedStreamIndex ],
                                fragments,
                                currentPts - startPts,
                                skipBackMs,
                                completePts - startPts,
                                streamingPts - startPts,
                                streamingIndex,
                                bufferedFragments.length,
                                player.buffer.partialBytes,
                                freeBytes,
                                highStreamRetentionBlocks,
                                maxSimulationBlocks - highStreamRetentionBlocks,
                                lowestWatermarkLevel,
                                player.drainingBytes,
                                player.looping);
    }

    if (feasible && feasible.result) {

        result.lowestSimulatedBufferLevel = feasible.lowestBufferLevel;

        // Only do this if we're not already at the highest stream
        if (selectedStreamIndex + 1 < streams.length) {

            if ( bufferLevel > config.lowestBufForUpswitch ) {

                var upswitchallowed = false;

                if ( _.isUndefined( this.lastDownswitchPts ) || ( this.lastUpswitchPts > this.lastDownswitchPts ) ) {
                    // never switched down or most recent switch was up
                    upswitchallowed = true;
                } else if ( ( streamingPts - this.lastDownswitchPts ) > config.lockPeriodAfterDownswitch ) {
                    // most recent was downswitch but it was past the lock period
                    upswitchallowed = ( bufferLevel > config.lowWatermarkLevel );
                }

                if ( upswitchallowed ) {

                    DEBUG && console.log( 'Upswitch allowed. lastDownswitchPts = ' + this.lastDownswitchPts + ', lastUpswitchPts = ' + this.lastUpswitchPts );
                    
                    var throughput = null;

                    for (nextStreamIndex = selectedStreamIndex + 1; nextStreamIndex < streams.length; ++nextStreamIndex) {
                        if (!isStreamUsable(streams[nextStreamIndex]))
                            continue;

                        nextStream = streams[ nextStreamIndex ];

                        if ( !nextStream.fragments || !nextStream.fragments.length ) {
                            desiredStreamHeaders[ nextStreamIndex ] = true;
                        }
                        
                        // If this stream has throughput <= a lower infeasible stream, skip it
                        var nextThroughput = getStreamThroughput(nextStream);
                        if ( !_.isNull( throughput ) && nextThroughput <= throughput ) {
                            continue;
                        }
                        
                        throughput = nextThroughput;

                        if ( throughput >= nextStream.bitrate * config.fastUpswitchFactor ) {
                            DEBUG && console.log('Upswitch feasible based on high throughput (' + getStreamThroughput(nextStream) + 'kbps vs bitrate ' + nextStream.bitrate+ 'kbps)');
                            
                            feasible = { result: true };
                            continueStream = isHighestBitrate( streams, nextStreamIndex );
                            
                        } else {
                        
                            responseTime = 0;
                            if ( config.considerConnectTime ) {
                                if ( !pipeline
                                    || nextStream.server !== selectedStream.server ) {
                                        responseTime = getStreamResponseTime( nextStream );
                                        DEBUG && console.log('Adding ' + responseTime + 'ms to upswitch simulation for response time' );
                                }
                            }

                            feasible = isFeasible(
                                        config,
                                        nextStream,
                                        selectedStream,
                                        fragments,
                                        currentPts + responseTime - startPts,
                                        skipBackMs,
                                        completePts - startPts,
                                        streamingPts - startPts,
                                        streamingIndex,
                                        bufferedFragments.length,
                                        player.buffer.partialBytes,
                                        freeBytes,
                                        highStreamTransitionBlocks,
                                        maxSimulationBlocks - highStreamTransitionBlocks,
                                        lowestWatermarkLevel,
                                        player.drainingBytes,
                                        player.looping );
                        }

                        if (feasible && feasible.result) {

                            DEBUG && console.log('Switching up to this one!');
                            result.selectedStreamIndex = nextStreamIndex;
                            result.lowestSimulatedBufferLevel = feasible.lowestBufferLevel;
                            break;
                        
                        } else if ( !config.skipBitrateInUpswitch || bufferLevel < config.watermarkLevelForSkipStart ) {
                        
                            DEBUG && console.log('Skip bitrate for upswitch disabled or buffer level too low');
                            break;
                        }
                    }
                    
                    if ( nextStreamIndex >= streams.length && result.selectedStreamIndex === selectedStreamIndex ) {
                        DEBUG && console.log( 'No higher stream available / feasible' );
                    }
                } else {
                    DEBUG && console.log( 'Upswitch not allowed. lastDownswitchPts = ' + this.lastDownswitchPts + ', lastUpswitchPts = ' + this.lastUpswitchPts );
                }
            } else {
                DEBUG && console.log( 'Buffer level of ' + bufferLevel + 'ms is below threshold for upswitch of ' + config.lowestBufForUpswitch );
            }
        }
    } else {
        // If it came out infeasible because it did not have fragments, we'll stay on it
        if (!selectedStream.fragments || !selectedStream.fragments.length) {
            DEBUG && console.log(' +FEASIBLE: Forcing it to be feasible because we have no fragments');
        } else {
            // The current stream came out infeasible, so look at lower ones.
            DEBUG && console.log('Current stream is not feasible, looking at feasibility of lower bitrate streams');
            currentStreamInfeasible = true;

            var lowestAvailable = selectedStreamIndex,
                oneFeasible = false;
            for (nextStreamIndex = selectedStreamIndex - 1; nextStreamIndex >= 0; --nextStreamIndex) {

                nextStream = streams[ nextStreamIndex ];

                if ( isStreamUsable( nextStream ) ) {

                    for (secondStreamIndex = nextStream - 1; secondStreamIndex >= 0; --secondStreamIndex) {
                        if (isStreamUsable(streams[secondStreamIndex]))
                            break;
                    }
                    
                    responseTime = 0;
                    if ( config.considerConnectTime ) {
                        if ( !pipeline
                            || nextStream.server !== selectedStream.server ) {
                                responseTime = getStreamResponseTime( nextStream );
                                DEBUG && console.log('Adding ' + responseTime + 'ms to downswitch simulation for response time' );
                        }
                    }

                    feasible = isFeasible(
                                config,
                                nextStream,
                                secondStreamIndex >= 0 ? streams[ secondStreamIndex ] : nextStream,
                                fragments,
                                currentPts + responseTime - startPts,
                                skipBackMs,
                                completePts - startPts,
                                streamingPts - startPts,
                                streamingIndex,
                                bufferedFragments.length,
                                player.buffer.partialBytes,
                                freeBytes,
                                highStreamTransitionBlocks,
                                maxSimulationBlocks - highStreamTransitionBlocks,
                                lowestWatermarkLevel,
                                player.drainingBytes,
                                player.looping );

                    if (feasible && feasible.result) {

                        result.selectedStreamIndex = nextStreamIndex;
                        result.lowestSimulatedBufferLevel = feasible.lowestBufferLevel;
                        oneFeasible = true;
                        break;
                    }

                    lowestAvailable = nextStreamIndex;
                }
            }

            if (!oneFeasible) {
                DEBUG && console.log('No lower bitrate streams are feasible');
                if (lowestAvailable === selectedStreamIndex) {
                    DEBUG && console.log('And no lower bitrate streams are available');
                } else {
                    DEBUG && console.log('Switching to lowest available stream');
                    result.selectedStreamIndex = lowestAvailable;
                    result.lowestSimulatedBufferLevel = 0;
                }
            }
        }
    }

    // If we want to have headers to simulate, add the stream ids to the result
    desiredStreamHeaders = Object.keys(desiredStreamHeaders);
    if (desiredStreamHeaders.length) {
        result.desiredStreamHeaders = desiredStreamHeaders.map(function(key) {
            return parseInt(key, 10);
        });
    }
    
    result.continueStream = ( continueStream !== false );

    // signal to the ase manager that the current stream is not feasible anymore
    result.currentStreamInfeasible = (currentStreamInfeasible !== false);

    return result;
}

//=========================================================================
// Optimized simulation function
// fragments - DataView of fragments information
//  Fragment Format:
//  [size] 4 bytes
//  [unused] 4 bytes (this is the stream-relative startPts)
//  [offset] 6 bytes
//  [duration] 2 bytes
// currentPts - the current PTS relative to the buffer start
// completePts - the start PTS of the first incomplete block relative to the buffer start
// skipBackMs - the skip back buffer duration
// partialBytes - number of unreceived bytes in committed blocks
// streamingPts - streaming pts relative to buffer start
// streamingIndex - index of next block to be selected
// firstCheckIndex - index of the block at which we can terminate if we maintained buffer level
// drainingBytes - min number of bytes to drain in buffer full state
// freeBytes - number of free bytes in the buffer
// throughput - kbit/s
// minBufferLevel - the level below which stream is infeasible
//
// Return true or false
function simulate( config, fragments, blocks, currentPts, completePts, skipBackMs, partialBytes, streamingPts, streamingIndex, firstCheckIndex, drainingBytes, freeBytes, throughput, minBufferLevel ) {

    if ( DEBUG ) {
        assert( _.isNumber( currentPts ), 'Missing current pts' );
        assert( _.isNumber( completePts ), 'Missing complete pts' );
        assert( _.isNumber( skipBackMs ), 'Missing skip back ms' );
        assert( _.isNumber( partialBytes ), 'Missing partial bytes' );
        assert( _.isNumber( streamingIndex ), 'Missing stream index' );
        assert( streamingIndex >= 0, 'Streaming index < 0' );
        assert( _.isNumber( drainingBytes ), 'Missing draining bytes' );
        assert( _.isNumber( freeBytes ), 'Missing free bytes' );
        assert( _.isNumber( throughput ), 'Missing throughput' );
        assert( throughput > 0, 'Thoughput not greater than zero' );
        assert( _.isNumber( minBufferLevel ), 'Missing min buffer level' );
    }

    var fragmentsLength = Math.min( fragments.byteLength, blocks * 16 ),  // size of fragments array
        fragmentOffset,                                         // offset of current streaming fragment
        firstCheckOffset,                                       // offset at which to perform buffer level check
        fragmentSize,                                           // size of current streaming fragment
        fragmentDuration,                                       // duration of current streaming fragment
        initialBufferLevel = completePts - currentPts,          // original buffer level
        bufferLevel,                                            // current buffer level
        lowestBufferLevel = Infinity,                           // lowest buffer level
        lastBufferLevel = 0,                                    // last buffer level
        drainAmount,                                            // amount to drain before more streaming
        evictionOffset = 0,                                     // offset of next block to evict
        evictionDur = fragments.getUint16( 14 ),                // duration of next block to evict
        evictionPts = evictionDur + skipBackMs,                 // currentPts value where next eviction happens
        partialMs = ( ( partialBytes * 8 ) / throughput ) | 0,  // time to download partial blocks
        throughputKbytes = ( throughput / 8 ) | 0;

    DEBUG && assert( streamingIndex < fragmentsLength / 16, 'Streaming index greater than number of fragments' );

    DEBUG && console.log(   "   simulate: " +
                            "currentPts: " + currentPts + "ms, " +
                            "completePts: " + completePts + "ms, " +
                            "partialMs: " + partialMs + "ms, " +
                            "streamingPts: " + streamingPts + "ms, " +
                            "initialBufferLevel: " + initialBufferLevel + "ms, " +
                            "freeBytes:" + freeBytes +
                            "streamingIndex: " + streamingIndex );

    currentPts += partialMs;

    if ( currentPts > completePts ) {
        return { result : false, lowestBufferLevel: 0 };
    }

    fragmentOffset = streamingIndex * 16;
    firstCheckOffset = firstCheckIndex * 16;

    while( fragmentOffset < fragmentsLength ) {                                         // 1

        // Extract fragment information
        fragmentSize = fragments.getUint32( fragmentOffset );
        fragmentDuration = fragments.getUint16( fragmentOffset + 14 );

        // Deal with buffer full state
        if ( freeBytes < fragmentSize ) {                         // 3
            drainAmount = Math.max( fragmentSize, drainingBytes );
            while( freeBytes < drainAmount ) {
                currentPts = evictionPts;
                freeBytes += fragments.getUint32( evictionOffset );
                evictionOffset += 16;
                evictionDur = fragments.getUint16( evictionOffset + 14 );
                evictionPts += evictionDur;
                
            }
            
            bufferLevel = streamingPts - currentPts;

        } else {

            bufferLevel = streamingPts - currentPts;

            // Check the buffer level
            if ( bufferLevel < minBufferLevel && bufferLevel < lastBufferLevel )        // 5, 6
                return { result: false, lowestBufferLevel : Math.min( bufferLevel, lowestBufferLevel ) };
        }

        // Stream the next block
        currentPts += ( fragmentSize / throughputKbytes ) | 0;
        streamingPts += fragmentDuration;
        freeBytes -= fragmentSize;

        // Evict from the skipback buffer
        while( evictionPts < currentPts ) {                                             // 11
            freeBytes += fragments.getUint32( evictionOffset );                         // 12
            evictionOffset += 16;                                                       // 13
            evictionPts += fragments.getUint16( evictionOffset + 14 );                  // 14, 15
        }

        fragmentOffset += 16;                                                           // 16

        // Early termination of simulation if we maintain buffer level after firstCheckIndex
        if ( fragmentOffset >= firstCheckOffset && bufferLevel > initialBufferLevel )   // 17, 18
            break;
        
        lastBufferLevel = bufferLevel;
        lowestBufferLevel = Math.min( bufferLevel, lowestBufferLevel );                 // 19
    }

    return { result: true, lowestBufferLevel: lowestBufferLevel };
}

//=========================================================================
// Export functions

module.exports = {  'STARTING'          : config.initBitrateSelectorAlgorithm === 'simplified' ? selectStartingSimplified : selectStarting,
                    'BUFFERING'         : selectBuffering,
                    'REBUFFERING'       : selectBuffering,
                    'PLAYING'           : selectPlaying };



},{"103":103,"47":47,"48":48,"65":65}],71:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var Enums = require(48),

    common = require(65),
    console = common.console,
    DEBUG = ("debug" !== 'release'),
    SelectionResult = common.SelectionResult;

//====================================================================================

function selectStream(config, player, streams, selectedStreamIndex)
{
    DEBUG && console.log('Using "select RANDOMLY!" algorithm');

    var choices = streams.map(function(stream, index) {
        return (stream.isAvailable && stream.inRange && !stream.hasFailed) ? index : null;
    }).filter(function(index) {
        return index !== null;
    });

    if (!choices.length) {
        return null;
    }

    return new SelectionResult(choices[Math.floor(Math.random() * choices.length)]);
}

module.exports = {  'STARTING' :   selectStream,
                    'BUFFERING' :  selectStream,
                    'REBUFFERING' :  selectStream,
                    'PLAYING' :    selectStream   };

},{"48":48,"65":65}],72:[function(require,module,exports){
/*
 * (c) 1997-2014 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var _ = require(103),

    Enums = require(48),

    common = require(65),
    console = common.console,
    DEBUG = ("debug" !== 'release'),
    firstAvailableStream = common.firstAvailableStream,
    isStreamUsable = common.isStreamUsable,
    SelectionResult = common.SelectionResult;

//====================================================================================

function selectStream(config, player, streams, selectedStreamIndex)
{
    DEBUG && console.log('Using "select Round-Robin!" algorithm ' + selectedStreamIndex);

    var updatedIndex = this._lastSelectedIndex;
    var now = player.buffer.streamingPts;
    var choiceIndx;
    var forward = config.roundRobinDirection === 'forward';

    if (_.isUndefined(updatedIndex)) {
        if ( forward )
        {
            updatedIndex = firstAvailableStream(streams);
        }
        else
        {
            updatedIndex = firstAvailableStream(streams, streams.length);
        }
        this._lastSwitchTime = now;
        this._lastSelectedIndex = updatedIndex;
        return new SelectionResult(updatedIndex);
    }
    else
    {
        if (!isStreamUsable(streams[updatedIndex]))
        {
            updatedIndex = firstAvailableStream(streams, updatedIndex);
            this._lastSwitchTime = now;
            this._lastSelectedIndex = updatedIndex;
        }
        if ( updatedIndex < 0 )
            return null;

        DEBUG && console.log('streaming pts: ' + now + ', last switch time: ' + this._lastSwitchTime + ', ' + config.timeAtEachBitrateRoundRobin);
        if ( now > this._lastSwitchTime + config.timeAtEachBitrateRoundRobin )
        {
            var choices = streams.map(function(stream, index) {
                return (stream.isAvailable && stream.inRange && !stream.hasFailed) ? index : null;
            }).filter(function(index) {
                return index !== null;
            });

            if (!choices.length) {
                return null;
            }

            if ( forward )
            {
                choiceIndx = (choices.indexOf(updatedIndex) + 1) % choices.length;
            }
            else
            {
                choiceIndx = choices.indexOf(updatedIndex) - 1;
                if (choiceIndx < 0)
                {
                    choiceIndx = choices.length - 1;
                }
            }
            DEBUG && console.log('selected stream: ' + streams[choices[choiceIndx]].bitrate + ' kbps');
            this._lastSelectedIndex = choices[choiceIndx];
            this._lastSwitchTime = now;
            return new SelectionResult(choices[choiceIndx]);
        }
        else
        {
            return new SelectionResult(updatedIndex);
        }
    }
}

module.exports = {  'STARTING' :   selectStream,
                    'BUFFERING' :  selectStream,
                    'REBUFFERING' :  selectStream,
                    'PLAYING' :    selectStream   };


},{"103":103,"48":48,"65":65}],73:[function(require,module,exports){
/*
 * (c) 1997-2016 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var _ = require(103),
    Enums = require(48),
    common = require(65),
    platform = require(61),
    console = common.console,
    DEBUG = ("debug" !== 'release'),
    firstAvailableStream = common.firstAvailableStream,
    isStreamUsable = common.isStreamUsable,
    SelectionResult = common.SelectionResult;

//====================================================================================

var testSelectedBitrate = null;
var allStreams = null;
var usableStreams = null;

if (platform.cert){
    platform.cert.streamSelector = {
        init : function(){
            testSelectedBitrate = null;
            allStreams = null;
            usableStreams = null;
        },
        selectStream : function(kbps){
            testSelectedBitrate = kbps;
        },
        getStreamsInfo : function(){
            return {all:allStreams, usable:usableStreams};
        }
    };
}

function selectStream(config, player, streams, selectedStreamIndex)
{
    if (DEBUG){
        console.log('Using "Test Configurable!" algorithm ' + testSelectedBitrate);
    }
    allStreams = streams;

    //save off usbale stream for inspection by tests
    usableStreams = streams.map(function(stream, index) {
        return (stream.isAvailable && stream.inRange && !stream.hasFailed) ? index : null;
    }).filter(function(index) {
        return index !== null;
    });

    if (testSelectedBitrate === null){
        var firstIndex = firstAvailableStream(streams);
        testSelectedBitrate = streams[firstIndex].bitrate;
        return SelectionResult(firstIndex);
    }

    //nothing usable, return null
    if (!usableStreams.length){
        return null;
    }

    //get the desired from usables (too bad no array.find in gibbon yet)
    var desiredIndex = usableStreams.filter(function(streamIndex){
        return streams[streamIndex].bitrate == testSelectedBitrate;
    })[0];

    if (desiredIndex === undefined){
        console.log('Defaulting to first stream due to unvalid bitrate requested: '+testSelectedBitrate);
        return new SelectionResult(usableStreams[0]);
    }
    return new SelectionResult(desiredIndex);
}


module.exports = {  'STARTING' :   selectStream,
                    'BUFFERING' :  selectStream,
                    'REBUFFERING' :  selectStream,
                    'PLAYING' :    selectStream   };


},{"103":103,"48":48,"61":61,"65":65}],74:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_high");

var _ = require(103),

    mixin = require(95),
    EventEmitter = require(94).EventEmitter,

    config = require(47),
    Enums = require(48),

    common = require(65),
    platform = require(61),
    console = common.console,
    DEBUG = ("debug" !== 'release'),
    assert = common.assert,
    forEachReverse = common.forEachReverse,

    // List of needed stream selection functions
    selectorFunctions = [   Enums.PLAYER_STATE.name[ Enums.PLAYER_STATE.STARTING ],
                            Enums.PLAYER_STATE.name[ Enums.PLAYER_STATE.BUFFERING ],
                            Enums.PLAYER_STATE.name[ Enums.PLAYER_STATE.REBUFFERING ],
                            Enums.PLAYER_STATE.name[ Enums.PLAYER_STATE.PLAYING ],
                            "checkBuffering" ],

    // Give names to the available algorithms - each one can provide any or all of the needed functions
    selectorMap = { 'first'         : require(69),
                    'lowest'        : require(69),
                    'random'        : require(71),
                    'optimized'     : require(70),
                    'roundrobin'    : require(72),
                    'selectaudio'   : require(67),
                    'default'       : require(70),
                    'bufferbased'   : require(68),
                    'checkdefault'  : require(64),
                    'testscript'    : require(73) // This selector was created by Casten and is used for Security + Cert Tests on 3/3/16.
                     },

    // define the default algoithm for each of the needed functions
    defaultFunctions = {    'STARTING'          : 'default',
                            'BUFFERING'         : 'default',
                            'REBUFFERING'       : 'default',
                            'PLAYING'           : 'default',
                            'checkBuffering'    : 'checkdefault' };

//=============================================================================

function StreamSelector(events, errorDirector, selector ) {
    this.events = events || mixin(EventEmitter, {});
    this.errorDirector = errorDirector;

    // Selector may be a string or a map giving different selectors for the four cases
    selector = selector || config.streamSelectorAlgorithm;

    // Assign functions to the four members
    this.algorithms = selectorFunctions.reduce( ( function( algorithms, fn ) {

            // If individual algorithms are specified, use default for any that are missing
        var selectorName = _.isObject( selector ) ? ( selector[ fn ] || defaultFunctions[ fn ] ) : selector,
            // If an unknown algorithm is requested, use the default
            selectorAlg = selectorMap[ selectorName ] || selectorMap[ defaultFunctions[ fn ] ],
            // If the selected algorithm does not have a function for this case, use the default
            selectorFn = selectorAlg[ fn ] || selectorMap[ defaultFunctions[ fn ] ][ fn ];

        DEBUG && console.log( 'Using ' + ( selectorMap[ selectorName ] ? selectorName : 'default' ) + ' algorithm for ' + fn );

        algorithms[ fn ] = selectorFn.bind( this );

        return algorithms;

    } ).bind( this ), {} );

    // Rebuffering is always the same as buffering
    //this.algorithms[ Enums.PLAYER_STATE.name[ Enums.PLAYER_STATE.REBUFFERING ] ] = this.algorithms[ Enums.PLAYER_STATE.name[ Enums.PLAYER_STATE.BUFFERING ] ];

    if (selector === 'bufferbased') {
        if (events) {
            //if session has initialized, hook up the session player state event
            events.addEventListener('playerstatechanged', this.playerStateChangeHandler);
        }

        // Buffer-based buffering history (reset whenever player state changes)
        // these variables are used to smooth state transition to avoid sudden bitrate changes
        // EX: from starting/buffering to playing
        this._initialBufferLevel = undefined;
        this._initialTimestamp = undefined;
    }
}

StreamSelector.prototype.constructor = StreamSelector;

StreamSelector.prototype.selectStream = function selectStream(player, streams, unused, predictor, pipeline, maxPreBuffer )
{
    var result,
        selected,
        buffer = player && player.buffer,
        statistics,
        playerState = player && player.state,
        throughput;

    // The "current stream" is equal to the stream of the last fragment in the fragments list,
    // calculated below, or the last stream selection decision if there are no fragments yet.

    var selectedStreamIndex = this._lastSelectedStreamIndex;

    //--------------------------------------------------------------------------
    // NRDJS-4098
    // If there is a _lastSelectedStreamIndex and this selector is going back
    // to the STARTING state, it should be forgotten, because this could be
    // a track change and the old index may not be valid for the new list.

    if (_.isNumber(selectedStreamIndex) && player && player.state === Enums.PLAYER_STATE.STARTING) {
        console.warn("Resetting last selected stream index");
        delete this._lastSelectedStreamIndex;
        selectedStreamIndex = undefined;
    }

    // Another check to ensure it is within range

    if (_.isNumber(selectedStreamIndex) && selectedStreamIndex >= streams.length) {
        console.warn("Last selected stream index is out of range :",
            selectedStreamIndex, ">=", streams.length, "resetting it");
        delete this._lastSelectedStreamIndex;
        selectedStreamIndex = undefined;
    }

    //--------------------------------------------------------------------------

    if ( DEBUG ) {

        assert(_.isObject(player), 'Player is not an object');
        assert(!_.isUndefined(Enums.PLAYER_STATE.name[player.state]), 'Invalid player state ' + player.state);

        assert(buffer, 'Missing player.buffer');
        assert(buffer.capacity > 0, 'Buffer capacity must be > 0');
        assert(_.isNumber(buffer.startPts), 'Buffer missing startPts');         // absolute since streaming start
        assert(_.isNumber(buffer.currentPts), 'Buffer missing currentPts');     // absolute since streaming start
        assert(_.isNumber(buffer.completePts), 'Buffer missing completePts');   // absolute since streaming start
        assert(_.isNumber(buffer.streamingPts), 'Buffer missing streamingPts'); // absolute since streaming start

        assert(_.isArray(buffer.fragments), 'Buffer missing fragments');

        assert(_.isArray(streams), 'Stream list is not an array');
        assert(streams.length > 0, 'Stream list is empty');
        streams.forEach(function(stream){
            assert(_.isString(stream.id), 'Stream missing id');
            assert(_.isNumber(stream.startPts), 'Stream missing startPts');
            assert(_.isNumber(stream.bitrate), 'Stream missing bitrate');
            assert(_.isBoolean(stream.isAvailable), 'Stream missing isAvailable');
            assert(_.isBoolean(stream.inRange), 'Stream missing inRange');
        });

        assert(_.isUndefined(selectedStreamIndex) ||
            (_.isNumber(selectedStreamIndex) &&
                selectedStreamIndex >= 0 &&
                selectedStreamIndex < streams.length), 'Invalid selected stream index ' + selectedStreamIndex);
    }

    var fragments = buffer.fragments,
        fragmentCount = fragments.length;

    DEBUG && console.log('==================================================================================');

    DEBUG && console.log('Selecting stream' +
        ' : state = ' + Enums.PLAYER_STATE.name[player.state] +
        ' : stream list length = ' + streams.length +
        ' : current bitrate = ' + ((fragmentCount > 0) ? fragments[ fragmentCount - 1 ].bitrate
                                    : ( this._lastSelectedStreamIndex ? streams[ this._lastSelectedStreamIndex ].bitrate : 'none' ) ) +
        ' : streaming index = ' + player.streamingIndex );

    buffer = player.buffer;

    DEBUG && console.log('  Buffer' +
        ' : capacity = ' + buffer.capacity +
        ' : startPts = ' + buffer.startPts +
        ' : currentPts = ' + buffer.currentPts +
        ' : completePts = ' + buffer.completePts +
        ' : streamingPts = ' + buffer.streamingPts +
        ' : level = ' + player.bufferLevelMs || (buffer.completePts - buffer.currentPts) +
        ' : partial bytes = ' + buffer.partialBytes +
        ' : fragment count = ' + buffer.fragments.length);

    DEBUG   && this.lastDownswitchPts
            && ( !this.lastUpswitchPts || this.lastDownswitchPts > this.lastUpswitchPts )
            && console.log( '  Last switch was DOWN, ' + ( buffer.streamingPts - this.lastDownswitchPts ) + 'ms ago' );

    DEBUG   && this.lastUpswitchPts
            && ( !this.lastDownswitchPts || this.lastDownswitchPts < this.lastUpswitchPts )
            && console.log( '  Last switch was UP, ' + ( buffer.streamingPts - this.lastUpswitchPts ) + 'ms ago' );

    forEachReverse(streams, function( stream , index ) {

        if ( fragmentCount > 0 && stream.id === fragments[ fragmentCount - 1 ].streamId ) {
            selectedStreamIndex = index;
        }

        if (stream.isAvailable && stream.inRange && !stream.hasFailed && stream.statistics && stream.statistics.confidence) {

            // predictor may be expensive, so we cache the result here
            // this will not work if the streams are on a variety of locations and
            // are not sorted by location
            if ( statistics !== stream.statistics ) {
                statistics = stream.statistics;
                throughput = Math.floor(predictor( stream.statistics , player.buffer ));
                // avoid the scenario where throughput is floored to zero
                throughput = throughput === 0 ? 1 : throughput;
            }

            stream.throughput = throughput;
            DEBUG && assert(_.isNumber(stream.throughput));
        } else {
            delete stream.throughput;
        }

        DEBUG && console.trace(
            (index == selectedStreamIndex ? '>>' : '  ') +
            '[' + index + '] ' +
            stream.id +
            ' b(' + stream.bitrate + ')' +
            ' avail(' + stream.isAvailable + ')' +
            ' failed(' + (!!stream.hasFailed) + ')' +
            ' inrange(' + (!!stream.inRange) + ')' +
            ' loc(' + stream.location + ')' +
            ' tp(' + stream.throughput + ')'
        );
    });

    DEBUG && console.log(' selected stream index: ' + selectedStreamIndex );

    // The "current stream"
    if ( _.isUndefined( selectedStreamIndex ) ) {
        selectedStreamIndex = this._lastSelectedStreamIndex;
    }

    if ( playerState === Enums.PLAYER_STATE.STARTING && _.isNumber(selectedStreamIndex) )
    {
        // this handles the case that the manager has already had cached date
        playerState = Enums.PLAYER_STATE.BUFFERING;
    }

    //=========================================================================
    // Make sure the player state is valid

    switch (player.state) {
        case Enums.PLAYER_STATE.STARTING:
            delete this.lastDownswitchPts;
            delete this.lastUpswitchPts;

            this._bufferBasedState = Enums.BUFFER_BASED_STATE.STARTUP;
            this._heuristicState = Enums.HEURISTIC_STATE.STARTING;
            break;
        case Enums.PLAYER_STATE.BUFFERING:
        case Enums.PLAYER_STATE.REBUFFERING:
            this._heuristicState = Enums.HEURISTIC_STATE.STARTING;
            break;

        case Enums.PLAYER_STATE.PLAYING:
            break;
        default:
            console.error("Stream selector called with invalid player state " +
                Enums.PLAYER_STATE.name[player.state]);
            return null;
    }

    //=========================================================================
    // Update the heuristics state

    if ( player.state === Enums.PLAYER_STATE.PLAYING ) {

        var bufferLevel = player.bufferLevelMs || (buffer.completePts - buffer.currentPts);

        DEBUG && console.log('Buffer level is ' + bufferLevel + ' ms, heuristic state is ' + Enums.HEURISTIC_STATE.name[ this._heuristicState ] );

        if (this._heuristicState !== Enums.HEURISTIC_STATE.STABLE && bufferLevel >= config.toStableThreshold) {
            DEBUG && console.log('Heuristic state is now STABLE, buffer level = ' + bufferLevel + ' ms');
            this._heuristicState = Enums.HEURISTIC_STATE.STABLE;
        } else if (this._heuristicState === Enums.HEURISTIC_STATE.STABLE && bufferLevel < config.toUnstableThreshold) {
            DEBUG && console.log('Heuristic state is UNSTABLE, buffer level = ' + bufferLevel + ' ms');
            this._heuristicState = Enums.HEURISTIC_STATE.UNSTABLE;
        }
    }

    //=========================================================================

    result = this.algorithms[ Enums.PLAYER_STATE.name[ playerState ] ].call(this, config, player, streams, selectedStreamIndex, predictor, pipeline);

    //=========================================================================

    DEBUG && console.log('Stream selection result is : ' + JSON.stringify(result));

    DEBUG && assert(_.isObject(result), 'Result is not an object');

    if (!result || result.selectedStreamIndex === null) {
        console.warn('Stream selection failed to find any stream, this could be due to incorrect bitrate ranges.');
        return null;
    }

    if ( DEBUG ) {
        assert(_.isNumber(result.selectedStreamIndex), 'Result selected stream index is not a number');
        assert(result.selectedStreamIndex >= 0 && result.selectedStreamIndex < streams.length, 'Resulting stream index is not in bounds');
        assert(_.isNumber(result.requiredBufferingLengthMs), 'Result required buffering length is not a number');
        assert(_.isNumber(result.numberOfPredictedRebuffers), 'Result number of predicted rebuffers is not a number');
    }

    this._lastSelectedStreamIndex = result.selectedStreamIndex;

    selected = streams[result.selectedStreamIndex];

    DEBUG && console.log('> And the winner is... [' + result.selectedStreamIndex + '] ' + selected.id
                            + ' (' + selected.bitrate + ' Kbps)'
                            + ' lowest buffer level ' + result.lowestSimulatedBufferLevel + 'ms' );

    if (!_.isNumber(selectedStreamIndex)) {
        console.log(
            'INITIAL STREAM' +
            ' [' + result.selectedStreamIndex + '] ' +
            selected.id +
            ' (' + selected.bitrate + ' Kbps)');
    } else {

        if ( selected.bitrate < streams[selectedStreamIndex].bitrate ) {
            this.lastDownswitchPts = buffer.streamingPts;
        }

    }

    if (player.state != Enums.PLAYER_STATE.PLAYING) {
        var cbc = this.checkBufferingComplete(player, selected, maxPreBuffer);
        result.bufferingComplete = cbc.complete;
        if (cbc.complete) {
            result.reason = cbc.reason;
            console.warn('BUFFERING COMPLETE' +
                ' BL(' + ( player.buffer.completePts - player.buffer.currentPts ) + ') ' +
                ' FC(' + (fragmentCount) + ') '
            );
        } else {
            DEBUG && console.trace('BUFFERING INCOMPLETE: ' + JSON.stringify( cbc ) );
            result.bufferingComplete = false;
            result.requiredBuffer = cbc.requiredBuffer;
            result.lowThroughput = cbc.lowThroughput;
            result.progress = cbc.progress;
        }
    } else {
        result.bufferingComplete = true;
    }

    return result;
};

//=============================================================================

StreamSelector.prototype.checkBufferingComplete = function checkBufferingComplete(player, stream, maxPreBuffer) {

    // returns { complete : boolean, optional requiredBuffer: ms, optional lowThroughput: boolean, optional progress: double }
    return this.algorithms["checkBuffering"].call( this, player, stream, maxPreBuffer );
};

//=============================================================================

StreamSelector.prototype.streamSelected = function streamSelected( pts, oldStream, newStream ) {

    DEBUG && console.log( 'StreamSelector notified of stream selected ' + newStream.bitrate + 'kbit/s at ' + pts + 'ms' );

    var rateSwitch,
        locationSwitch;

    if ( !_.isUndefined(oldStream) ) {
        if ( oldStream.bitrate < newStream.bitrate ) {
            this.lastUpswitchPts = pts;
            rateSwitch = true;
        } else if ( oldStream.bitrate > newStream.bitrate ) {
            rateSwitch = true;
        }

        locationSwitch = (oldStream.location !== newStream.location);

        DEBUG && (rateSwitch || locationSwitch) &&
            console.log("STREAM SWITCH AT " + pts + ": " +
                oldStream.bitrate + " [" + oldStream.location + "]" +
                " -> " +
                newStream.bitrate + " [" + newStream.location + "]");
    } else {
        delete this.lastUpswitchPts;
        delete this.lastDownswitchPts;
    }
};

StreamSelector.prototype.playerStateChangeHandler = function playerStateChangeHandler(args){
    var oldState = args.oldValue,
        newState = args.newValue;

    if (oldState !== newState &&
        (newState === Enums.PLAYER_STATE.PLAYING || newState === Enums.PLAYER_STATE.BUFFERING)){
        //reset the buffer history
        this._initialBufferLevel = undefined;
        this._initialTimestamp = undefined;

        //reset the state to startup
        this._bufferBasedState = Enums.BUFFER_BASED_STATE.STARTUP;
    }
};

//=============================================================================

module.exports = StreamSelector;

},{"103":103,"47":47,"48":48,"61":61,"64":64,"65":65,"67":67,"68":68,"69":69,"70":70,"71":71,"72":72,"73":73,"94":94,"95":95}],75:[function(require,module,exports){
var ObservableProperty$counter = 0;
/** @const */
var ORDERPROPERTY = '$ASE$order';
/** @const */
var ORDERPROPERTY$early = -1;
/** @const */
var ORDERPROPERTY$late = 1;


/**
* @constructor
* @param {*=} defaultValue
* @param {function(Object=)=} handler1
*/
function ObservableProperty(defaultValue, handler1) {
    var mixIn = require(95);
    var _self = this,
        _handlers = handler1 ? [handler1] : [],
        _id = '$op$' + (ObservableProperty$counter++);

    mixIn(
    /** @lends {ObservableProperty.prototype} */
    {
        value: defaultValue,

        addListener: _addListener,
        removeListener: _removeListener,
        set: _set
    }, _self);

    // --------------------------------------------------------------------------------
    // -- private implementation

    /**
    * @param {number=} order
    */
    function _addListener(handler, order) {
        //debug$assertFunction(handler);
        //debug$assert(_handlers.indexOf(handler) < 0);

        // duplicate before modifying, so if add/remove can work properly when called from handlers
        handler[ORDERPROPERTY + _id] = order;
        _handlers = _handlers.slice();
        _handlers.push(handler);
        _handlers.sort(sortByOrderProperty);
    }

    function _removeListener(handler) {
        //debug$assertFunction(handler);

        // duplicate before modifying, so if add/remove can work properly when called from handlers
        _handlers = _handlers.slice();
        var index;
        if ((index = _handlers.indexOf(handler)) >= 0) {
            _handlers.splice(index, 1);
        }
    }

    /**
    * @param {*} newValue
    * @param {Object=} customArgs
    */
    function _set(newValue, customArgs) {
        if (_self.value === newValue)
            return;

        var args = {
            oldValue: _self.value,
            newValue: newValue
        };

        customArgs && mixIn(customArgs, args);

        _self.value = newValue;

        // copy the variable so add and remove can modify it
        var handlers = _handlers,
            length = handlers.length;
        for (var i = 0; i < length; i++) {
            handlers[i](args);
        }
    }

    function sortByOrderProperty(a, b) {
        return (a[ORDERPROPERTY + _id] || 0) - (b[ORDERPROPERTY + _id] || 0);
    }
}

module.exports = ObservableProperty;
},{"95":95}],76:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_high");

var Bucketizer = require(78),
    Discontiguous = require(80);


/**
* @constructor
*/
function BucketHoltWinters( alpha_ms, gamma_ms, window_ms, bucket_ms )
{
    Bucketizer.call( this, window_ms, bucket_ms, false );

    this.alpha_ms = alpha_ms;
    this.gamma_ms = gamma_ms;

    this.alpha = 1 - Math.pow( 0.5, 1.0 / ( alpha_ms / bucket_ms ) ),
    this.gamma = 1 - Math.pow( 0.5, 1.0 / ( gamma_ms / bucket_ms ) );

    this.stationary = null;
    this.trend = null;
}

BucketHoltWinters.prototype = Object.create( Bucketizer.prototype );

//We will do our calculations only when ata gets shifted out of the buffer
BucketHoltWinters.prototype.shift = function shift()
{
    if ( this._buckets.length > 2 )
    {
        if ( this.stationary === null )
        {
            this.stationary = this._buckets[ 1 ];
            this.trend = this._buckets[ 1 ] - this._buckets[ 0];

            Bucketizer.prototype.shift.call( this );
        }
        else
        {
            var stationary = this.alpha * this._buckets[0] +
                            (1.0 - this.alpha) * ( this.stationary + this.trend );

            this.trend = this.gamma * (stationary - this.stationary) +
                            (1.0 - this.gamma) * this.trend;

            this.stationary = stationary;
        }

        Bucketizer.prototype.shift.call( this );
    }
};

BucketHoltWinters.prototype.get = function get()
{
    var stationary, trend;
    if ( this.stationary === null )
    {
        if ( this._buckets.length === 0 )
        {
            stationary = 0;
            trend = 0;
        }
        else if ( this._buckets.length === 1 || this._buckets.length === 2 )
        {
            stationary = this._buckets[ 0 ];
            trend = 0;
        }
        else
        {
            stationary = this._buckets[ this._buckets.length - 2 ];
            trend = this._buckets[ this._buckets.length - 2 ] - this._buckets[ this._buckets.length - 3 ];
        }
    }
    else
    {
        stationary = this.stationary;
        trend = this.trend;

        for( var i = 0; i < this._buckets.length - 1; ++i )
        {
            var stemp = this.alpha * this._buckets[ i ] + ( 1.0 - this.alpha ) * ( stationary + trend );
            trend = this.gamma * ( stemp - stationary ) + ( 1.0 - this.gamma ) * trend;
            stationary = stemp;
        }
    }

    return {  average : Math.max( Math.floor( ( stationary + trend ) * 8 / this._bucket_ms ), 0 ),
              stationary : Math.floor( stationary * 8 / this._bucket_ms ),
              trend: Math.floor( trend * 8 / this._bucket_ms ),
              thisstationary : Math.floor( this.stationary * 8 / this._bucket_ms ),
              thistrend : Math.floor( this.trend * 8 / this._bucket_ms ),
              buckets: this._buckets.map( function( b ) { return Math.floor( ( b * 8 / this._bucket_ms ) ); }.bind( this ) ) };
};

BucketHoltWinters.prototype.reset = function reset() {

    Bucketizer.prototype.reset.call( this );

    this.stationary = null;
    this.trend = null;
};

BucketHoltWinters.prototype.toString = function() {
    return 'bhw(' + this.alpha_ms + ',' + this.gamma_ms + ',' + this._window_ms + ',' + this._bucket_ms + ')';
};

function DiscontiguousBucketHoltWinters( alpha_ms, gamma_ms, window_ms, bucket_ms )
{
    Discontiguous.call( this, new BucketHoltWinters( alpha_ms, gamma_ms, window_ms, bucket_ms ) );
}

DiscontiguousBucketHoltWinters.prototype = Object.create( Discontiguous.prototype );

DiscontiguousBucketHoltWinters.prototype.setInterval = function setInterval( interval ) {};

module.exports = DiscontiguousBucketHoltWinters;

},{"78":78,"80":80}],77:[function(require,module,exports){
/*
 * (c) 2016 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

var Bucketizer = require(78),    
    PercentileCalculator = require(85);

/**
* @constructor
*/
function BucketInterQuartileRange( maxIQRSamples, window_ms, bucket_ms, real_time ) {

    Bucketizer.call( this, window_ms, bucket_ms, real_time );
    this._iqrCalculator = new PercentileCalculator(maxIQRSamples);
}

BucketInterQuartileRange.prototype = Object.create( Bucketizer.prototype );

BucketInterQuartileRange.prototype.shift = function shift() {
    var shifted = this._buckets.shift();
    this._offsets.shift();
    if ( shifted > 0 ){
        this._iqrCalculator.addSample(shifted);
    }
};

BucketInterQuartileRange.prototype.getNormalizedIQR = function getNormalizedIQR() {
    if ( !this._iqrCalculator.getSampleSize() ){
        //we don't have any sample yet
        return;
    }

    var p25 = this._iqrCalculator.calculatePercentile(25),
        p50 = this._iqrCalculator.calculatePercentile(50),
        p75 = this._iqrCalculator.calculatePercentile(75);

    return (p75 - p25) / p50;
};

BucketInterQuartileRange.prototype.getSampleSize = function getSampleSize(){
    return this._iqrCalculator.getSampleSize();
};

BucketInterQuartileRange.prototype.getPercentiles = function getPercentiles() {
    if ( !this._iqrCalculator.getSampleSize() ){
        //we don't have any sample yet
        return {p25: undefined,
                p50: undefined,
                p75: undefined};
    }

    return {p25: this._iqrCalculator.calculatePercentile(25),
            p50: this._iqrCalculator.calculatePercentile(50),
            p75: this._iqrCalculator.calculatePercentile(75)};
};

BucketInterQuartileRange.prototype.toString = function() {
    return 'biqr(' + this._window_ms + ',' + this._bucket_ms + ',' + this._window + ')';
};

module.exports = BucketInterQuartileRange;
},{"78":78,"85":85}],78:[function(require,module,exports){
/*
 * (c) 2016 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

/**
* @constructor
*/
function Bucketizer( window_ms, bucket_ms, real_time ) {

    //DEBUG && console.log( "Bucketizer( " + window_ms + "," + bucket_ms + "," + real_time + ")" );

    this._window_ms = window_ms;
    this._window = Math.floor( ( window_ms + bucket_ms - 1 ) / bucket_ms );
    this._bucket_ms = bucket_ms;

    this._real_time = real_time;

    this.reset();
}

Bucketizer.prototype.shift = function shift()
{
    this._buckets.shift();
    this._offsets.shift();
};

Bucketizer.prototype.update = function update( bucket, bytes )
{
    this._buckets[ bucket ] += bytes;
};

Bucketizer.prototype.push = function push( offset )
{
    this._buckets.push( 0 );
    this._offsets.push( offset ? offset : 0 );
    this._time += this._bucket_ms;
};

Bucketizer.prototype.add = function add( b, s, e, o ) {

    var i;

    if ( this._time === null ) {
        var buckets = Math.max( Math.floor( ( ( e - s ) + this._bucket_ms - 1 ) / this._bucket_ms ), 1 );

        this._time = s;

        while( this._buckets.length < buckets ) {
            this.push( o );
        }
    }

    while( this._time < e ) {
        this.push( o );

        if ( !this._real_time ) {
            if( this._buckets.length > this._window ) {
                this.shift();
            }
        } else {
            while( this._buckets.length > 1 && ( e + o ) - ( this._time - this._bucket_ms * this._buckets.length + this._offsets[ 0 ] ) > this._window_ms ) {
                this.shift();
            }
        }
    }

    if ( s > this._time - this._bucket_ms ) {

        this.update( this._buckets.length - 1, b );

    } else if ( s == e ) {

        i = this._buckets.length - Math.max( Math.ceil( ( this._time - e ) / this._bucket_ms ), 1 );
        if ( i >= 0 ) {
            this.update( i, b );
        }

    } else {

        for( i = 1; i <= this._buckets.length; ++i ) {
            var bs = this._time - i * this._bucket_ms,
              be = bs + this._bucket_ms;

            if ( bs > e ) continue;
            if ( be < s ) break;

            var overlap = Math.min( be, e ) - Math.max( bs, s );

            this.update( this._buckets.length - i, Math.round( b * overlap / ( e - s ) ) );
        }

    }

    var oldlength = this._buckets.length;

    while( this._buckets.length > this._window ) this.shift();

    //print("bsw " + this._window + " add " + s + ", " + e + ", " + b + ", " + ( getAverage( this._buckets ) * 8.0 / this._bucket_ms )
    //        + ", " + getVariance( this._buckets ) * 64.0 / ( this._bucket_ms * this._bucket_ms ) + '\n');
};

Bucketizer.prototype.reset = function reset() {

    this._buckets = [ ];
    this._offsets = [ ];

    this._time = null;
};

Bucketizer.prototype.setInterval = function setInterval( window_ms )
{
    this._window = Math.floor( ( window_ms + this._bucket_ms - 1 ) / this._bucket_ms );
};

module.exports = Bucketizer;

},{}],79:[function(require,module,exports){
/*
 * (c) 2016 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

var Bucketizer = require(78),
    Discontiguous = require(80),
    getAverage = require(87).getAverage,
    getVariance = require(87).getVariance;

/**
* @constructor
*/
function BucketSlidingWindow( window_ms, bucket_ms, real_time ) {

    Bucketizer.call( this, window_ms, bucket_ms, real_time );
 
}

BucketSlidingWindow.prototype = Object.create( Bucketizer.prototype );

BucketSlidingWindow.prototype.average = function average() {
    return Math.floor( getAverage( this._buckets ) * 8.0 / this._bucket_ms );
};

BucketSlidingWindow.prototype.variance = function variance() {
    return Math.floor( getVariance( this._buckets ) * 64.0 / ( this._bucket_ms * this._bucket_ms ) );
};

BucketSlidingWindow.prototype.cv = function cv() {
 
    var average = getAverage( this._buckets ) * 8.0 / this._bucket_ms,
        variance = getVariance( this._buckets ) * 64.0 / ( this._bucket_ms * this._bucket_ms );
 
    return Math.sqrt( variance ) / average;

};

BucketSlidingWindow.prototype.get = function get() {
    return { average : this.average(), variance : this.variance(), buckets: this._buckets.length };
};

BucketSlidingWindow.prototype.toString = function() {
    return 'bsw(' + this._window_ms + ',' + this._bucket_ms + ',' + this._window + ')';
};

function DiscontiguousBucketSlidingWindow( window_ms, bucket_ms )
{
    Discontiguous.call( this, new BucketSlidingWindow( window_ms, bucket_ms, false ) );
}

DiscontiguousBucketSlidingWindow.prototype = Object.create( Discontiguous.prototype );

DiscontiguousBucketSlidingWindow.prototype.setInterval = function setInterval( interval )
{
    this._continuous.setInterval( interval );
};

module.exports = DiscontiguousBucketSlidingWindow;
},{"78":78,"80":80,"87":87}],80:[function(require,module,exports){
/*
 * (c) 2016 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

/**
* @constructor
*/
function Discontiguous( continuous ) {
    this._continuous = continuous;
    this._offset = 0;
    this._stopped = null;
}

Discontiguous.prototype.add = function add( b, s, e ) {
 
    if ( this._stopped !== null && s > this._stopped ) {
        this._offset += ( s - this._stopped );
        this._stopped = null;
    }
 
    this._continuous.add( b, s - this._offset, e - this._offset, this._offset );
};

Discontiguous.prototype.stop = function stop( t ) {

    if ( this._stopped === null ) this._stopped = t;
 
};

Discontiguous.prototype.predict = function predict( duration_ms, debug ) {
    return this._continuous.predict( duration_ms, debug );
};

Discontiguous.prototype.cv = function cv() {
    return this._continuous.cv();
};

Discontiguous.prototype.get = function get() {
    return this._continuous.get();
};

Discontiguous.prototype.reset = function reset() {
    this._continuous.reset();
};

Discontiguous.prototype.toString = function() {
    return this._continuous.toString();
};

module.exports = Discontiguous;
},{}],81:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

/* Exponentially weighted average and variance for a sequence of discrete measurements

    dictionary EwmavValue {
        unsigned long average;
        unsigned long variance;
    };

    // halflife - number of discrete values where the first has half the weight of the last
    // initial - number of discrete values given equal weight at the start
    [Constructor( unsigned long halflife, unsigned long initial )]
    interface DiscreteEwmav {

        void setParams( unsigned long halfLife, unsigned long initial );

        void        add( unsigned long measurement );
        EwmavValue? get();
        void        reset();
        void        reset( unsigned long mean, unsigned long variance );
        object      getState();
        void        setState( object state );
    };

*/

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

var _ = require(103);
//var platform = require( "../platform.js" ),
//    console = new platform.Console('ASEJS_NETWORK_MONITOR_EWMAV', 'media|asejs'),
//    DEBUG = (process.env.DEBUG === 'true');

function DiscreteEwmav( halfLife, initial ) {

    this.reset();

    this.setParams( halfLife, initial );
}

DiscreteEwmav.prototype.setParams = function( halfLife, initial ) {
    /* a(n) = alpha * a(n-1) + ( 1 - alpha ) * <measurement>
     *
     * alpha ^ h = 0.5
     * alpha = 0.5 ^ ( 1 / h )
     */
    this._alpha = Math.pow( 0.5, 1.0 / halfLife );
    this._initial = _.isNumber( initial ) ? initial : halfLife;
};

DiscreteEwmav.prototype.reset = function( statistics ) {

    if ( !statistics || !statistics.average || !_.isNumber( statistics.average ) ) {
        this._count = 0;
        this._average = 0;
        this._averageOfSquares = 0;
    } else if ( !statistics.variance || !_.isNumber( statistics.variance ) ) {
        this._count = this._initial;
        this._average = statistics.average;
        this._averageOfSquares = statistics.average * statistics.average;
    } else {
        this._count = this._initial;
        this._average = statistics.average;
        this._averageOfSquares = statistics.variance + statistics.average * statistics.average;
    }
};

DiscreteEwmav.prototype.add = function( measurement ) {

    if ( _.isNumber( measurement ) ) {
        
        this._count++;

        var alpha = ( this._count > this._initial ) ? this._alpha : ( 1.0 - ( 1.0 / this._count ) );

        this._average = alpha * this._average + ( 1.0 - alpha ) * measurement;
        this._averageOfSquares = alpha * this._averageOfSquares + ( 1.0 - alpha ) * measurement * measurement;
    }
};

DiscreteEwmav.prototype.get = function() {

    if ( this._count === 0 ) return { average : 0, variance : 0 };

    var avg = this._average,
        avgofsquares = this._averageOfSquares,
        squareofavg = avg * avg,
        variance = avgofsquares > squareofavg ? ( avgofsquares - squareofavg ) : 0;

    return { average: Math.floor( avg ), variance: Math.floor( variance ) };
};

DiscreteEwmav.prototype.getState = function() {
    if ( this._count === 0 ) return null;
    var result = { "a": Math.round( this._average ), "s": Math.round( this._averageOfSquares ) };
    if ( this._count < this._initial ) result["c"] = this._count;
    return result;
};

DiscreteEwmav.prototype.setState = function( state ) {
    
    if ( _.isNull( state ) ||
            !_.has( state, "a" ) ||
            !_.has( state, "s" ) ||
            !_.isFinite( state["a"] ) ||
            !_.isFinite( state["s"] ) ) {
        this._count = 0;
        this._average = 0;
        this._averageOfSquares = 0;
        
        return false;
    }
    
    this._count = ( _.has( state, "c" ) && _.isNumber( state["c"] ) ) ? state["c"] : this._initial;
    this._average = state["a"];
    this._averageOfSquares = state["s"];
    
    return true;
};

/* Exponentially weighted average and variance for continuous time series

    The input continuous time series is modeled as the sum of 'square' functions of the form
    f(x) = c for s < x < e
         = 0 otherwise

    Specifically, if the input is network throughput, then each input function represents the
    reception of b bytes over a period of time ( e - s ) and we make the assumption that those bytes
    arrived at a constant bitrate b / ( e - s ).

    These functions may overlap.

    dictionary EwmavValue {
        unsigned long average;
        unsigned long variance;
    };

    // halflife - period of time in ms over which the average will fall by half if no data received
    // initial - initial period of time in ms over which all data has equal weight
    [Constructor( unsigned long halflife, initial )]
    interface ContinuousEwmav {

        // reset to initial state
        void        reset();

        // reset to specified value
        void        reset( unsigned long mean, unsigned long variance );

        // adjust the paramaters
        void        setParams( halfLife, initial );

        // c = value, s = start time (ms), e = end time (ms)
        void        add( c, s, e );

        // t = time (ms) - must be greater than the highest value of e provided
        EwmavValue? get( t );

    };

*/
/**
 *
 * @param {number} halfLife
 * @param {number} warmup
 * @param {boolean} enableDecay
 * @param {string} warmupMode (normal|initialize)
 * @constructor
 */
function ContinuousEwmav( halfLife, warmup, enableDecay, warmupMode ) {

    this._originalWarmup = warmup;
    this._enableDecay = _.isUndefined( enableDecay ) ? true : enableDecay;
    this._warmupMode = warmupMode;
    this._warmupTolerance = 1.25;
    
    this.setInterval( halfLife );
    
    this.reset();
}

ContinuousEwmav.prototype.setInterval = function( halfLife ) {

    // If no reception for time t,
    //    a(x+t) = a(x) * e^(-alpha*t)
    //
    // So, e^(-alpha*halflife) = 0.5
    //     alpha = -ln(0.5) / halflife
    this._halfLife = halfLife;
    this._alpha = - Math.log( 0.5 ) / halfLife;
};
/**
 *
 * @param {Object=}statistics
 */
ContinuousEwmav.prototype.reset = function( statistics ) {

    this._start = null;
    this._time = null;
    this._warmup = this._originalWarmup;

    if ( !statistics || !_.isFinite( statistics.average ) ) {
        this._bits = 0;
        this._average = 0.0;
        this._averageOfSquares = 0.0;
    } else if ( !_.isFinite( statistics.variance ) ) {
        this._bits = 0;
        this._average = statistics.average;
        this._averageOfSquares = statistics.average * statistics.average;
    } else {
        this._bits = 0;
        this._average = statistics.average;
        this._averageOfSquares = statistics.variance + statistics.average * statistics.average;
    }
};

ContinuousEwmav.prototype.add = function( b, s, e ) {
    
    if ( _.isNull( this._start ) ) {
        this._start = s;
        this._time = s;
    }
    
    this._start = Math.min( this._start, s );
    
    if ( ( this._time < this._start + this._warmup )
        && ( e > this._start + this._warmup )
        && (this._time - this._start) > 0
        && ( this._warmupMode === 'initialize' ) ) {
    
        //DEBUG && console.log( 'Initializing EWMA to ' + this._bits / ( this._time - this._start ) + 'kbit/s instead of ' + this._average + 'kbit/s' );
        this._average = this._bits / ( this._time - this._start );
        this._prev = this._average;
        this._averageOfSquares = this._average * this._average;
    }
    
    var c = b * 8 / ( e - s ),
        duration = e - s,
        alpha = this._alpha,
        time = ( e > this._time ) ? e : this._time,

        // decay the current value for elapsed time
        decay = ( time > this._time ) ? Math.exp( - alpha * ( time - this._time ) ) : 1.0,

        // integrate the square input function with the decay curve
        multiplier = ( 1.0 - Math.exp( - alpha * duration ) ),

        // factor in further decay from the end of the input until now
        newdecay = ( e > time ) ? Math.exp( - alpha * ( time - e ) ) : 1.0,
    
        // calculate an adjustment factor for the average of squares where there is overlap
        // without this adjustment, for periods where the square input funcitons overlap, we
        // will calculate the sum of the squares of the overlapping segments, instead of the
        // square of the sum. The difference is ( u + v )^2 - ( u^2 +  v^2 ) = 2uv
        // this is an approximation for two reasons
        // - there may have been overlapping inputs other than the previous one which we are not considering
        // - the overlap may not have been for the whole duration of the current input
        prev = /*this._average*/ this._prev ? this._prev : 0.0,
        oend = Math.min( e, this._time ),
        omul = oend > s ? ( 1.0 - Math.exp( - alpha * ( oend - s ) ) ) : 0.0,
        odecay = oend > s && oend < time ? Math.exp( - alpha * ( time - oend ) ) : 1.0;


    this._averageOfSquares = this._averageOfSquares * decay +
                                2 * prev * c * omul * odecay +
                                c * c * multiplier * newdecay;

    this._average = this._average * decay + c * multiplier * newdecay;

    //console.log( "normal("+c+","+b+","+s+","+e+") decay: " + decay + ", multiplier: " + multiplier +" -> "+this._average+", "+this._averageOfSquares );
    //console.log( "EWMA average: "+this._average + ", recent throughput:" + c);

    if ( time >= this._time ) this._prev = c;

    // Update our current time
    this._time = time;
    
    // Update total bits
    this._bits += c * duration;
};

ContinuousEwmav.prototype.get = function( t ) {
    
    t = Math.max( t, this._time );

    var decay;
    if (this._enableDecay)
        decay = Math.exp( - this._alpha * ( t - this._time ) );
    else
        decay = 1.0;

    var avg = this._average * decay,
        avgofsquares = this._averageOfSquares * decay,
        squareofavg = avg * avg,
        variance = avgofsquares > squareofavg ? avgofsquares - squareofavg : 0;
//    console.log('ContinuousEwmav.get average: ' + this._average + ', decay: ' + decay);
    //console.log("get("+t+"), time="+this._time+", decay="+decay+" -> " + avg + ", "+variance );
    if ( this._time <= this._start + this._warmup ) {
        var ravg = this._bits / ( this._time - this._start );
        avg = ( avg < ravg * this._warmupTolerance ) && ( avg > ravg / this._warmupTolerance ) ? avg : ravg;
        variance = 0;
    }

    return { average: Math.floor( avg ), variance: Math.floor( variance ) };
};

ContinuousEwmav.prototype.toString = function() {
    return 'ewmav(' + this._halfLife + ',' + this._originalWarmup + ')';
};

/* Exponentially weighted average and variance for discontiguous continuous time series

    This is for a continuous time series as ContinuousEwmav with gaps.

    // halflife - period of time in ms over which the average will fall by half if no data received
    // initial - initial period of time in ms over which all data has equal weight
    [Constructor( unsigned long halflife, unsigned long initial )]
    interface DiscontiguousEwmav {

        // reset to initial state
        void        reset( statistics);

        // reset to specified value
        void        reset( unsigned long mean, unsigned long variance );

        // adjust the paramaters
        void        setInterval( halfLife );

        // c = value, s = start time (ms), e = end time (ms)
        void        add( c, s, e );

        // indicate a time to stop
        void        stop( t );

        // t = time (ms) - must be greater than the highest value of e provided
        EwmavValue? get( t );

    };

*/

function DiscontiguousEwmav( halflife, warmup, enableDecay, warmupMode ) {
    this._ewmav = new ContinuousEwmav( halflife, warmup, enableDecay, warmupMode );
    this._offset = 0;
    this._stop = null;
}

DiscontiguousEwmav.prototype.setInterval = function( halflife ) {
    this._ewmav.setInterval( halflife );
};

DiscontiguousEwmav.prototype.reset = function( statistics ) {
    this._ewmav.reset( statistics );
    this._offset = 0;
    this._stop = null;
};

DiscontiguousEwmav.prototype.add = function( b, s, e ) {
    if ( !_.isNull( this._stop ) && e > this._stop ) {
        this._offset += ( s > this._stop ) ? s - this._stop : 0;
        this._stop = null;
    }

    this._ewmav.add( b, s - this._offset, e - this._offset );
};

DiscontiguousEwmav.prototype.stop = function( t ) {
    this._stop = Math.max( _.isNull( this._ewmav._time ) ? 0 : this._ewmav._time + this._offset,
                            _.isNull( this._stop ) ? t : Math.min( this._stop, t ) );
};

DiscontiguousEwmav.prototype.get = function( t ) {
    return this._ewmav.get( ( _.isNull( this._stop ) ? t : this._stop ) - this._offset );
};

DiscontiguousEwmav.prototype.toString = function() {
    return this._ewmav.toString();
};

module.exports = {  DiscreteEwmav: DiscreteEwmav,
                    ContinuousEwmav: ContinuousEwmav,
                    DiscontiguousEwmav: DiscontiguousEwmav };








},{"103":103}],82:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

/* Gaussian distribution */

// Complementary error function
// From Numerical Recipes in C 2e p221
function erfc(x) {
    var z = Math.abs(x);
    var t = 1 / (1 + z / 2);
    var r = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 +
            t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 +
            t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 +
            t * (-0.82215223 + t * 0.17087277)))))))));
    return x >= 0 ? r : 2 - r;
}

// Inverse complementary error function
// From Numerical Recipes 3e p265
function ierfc(x) {
    if (x >= 2) { return -100; }
    if (x <= 0) { return 100; }

    var xx = (x < 1) ? x : 2 - x;
    var t = Math.sqrt(-2 * Math.log(xx / 2));

    var r = -0.70711 * ((2.30753 + t * 0.27061) /
            (1 + t * (0.99229 + t * 0.04481)) - t);

    for (var j = 0; j < 2; j++) {
      var err = erfc(r) - xx;
      r += err / (1.12837916709551257 * Math.exp(-(r * r)) - r * err);
    }

    return (x < 1) ? r : -r;
}

// Models the normal distribution
function Gaussian(mean, variance) {
    this.average = mean;
    this.variance = variance;
}

// Probability density function
Gaussian.prototype.pdf = function(x) {
    var m = Math.sqrt( this.variance ) * Math.sqrt(2 * Math.PI);
    var e = Math.exp(-Math.pow(x - this.average, 2) / (2 * this.variance));
    return e / m;
};

// Cumulative density function
Gaussian.prototype.cdf = function(x) {
    return 0.5 * erfc(-(x - this.average) / Math.sqrt( 2 * this.variance ) );
};

Gaussian.prototype.ppf = function(x) {
    return this.average - Math.sqrt( 2 * this.variance ) * ierfc(2 * x);
};

Gaussian.prototype.ppfs = function(xs) {
    var that = this;
    return xs.map( function( x ) { return that.ppf( x ); } );
};

module.exports = Gaussian;

},{}],83:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_medium");

/**
*  Holt Winters does double exponential smoothing for a sequence of throughput time series measurements
*  Holt Winters is similar to EWMAV, but it also does a second-order exponential
*  smoothing to capture trends (a.k.a the slope component).
*/

var _ = require(103);
var platform = require(61),
    console = new platform.Console('ASEJS_NETWORK_MONITOR_HW', 'media|asejs'),
    DEBUG = ("debug" !== 'release');


/**
 * @constructor
 */
function ByteBucketArray(bucketInterval){
    this._bytes = [];
    this._stime = [];
    this._etime = [];
    this._intervalMs = bucketInterval;
}

ByteBucketArray.prototype.setBucketInterval = function (bucketInterval) {
    DEBUG && console.trace("set BucketInterval to:" + bucketInterval);
    this._intervalMs = bucketInterval;
};

ByteBucketArray.prototype.getBytes = function (index) {
    if ( index >= this._bytes.length ) {
        console.warn("Byte Bucket Array - Index Out of Boundary");
        index = this._bytes.length - 1;
    }
    if ( index < 0){
        console.warn("Either Byte Bucket Array is empty or trying to use a negative index");
        return 0;
    }
    if ( this._bytes[index] === 0 ){
        return 0;
    }

    if ( !this._bytes[index] ){
        console.warn("Retrieving a null/undefined value from the Byte Bucket Array!");
        return null;
    }
    DEBUG && console.trace("ByteBucketArray[" + index + "], bytes: " + this._bytes[index] +", stime: " + this._stime[index] + ", etime:" + this._etime[index] + ", active_time:" + (this._etime[index] - this._stime[index]) + ", interval:" + this._intervalMs + ", normalized bytes: " + this._bytes[index] * (this._intervalMs / (this._etime[index] - this._stime[index])));
    return this._bytes[index] * (this._intervalMs / (this._etime[index] - this._stime[index]));
};

ByteBucketArray.prototype.getStartTime = function (index) {
     if ( index >= this._bytes.length ) {
        console.warn("Byte Bucket Array - Index Out of Boundary");
        return 0;
    }
    return this._stime[index];
};

ByteBucketArray.prototype.add = function (index, bytes, startTime, endTime){
    var endOfBytes = this._bytes.length;

    //Note that even though we try to remove gaps by calling stop(), start() on Network Monitor
    //The gaps between mediaRequests might exist either due to long RTT or a busy system
    //When that happens, we will have "nulls" in our ByteBucketArray
    // and we should remove those "null"s when making a prediction.

    if ( _.isUndefined(this._stime[index]) ) {
        this._stime[index] = startTime;
    } else if( startTime < this._stime[index] ){
        this._stime[index] = startTime;
    }
    if ( _.isUndefined(this._etime[index]) ) {
        this._etime[index] = endTime;
    }else if ( endTime > this._etime[index] ){
        this._etime[index] = endTime;
    }

    if( !this._bytes[index] ){
        this._bytes[index] = 0;
    }
    this._bytes[index] += bytes;
    DEBUG && console.trace("after adding bytes at index("+ index +"), the array: " + JSON.stringify(this._bytes) + ", the last throughput:" + this._bytes[index] * 8 / this._intervalMs + " kbps");
    DEBUG && console.trace("stime: " + JSON.stringify(this._stime) + ", etime:" + JSON.stringify(this._etime));
};

ByteBucketArray.prototype.shift = function () {
    this._bytes.shift();
    this._stime.shift();
    this._etime.shift();
};

ByteBucketArray.prototype.getLength = function () {
    return this._bytes.length;
};

ByteBucketArray.prototype.toString = function (){
    var output = "[";
    for(var i = 0; i < this._bytes.length; i++){
        if( i > 0){
            output += ", ";
        }
        output += this._bytes[i] * (this._intervalMs / (this._etime[i] - this._stime[i]));
    }
    output += "]";
    return output;
};

/**
 * @param {number} halfLifeAlpha half life for the first-order exponential smoothing
 * @param {number} halfLifeGamma half life for the second-order exponential smoothing
 * @param {number} intervalMs interval to discretize measurements (Note that half life is calculated as number of discretized samples)
 * @param {number} initial number of discrete values given equal weight at the start
 * @param {number} minInitial minimum number of discrete values given equal weight at the start
 * @param {boolean} curveEnabled whether or not we use buffer level to adjust half life
 * @param {boolean} upperBoundEnabled whether or not we use have an upper bound for HW
 * @constructor
 */
function HoltWinters( halfLifeAlpha, halfLifeGamma, intervalMs, initial, minInitial, curveEnabled, upperBoundEnabled){
    this.setParams( halfLifeAlpha, halfLifeGamma, intervalMs, initial, minInitial, curveEnabled, upperBoundEnabled );
    this.reset();
}

/* Public Functions */
/**
 * @param {number} halfLifeAlphaInMs half life for the first-order exponential smoothing
 * @param {number} halfLifeGammaInMs half life for the second-order exponential smoothing
 * @param {number} intervalMs interval to discretize measurements (Note that half life is calculated as number of discretized samples)
 * @param {number} initial number of discrete values given equal weight at the start
 * @param {number} minInitial minimum number of discrete values given equal weight at the start
 * @param {boolean} curveEnabled whether or not we use buffer level to adjust half life
 * @param {boolean} upperBoundEnabled whether or not we use have an upper bound for HW
 */
HoltWinters.prototype.setParams = function( halfLifeAlphaInMs, halfLifeGammaInMs, intervalMs, initial, minInitial, curveEnabled, upperBoundEnabled) {
	/* s(n) = (1 - alpha) * (s(n-1) + t(n-1)) + alpha * <measurement>
	 * t(n) = (1 - gamma) * t(n-1) + gamma * (s(n) - s(n-1))
     *
     * alpha ^ h = 0.5
     * alpha = 0.5 ^ ( 1 / h )
     *
     * gamma ^ h = 0.5
     * gamma = 0.5 ^ ( 1 / h)
     */
    var halfLifeAlpha = halfLifeAlphaInMs / intervalMs,
        halfLifeGamma = halfLifeGammaInMs / intervalMs;
    this._alpha = 1 - Math.pow( 0.5, 1.0 / halfLifeAlpha );
    this._gamma = 1 - Math.pow( 0.5, 1.0 / halfLifeGamma );
    this._halfLifeRatio = halfLifeGamma / halfLifeAlpha;
    this._intervalMs = intervalMs;
    DEBUG && console.trace("alpha: " + this._alpha + ", gamma: " + this._gamma + ", intervalMs:" + this._intervalMs );
    if( this._byteBuckets ){
        this._byteBuckets.setBucketInterval(this._intervalMs);
    }
    //Holt-Winter requires at least 3 samples to bootstrap
    this._initial = _.isNumber( initial ) && (initial > minInitial) ? initial : minInitial;
    this._curveEnabled = curveEnabled;
    this._upperBoundEnabled = upperBoundEnabled;
};
/**
 * @param {Object=} statistics
 */
HoltWinters.prototype.reset = function( statistics ) {

    if( statistics && statistics.average ){
        this._stationary = statistics.average;
        this._trend = 0;
    }else{
        this._stationary = null;
        this._trend = null;
    }
    DEBUG && console.trace("Holt Winters Reset");
    this._count = 0;
    this._average = 0;
    this._averageOfSquares = 0;
    this._squareOfDifference = 0;
    this._variance = 0;
    this._offset = 0;
    this._lastBytesCompressed = 0;
    this._stop = null;
    this._start = null;
    this._lastSeenEndtime = null;
    this._byteBuckets = new ByteBucketArray(this._intervalMs);
    this._compressedBuckets = [];
    this._startindex = null;
    this._bootstrapping = true;
    this._bootstrapDiscard = true;
};

// JSASE use this function to adjust halfLife based on buffer level
HoltWinters.prototype.setInterval = function( halfLifeInMs ){
    if(!this._halfLifeRatio){
        this._halfLifeRatio = 1;
    }
    var halfLifeAlphaInSamples = halfLifeInMs / this._intervalMs,
        halfLifeGammaInSamples = this._halfLifeRatio * halfLifeAlphaInSamples;

    if (this._curveEnabled) {
        this._alpha = 1 - Math.pow( 0.5, 1.0 / halfLifeAlphaInSamples );
        if (this._alpha < 0.05){
            this._alpha = 0.05;
        }
        this._gamma = 1 - Math.pow( 0.5, 1.0 / halfLifeGammaInSamples );
        if (this._gamma < 0.05){
            this._gamma = 0.05;
        }
        DEBUG && console.trace("setInterval, halfLife (in samples):"+ halfLifeAlphaInSamples + ", reset alpha to: " + this._alpha + ", gamma: " + this._gamma);
    }
};

/**
* @param {number} b bytes
* @param {number} s abosulte start timestamp (not offseted)
* @param {number} e abosulte end timestamp (not offseted)
**/
HoltWinters.prototype.add = function( b, s, e ) {
    DEBUG && console.trace("Adding Sample with Raw Throughput: " + b*8/(e-s) +" kbps");
    DEBUG && console.trace("Start: " + s + " End: " + e);
    if ( !_.isNull( this._stop ) && e > this._stop ) {
        DEBUG && console.trace("offset before:" + this._offset);
        this._offset += ( s > this._stop ) ? s - this._stop : 0;
        DEBUG && console.trace("offset after:" + this._offset);
        if( ( s > this._stop )
            || ( s < this._stop && e > this._stop ) ){
            this._stop = null;
        }
    }

    s = s - this._offset;
    e = e - this._offset;

    if ( _.isNull( this._lastSeenEndtime ) ) {
        this._lastSeenEndtime = e ;
    }
    //this._lastSeenEndtime operates in offsetted timeline
    this._lastSeenEndtime = ( e > this._lastSeenEndtime ) ? e : this._lastSeenEndtime;

    this._discretize(s, e, b);
    this._compress();
};

HoltWinters.prototype.stop = function( t ) {
    //this._stop is operate in absolute timeline
    //DEBUG && console.trace("stop is called, before setting, (t, stop, time, offset): (" + t + "," + this._stop + ", "+ this._lastSeenEndtime + "," + this._offset +")");
    this._stop =  Math.max( _.isNull( this._lastSeenEndtime ) ? 0 : this._lastSeenEndtime + this._offset,
                            _.isNull( this._stop ) ? t : Math.min( this._stop, t ) );
    //DEBUG && console.trace("stop is called, after setting, (t, stop): (" + t + "," + this._stop + ")");
};

HoltWinters.prototype.get = function( t ) {
    var avg;
    if ( _.isNull(this._stationary) ){
        avg = this._average;
        var avgofsquares = this._averageOfSquares,
            squareofavg = avg * avg,
            variance = avgofsquares > squareofavg ? ( avgofsquares - squareofavg ) : 0;
        DEBUG && console.trace("bootstrap => average: " + Math.floor( avg ) + " bytes/bucket, variance: " + Math.floor( variance ));
        return this._normalize({average: avg, variance: variance, raw: []});
    }
    avg = (this._stationary + this._trend);
    // When bandwidth suddenly drops, the trend value can be a large negative value.
    // We bound this case with the value from the last throughput observation
    avg = avg < this._lastBytesCompressed && this._trend < 0 ? this._lastBytesCompressed : avg;

    DEBUG && console.trace("upperBoundEnabled? " + this._upperBoundEnabled);
    if ( this._upperBoundEnabled ) {
        // When bandwidth suddenly increased, the trend value can be a large positive value.
        // We bound this case with the value from the last throughput observation
        avg = avg > this._lastBytesCompressed && this._trend > 0 ? this._lastBytesCompressed : avg;
    }

    DEBUG && console.trace("alpha: " + this._alpha + ", gamma: " + this._gamma + ", interval: " + this._intervalMs );
    DEBUG && console.trace("t: " + t + ", stationary:" + this._stationary + ", trend:" + this._trend + ", hw average:" + avg);
    // The raw value is only for testing purposes
    var raw = this._compressedBuckets;
    DEBUG && console.trace("hw raw: " + JSON.stringify(raw));
    if( this._compressedBuckets.length > 10){
        this._compressedBuckets.splice(0, this._compressedBuckets.length - 10);
    }
    return this._normalize({average: avg, variance: this._variance, raw: raw});
};

/* Private Functions */

HoltWinters.prototype._addToBytes = function (bucket, b, s, e) {
    DEBUG && console.trace("before adding bytes: " + JSON.stringify(this._byteBuckets));
    if ( _.isNull(this._startindex) ) {
        this._startindex = bucket;
    }
    var index = bucket - this._startindex;
    this._byteBuckets.add(index, b, s, e);
};

HoltWinters.prototype._discretize = function (news, newe, b) {
    var sbucket = Math.floor(news/this._intervalMs),
    	ebucket = Math.floor(newe/this._intervalMs),
    	bytediv = b / (newe-news);

    if (sbucket == ebucket) {
        this._addToBytes(sbucket, b, news, newe);
    } else {
        var st = sbucket;
        if (news > sbucket * this._intervalMs ) {
            this._addToBytes(sbucket,
            				Math.floor(((sbucket + 1) * this._intervalMs - news) * bytediv),
                            news, (sbucket+1) * this._intervalMs);
            st = sbucket + 1;
        }
        for (var i = st; i < ebucket; i++) {
            this._addToBytes(i, Math.floor(this._intervalMs * bytediv),
                             i * this._intervalMs,
                             (i+1) * this._intervalMs);
        }
        if (newe > ebucket * this._intervalMs){
            this._addToBytes(ebucket,
            				Math.floor((newe - (ebucket * this._intervalMs)) * bytediv),
                            ebucket * this._intervalMs,
                            newe);
        }
    }
};

/* Implementation of Welford algorithm from Knuth's The Art of Computer Programming */
HoltWinters.prototype._streamingVariance = function (b) {
    DEBUG && console.trace("adding " + b + " bytes into _streamingVariance calculation ");
    this._count += 1;
    var delta = b - this._average;
    this._average += delta / this._count;
    this._squareOfDifference += delta * (b - this._average);
    if (this._count > 1){
    	this._variance = this._squareOfDifference / (this._count - 1);
    }
    DEBUG && console.trace("_streamingVariance calculation result: {average: " + this._average + ", variance: " + this._variance + "}" );
};

HoltWinters.prototype._compress = function() {

    DEBUG && console.trace("before compress: "+ JSON.stringify(this._byteBuckets));
    DEBUG && console.trace("value of initial: "+ this._initial);

    var bucketLen = this._byteBuckets.getLength();
    if ( this._bootstrapping && bucketLen > this._initial ) {
        this._bootstrapping = false;
    }

    if ( this._bootstrapping ) {
        var alpha = ( 1.0 - ( 1.0 / bucketLen ) );
        var measurement;
        this._average = 0;
        this._squareOfDifference = 0;
        for(var i = 0 ; i < bucketLen; i++){
            measurement = this._byteBuckets.getBytes(i);
            if( _.isNull(measurement)){
                break;
            }
            DEBUG && console.trace("measurement: "+ measurement + ", alpha:" + alpha);
            this._average = alpha * this._average + ( 1.0 - alpha ) * measurement; //bytes
            DEBUG && console.trace("average: "+ this._average);
            this._averageOfSquares = alpha * this._averageOfSquares + ( 1.0 - alpha ) * measurement * measurement;
        }
    } else if ( _.isNull(this._stationary) && bucketLen > this._initial ) {

        //Initialize Holt-Winters algorithm
        this._stationary = this._byteBuckets.getBytes(0);
        if ( _.isNull(this._stationary) ) {
            // This should never happen, given we remove the null values at the beginning
            console.error(" the statiionary is NaN during the initialization => stationary: " + this._stationary );
        }
        this._trend = this._byteBuckets.getBytes(1) - this._byteBuckets.getBytes(0);
        if ( _.isNull(this._trend) ) {
            // this._byteBuckets.getBytes(1) is null, if this is the case, set trend to be 0 for bootstrapping
            // the null value will be phased out at the next round
            this._trend = 0;
        }

        //Going to recalculate the average and variance using Holt-Winter
        //therefore reset the values here
        //Intialize the value of stationary with ewma average
        this._average = 0;
        this._squareOfDifference = 0;

        DEBUG && console.trace("bootstraping the bytes array: "+ JSON.stringify(this._byteBuckets));
        this._streamingVariance(this._byteBuckets.getBytes(0));
        this._lastBytesCompressed = this._stationary;
        this._compressedBuckets.push({time: this._byteBuckets.getStartTime(0), value: this._stationary});
        this._byteBuckets.shift();
        this._startindex += 1;
    }

    while( this._byteBuckets.getLength() > this._initial) {
        while( this._byteBuckets.getLength() > 0 && _.isNull(this._byteBuckets.getBytes(0)) ){
            //remove nulls from the beginning of the list
            this._byteBuckets.shift();
            this._startindex += 1;
        }
        if( this._byteBuckets.getLength() <= this._initial ){
            break;
        }
        var newstat;
        var bytesToBeCompressed = this._byteBuckets.getBytes(0);
        newstat = this._alpha * bytesToBeCompressed + (1 - this._alpha) * (this._stationary + this._trend);
        newstat = newstat > 0 ? newstat : bytesToBeCompressed;
        this._trend = this._gamma * (newstat - this._stationary) + (1 - this._gamma) * this._trend;
        this._stationary = newstat;
        if ( _.isNull(this._stationary) ||  _.isNull(this._trend) ) {
            console.warn(" the statiionary or the trend is null ( stationary: " + this._stationary + ", trend: " + this._trend + " )");
        }
        this._streamingVariance(bytesToBeCompressed);
        this._lastBytesCompressed = bytesToBeCompressed;
        this._compressedBuckets.push({time: this._byteBuckets.getStartTime(0), value: bytesToBeCompressed});
        this._byteBuckets.shift();
        this._startindex += 1;
    }
    DEBUG && console.trace("after compressed: "+ JSON.stringify(this._byteBuckets) + ", stationary: " + this._stationary + ", trend:" + this._trend);
};

/**
 * @param {{average: number, variance: number}} result prediction result from Holt-Winters before normalization
 */
HoltWinters.prototype._normalize = function( result ){
    // Convert the average/varience to kbit/s
    DEBUG && console.trace("(before norm.) => average: " + result.average + ", variance: " + result.variance + ", raw: " + JSON.stringify(result.raw));
    var raw = result.raw.map( function(x) {return {time: x.time, value:(x.value * 8.0 / this._intervalMs)}; }, this );
    var resultInKbps = {average: Math.floor( result.average * 8.0 / this._intervalMs ),
                        variance: Math.floor( (8.0 / this._intervalMs) * (8.0 / this._intervalMs) * result.variance ),
                        raw: raw
                       };
    DEBUG && console.trace("(after norm.) => average: " + resultInKbps.average + "kbps, variance: " + resultInKbps.variance + ", raw: " + JSON.stringify(resultInKbps.raw));
    return resultInKbps;
};

module.exports = {  HoltWinters : HoltWinters };

},{"103":103,"61":61}],84:[function(require,module,exports){
module.exports = {
    ewma                    : require(81),
    slidingwindow           : require(86),
    holtwinters             : require(83),
    Gaussian                : require(82),
    BucketSlidingWindow     : require(79),
    BucketHoltWinters       : require(76),
    concatBuffers           : require(87).concatBuffers,
    ObservableProperty		: require(75),
    PercentileCalculator      : require(85),
    BucketInterQuartileRange  : require(77)
};
},{"75":75,"76":76,"77":77,"79":79,"81":81,"82":82,"83":83,"85":85,"86":86,"87":87}],85:[function(require,module,exports){
/*
 * (c) 1997-2016 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_high");

/**
 * @param {number} maxNumberOfSamples is the maximum number of samples that should be included in the calculation.
 * The most recent samples are used.
 * @constructor
 */
function PercentileCalculator(maxNumberOfSamples) {
    this._maxNumberOfSamples = maxNumberOfSamples;
    this._samples = [];
    this._updated = false;
    this._sortedSamples = undefined;
    this._percentiles = {};
}

PercentileCalculator.prototype.addSample = function(sample) {
    if(this._samples.length === this._maxNumberOfSamples) {
        this._samples.shift();
    }

    this._samples.push(sample);
    this._updated = true;
};

PercentileCalculator.prototype.getSampleSize = function(sample) {
    return this._samples.length;
};

PercentileCalculator.prototype.calculatePercentile = function(percentile) {
    if (this._updated || this._sortedSamples === undefined ){
        this._sortedSamples = this._samples.slice(0).sort(function(a, b) { return a-b; });
        this._percentiles = {};
        this._updated = false;
    }

    if ( this._percentiles[percentile] === undefined ){

        var sortedSamples = this._sortedSamples;

        var k = Math.floor((percentile / 100 * (sortedSamples.length - 1) + 1)) - 1;
        var f = (percentile / 100 * (sortedSamples.length - 1) + 1) % 1;

        if ( k === (sortedSamples.length - 1)) {
            this._percentiles[percentile] = sortedSamples[k];
        } else {
            this._percentiles[percentile] = sortedSamples[k] + (f * (sortedSamples[k+1] - sortedSamples[k]));
        }
    }
    return this._percentiles[percentile];
};

module.exports = PercentileCalculator;

},{}],86:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

("clear" === 'obfuscate') && jscrambler && jscrambler("jscrambler ignore_transformations_@ jscrambler_high");

var _ = require(103);

/**
 * @param {number} windowMs sliding window length
 * @constructor
 */
function ContiguousSlidingWindow( windowMs ) {

    this._windowMs = windowMs;

    this.reset();

}

ContiguousSlidingWindow.prototype._push = function( d, b ) {

    this._time += d;
    this._duration += d;
    this._bytes += b;
    this._queue.push( { d : d, b : b } );

};

ContiguousSlidingWindow.prototype._prune = function() {

    while( this._duration > this._windowMs ) {

        var a = this._queue.shift();
        this._bytes -= a.b;
        this._duration -= a.d;

    }

};

ContiguousSlidingWindow.prototype.reset = function() {
    this._queue = [ ];
    this._time = null;
    this._bytes = 0;
    this._duration = 0;
};

ContiguousSlidingWindow.prototype.setInterval = function( windowMs ) {

    this._windowMs = windowMs;

    this._prune();

};

ContiguousSlidingWindow.prototype.add = function( b, s, e ) {

    if ( _.isNull( this._time ) ) this._time = s;

    if ( s > this._time ) this._push( s - this._time, 0 );

    this._push( e > this._time ? ( e - this._time ) : 0, b );

    this._prune();

};

ContiguousSlidingWindow.prototype.get = function() {

    return { average : Math.floor( this._bytes * 8 / this._duration ), variance : 0 };

};

function DiscontiguousSlidingWindow( windowMs ) {

    this._window = new ContiguousSlidingWindow( windowMs );
    this._offset = 0;
    this._stop = null;

}

DiscontiguousSlidingWindow.prototype.reset = function() {

    this._window.reset();
    this._offset = 0;
    this._stop = null;

};

DiscontiguousSlidingWindow.prototype.add = function( b, s, e ) {

    if ( !_.isNull( this._stop ) && e > this._stop ) {

        if ( s > this._stop ) {
            this._offset += s - this._stop;
        }

        this._stop = null;
    }

    this._window.add( b, s - this._offset, e - this._offset );

};

DiscontiguousSlidingWindow.prototype.stop = function( t ) {

    this._stop = _.isNull( this._stop ) ? t : Math.min( t, this._stop );

};

DiscontiguousSlidingWindow.prototype.get = function() {

    return this._window.get();

};

DiscontiguousSlidingWindow.prototype.setInterval = function( windowMs ) {
    this._window.setInterval( windowMs );
};

module.exports = {  ContiguousSlidingWindow : ContiguousSlidingWindow,
                    DiscontiguousSlidingWindow : DiscontiguousSlidingWindow };






},{"103":103}],87:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

var _ = require(103);

////////////////////
// enumerateOwnProperties
////////////////////
function enumerateOwnProperties(x, cb) {
    if (x===undefined) return;
    _.pairs(x).forEach(function (pair) {
        cb(pair[0],pair[1]);
    });
}

////////////////////
// _concatBuffers
//
// returns a new ArrayBuffer from concatenating two other ArrayBuffer's
////////////////////
function concatBuffers(buffer1, buffer2)
{
    var newBuf = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
    newBuf.set(new Uint8Array(buffer1), 0);
    newBuf.set(new Uint8Array(buffer2), buffer1.byteLength);
    return newBuf.buffer;
}

var getSum = function(numArr){
    if( !Array.isArray(numArr) ){ return false; }
    return numArr.reduce(function(total, num){ return total + num; }, 0);
};

var getAverage = function(numArr){
    if( !Array.isArray(numArr) ){ return false; }
    return getSum(numArr) / numArr.length;
};

var getVariance = function(numArr){
    if( !Array.isArray(numArr) ){ return false; }
    var avg = getAverage( numArr), 
        i = numArr.length,
        v = 0;
    return getSum(numArr.map( function( o ) { return (o - avg) * (o - avg); })) / (numArr.length - 1);
};

var getStandardDeviation = function(numArr){
    if( !Array.isArray(numArr) ){ return false; }
    var variance = getVariance( numArr);
    var stdDev = Math.sqrt( variance );
    return stdDev;
};

var getCovariance = function (set1, set2) {
  if (set1.length == set2.length) {
    var n = set1.length;
    var total = 0;
    var sum1 = getSum(set1);
    var sum2 = getSum(set2);

    for (var i = 0; i < n; i++) {
      total += set1[i] * set2[i];
    }
    return (total - sum1 * sum2 / n) / n;
  } else {
    return false;
  }
};

var getCorrelation = function (arrX, arrY) {
  if (arrX.length == arrY.length) {
    var covarXY = getCovariance(arrX, arrY);
    var stdDevX = getStandardDeviation(arrX);
    var stdDevY = getStandardDeviation(arrY);

    return covarXY / (stdDevX * stdDevY);
  } else {
    return false;
  }
};

module.exports = {
    concatBuffers           : concatBuffers,
    enumerateOwnProperties  : enumerateOwnProperties,
    getSum                  : getSum,
    getAverage              : getAverage,
    getVariance             : getVariance,
    getStandardDeviation    : getStandardDeviation,
    getCovariance           : getCovariance,
    getCorrelation          : getCorrelation
};

},{"103":103}],88:[function(require,module,exports){
var CHARS_COMMON = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
    CHARS = CHARS_COMMON + '+/',
    CHARS_URL_SAFE = CHARS_COMMON + '-_';

var slice = Array.prototype.slice,
    // convert strinsg to array of characters, it's faster to access
    map = slice.call(CHARS),
    mapUrlSafe = slice.call(CHARS_URL_SAFE),
    charNumber1 = { },
    charNumber2 = { },
    charNumber3 = { },
    charNumber4 = { },
    prepRegex = /\s+/g;

[map, mapUrlSafe].forEach(function(map) {
    var i = map.length;
    var c;
    while (i--) {
        // pre-calculate values for each of quad-s
        c = map[i];
        charNumber1[c] = i << 18;
        charNumber2[c] = i << 12;
        charNumber3[c] = i << 6;
        charNumber4[c] = i;
    }
});

function encode(a, map, padChar) {
    var s = '',
        i = 0,
        l = a.length,
        lMinus2 = l - 2,
        triplet;

    // assert(every.call(a, isByte));

    while (i < lMinus2) {
        triplet =
            (a[i++] << 16) +
            (a[i++] << 8 ) +
            (a[i++]      );

        if (!(triplet >= 0 && triplet <= 0xFFFFFF)) {
            throw new Error('not bytes');
        }

        s +=
            map[(triplet >>> 18)       ] +
            map[(triplet >>> 12) & 0x3F] +
            map[(triplet >>> 6 ) & 0x3F] +
            map[(triplet       ) & 0x3F];
    }

    if (i == lMinus2) {
        triplet =
            (a[i++] << 8) +
            (a[i++]     );

        if (!(triplet >= 0 && triplet <= 0xFFFF)) {
            throw new Error('not bytes');
        }

        s +=
            map[(triplet >>> 10)       ] +
            map[(triplet >>> 4 ) & 0x3F] +
            map[(triplet <<  2 ) & 0x3F] +
            padChar;

    } else if (i == l - 1) {
        triplet =
            (a[i++]);

        if (!(triplet >= 0 && triplet <= 0xFF)) {
            throw new Error('not bytes');
        }

        s +=
            map[(triplet >>> 2)       ] +
            map[(triplet <<  4) & 0x3F] +
            padChar +
            padChar;

    } else {
        // we will never get here
        // assert(i == l);
    }

    return s;
}

function decode(s) {
    s = s.replace(prepRegex, '');

    var l = s.length,
        c;

    // strip at most 2 pad chars from the end ('=' for regular, '.' for url safe)
    c = s.charAt(l - 1);
    if (c === '=' || c === '.') { l--; }
    c = s.charAt(l - 1);
    if (c === '=' || c === '.') { l--; }

    var aLength = ((l >> 2) * 3);
    var aPaddedLength = 0;
    switch(l % 4) {
        case 2:
            aPaddedLength = 1;
            break;
        case 3:
            aPaddedLength = 2;
            break;
        case 1:
            throw new Error('bad base64');
    }

    var a = new Uint8Array(aLength + aPaddedLength),
        si = 0,
        ai = 0,
        triplet;

    while (ai < aLength) {
        triplet = charNumber1[s[si++]] + charNumber2[s[si++]] + charNumber3[s[si++]] + charNumber4[s[si++]];

        if (!(triplet >= 0 && triplet <= 0xFFFFFF)) {
            throw new Error('bad base64');
        }

        a[ai++] = (triplet >>> 16);
        a[ai++] = (triplet >>> 8 ) & 0xFF;
        a[ai++] = (triplet       ) & 0xFF;
    }

    if (aPaddedLength > 0) {
        triplet = charNumber1[s[si++]] + charNumber2[s[si++]];
        a[ai++] = (triplet >>> 16);

        if (aPaddedLength > 1) {
            triplet = triplet + charNumber3[s[si++]];
            a[ai++] = (triplet >>> 8) & 0xFF;
        }

        if (!(triplet >= 0 && triplet <= 0xFFFF00 && ((triplet & (aPaddedLength > 1 ? 0x0000FF : 0x00FFFF)) === 0))) {
            throw new Error('bad base64');
        }
    }

    return a;
}


module.exports = {

    encode: function (a) {
        return encode(a, map, '=');
    },

    encodeUrlSafe: function (a) {
        return encode(a, mapUrlSafe, '');
    },

    decode: decode
    
};
},{}],89:[function(require,module,exports){
/* global Promise */

/**
 *  Private:
 *    movieMap: map with movieIds as Keys to a Data structure {manifest,ldl, headers, media}
 *    UrlMap:   map with url as key to a DS { value: dataInTheUrl , ts: createTimeStamp } TODO
 *
 *  Members:
 *    constructor: options: { log, cacheExpiryMs}
 *    hasData: ({id: movieId, field: 'manifest|ldl'}) // returns true or false
 *    getData: ({id: movieId, field: 'manifest|ldl'}) // field {'manifest', 'ldl'}
 *    setData: ({id: moviedId, field: 'manifest|ldl', value: value})
 *    clearData: (movieId) clears entry reference.
 */

/*jshint -W069 */

// Cache dirty for manifest and LDL when playback has begun for this movieId
// Cache dirty for headers, media chunks to be decided !
var mixin = require(95);
var sizeof = require(90);
var createMap = function() {
    return Object['create'](null);
};
var DefaultCaps = "DEFAULTCAPS";
var expiryMap = createMap(),
    cacheSizeBytesMap = createMap(),
    cacheSizeCountMap = createMap();

// TODO Make all this configurable
expiryMap['manifest'] = 20 * 60 * 1000; // 20 mins since server cache is set to 20 right now
expiryMap['ldl'] = (11.5) * 60 * 60 * 1000; // license expire in 12 hours
expiryMap['metadata'] = 20 * 60 * 1000; // 20 mins since server cache is set to 20 right now
expiryMap['default'] = 20 * 60 * 1000;

cacheSizeBytesMap['manifest'] = 10 * 1024;
cacheSizeBytesMap['ldl'] = 10 * 1024;
cacheSizeBytesMap['metadata'] = 10 * 1024;
cacheSizeBytesMap['default'] = 10 * 1024;

cacheSizeCountMap['manifest'] = 10;
cacheSizeCountMap['ldl'] = 10;
cacheSizeCountMap['metadata'] = 10;
cacheSizeCountMap['default'] = 10;


function CacheManager(options) {
    this.log = options.log;
    this.clock = options.clock;
    this.movieMap = createMap();
    this.Promise = options.Promise;
    this.compress = options.compress;
    this.uncompress = options.uncompress;
    this.isDebug = options.isDebug || false;
    
    cacheSizeCountMap['manifest'] =  options.maxCountManifestCache || cacheSizeCountMap['manifest'];
    cacheSizeCountMap['ldl'] =  options.maxCountLdlCache || cacheSizeCountMap['ldl'];

    if (options.eventEmitter) {
        this.eventEmitter = options.eventEmitter;
        mixin(this.eventEmitter, CacheManager.prototype);
    }
}
CacheManager.prototype.hasData = function hasData(movieId, field, caps) {
    this.debugAssert(typeof movieId !== "undefined");
    this.debugAssert(typeof field !== "undefined");
    var entry = this._findEntry(movieId, field, caps);
    return !!entry.value; // value is always of type  == 'object'
};

//A. data is not set
//B. data is expired
//C. data is a promise 
//D. data is a valid value
CacheManager.prototype._findEntry = function _findEntry(movieId, field, caps) {
    var data = {
            value: null,
            reason: '',
            log: ''
        },
        movieMap = this.movieMap,
        fieldCache = movieMap[field];
    var capabilities = caps ? caps : DefaultCaps;
    if (typeof fieldCache === "undefined") {
        data.log = 'cache miss: no data exists for field:' + field;
        data.reason = 'unavailable';
        return data;
    }
    if (typeof fieldCache[movieId] === "undefined") {
        data.log = 'cache miss: no data exists for movieId:' + movieId;
        data.reason = 'unavailable';
    } else {
        var movieData = fieldCache[movieId][capabilities];
        if (!movieData || !movieData.value) {
            data.log = 'cache miss: ' + field + ' data not available for movieId:' + movieId;
            data.reason = 'unavailable';
        } else if (this.isExpired(field, movieData.creationTime)) {
            data.log = 'cache miss: ' + field + ' data expired for movieId:' + movieId;
            data.reason = 'expired';
        } else if (this.Promise && movieData.value instanceof this.Promise) { // in progress is yes
            data.log = 'cache hit: ' + field + ' request in flight for movieId:' + movieId;
            data.value = movieData.value;
        } else {
            data.log = 'cache hit: ' + field + ' available for movieId:' + movieId;
            data.value = movieData.value;
        }
    }
    return data;
};

CacheManager.prototype.getData = function getData(movieId, field, caps) {
    this.debugAssert(typeof movieId !== "undefined");
    this.debugAssert(typeof field !== "undefined");
    var data = this._findEntry(movieId, field, caps);
    this.log.trace(data.log);
    if (!data.value) {
        if (this.Promise) {
            return Promise.reject(data.reason);
        } else {
            return data.reason;
        }
    } else {
        if (this.Promise) {
            if (data.value instanceof this.Promise) {
                return data.value;
            } else {
                return Promise.resolve(data.value);
            }
        } else {
            if (this.uncompress) {
                return JSON.parse(this.uncompress(data.value, "gzip", false));
            } else {
                return data.value;
            }
        }
    }
};

CacheManager.prototype.setData = function setData(movieId, field, value, destroyFn, caps) {
    this.debugAssert(typeof movieId !== "undefined");
    this.debugAssert(typeof field !== "undefined");
    var movieMap = this.movieMap,
        capabilities = caps ? caps : DefaultCaps;

    if (!movieMap[field]) {
        movieMap[field] = createMap();
        Object.defineProperty(movieMap[field], 'numEntries', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(movieMap[field], 'size', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    
    var compressedData = this.compress ? (this.compress(JSON.stringify(value), "gzip", true)) : value,
        size = sizeof(compressedData),
        movieCache = movieMap[field];
    
    this._makeSpaceIfRequired(movieId, field, capabilities, size, value, movieCache);

    var entry = {
        creationTime: this.clock.getTime(),
        value: compressedData,
        size: size,
        type: field,
        destroyFn: destroyFn
    };
    movieCache[movieId] = movieCache[movieId] || createMap();
    movieCache[movieId][capabilities] = movieCache[movieId][capabilities] || createMap();
    movieCache[movieId][capabilities] = entry;
    movieCache['size'] += size;
    movieCache['numEntries']++;

    if (this.eventEmitter) {
        this.emit("addedCacheItem", entry);
    }
    if (this.isDebug && "cadmium" !== 'cadmium') {
        this.log.debug("setData: added data " + JSON.stringify(this.movieMap));
    }
    return entry;
};

CacheManager.prototype._makeSpaceIfRequired = function _makeSpaceIfRequired(movieId, field, capabilities, size, value, movieCache) {
    var self = this;

    {
        // A. overwrite same movieID entry, Or find the expired one Or C. find the oldest entry. LRU
        var currentCount = movieCache['numEntries'],
            maxCount = cacheSizeCountMap[field],
            movieToBeRemoved;
        
        var existingEntry = movieCache[movieId] && movieCache[movieId][capabilities];
        if (existingEntry && existingEntry.value) {
            movieToBeRemoved = movieId; // either a promise or expired entry. 
        } else if (currentCount >= maxCount) {
            var oldestMovieId,
                oldestCreationTime = Number['POSITIVE_INFINITY'],
                expiredMovieId;

            Object.keys(movieCache).every(function(m) {
                var entry = movieCache[m] && movieCache[m][capabilities];
                if (entry && entry.value && self.isExpired(field, entry.creationTime)) {
                    expiredMovieId = m;
                    //return false;
                }
                if (entry && entry.value && (entry.creationTime < oldestCreationTime)) {
                    oldestCreationTime = entry.creationTime;
                    oldestMovieId = m;
                }
                return true;
            });
            movieToBeRemoved = expiredMovieId || oldestMovieId;
        }
            
        if (movieToBeRemoved) {
            self.clearData(movieToBeRemoved, field, capabilities);
        }
        if (this.isDebug) {
            this.log.debug("makespace ", {'maxCount': maxCount, 'currentCount': movieCache['numEntries'], 'field': field, 'movieId': movieId,'movieToBeRemoved': movieToBeRemoved});
        }
    }
};
// deletes all other entries from cache, other than for movieId provided
// fields is a mandatory field. it must be an array like ['manifest','ldl']
CacheManager.prototype.clearAllOtherData = function(movieId, fields) {
    var _self = this;
    _self.debugAssert(typeof movieId !== 'undefined');
    var movieIdStr = movieId + '';
    fields.forEach(function(field) {
        var cache = _self.movieMap[field];
        if (!cache) { // no data for this field
            return;
        }
        Object.keys(cache).forEach(function(k) {
            if (k != movieIdStr) {
                _self.clearData(k, field);
            }
        });
    });
};

CacheManager.prototype.clearData = function clearData(movieId, field, caps) {
    this.debugAssert(typeof movieId !== 'undefined');
    this.debugAssert(typeof field !== 'undefined');
    var fieldCache = this.movieMap[field];
    var movieData = fieldCache ? fieldCache[movieId] : undefined;
    var capabilities = caps ? caps : DefaultCaps;
    if (movieData && movieData[capabilities]) {
        fieldCache['size'] -= movieData[capabilities].size;
        fieldCache['numEntries']--;
        var entry = movieData && movieData[capabilities];
        if (entry) {
            movieData[capabilities] = undefined;
            if (entry.destroyFn) {
                entry.destroyFn();
            }
        }
        // TODO send event 
        if (this.eventEmitter) {
            this.emit("deletedCacheItem", entry);
        }
    }
};

CacheManager.prototype.flush = function flush(field) {
    this.debugAssert(typeof field !== 'undefined');
    var movieMap = this.movieMap;
    movieMap[field] = createMap();
    movieMap[field]['numEntries'] = 0;
    movieMap[field]['size'] = 0;
};

CacheManager.prototype.cleanUp = function cleanUp(field, caps) {
    this.debugAssert(typeof field !== 'undefined');
    var self = this;
    var movieMap = this.movieMap;
    var movies;
    var capabilities = caps ? caps : DefaultCaps;
    if (movieMap[field] instanceof Object) {
        movies = Object.keys(movieMap[field]);
        movies.forEach(function(movie) {
            var entry = movieMap[field][movie][capabilities];
            if ((self.clock.getTime() - entry.creationTime) > expiryMap[field]) {
                this.clearData(movie, field, capabilities);
            }
        });
    }
};

CacheManager.prototype.isExpired = function isExpired(field, creationTime) {
    return (this.clock.getTime() - creationTime) > expiryMap[field];
};

CacheManager.prototype.getStats = function getStats(startTime, endTime, caps) {
    var data = {},
        self = this,
        movieMap = self.movieMap,
        captureDelta = isDefined(startTime) && isDefined(endTime),
        capabilities = caps || DefaultCaps;

    Object.keys(movieMap).forEach(function(field) { //manifest or ldl
        var movieIds = Object.keys(movieMap[field]),
            entry = movieMap[field];
        movieIds.forEach(function(m) {
            var v = entry && entry[m] && entry[m][capabilities];
            if (!v || !isDefined(v.value) || (v.value instanceof this.Promise)) {
                return;
            }

            data[field] = (data[field] | 0) + 1;
            if (self.isExpired(v.type, v.creationTime)) {
                data[field + '_expired'] = (data[field + '_expired'] | 0) + 1;
            }
            if (captureDelta && v.creationTime >= startTime && v.creationTime < endTime) {
                data[field + '_delta'] = (data[field + '_delta'] | 0) + 1;
            }
        });
    });

    return data;
};

CacheManager.prototype.setMaxCount = function setMaxCount(field, count) {
    this.debugAssert(typeof field !== "undefined");
    this.debugAssert(typeof count !== "undefined");
    cacheSizeCountMap[field] = count;
};

CacheManager.prototype.setMaxSize = function setMaxSize(field, size) { // Size in bytes
    this.debugAssert(typeof field !== "undefined");
    this.debugAssert(typeof size !== "undefined");
    cacheSizeBytesMap[field] = size;
};

CacheManager.prototype.getCurrentSize = function getSize(field) { // Size in bytes
    this.debugAssert(typeof field !== "undefined");
    return (this.movieMap[field]) ? this.movieMap[field]['size'] : 0;
};

CacheManager.prototype.getCurrentCount = function getCount(field) {
    this.debugAssert(typeof field !== "undefined");
    return (this.movieMap[field]) ? this.movieMap[field]['numEntries'] : 0;
};

CacheManager.prototype.debugAssert = function debugAssert(x) {
    if (!x) {
        {
            this.log.error("Debug Assert Failed for" + x);
        }
    }
};
function isDefined(x) {
    return typeof x !== 'undefined';
}
module.exports = CacheManager;

},{"90":90,"95":95}],90:[function(require,module,exports){
var isCyclicObject = function(obj) {
  var seenObjects = [];

  var detect = function detect (obj) {
    if (obj && typeof obj === 'object') {
      if (seenObjects.indexOf(obj) !== -1) {
        return true;
      }
      seenObjects.push(obj);
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && detect(obj[key])) {
          return true;
        }
      }
    }
    return false;
  };

  return detect(obj);
};
var getJsonObjectSize = function getJsonObjectSize(obj, doCyclicCheck){
    if (doCyclicCheck) {
        if (isCyclicObject(obj)) { return -1;}
    }
    var objectList = [];
    var stack = [ obj ];
    var bytes = 0;

    while ( stack.length ) {
        var value = stack.pop();

        if ( typeof value === 'boolean' ) {
            bytes += 4;
        }
        else if ( typeof value === 'string' ) {
            bytes += value.length * 2;
        }
        else if ( typeof value === 'number' ) {
            bytes += 8;
        }
        else if
        (
            typeof value === 'object'
            && objectList.indexOf( value ) === -1
        )
        {
            objectList.push( value );

            for( var i in value ) {
                stack.push( value[ i ] );
            }
        }
    }
    return bytes;
};

module.exports = getJsonObjectSize;

},{}],91:[function(require,module,exports){
var BASE16_DIGITS = '0123456789ABCDEF';

/**
* @constructor
*/
function DataStream(buffer) {
    // debug$assert(isArray(buffer) || isUint8Array(buffer));

    this.buffer = buffer;
    this.position = 0;
}

DataStream.prototype = {
    
    seek: function (position) {
        // debug$assert(position >= 0 && position <= this.buffer.length);
        this.position = position;
    },

    skip: function (bytesToSkip) {
        // debug$assert(bytesToSkip <= this.getRemaining());
        this.position += bytesToSkip;
    },

    getPosition: function () {
        return this.position;
    },

    getRemaining: function () {
        return this.buffer.length - this.position;
    },

    getLength: function () {
        return this.buffer.length;
    },

    isEndOfStream: function () {
        return this.position >= this.buffer.length;
    },

    readByte: function () {
        return this.buffer[this.position++];
    },

    readArray: function (length) {
        // debug$assert(length <= this.getRemaining());
        var oldPosition = this.position;
        this.position += length;
        var buffer = this.buffer;
        if (buffer.subarray) {
            // it's a Uint8Array
            return buffer.subarray(oldPosition, this.position);
        } else {
            // it's a regular array, return a regular array
            return buffer.slice(oldPosition, this.position);
        }
    },

    readNumber: function (bytes) {
        var ret = 0;
        while (bytes--) {
            ret = (ret * 256) + this.buffer[this.position++];
        }
        return ret;
    },

    readChars: function (length) {
        var ret = '';
        while (length--) {
            ret += String.fromCharCode(this.buffer[this.position++]);
        }
        return ret;
    },

    readNullTerminatedString: function () {
        var ret = '';
        var b;
        while (b = this.readByte()) {
            ret += String.fromCharCode(b);
        }
        return ret;
    },

    readUShort: function () {
        return this.readNumber(2);
    },

    readUInt: function () {
        return this.readNumber(4);
    },

    readULong: function () {
        return this.readNumber(8);
    },

    readFixedPoint8x8: function () {
        return this.readNumber(2) / 0x100;
    },

    readFixedPoint16x16: function () {
        return this.readNumber(4) / 0x10000;
    },

    /**
    * @param {number} length
    */
    readBytesAsHex: function (length) {
        var b;
        var hex = '';
        while(length--) {
            b = this.readByte();
            hex += BASE16_DIGITS[b >>> 4] + BASE16_DIGITS[b & 0xF];
        }
        return hex;
    },

    readGuid: function () {
        return this.readBytesAsHex(4) + '-' +
            this.readBytesAsHex(2) + '-' +
            this.readBytesAsHex(2) + '-' +
            this.readBytesAsHex(2) + '-' +
            this.readBytesAsHex(6);
    },

    readNumberLittleEndian: function (bytes) {
        var ret = 0;
        for (var i = 0; i < bytes; i++) {
            ret += this.readByte() << (i << 3);
        }
        return ret;
    }, 

    readUIntLittleEndian: function () {
        return this.readNumberLittleEndian(4);
    },

    /**
    * @param {number} length
    */
    readBytesAsHexLittleEndian: function (length) {
        var b;
        var hex = '';
        var i = length;
        while(i--) {
            b = this.buffer[this.position + i];
            hex += BASE16_DIGITS[b >>> 4] + BASE16_DIGITS[b & 0xF];
        }
        this.skip(length);
        return hex;
    },    

    readGuidLittleEndian: function () {
        return this.readBytesAsHexLittleEndian(4) + '-' +
            this.readBytesAsHexLittleEndian(2) + '-' +
            this.readBytesAsHexLittleEndian(2) + '-' +
            this.readBytesAsHex(2) + '-' +
            this.readBytesAsHex(6);
    },

    writeUShort: function (value) {
        this.writeNumber(value, 2);
    },

    writeUInt: function (value) {
        this.writeNumber(value, 4);
    },

    writeULong: function (value) {
        this.writeNumber(value, 8);
    },

    writeByte: function (b) {
        this.buffer[this.position++] = b;
    },

    writeNumber: function (number, bytes) {
        this.position += bytes;
        for (var delta = 1; delta <= bytes; delta++) {
            this.buffer[this.position - delta] = number & 0xFF;
            // Note: bitshifting doesn't work for anything above 32 bit, unfortunately
            number = Math.floor(number / 0x100);
        }
    },

    writeChars: function (s) {
        for (var i = 0; i < s.length; i++) {
            this.buffer[this.position++] = s.charCodeAt(i);
        }
    },

    writeArray: function (src) {
        // TODO: can this be done faster?
        var l = src.length;
        for (var i = 0; i < l; i++) {
            this.buffer[this.position++] = src[i];
        }
    },

    writeFromStream: function (stream, length) {
        this.writeArray(stream.readArray(length));
    }

};

module.exports = DataStream;
},{}],92:[function(require,module,exports){
/**
 * Basic EventEmitter functionality that
 * can be mixed in to object literals. Note
 * that this creates a "._listeners" object
 * when it is mixed in with an object
 */

/**
 * Add an event listener
 *
 * returns true if listener was successfully added
 * throws a type error on an error condition:
 *    listener argument not included
 *    listener argument not a function
 *    event argument not a string
 */

function addEventListener(event, listener) {
    var list;

    if (listener === undefined ||
        typeof listener !== "function" ||
        typeof event !== "string") {

        // error condition
        // return false;
        throw new TypeError("EventEmitter: addEventListener requires a string and a function as arguments");
    }

    if (this._listeners === undefined) {
        this._listeners = {};
        this._listeners[event] = [listener];
        return true;
    }

    list = this._listeners[event];

    if (list === undefined) {
        this._listeners[event] = [listener];
        return true;
    }

    if (list.indexOf(listener) < 0) {
        list.push(listener);
        return true;
    }

    // The listener already existed
    return false;
}

/**
 * Remove an event listener
 * returns true if listener was removed
 * returns false on error condition:
 *      listener undefined
 *      listener not a function
 *      event not a string
 */
function removeEventListener(event, listener) {
    var indexToRemove,
        list;

    if (listener === undefined ||
        typeof listener !== "function" ||
        typeof event !== "string") {

        throw new TypeError("EventEmitter: removeEventListener requires a string and a function as arguments");
    }

    if (this._listeners === undefined ) {
        return false;
    }

    list = this._listeners[event];

    if (list === undefined) {
        return false;
    }

    indexToRemove = list.indexOf(listener);

    if (indexToRemove < 0) {
        return false;
    }

    // Removing the last listener for this event
    if (list.length === 1) {
        delete this._listeners[event];
        return true;
    }

    // Removing it, but it is not the last
    list.splice(indexToRemove, 1);
    return true;
}

/**
 * Calls all listeners listening for an event
 *
 * Returns false on error condition:
 *   no listeners defined at all
 *   no listeners for given event
 *
 */
function callEventListeners(event, data) {
    var list = this._listeners ? this._listeners[event] : undefined;
    if (!list) {
        return false;
    }

    list.forEach(function (listener) {
        listener(data);
    });

    return true;
}

/**
 * Removes all listeners for an event, or all listeners if no event
 */

function removeAllListeners(event) {
    if (this._listeners) {
        if (event === undefined) {
            delete this._listeners;
        } else {
            delete this._listeners[event];
        }
    }
    return this;
}

module.exports = {
    addEventListener:       addEventListener,
    on:                     addEventListener,   // alias
    removeEventListener:    removeEventListener,
    callEventListeners:     callEventListeners,
    emit:                   callEventListeners, // alias
    removeAllListeners:     removeAllListeners
};


},{}],93:[function(require,module,exports){

function tracer(console, listener, event, data) {
    console.trace(":", event, ":", data);
    listener(data);
}

function EventListenerGroup(console) {
    this.listeners = [];
    this.console = console;
}

EventListenerGroup.prototype.constructor = EventListenerGroup;

EventListenerGroup.prototype.addEventListener = function(emitter, event, listener, thisArg) {
    var boundListener = thisArg ? listener.bind(thisArg) : listener,
        added = false;
    if (emitter) {
        if (this.console) {
            boundListener = tracer.bind(null, this.console, boundListener, event);
        }
        if (typeof emitter.addEventListener === "function") {
            added = emitter.addEventListener(event, boundListener);
        }
        else if (typeof emitter.addListener === "function") {
            added = emitter.addListener(event, boundListener);
        }
        else {
            throw new Error("Emitter does not have a function to add listeners for '" + event + "'");
        }
        this.listeners.push([emitter, event, boundListener]);
    }
    return added;
};

EventListenerGroup.prototype.on = EventListenerGroup.prototype.addEventListener;

EventListenerGroup.prototype.clear = function() {
    var removed = this.listeners.length;
    this.listeners.forEach(function(tuple) {
        var emitter = tuple[0],
            event = tuple[1],
            listener = tuple[2];
        if (typeof emitter.removeEventListener === "function") {
            emitter.removeEventListener(event, listener);
        }
        else if (typeof emitter.removeListener === "function") {
            emitter.removeListener(event, listener);
        }
    });
    this.listeners = [];
    if (this.console) {
        this.console.trace("removed", removed, "listener(s)");
    }
};

module.exports = EventListenerGroup;

},{}],94:[function(require,module,exports){
module.exports = {
    EventEmitter: require(92),
    EventListenerGroup: require(93)
};

},{"92":92,"93":93}],95:[function(require,module,exports){
/**
 * Mixin the contents of one object literal (the provider) into
 * another object literal (the receiver)
 */
var mixin = function (provider, receiver) {
    var key;

    for (key in provider) {
        if (provider.hasOwnProperty(key)) {
            receiver[key] = provider[key];
        }
    }

    return receiver;
};

module.exports = mixin;

},{}],96:[function(require,module,exports){
var DataStream = require(91);

// box type must look like this
var BOX_TYPE_PATERN = /^[a-zA-Z0-9-]{4,4}$/;

/**
 * Reads an MP4 box from given buffer, at given offset
 * Returns nothing if entire box cannot be read.
 */
function readBox(buffer, offset) {
    var stream = new DataStream(buffer);
    if (offset) stream.seek(offset);
    return readBoxFromStream(stream);
}

/**
 * Reads all complete boxes from given buffer, starting at given offset.
 * @param {Uint8Array} buffer
 */
function readAllBoxes(buffer, offset) {
    if (!buffer) {
        throw new Error('mp4-badinput');
    }

    var stream = new DataStream(buffer),
        boxes = [],
        box;

    if (offset) stream.seek(offset);

    while ((box = readBoxFromStream(stream))) {
        boxes.push(box);
    }

    return boxes;
}

/**
 * @constructor
 */
function Box(type, size, contentLength) {
    // debug$assertString(type);
    // debug$assertUInt(contentLength);

    this.type = type;
    this.size = size;
    this.contentLength = contentLength;
}

/**
 * Given path, return the descendant node if it exists.
 * For example: moovBox.getDescendant('trak/mdia/minf/smhd') or 
 *   moovBox.getDescendant('trak/mdia/minf/stbl/stsd/encv|enca'), 
 *   each entry can have multiple matches seperated by pipe
 */
Box.prototype.getDescendant = function(path) {
    var box = this,
        trail = path.split('/'),
        child,
        childTypes,
        childType,
        i,
        j;
    for (i = 0; (i < trail.length) && box; i++) {
        childTypes = trail[i].split('|');
        child = undefined;
        for(j = 0; (j < childTypes.length) && (!child); j++) {
            childType = childTypes[j];
            child = box.firstChildByType && box.firstChildByType[childType];
        }
        box = child;
    }
    return box;
};

Box.prototype.toString = function() {
    return '[' + this.type + ']';
};

/**
 * Reads an MP4 box from given stream
 */
function readBoxFromStream(stream) {
    var boxHeader = readBoxHeader(stream);
    if (boxHeader && boxHeader.contentLength <= stream.getRemaining()) {
        return readBoxContent(stream, boxHeader);
    }
}

/**
 * Reads MP4 box header from given stream, returns undefined if end of stream is reached before box can be read.
 * throws if invalid content is detected.
 */
function readBoxHeader(stream) {
    var offset = stream.getPosition(),
        size,
        type;

    if (stream.getRemaining() >= 8) {
        size = stream.readUInt();
        type = stream.readChars(4);

        if (!BOX_TYPE_PATERN.test(type)) {
            stream.seek(offset);
            throw new Error('mp4-badtype');
        }

        if (size == 1) {
            // it's a long size
            if (stream.getRemaining() < 8) {
                // header is incomplete
                stream.seek(offset);
                return;
            }
            size = stream.readULong();
        }

        if (!(size >= 8)) {
            stream.seek(offset);
            throw new Error('mp4-badsize');
        }

        if (type == 'uuid') {
            // this is a user defined box
            if (stream.getRemaining() < 16) {
                // header is incomplete
                stream.seek(offset);
                return;
            }
            type = stream.readGuid();
        }

        return {
            type: type,
            offset: offset,
            size: size,
            contentLength: offset + size - stream.getPosition()
        };
    }
}

/**
 * Reads box content from given stream, returns a fully constructed Mp4 box
 * throws if stream is short or invalid content is detected.
 */
function readBoxContent(stream, boxHeader) {
    var type = boxHeader.type,
        size = boxHeader.size,
        contentLength = boxHeader.contentLength,
        box = new Box(type, size, contentLength),
        parser = boxParsers[type];

    if (stream.getRemaining() < contentLength) {
        throw new Error('mp4-shortcontent');
    }

    if (parser) {
        var contentStream = new DataStream(stream.readArray(contentLength));
        parser(box, contentStream);
        // debug$assert(contentStream.getRemaining() == 0);
    } else {
        stream.skip(contentLength);
    }

    // hang on to raw data
    stream.seek(boxHeader.offset);
    box.raw = stream.readArray(size);

    return box;
}

function readChildren(box, stream) {
    var children = [];
    var firstChildByType = {};
    var child;
    var type;
    while (stream.getRemaining() > 0) {
        child = readBoxFromStream(stream);
        if (!child) {
            // while there is data in stream, there must be children
            throw new Error('mp4-badchildren');
        }
        type = child.type;
        children.push(child);
        if (!firstChildByType[type]) {
            firstChildByType[type] = child;
        }
    }
    box.children = children;
    box.firstChildByType = firstChildByType;
}

function readFullBox(box, stream) {
    box.version = stream.readNumber(1);
    box.flags = stream.readNumber(3);
}

function readSampleEntryBox(box, stream) {
    // 6 bytes are reserved
    stream.skip(6);
    box.dataReferenceIndex = stream.readUShort();
}

function readAudioSampleEntryBox(box, stream) {
    readSampleEntryBox(box, stream);

    // reserved int[2]
    stream.skip(4 * 2);

    box.channelCount = stream.readUShort();
    box.sampleSize = stream.readUShort();

    // predefined short
    // reserved short
    stream.skip(2 + 2);

    box.sampleRate = stream.readUShort();

    // skip short
    stream.skip(2);

    readChildren(box, stream);
}

function readVisualSampleEntryBox(box, stream) {
    readSampleEntryBox(box, stream);

    // short = 0, short reserved, 3x int reseved
    stream.skip(16);

    box.width = stream.readUShort();
    box.height = stream.readUShort();
    box.horizResolution = stream.readUInt();
    box.vertResolution = stream.readUInt();
    stream.skip(4);
    box.frameCount = stream.readUShort();

    var size = stream.readByte();

    // debug$assert(size <= 31);

    box.compressorName = stream.readChars(size);
    // padding
    stream.skip(31 - size);

    box.depth = stream.readUShort();

    stream.skip(2);

    readChildren(box, stream);
}

function readTrackEncryptionBox(box, stream) {
    readFullBox(box, stream);
    box.defaultAlgorithmId = stream.readNumber(3);
    box.defaultIvSize = stream.readByte();
    box.keyId = stream.readArray(16);
}

function parseNalSets(stream, count) {
    var ret = [];
    var length;
    while (count--) {
        length = stream.readUShort();
        ret.push(stream.readArray(length));
    }
    return ret;
}

function readSampleFlags(stream) {
    var flagBytes = stream.readArray(2);

    var flags = {
        // ........ ....XXX.
        samplePaddingValue: (flagBytes[1] >> 1) & 0x07,
        // ........ .......X
        sampleIsDifferenceSample: !!(flagBytes[1] & 0x01),

        sampleDegradationPriority: stream.readUShort()
    };

    // ......XX XXXX....
    parseSampleFlags(flags, ((flagBytes[0] << 8) | flagBytes[1]) >> 4);

    return flags;
}

function parseSampleFlags(flags, b) {
    // ..XX....
    flags.sampleDependsOn = (b >> 4) & 0x03;
    // ....XX..
    flags.sampleIsDependedOn = (b >> 2) & 0x03;
    // ......XX
    flags.sampleHasRedundancy = b & 0x03;

    return flags;
}

var boxParsers = {

    'ftyp': function(box, stream) {
        box.majorBrand = stream.readChars(4);
        box.minorBrand = stream.readUInt();
        box.compatibleBrands = [];
        while (stream.getRemaining() >= 4) {
            box.compatibleBrands.push(stream.readChars(4));
        }
    },

    'moov': readChildren,

    'sidx': function(box, stream) {
        readFullBox(box, stream);
        box.referenceTrackId = stream.readUInt();
        box.timeScale = stream.readUInt();
        box.earliestPresentationTime = (box.version >= 1) ? stream.readULong() : stream.readUInt();
        box.firstOffset = (box.version >= 1) ? stream.readULong() : stream.readUInt();
        stream.skip(2);

        var referenceCount = stream.readUShort();
        var references = [];
        var c1, type, size, duration;
        while (referenceCount--) {
            c1 = stream.readUInt();
            type = c1 >> 31; // take the first bit
            if (type !== 0) {
                throw new Error('mp4-badsdix');
            }
            size = c1 & 0x7fffffff; // drop the first bit
            duration = stream.readUInt();
            // skip RandomAccessPointDeltaTime 
            stream.skip(4);
            references.push({
                size: size,
                duration: duration
            });
        }
        box.references = references;
    },

    'moof': readChildren,

    // -- moov/*

    'mvhd': function(box, stream) {
        readFullBox(box, stream);
        var fieldSize = box.version >= 1 ? 8 : 4;

        box.creationTime = stream.readNumber(fieldSize);
        box.modificationTime = stream.readNumber(fieldSize);
        box.timeScale = stream.readUInt();
        box.duration = stream.readNumber(fieldSize);

        box.rate = stream.readFixedPoint16x16();
        box.volume = stream.readFixedPoint8x8();

        // reserved bit(16)  
        // reserved int(32)[2]
        // not used: matrix 3x3 ints
        // not used: preDefined is int[6]
        stream.skip(2 + 4 + 4 + 4 * 9 + 4 * 6);

        box.nextTrackId = stream.readUInt();
    },

    'pssh': function(box, stream) {
        // PLAYREADY = '9A04F079-9840-4286-AB92-E65BE0885F95'
        // WIDEVINE a.k.a. NETFLIX = '29701FE4-3CC7-4A34-8C5B-AE90C7439A47'
        // WIDEVINE2 = 'EDEF8BA9-79D6-4ACE-A3C8-27DCD51D21ED'

        readFullBox(box, stream);
        box.drmSystemId = stream.readGuid();
        var dataSize = stream.readUInt();
        box.data = stream.readArray(dataSize);
    },

    'trak': readChildren,

    // -- moov/trak/*

    'mdia': readChildren,

    // -- moov/trak/mdia/*

    'minf': readChildren,


    // -- moov/trak/mdia/minf/*

    'stbl': readChildren,

    // -- moov/trak/mdia/minf/stbl/*

    'stsd': function(box, stream) {
        readFullBox(box, stream);
        var count = stream.readUInt();
        readChildren(box, stream);
        // debug$assert(box.children.length == count);
    },

    // -- moov/trak/mdia/minf/stbl/stsd/*

    'encv': readVisualSampleEntryBox,

    'avc1': readVisualSampleEntryBox,

    'hvcC': readVisualSampleEntryBox,

    'hev1': readVisualSampleEntryBox,

    'mp4a': readAudioSampleEntryBox,

    'enca': readAudioSampleEntryBox,

    'ec-3': readAudioSampleEntryBox,

    // -- moov/trak/mdia/minf/stbl/stsd/encv|avc1/*

    'avcC': function(box, stream) {
        box.version = stream.readByte();
        // debug$assert(box.version == 1);

        box.avcProfileIndication = stream.readByte();
        box.profileCompatibility = stream.readByte();
        box.avcLevelIndication = stream.readByte();

        // bit(6) reserved = 111111b
        box.lengthSize = (stream.readByte() & 0x03) + 1;

        box.sequenceParameterSetNALUnits = parseNalSets(stream, stream.readByte() & 0x1F);
        box.pictureParameterSetNALUnits = parseNalSets(stream, stream.readByte());
    },

    'pasp': function(box, stream) {
        box.hSpacing = stream.readUInt();
        box.vSpacing = stream.readUInt();
    },

    'sinf': readChildren,

    // -- moov/trak/mdia/minf/stbl/stsd/encv|avc1/sinf/*

    'frma': function(box, stream) {
        box.dataFormat = stream.readChars(4);
    },

    'schm': function(box, stream) {
        readFullBox(box, stream);
        box.schemeType = stream.readChars(4);
        box.schemeVersion = stream.readUInt();
        if (box.flags & 0x01 /* HasSchemeUriFlag */ ) {
            box.schemeUri = stream.readNullTerminatedString();
        }
    },

    'schi': readChildren,

    // -- moov/trak/mdia/minf/stbl/stsd/encv|avc1/sinf/schi

    'tenc': readTrackEncryptionBox,

    // -- moov/*

    'mvex': readChildren,

    // -- moov/mvex/*

    // NotImplemented
    // 'mehd': function (box, stream) { },

    'trex': function(box, stream) {
        readFullBox(box, stream);
        box.trackId = stream.readUInt();
        box.defaultSampleDescriptionIndex = stream.readUInt();
        box.defaultSampleDuration = stream.readUInt();
        box.defaultSampleSize = stream.readUInt();

        box.defaultSampleFlags = readSampleFlags(stream);
    },

    // -- moof/*

    'traf': readChildren,

    // -- moof/traf/*

    'tfhd': function(box, stream) {
        readFullBox(box, stream);
        box.trackId = stream.readUInt();
        var flags = box.flags;
        if (flags & 0x01) box.baseDataOffset = stream.readULong();
        if (flags & 0x02) box.sampleDescriptionIndex = stream.readUInt();
        if (flags & 0x08) box.defaultSampleDuration = stream.readUInt();
        if (flags & 0x10) box.defaultSampleSize = stream.readUInt();
        if (flags & 0x20) box.defaultSampleFlags = readSampleFlags(stream);
    },

    'saio': function(box, stream) {
        readFullBox(box, stream);
        if (box.flags & 0x01) {
            box.auxInfoType = stream.readUInt();
            box.auxInfoTypeParameter = stream.readUInt();
        }
        var fieldSize = box.version >= 1 ? 8 : 4;
        var entryCount = stream.readUInt();
        var sampleInfoOffsets = [];
        var entryOffset = stream.getPosition();
        while (entryCount--) {
            sampleInfoOffsets.push(stream.readNumber(fieldSize));
        }
        box.sampleInfoOffsets = sampleInfoOffsets;
    },

    'mdat': function(box, stream) {
        box.data = stream.readArray(stream.getRemaining());
    },

    // -- moov/trak/*

    'tkhd': function(box, stream) {
        readFullBox(box, stream);
        var fieldSize = box.version >= 1 ? 8 : 4;

        box.creationTime = stream.readNumber(fieldSize);
        box.modificationTime = stream.readNumber(fieldSize);
        box.trackId = stream.readUInt();
        // reserved int
        stream.skip(4);
        box.duration = stream.readNumber(fieldSize);
        // reserved int[2]
        stream.skip(4 * 2);
        box.layer = stream.readUShort();
        box.alternateGroup = stream.readUShort();
        box.volume = stream.readFixedPoint8x8();
        // reserved 16 bits
        stream.skip(2);
        // unused int[3x3]
        stream.skip(4 * 9);
        box.width = stream.readFixedPoint16x16();
        box.height = stream.readFixedPoint16x16();
    },

    // -- moov/trak/mdia/*

    'mdhd': function(box, stream) {
        readFullBox(box, stream);
        var fieldSize = box.version >= 1 ? 8 : 4;
        box.creationTime = stream.readNumber(fieldSize);
        box.modificationTime = stream.readNumber(fieldSize);
        box.timeScale = stream.readUInt();
        box.duration = stream.readNumber(fieldSize);

        // language is presented as skip 1 bit and 3x (5 bit char), 16 bits presenting 3 chars
        var l = stream.readUShort();
        box.language =
            String.fromCharCode(((l >> 10) & 0x1f) + 0x60) +
            String.fromCharCode(((l >> 5) & 0x1f) + 0x60) +
            String.fromCharCode(((l) & 0x1f) + 0x60);

        // reserved: 2 bytes
        stream.skip(2);
    },

    // -- moov/trak/mdia/minf/*

    // NotImplemented
    // 'vmhd': function (box, stream) { },

    // NotImplemented
    // 'dinf': function (box, stream) { },

    // -- moof/*

    'mfhd': function(box, stream) {
        readFullBox(box, stream);
        box.sequenceNumber = stream.readUInt();
    },

    // -- moof/traf/*

    'tfdt': function(box, stream) {
        readFullBox(box, stream);
        var fieldSize = box.version >= 1 ? 8 : 4;
        box.baseMediaDecodeTime = stream.readNumber(fieldSize);
        // TODO: extra 8 bytes don't match the spec... and not all streams have them
        if (stream.getRemaining() == 8) {
            stream.skip(8);
        }
    },

    'saiz': function(box, stream) {
        readFullBox(box, stream);
        if (box.flags & 0x01) {
            box.auxInfoType = stream.readUInt();
            box.auxInfoTypeParameter = stream.readUInt();
        }
        var defaultSampleInfoSize = stream.readByte();
        var sampleCount = stream.readUInt();
        var sampleInfoSizes = [];
        while (sampleCount--) {
            sampleInfoSizes.push(defaultSampleInfoSize || stream.readByte());
        }
        box.sampleInfoSizes = sampleInfoSizes;
    },

    'trun': function(box, stream) {
        readFullBox(box, stream);
        var sampleCount = stream.readUInt();
        var flags = box.flags;
        if (flags & 0x01) box.dataOffset = stream.readUInt();
        if (flags & 0x04) box.firstSampleFlags = readSampleFlags(stream);

        var samples = [];
        var sample;
        while (sampleCount--) {
            sample = {};
            if (flags & 0x100) sample.duration = stream.readUInt();
            if (flags & 0x200) sample.size = stream.readUInt();
            if (flags & 0x400) sample.flags = stream.readUInt();
            if (flags & 0x800) sample.compositionTimeOffset = stream.readUInt();
            samples.push(sample);
        }
        box.samples = samples;
    },

    'sdtp': function(box, stream) {
        readFullBox(box, stream);
        var samples = [];
        while (stream.getRemaining() > 0) {
            samples.push(parseSampleFlags({}, stream.readByte()));
        }
        box.samples = samples;
    },

    // UUID - Netflix header box
    '4E657466-6C69-7850-6966-665374726D21': function(box, stream) {
        readFullBox(box, stream);
        box.fileSize = stream.readULong();
        box.timeScale = stream.readULong();
        box.duration = stream.readULong();
        box.offsetToFirstMoof = stream.readULong();
        box.sizeOfAllMoofAndMDat = stream.readULong();

        if (box.version >= 1) {
            box.netflixIndexOffset = stream.readULong();
            box.netflixIndexSize = stream.readUInt();
            box.offsetToFirstSidx = stream.readULong();
            box.firstSidxSize = stream.readUInt();
            box.fileId = stream.readGuid();
        }
    },

    // UUID - Sample encryption box
    'A2394F52-5A9B-4F14-A244-6C427C648DF4': function(box, stream) {
        readFullBox(box, stream);
        // Override TrackEncryptionBox parameters?
        if (box.flags & 0x01) {
            box.algorithmID = stream.readNumber(3);
            box.ivSize = stream.readByte();
            box.kid = stream.readGuid();
        }
        box.sampleCount = stream.readUInt();
        // Note: we only care to find the location of samples, in order
        // to implement this parsing properly we should read algorithmID, ivSize and KID from Track Encryption Box 
        box.auxData = stream.readArray(stream.getRemaining());
    },

    // UUID - Netflix frame rate box
    '4E657466-6C69-7846-7261-6D6552617465': function(box, stream) {
        readFullBox(box, stream);
        box.numerator = stream.readUInt();
        box.denominator = stream.readUShort();
    },

    // UUID - track encryption box (now replaced with "tenc")
    '8974DBCE-7BE7-4C51-84F9-7148F9882554': readTrackEncryptionBox,

    // UUID - ISCTrack 'itrk'
    '636F6D2E-6E65-7466-6C69-782E6974726B': readChildren,

    // UUID - Header Info 'hinf'
    '636F6D2E-6E65-7466-6C69-782E68696E66': function(box, stream) {
        readFullBox(box, stream);
        box.assetId = stream.readGuid();
        box.creationTime = stream.readULong();
        box.movieId = stream.readULong();
        box.packageId = stream.readULong();
        box.rootContainerExtentX = stream.readUShort();
        box.rootContainerExtentY = stream.readUShort();
        box.languageCode = stream.readArray(16);
        box.subtitleType = stream.readArray(16);   
    },

    // UUID - Version Info 'vinf'
    '636F6D2E-6E65-7466-6C69-782E76696E66': function(box, stream) {
        readFullBox(box, stream);
        box.builtWithLibraryVersion = stream.readArray(stream.getRemaining());
    },

    // UUID - Master Index 'midx'
    '636F6D2E-6E65-7466-6C69-782E6D696478': function(box, stream) {
        readFullBox(box, stream);
        box.segmentOffset = stream.readULong();
        var segmentCount = stream.readUInt();
        box.segments = [];
        for (var i=0; i < segmentCount; i++) {
            box.segments.push({
                duration: stream.readUInt(),
                size: stream.readUShort()
            });
        }
    },

    // UUID - Segment Index 'iseg'
    '636F6D2E-6E65-7466-6C69-782E69736567': readChildren,

    // UUID - Segment Index 'sidx'
    '636F6D2E-6E65-7466-6C69-782E73696478': function(box, stream) {
        readFullBox(box, stream);
        box.assetId = stream.readGuid();
        box.duration = stream.readUInt();
        var sampleCount = stream.readUInt();
        box.samples = [];
        for (var i = 0; i < sampleCount; i++) {
            box.samples.push({
                displayTime: stream.readUInt(),
                duration: stream.readUInt(),
                originX: stream.readUShort(),
                originY: stream.readUShort(),
                sizeX: stream.readUShort(),
                sizeY: stream.readUShort(),
                imageStartPosition: stream.readULong(),
                imageSize: stream.readUInt()
            });
        }
    },

    // UUID - Segment Encryption Info 'senc'
    '636F6D2E-6E65-7466-6C69-782E73656E63': function(box, stream) {
        readFullBox(box, stream);
        var sampleCount = stream.readUInt();
        var defautlt_ivSize = stream.readByte();
        box.samples = [];
        for (var i = 0; i < sampleCount; i++) {
            var encryptionModeAndivSize = stream.readByte();
            // 0 is none, 1 is AES-CTR, 2 is AES-CBC
            var encryptionMode = encryptionModeAndivSize >> 6;
            var ivSize = encryptionModeAndivSize & 0x3F;
            if (encryptionMode != 0 && ivSize === 0) {
                ivSize = defautlt_ivSize;
            }
            box.samples.push({
                encryptionMode: encryptionMode,
                iv: stream.readArray(ivSize)
            });
        }
    }    
};

module.exports = {

    readBox: readBox,

    readAllBoxes: readAllBoxes

};
},{"91":91}],97:[function(require,module,exports){
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

/* jshint -W030 */

var mixin = require(95);
var EventEmitter = require(94).EventEmitter;

//------------------------------------------------------------------------------
// The keys for these objects are the local keys
//------------------------------------------------------------------------------

var defaults = {};
var persistent = Object.create(defaults);
var overrides = Object.create(persistent);
var config = Object.create(overrides);

//------------------------------------------------------------------------------
// Maps the foreign name to the local key
//------------------------------------------------------------------------------

var names = {};

//------------------------------------------------------------------------------
// Stores conversion functions using the foreign name
// (Because only updated values need to be converted)
//------------------------------------------------------------------------------

var conversions = {};

//------------------------------------------------------------------------------
// Options that - when they are set - are undeclared go here until they get
// declared. They are keyed on the foreign name, and the value for each name
// is an array of tuples. Each tuple has the destination object as the first
// item (persisten or overrides) and the value as the second.
//------------------------------------------------------------------------------

var undeclared = {};

//------------------------------------------------------------------------------
// Declare options by passing an object where each item is an array of 2 or 3
// values.
// The first value is the foreign name of the option. This can be an
// array of possible names.
// The second value is the default value (and implies the option's type). This
// can also be a function that returns the default value.
// The third value is optionally a function that will convert a string to the
// correctly typed value for the option.
//------------------------------------------------------------------------------

config.declare = function configDeclare(values) {
    Object.keys(values).forEach(function(key) {
        var tuple = values[key],
            declaredNames = tuple[0],
            defaultValue = tuple[1],
            conversion = tuple[2];

        // This is a programmatic errors - some declare is wrong and should be fixed
        if (defaults.hasOwnProperty(key)) {
            throw new Error("The local configuraion key '" + key + "' is already in use");
        }

        if (typeof declaredNames === "string") {
            declaredNames = [declaredNames];
        }
        declaredNames.forEach(function(name) {
            var undeclaredList;

            // This is a programmatic errors - some declare is wrong and should be fixed
            if (names.hasOwnProperty(name)) {
                throw new Error("The configuration value '" + name +
                    "' has been declared more than once");
            }
            // This doesn't have to be done for every name
            if (!defaults.hasOwnProperty(key)) {
                if (typeof defaultValue === "function") {
                    defaultValue = defaultValue();
                }
                defaults[key] = defaultValue;
            }
            names[name] = key;
            if (typeof conversion === "function") {
                conversions[name] = conversion;
            }

            // See if there are any values that are waiting for this option to be
            // declared
            undeclaredList = undeclared[name];
            if (undeclaredList) {
                undeclaredList.forEach(function(tuple) {
                    var destination = tuple[0],
                        value = {};
                    value[name] = tuple[1];
                    updateValues.call(destination, value, false);
                });
                delete undeclared[name];
            }
        });
    });
    return config;
};

//------------------------------------------------------------------------------
// Default type conversions
//------------------------------------------------------------------------------

var typeConversions = {

    "object":   function convertObject(s) {
                    if (typeof s == "object") {
                        return s;
                    }
                    return JSON.parse("" + s);
                },

    "boolean":  function convertBoolean(s) {
                    if (typeof s == "boolean") {
                        return s;
                    }
                    return !(("" + s) === "0" || ("" + s).toLowerCase() === "false");
                },

    "number":   function convertNumber(s) {
                    if (typeof s == "number") {
                        return s;
                    }
                    var result = parseFloat("" + s);
                    if (isNaN(result)) {
                        throw new Error("parseFloat returned NaN");
                    }
                    return result;
                }
};

//------------------------------------------------------------------------------
// Parse a string of comma-separated options with optional values. Those with
// no values are assumed to be 'true'. Returns an object with keys and values
//------------------------------------------------------------------------------

function parseValues(values) {
    return values.split(",").reduce(function(result, option) {
        var pair = option.split("="),
            name = pair[0],
            value = pair.slice(1).join("=");
        if (name && name.length) {
            result[name] = value || true;
        }
        return result;
    }, {});
}

//------------------------------------------------------------------------------

function toString(value) {
    if (value && typeof value === "object") {
        return JSON.stringify(value);
    } else if (typeof value === "string") {
        return "\"" + value + "\"";
    }
    return "" + value;
}

//------------------------------------------------------------------------------
// Updates the values in "this". 'values' can be an object with foreign names
// as the keys or a string of comma-separated pairs of names and values
// separated by equal. For example: "a=10,foo=hello,bar"
//------------------------------------------------------------------------------

/**
 * @param {!Object}  values
 * @param {boolean}  deferUndeclared
 * @param {Object=}  console
 */

function updateValues(values, deferUndeclared, console) {
    if (typeof values === "string") {
        return updateValues.call(this, parseValues(values), deferUndeclared, console);
    }
    var changes = 0;
    Object.keys(values).forEach(function(name) {
        var key = names[name],      // The local key for the foreign name
            value = values[name],   // The value passed in
            conversion,             // A conversion function
            previousValue,          // The old value
            undeclaredList;

        // If the local key doesn't exist, there is no declared config with the
        // name passed in - we skip it, unless the caller wants to defer setting
        // the value until the option is declared
        if (!key) {
            if (deferUndeclared) {
                //console.trace("Deferring value for undeclared option '" + name + "'");
                undeclaredList = undeclared[name];
                if (!undeclaredList) {
                    undeclaredList = [];
                } else {
                    undeclaredList = undeclaredList.filter(function(tuple) {
                        // Drop all previous entries that apply to the same
                        // destination as this one, because only the last one
                        // will have an effect.
                        return tuple[0] !== this;
                    }, this);
                }
                undeclaredList.push([this, value]);
                undeclared[name] = undeclaredList;
            } else {
                console && console.error("Attempt to change undeclared config option '" + name + "'");
            }
            return;
        }

        // Use the conversion function given at "declare" time for the foreign
        // name, or a default one based on the type of the declared default
        // value
        conversion = conversions[name] || typeConversions[typeof defaults[key]];
        if (conversion) {
            try {

                value = conversion(value);

            } catch(e) {
                console && console.error("Failed to convert value '" + value +
                    "' for config '" + name + "' : " + e.toString());
                return;
            }
        }

        // Get the previous value from config, using the local key. This will
        // use the prototype chain, so it will fetch the topmost value
        previousValue = config[key];

        // Set it regardless of the previous value, because it may be set in
        // a different level. Say the value for 'foo' is 'true' in the overrides
        // but non-existent in the persistent level and we are setting it to
        // 'true' there. We want to capture it so that we can save it for next
        // time. However, the final value has not changed - it is still 'true'
        this[key] = value;

        if (config[key] !== previousValue) {
            // This is just for reporting
            console && console.trace("Config changed for '" + name + "' from " +
                toString(previousValue) + " (" + typeof previousValue + ") " +
                "to " + toString(value) + " (" + typeof value + ")");
            ++changes;
        }
    }, this);

    if (changes) {
        config.emit("changed");
    }
    return changes;
}

//------------------------------------------------------------------------------
// Updates persistent values
//------------------------------------------------------------------------------

config.set = updateValues.bind(persistent);

//------------------------------------------------------------------------------
// Updates override values
//------------------------------------------------------------------------------

config.override = updateValues.bind(overrides);

//------------------------------------------------------------------------------
// Returns an object that for each key has an array of all its foreign names
//------------------------------------------------------------------------------

function getReverseNames() {
    return Object.keys(names).reduce(function(result, name) {
        var key = names[name],
            list = result[key];
        if (!list) {
            result[key] = [name];
        } else {
            list.push(name);
            result[key] = list.sort(function(a,b) {
                return b.length - a.length;
            });
        }
        return result;
    }, {});
}

//------------------------------------------------------------------------------
// Dumps out the names of all the config options and all of the values
//------------------------------------------------------------------------------

function ownValue(object, key) {
    return object.hasOwnProperty(key) ? toString(object[key]) : undefined;
}

function ifUndefined(value, whenUndefined) {
    return (typeof value === "undefined") ? whenUndefined : value;
}

config.dump = function configDump(console, verbose) {
    var undeclaredNames = Object.keys(undeclared).sort(),
        keysSeen = {},
        reverseNames = getReverseNames(),
        printedHeader;

    verbose = ifUndefined(verbose, true);

    function printHeader() {
        if (!printedHeader) {
            printedHeader = true;
            console && console.log("Current config values");
            printDivider();
        }
    }
    function printDivider() {
        if (printedHeader) {
            console && console.log("===========================================");
        }
    }

    Object.keys(names).sort().forEach(function(name) {
        var key = names[name],
            line,
            persistentValue,
            overrideValue;

        if (keysSeen[key]) {
            return;
        }
        keysSeen[key] = true;

        persistentValue = ownValue(persistent, key);
        overrideValue = ownValue(overrides, key);
        // Unless verbose is true, don't dump options that have only default values
        if (verbose || typeof persistentValue !== "undefined" || typeof overrideValue !== "undefined") {
            line = reverseNames[key].join(",");
            line += " = " + toString(config[key]) + " (" + typeof config[key] + ") [";
            line += ifUndefined(overrideValue, "<unset>") + ",";
            line += ifUndefined(persistentValue, "<unset>") + ",";
            line += ownValue(defaults, key) + "]";
            printHeader();
            console && console.log(line);
        }
    });
    if (verbose || undeclaredNames.length) {
        console && console.log("<undeclared> :", undeclaredNames);
    }
    printDivider();
};

//------------------------------------------------------------------------------
// Returns all of the persistent values in an object that uses the foreign
// name as the key
//------------------------------------------------------------------------------

config.persistent = function configPersistent() {
    var reverseNames = getReverseNames();
    return Object.getOwnPropertyNames(persistent).reduce(function(result, key) {
        result[reverseNames[key][0]] = persistent[key];
        return result;
    }, {});
};

//------------------------------------------------------------------------------
// Clears out the values in the persistent object
//------------------------------------------------------------------------------

config.reset = function configReset() {
    Object.keys(persistent).forEach(function(key) {
        delete persistent[key];
    });
};

//------------------------------------------------------------------------------

config._listeners = {};
mixin(EventEmitter, config);

//------------------------------------------------------------------------------
// The final config object, which cannot be changed directly
//------------------------------------------------------------------------------

module.exports = Object.freeze(config);

},{"94":94,"95":95}],98:[function(require,module,exports){
/* global setTimeout, console */

var EventEmitter = require(42).EventEmitter;
var SubtitleTimer = require(101);
var type = require(102)();

var ImageStream = require(99);
var IncrementalTextStream = null;

var platformTypeSpec = {
    request : "function",
    getPts  : "function",
    logger  : "object"
};

/**
* @constructor
* @extends events.EventEmitter
*/
var SubtitleManager = function SubtitleManager (platform, options) {
    var self = this;
    var streamOpts,
        isDebug = platform.isDebug || false;

    if (!(self instanceof SubtitleManager)) {
        return new SubtitleManager(platform, options);
    }

    EventEmitter.call(self);

    self._logger   = platform.logger || console;
    self._request  = platform.request;
    self._getPts   = platform.getPts;
    self._timer    = null;
    self._paused   = true;
    self._intervals = [];

    self._profile     = options.profile;
    self._url         = options.url;
    self._pts         = options.pts;
    self._preferences = options.preferences;
    self._defaults    = options.defaults;

    streamOpts = {
        url         : self._url,
        request     : self._request,
        pts         : self._pts,
        xml         : options.xml,
        preferences : self._preferences,
        defaults    : self._defaults,
        logger      : self._logger,
        isDebug     : isDebug,
        bufferSize  : options.bufferSize,
        crypto      : options.crypto,
        key         : options.key
    };

    if (self._profile === "nflx-cmisc") {
        streamOpts.offset = options.midxOffset;
        streamOpts.size = options.midxSize;
        self._stream = new ImageStream(streamOpts);
    } else if (self._profile === "nflx-cmisc-enc") {
        streamOpts.version = 2;
        streamOpts.offset = options.midxOffset;
        streamOpts.size = options.midxSize;
        self._stream = new ImageStream(streamOpts);
    } else if (self._profile === "dfxp-ls-sdh" && typeof IncrementalTextStream === "function") {
        self._stream = new IncrementalTextStream(streamOpts);
    } else {
        throw new Error("SubtitleManager: " + self._profile + " is an unsupported profile");
    }

    self._stream.on("ready", function (elt) {
        var autostart = !!options.autostart;

        self._logger.info("ready event fired by subtitle stream");

        self.emit("ready");
        var getSubtitles = self._stream.getCurrentAndNextSubtitles.bind(self._stream);
        self._timer = new SubtitleTimer(self._getPts, getSubtitles, self._logger);

        // forward the timers events on
        if (self._profile === "dfxp-ls-sdh" && typeof IncrementalTextStream === "function") {
            self._timer.on("stagesubtitle", stageSubtitle.bind(self));
        }
        self._timer.on("showsubtitle", showSubtitle.bind(self));
        self._timer.on("removesubtitle", removeSubtitle.bind(self));

        if (autostart) {
            self._logger.info("autostarting subtitles");
            // start showing subtitles immediately
            setTimeout(function () {
                self.updatePts(self._getPts());
            }, 10);
        }
    });

    self._stream.on('error', self.emit.bind(self, 'error'));
};

SubtitleManager.prototype = Object.create(EventEmitter.prototype);

SubtitleManager.prototype.updatePts = function updatePts (newPts) {
    var self = this;

    if (self._paused) {
        self._paused = false;

        startInterval.call(this, newPts);
    }

    if (self._timer !== null) {
        self._timer.updatePts(newPts);
    }
};

SubtitleManager.prototype.stop = function stop () {
    var self = this;
    var pts = self._getPts();
    var metrics;

    self._logger.info("stop called");

    if(!self._paused) {
        self.pause();
    }

    // remove listeners from the stream
    self._stream.removeAllListeners(["ready"]);

    if (self._timer !== null) {
        self._timer.stop();
    }

    // calculate metrics
    metrics = self._intervals.reduce(function (metrics, interval) {
        metrics.shown += interval.showCount;
        metrics.expected += interval.expectedCount;
        metrics.intervals.push(interval);
        return metrics;
    }, { shown : 0, expected : 0, intervals : [] });

    // close the stream
    if (typeof self._stream === "object") {
        self._stream.close();
    }

    self._logger.info("metrics: " + JSON.stringify(metrics));

    return metrics;
};

SubtitleManager.prototype.pause = function pause () {
    var self = this;
    var pts = self._getPts();

    if (self._paused) {
        self._logger.warn("pause called on subtitle manager, but it was already paused!");
    } else {
        self._logger.info("pause called at " + pts);
        self._paused = true;
        endInterval.call(self, pts);
    }

    if (self._timer !== null) {
        self._timer.pause();
    }
};

// this api is used for cadmium implementation only. use getSubtitlesCount for non-cadmium
SubtitleManager.prototype.getSubtitlesList = function getSubtitlesList(start, end) {
    return this._stream.getSubtitlesList(start, end);
};

// returns either a number or undefined if data is not available to calculate
SubtitleManager.prototype.getSubtitlesCount = function getSubtitlesCount(start, end) {
    return this._stream.getSubtitlesCount(start, end);
};


SubtitleManager = type([platformTypeSpec, "object"], SubtitleManager);

module.exports = SubtitleManager;

// private functions
function showSubtitle (subtitle) {
    var self = this;
    var count = 1;

    // we coalesce multiple subtitle entries into a single event
    // with text subtitles
    if (self._profile === "dfxp-ls-sdh") {
        count = subtitle.blocks.length;
    }

    self._logger.info("show subtitle called at " + self._getPts() + " for displayTime " + subtitle["displayTime"]);
    self.emit("showsubtitle", subtitle);
    currentInterval.call(self).showCount += count;
}

function removeSubtitle (subtitle) {
    var self = this;
    self._logger.info("remove subtitle called at " + self._getPts() + " for remove time " + (subtitle["displayTime"] + subtitle["duration"]));
    self.emit("removesubtitle", subtitle);
}

function stageSubtitle (subtitle) {
    var self = this;
    self._logger.info("stage subtitle called at " + self._getPts() + " for displayTime " + subtitle["displayTime"]);
    self.emit("stagesubtitle", subtitle);
}

function startInterval (pts) {
    var self = this;
    self._logger.info("creating a new subtitle interval at " + pts);

    self._intervals.push({
        startPts  : pts,
        showCount : 0
    });
}

function endInterval (pts) {
    var self = this;
    self._logger.info("ending subtitle interval at " + pts);

    var interval = currentInterval.call(self);
    interval.endPts = pts;
    interval.expectedCount =
        self._stream.getSubtitlesCount(interval.startPts, interval.endPts);

    self._logger.info("showed " + interval.showCount + " during this interval");
    self._logger.info("expected " + interval.expectedCount + " for this interval");
}

function currentInterval () {
    var self = this;
    return self._intervals[self._intervals.length - 1];
}

},{"101":101,"102":102,"42":42,"99":99}],99:[function(require,module,exports){
/* global setTimeout, clearTimeout, Uint8Array*/
var EventEmitter = require(42).EventEmitter;
var DataStream = require(91);
var mp4reader = require(96);
var utils = require(100);

var defaultBufferSize = 4 * 1024 * 1024;

var ITRK = '636F6D2E-6E65-7466-6C69-782E6974726B',
    HINF = '636F6D2E-6E65-7466-6C69-782E68696E66',
    VINF = '636F6D2E-6E65-7466-6C69-782E76696E66',
    MIDX = '636F6D2E-6E65-7466-6C69-782E6D696478',
    ISEG = '636F6D2E-6E65-7466-6C69-782E69736567',
    SIDX = '636F6D2E-6E65-7466-6C69-782E73696478',
    SENC = '636F6D2E-6E65-7466-6C69-782E73656E63';

/**
 * @constructor
 */
var ImageStream = function ImageStream(options) {
    var self = this;
    EventEmitter.call(self);

    // external Api
    self.getCurrentAndNextSubtitles = getCurrentAndNextSubtitles;

    self._url = options.url;
    self._request = options.request;

    self._pts = options.pts || 0;
    self._isDebug = options.isDebug;
    self._logger = options.logger;
    self._midx = null;
    self._sidexes = null;
    self._currentSidx = {};
    self._currentBufferSize = 0; //bytes
    self._maxBufferSize = options.bufferSize || defaultBufferSize; //bytes
    self._pendingDownloads = {};
    self._version = options.version || 1;

    if (options.key) {
        self._crypto = options.crypto;
        self._key = importKey.call(self, options.key);
    }

    var midxOptions = {
        url: self._url,
        offset: options.offset,
        size: options.size,
        responseType: "binary"
    };
    self._request(midxOptions, processMidxResponse.bind(self));
};

var events = ImageStream.events = {
    MIDXREADY: 'midxready',
    SIDXREADY: 'sidxready',
    READY: 'ready',
    ERROR: 'error'
};

var errorStrings = ImageStream.errorStrings = {
    MIDXDOWNLOADERROR: 'midxdownloaderror',
    MIDXPARSEERROR: 'midxparseerror',
    NOSIDXFOUNDINMIDX: 'nosidxfoundinmidx',
    SIDXDOWNLOADERROR: 'sidxdownloaderror',
    SIDXPARSEERROR: 'sidxparseerror',
};

ImageStream.prototype = Object.create(EventEmitter.prototype);
ImageStream.prototype.constructor = ImageStream;

// maybe we should implement this?
ImageStream.prototype.close = function close() {};

ImageStream.prototype.debugAssert = function debugAssert(flag) {
    if (this._isDebug) {
        utils.assert(flag, this._logger);
    }
};

ImageStream.prototype.getBufferSize = function getBufferSize() {
    return this._currentBufferSize;
};
ImageStream.prototype.getSubtitlesList = function getSubtitlesList(start, end) {
    return _getSubsInRange.call(this, start, end);
};
ImageStream.prototype.getSubtitlesCount = function getSubtitlesCount(start, end) {
    var ids = this.getSubtitlesList(start, end);
    return ids ? ids.length : ids;
};
// for memory profiler
/**
 * @constructor
 */
function Midx() {}
/**
 * @constructor
 */
function Sidx() {}

function processMidxResponse(err, data) {
    var self = this;

    if (err) {
        self.emit(events.ERROR, utils.getErrorData(err, errorStrings.MIDXDOWNLOADERROR));
        return;
    }
    try {
        var midx = parseMidx(data, self._version);
        self._midx = midx;
        var sidxStartOffset = midx.startOffset,
            size = midx.entries.reduce(function(acc, entry) {
                return acc + entry.size;
            }, 0);

        if (!size) {
            // midx.entryCount=0, log this special case for encoding team.TODO confirm if this is error.
            self.emit(events.ERROR, utils.getErrorData({}, errorStrings.NOSIDXFOUNDINMIDX));
            return;
        }
        var options = {
            url: this._url,
            offset: sidxStartOffset,
            size: size
        };

        self.emit(events.MIDXREADY, self._midx);
        // download all sidexes. make it configurable, based on memory available.
        self._request(options, processSidxResponse.bind(self));
    } catch (ex) {
        self.emit(events.ERROR, utils.getErrorData(ex, errorStrings.MIDXPARSEERROR));
    }
}

function processSidxResponse(err, resp) {
    var self = this;
    if (err) {
        self.emit(events.ERROR, utils.getErrorData(err, errorStrings.SIDXDOWNLOADERROR));
        return;
    }
    var offset = 0,
        sidexes = [],
        current = 0;

    try {
        self._midx.entries.forEach(function(e, i) {
            var entry = parseSidx(resp, offset, self._midx.indexId, self._logger, self._version);
            sidexes.push(entry);
            e.sidxEntry = entry;
            entry.rangeStart = current;
            entry.rangeEnd = current + e.duration;
            current = entry.rangeEnd;
            var images = entry.entries;
            if (images.length) {
                entry.startTime = images[0].displayTime;
                entry.endTime = images[images.length - 1].displayTime + images[images.length - 1].duration;
            }
            offset = offset + e.size;
        });
    } catch (e) {
        // make sure this is captured in HIVE 
        // If this happens a lot, then add handling for ignoring only the sidxes that failed parsing
        self.emit(events.ERROR, utils.getErrorData(e, errorStrings.SIDXPARSEERROR));
        return;
    }

    self._sidexes = sidexes;
    self.emit(events.SIDXREADY, this._sidexes);

    var sidexesToDownload = getSidexesForDownload.call(self, self._pts);

    if (sidexesToDownload.length) {
        downloadSidxImages.call(self, sidexesToDownload, self._pts, function(err) {
            if (err) {
                self._logger.error('initial sidx download failed');
                //will retry when the getNextAndCurrent is called.
                //capture in stats for failed requests. TODO. 
            }
            self.emit(events.READY);
        });
    } else {
        self.emit(events.READY);
    }
}

function parseMidx(data, version) {
    if (version === 2) {
        return parseMidx2(data);
    } else {
        return parseMidx1(data);
    }
}

function parseMidx1(data) {
    var stream = new DataStream(data),
        header = new Midx();

    header.identifier = stream.readChars(4);
    utils.assert('midx' === header.identifier);

    header.version = stream.readNumber(4);
    utils.assert(0 === header.version);

    header.indexId = stream.readArray(36);
    header.creationTime = stream.readULong();
    header.packageId = stream.readULong();
    header.movieId = stream.readULong();

    header.rootContainerExtentX = stream.readUShort();
    header.rootContainerExtentY = stream.readUShort();

    header.language = stream.readArray(16);
    header.textType = stream.readArray(16);

    header.startOffset = stream.readULong();
    header.entryCount = stream.readUShort();

    var entries = [];
    for (var i = 0; i < header.entryCount; i++) {
        var entry = {};
        entry.duration = stream.readNumber(4); // duration in ms
        entry.size = stream.readUShort();
        entries.push(entry);
    }
    header.entries = entries;
    return header;
}

function parseMidx2(data) {
    var header = new Midx();
    var itrkBox = mp4reader.readAllBoxes(data)[0];
    var hinfBox = itrkBox.getDescendant(HINF);
    var midxBox = itrkBox.getDescendant(MIDX);

    header.indexId = hinfBox.assetId;
    header.creationTime = hinfBox.creationTime;
    header.packageId = hinfBox.packageId;
    header.movieId = hinfBox.movieId;

    header.rootContainerExtentX = hinfBox.rootContainerExtentX;
    header.rootContainerExtentY = hinfBox.rootContainerExtentY;

    header.language = hinfBox.languageCode;
    header.textType = hinfBox.subtitleType;

    header.startOffset = midxBox.segmentOffset;

    var entries = [];
    for (var i = 0; i < midxBox.segments.length; i++) {
        var segment = midxBox.segments[i],
            entry = {};
        entry.duration = segment.duration; // duration in ms
        entry.size = segment.size;
        entries.push(entry);
    }
    header.entries = entries;
    return header;
}

function parseSidx(data, offset, indexId, logger, version) {
    if (version === 2) {
        return parseSidx2(data, offset, indexId, logger);
    } else {
        return parseSidx1(data, offset, indexId, logger);
    }    
}

function parseSidx1(data, offset, indexId, logger) {
    var stream = new DataStream(data),
        sidx = new Sidx(),
        j = 0;
    stream.position = offset;
    sidx.identifier = stream.readChars(4);
    utils.assert(sidx.identifier === 'sidx');
    sidx.indexId = stream.readArray(36); //match this UUID to the one in master index TODO. #log
    utils.compareIndexId(sidx.indexId, indexId, logger);
    sidx.duration = stream.readNumber(4);
    sidx.entryCount = stream.readUShort();
    sidx.entries = [];
    sidx.images = [];

    while (j < sidx.entryCount) {
        var entry = {};
        entry.displayTime = stream.readNumber(4); //absolute start time for the entry in ms
        entry.duration = stream.readNumber(4); //ms

        entry.originX = stream.readUShort();
        entry.originY = stream.readUShort();

        entry.sizeX = stream.readUShort();
        entry.sizeY = stream.readUShort();

        entry.imageStartPosition = stream.readULong(); //absolute offset of first byte of image
        entry.imageSize = stream.readNumber(4); //size in bytes
        j++;
        sidx.entries.push(entry);
    }
    return sidx;
}

function parseSidx2(data, offset, assetId, logger) {
    var sidx = new Sidx();
    var isegBoxes = mp4reader.readAllBoxes(data);

    sidx.entries = [];
    sidx.images = [];

    for (var i = 0; i < isegBoxes.length; i++) {
        var isegBox = isegBoxes[i];
        var sidxBox = isegBox.getDescendant(SIDX);
        var sencBox = isegBox.getDescendant(SENC);

        for (var j = 0; j < sidxBox.samples.length; j++) {
            var entry = {};

            var sidxSample = sidxBox.samples[j];
            entry.displayTime = sidxSample.displayTime;
            entry.duration = sidxSample.duration;
            entry.originX = sidxSample.originX;
            entry.originY = sidxSample.originY;
            entry.sizeX = sidxSample.sizeX;
            entry.sizeY = sidxSample.sizeY;
            entry.imageStartPosition = sidxSample.imageStartPosition;
            entry.imageSize = sidxSample.imageSize;

            var sencSample = sencBox && sencBox.samples[j];
            if (sencSample) {
                entry.encryptionInfo = {
                    iv: sencSample.iv.slice(0),
                    mode: sencSample.encryptionMode
                };
            }

            sidx.entries.push(entry);
        }
    }

    return sidx;
}

function getCurrentAndNextSubtitles(pts) {
    var self = this,
        sidexes = getSidexesForDownload.call(self, pts);

    if (sidexes.length) {
        downloadSidxImages.call(self, sidexes, pts);
    }

    var currentSidx = self._currentSidx.sidx,
        currentIndex = self._currentSidx.index,
        subtitles = [],
        nextSidx = utils.isDefined(currentIndex) && self._sidexes[currentIndex + 1];
    if (currentSidx && currentSidx.images.length) {
        subtitles = _getCurrentAndNextFromSidx(currentSidx, pts, [], self._midx);
    }
    if (nextSidx && nextSidx.images.length) {
        var next = _getCurrentAndNextFromSidx(nextSidx, pts, subtitles, self._midx);
        subtitles.push.apply(subtitles, next);
    }
    return consolidateContiguousSubtitles(subtitles);
}

// 1. getSidxForPts, if no sidx, return []
// 2. do we have images downloaded for this sidx
// if no, trigger a download request for this  and the next, and return []
function getSidexesForDownload(pts) {
    var self = this,
        sidexes = [],
        entry = getSidxForPts.call(self, pts);

    if (!entry) { // out of range pts or !midx.entryCount
        return sidexes;
    } else {
        self._currentSidx = entry; //for caching
    }
    var currentSidx = entry.sidx,
        nextSidx = self._sidexes[entry.index + 1];

    if (!currentSidx.images.length) {
        sidexes.push(currentSidx);
    }
    if (nextSidx && !nextSidx.images.length) {
        sidexes.push(nextSidx);
    }
    return sidexes;
}

function getSidxForPts(pts) {
    var self = this,
        entry,
        current = self._currentSidx,
        currentSidx = current.sidx,
        currentIndex = current.index,
        nextSidx, prevSidx,
        found,
        allSidexes = self._sidexes;
    self.debugAssert(utils.isDefined(pts));
    // optimize for 4 most common scenarios. 
    if (currentSidx) {
        if (currentIndex === 0 && pts <= currentSidx.startTime) {
            found = true;
            entry = current;
        } else if (pts >= currentSidx.startTime && pts <= currentSidx.endTime) {
            found = true;
            entry = current;
        } else {
            prevSidx = allSidexes[currentIndex - 1];
            nextSidx = allSidexes[currentIndex + 1];
            if (prevSidx && pts > prevSidx.endTime && pts <= currentSidx.startTime) {
                found = true;
                entry = current;
            } else if (nextSidx && pts >= currentSidx.endTime && pts <= nextSidx.endTime) {
                found = true;
                entry = {
                    sidx: nextSidx,
                    index: currentIndex + 1
                };
            }
        }
    }
    if (!found) {
        var entries = self._midx.entries,
            len = entries.length;
        for (var i = 0; i < len; i++) {
            var x = entries[i].sidxEntry;
            if ((pts <= x.startTime) || (pts > x.startTime && pts <= x.endTime)) {
                entry = {
                    sidx: entries[i].sidxEntry,
                    index: i
                };
                // console.debug('found via traversal, pts:' + pts, 'entry startTime', entry.sidx.startTime, 'index:' + entry.index, 'current', currentSidx && currentSidx.startTime, 'endTime: ', entry.sidx.endTime, pts, 'images downloaded', entry.sidx.images.length);
                break;
            }
        }
    } else {
        // console.debug('found via current, pts:' + pts, 'entry startTime', entry.sidx.startTime, 'index:' + entry.index, 'current', currentSidx && currentSidx.startTime, 'endTime: ', entry.sidx.endTime, pts, 'images downloaded', entry.sidx.images.length);
    }
    return entry;
}

function _getCurrentAndNextFromSidx(sidx, pts, arr, midx) {
    var entries = sidx.entries,
        start = 0, // optimize via last seen 
        len = entries.length,
        subtitles = [],
        entry,
        subtitle,
        i = start;
    if (!entries.length) {
        return subtitles;
    }

    while (i < len) {
        entry = entries[i];
        if (entry.displayTime <= pts) {
            if (entry.displayTime + entry.duration >= pts) {
                // this is a current
                subtitles.push(utils.createSubtitleEntryForPublic(entry, sidx.images[i].data, midx));
            }
        } else {
            var existingNext = (subtitles.length && subtitles[subtitles.length - 1]) || (arr.length && arr[arr.length - 1]);
            if (existingNext && (existingNext.displayTime > pts) && (existingNext.displayTime !== entry.displayTime)) {
                break;
            }
            // prevent duplicates
            if (existingNext.imageStartPosition !== entry.imageStartPosition) {
                //this is a next
                subtitles.push(utils.createSubtitleEntryForPublic(entry, sidx.images[i].data, midx));
            }
        }
        i++;
    }
    return subtitles;
}

function consolidateContiguousSubtitles(subtitles) {
    return subtitles
        .map(function(entry, i) {
            entry['duration'] += utils.durationOfNextContiguousEntries(subtitles.slice(i + 1), entry);
            return entry;
        })
        .reduce(function(acc, current) {
            if (!utils.searchArrayEntryById(acc, current['id'])) {
                acc.push(current);
            }
            return acc;
        }, []);
}

/**
 * sidexes must not be an empty array
 * @param {Array} sidexes
 * @param {number} pts
 * @param {Function=} callback
 */
function downloadSidxImages(sidexes, pts, callback) {
    var self = this;
    var firstSidx = sidexes[0],
        lastSidx = sidexes[sidexes.length - 1];
    var startOffset,
        lastEntry,
        size;

    if (firstSidx.entries.length > 0) {
        startOffset = firstSidx.entries[0].imageStartPosition;
        lastEntry = firstSidx.entries[firstSidx.entries.length - 1];
    }

    if (lastSidx.entries.length > 0) {
        if (!utils.isDefined(startOffset)) {
            startOffset = lastSidx.entries[0].imageStartPosition;
        }
        lastEntry = lastSidx.entries[lastSidx.entries.length - 1];
    }
    if (startOffset) {
        size = lastEntry.imageStartPosition + lastEntry.imageSize - startOffset;
    } else { // none of the sidx has any entries, we are done , typically happens towards the end.
        callback && callback(null);
        return;
    }

    var downloadId = utils.getDownloadId(startOffset, size);
    if (!self._pendingDownloads[downloadId]) {
        self._pendingDownloads[downloadId] = true;

        makeSpaceIfRequired.call(self, sidexes, pts);
        self._request({
            url: self._url,
            offset: startOffset,
            size: size
        }, function(err, data) {
            // in case the network goes down.
            setTimeout(function() {
                delete self._pendingDownloads[downloadId];
            }, 1000);

            if (err) {
                // log(err);
                // capture in stats TODO
                callback && callback(err);
            } else {
                var stream = new DataStream(data);
                var contentSize = 0;

                var encrypted;
                var images = [];
                sidexes.forEach(function(sidx) {
                    sidx.entries.forEach(function(e, i) {
                        stream.position = e.imageStartPosition - startOffset;
                        var image = {
                            data: stream.readArray(e.imageSize)
                        };

                        var encryptionInfo = e.encryptionInfo;
                        if (encryptionInfo) {
                            image.iv = encryptionInfo.iv;
                            image.encryptionMode = encryptionInfo.mode;

                            encrypted = true;
                            images.push(image);
                        }

                        sidx.images[i] = image;
                        !e.encryptionInfo && utils.validatePng(sidx.images[i].data, self.debugAssert.bind(self));
                        contentSize = contentSize + sidx.images[i].data.length;
                    });
                });
                self._currentBufferSize += contentSize;

                if(!encrypted) {
                    callback && callback(null);
                } else {
                    self._key
                    .then(function(key) {
                        return decryptImages.call(self, images, key);
                    })
                    .then(function() {
                        callback && callback(null);
                    })
                    .catch(function(e) {
                        self._logger.error('decrypterror', e);
                        callback && callback({success: false});
                    });                      
                }
            }
        });
    }
}

function makeSpaceIfRequired(sidexes, pts) {
    var self = this,
        currentBufferSize = self._currentBufferSize,
        capacity = self._maxBufferSize,
        requiredSpace = getSizeOfImages(sidexes);

    self._logger.info('make space start:', getLogFields());

    function hasEnoughSpace() {
        return self._currentBufferSize + requiredSpace <= self._maxBufferSize;
    }

    function getLogFields() {
        return {
            'pts': pts,
            'hasEnoughSpace': hasEnoughSpace(),
            'required': requiredSpace,
            'currentSize': self._currentBufferSize,
            'max': self._maxBufferSize,
            'currentIndex': getSidxForPts.call(self, pts).index,
            'sidxWithImages': getSidxWithImages.call(self),
            'newSidxes': sidexes.map(function(s) {
                return self._sidexes.indexOf(s);
            })
        };
    }

    function logIfNotDone(isDone, iteration) {
        self._isDebug && (!isDone && self._logger.info('not done in iteration', iteration));
    }

    function clearSpace(i) {
        var curr = self._sidexes[i],
            numberOImages = curr.images && curr.images.length;
        if (numberOImages > 0) {
            var size = getSizeOfImages([curr]);
            curr.images = [];
            self._currentBufferSize = self._currentBufferSize - size;
            if (self._isDebug) {
                self._logger.info('cleaning up space from sidx', {
                    index: i,
                    start: curr.startTime,
                    size: size,
                    images: numberOImages
                });
            }
            if (hasEnoughSpace()) {
                return true;
            }
        }
    }
    if (!hasEnoughSpace()) {
        var entry = getSidxForPts.call(self, pts),
            sidx = entry.sidx,
            index = entry.index,
            done = false,
            allSidexes = self._sidexes,
            x = 0,
            y = allSidexes.length - 1;

        if (index < 0) {
            self._logger.error('inconsistent sidx index'); // should never happen
            return;
        }
        // keep m to the left
        while (!done && x < (index - 2)) {
            done = clearSpace(x);
            x++;
        }
        logIfNotDone(done, 1);

        // keep n to the right
        while (!done && y > (index + 2)) {
            done = clearSpace(y);
            y--;
        }
        logIfNotDone(done, 2);
        // now take out the left m neighbors of current
        while (!done && x < index) {
            done = clearSpace(x);
            x++;
        }
        logIfNotDone(done, 3);
        // now take out the right n neighbors
        while (!done && y > index) {
            done = clearSpace(y);
            y--;
        }
        logIfNotDone(done, 4);
        // lets see how many assets + device see this.
        if (!done) {
            self._logger.error('could not make enough space', {
                'maxBuffer': this._maxBufferSize
            });
        }
    }
    self._logger.info('make space end', getLogFields());
}

function getSizeOfImages(sidexes) {
    return sidexes.reduce(function(total, sidx) {
        return total + sidx.entries.reduce(function(acc, entry) {
            return entry.imageSize + acc;
        }, 0);
    }, 0);
}

function getSidxWithImages() {
    var bufferSize = 0,
        sidxWithImages = [],
        self = this;

    if (self._midx && self._midx.entries) {
        bufferSize = self._midx.entries.reduce(function(acc, entry, i) {
            var sidxEntry = entry.sidxEntry,
                sidxImagesSize = 0;
            if (sidxEntry && sidxEntry.images.length) {
                sidxWithImages.push(i);
                sidxImagesSize = sidxEntry.images.reduce(function(acc1, image, i) {
                    return acc1 + image.data.length;
                }, 0);
            }
            return acc + sidxImagesSize;
        }, 0);
    }
    return sidxWithImages.join(', ');
}

function doesSidxIncludePts(sidx, pts) {
    return sidx.rangeStart <= pts && sidx.rangeEnd >= pts;
}

function _getSubsInRange(startPts, endPts) {
    var self = this,
        result,
        midx = self._midx,
        allSidexes = self._sidexes,
        sidxCount = allSidexes && allSidexes.length;
    if (startPts > endPts) {
        throw new Error('invalid range startPts: ' + startPts + ', endPts: ' + endPts);
    }
    if (!midx || !allSidexes) {
        return; // not ready yet
    }

    if (sidxCount === 0) {
        return []; // no subtitle was expected. should it really happen ? this will be captured in stats
    }

    // optimize for most common case O(1). divide by duration to get the index.
    var duration = allSidexes[0].duration,
        index,
        sidx;
    if (utils.isDefined(duration) && duration > 0) {
        index = Math.floor(startPts / duration);
        sidx = (index < sidxCount && doesSidxIncludePts(allSidexes[index], startPts)) ? allSidexes[index] : undefined;
    } else { //brute force. // capture in stats 
        if (self._isDebug) {
            self._logger.warn('duration not defined, so use brute force to get starting sidx');
        }
        for (index = 0; index < sidxCount; index++) {
            var entry = allSidexes[index];
            if (doesSidxIncludePts(entry, startPts)) {
                sidx = entry;
                break;
            }
        }
    }
    if (!utils.isDefined(sidx)) {
        return; // unknonwn
    }
    var subtitles = [],
        currentSidx,
        inRange = function inRange(s) {
            var doesEntryStartWithinRange = (startPts <= s.displayTime && s.displayTime <= endPts),
                doesRangeStartWithinEntry = (s.displayTime <= startPts && startPts <= (s.displayTime + s.duration));
            return doesEntryStartWithinRange || doesRangeStartWithinEntry;
        };
    while (index < sidxCount) {
        currentSidx = allSidexes[index];
        subtitles = subtitles.concat(currentSidx.entries.filter(inRange));
        if (endPts < currentSidx.rangeEnd) {
            break;
        }
        index++;
    }
    subtitles = subtitles.map(function(s) {
        return utils.createSubtitleEntryForPublic(s, null, self._midx);
    });
    return consolidateContiguousSubtitles(subtitles);
}

function importKey(key) {
    var self = this,
        algorithm = {'name': 'AES-CTR'};
    return self._crypto['importKey']('raw', key, algorithm, false, ['encrypt', 'decrypt']);
}

function decryptImages(images, key) {
    function decryptImage(image, key) {
        var self = this;
        var iv = new Uint8Array(16);
        iv.set(image.iv);
        var algorithm = {'name': "AES-CTR", 'counter': iv, 'length': 128};
        return self._crypto['decrypt'](algorithm, key, image.data)
        .then(function(data) {
            image.data.set(new Uint8Array(data));
            utils.validatePng(image.data, self.debugAssert.bind(self));
        });
    }

    var self = this;
    try {
        var results = [];

        images.forEach(function(image) {
            if (image.iv) {
                var result = decryptImage.call(self, image, key);
                results.push(result);            
            }
        });

        return Promise.all(results);
    } catch (e) {
        self._logger.error('decrypterror', e);
        return Promise.reject(e);
    }
}

module.exports = ImageStream;
},{"100":100,"42":42,"91":91,"96":96}],100:[function(require,module,exports){
module.exports = {
    compareIndexId: compareIndexId,
    createSubtitleEntryForPublic: createSubtitleEntryForPublic,
    getDownloadId: getDownloadId,
    validatePng: validatePng,
    isDefined: isDefined,
    searchArrayEntryById: searchArrayEntryById,
    durationOfNextContiguousEntries: durationOfNextContiguousEntries,
    getErrorData: getErrorData,
    assert: assert
};
function compareIndexId(sIndexId, mIndexId, logger) {
    for (var i = 0; i < sIndexId.length; i++) {
        if (sIndexId[i] !== mIndexId[i]) {
            logger.error('indexId mismatch in sidx', {
                'sIndexId': sIndexId,
                'mIndexId': mIndexId
            });
            // capture it and see how often we get this. 
            //if this is a problem, then add more logging to address this.
            return false;
        }
    }
    return true;
}

function createSubtitleEntryForPublic(entry, imageData, midx) {
    var subtitle = {};
    subtitle['displayTime'] = entry.displayTime;
    subtitle['duration'] = entry.duration;
    subtitle['originX'] = entry.originX;
    subtitle['originY'] = entry.originY;
    subtitle['sizeX'] = entry.sizeX;
    subtitle['sizeY'] = entry.sizeY;
    subtitle['imageData'] = imageData;
    subtitle['id'] = entry.imageStartPosition;
    subtitle['rootContainerExtentX'] = midx.rootContainerExtentX;
    subtitle['rootContainerExtentY'] = midx.rootContainerExtentY;
    return subtitle;
}

function getDownloadId(offset, size) {
    return ('o_' + offset + 's_' + size);
}

function validatePng(img, debugAssert) {
    debugAssert(String.fromCharCode(img[1]) == 'P');
    debugAssert(String.fromCharCode(img[2]) == 'N');
    debugAssert(String.fromCharCode(img[3]) == 'G');
}

function isDefined(x) {
    return (typeof x !== 'undefined');
}

function searchArrayEntryById(arr, id) {
    return arr.some(function(entry) {
        return entry['id'] === id;
    });
}

function durationOfNextContiguousEntries(entries, entry) {
    return entries
        .filter(sameAndContiguous.bind(null, entry))
        .map(pluckDurations)
        .reduce(aggregateDurations, 0);
}

function sameAndContiguous(base, current) {
    return base['id'] === current['id'] && (base['displayTime'] + base['duration'] === current['displayTime']);
}

function pluckDurations(entry) {
    return entry['duration'];
}

function aggregateDurations(acc, curr) {
    return acc + curr;
}

function getErrorData(err, errorString) {
    var errorData = Object.create({});
    for (var i in err) {
        errorData[i] = err[i];
    }
    if (err instanceof Error) {
        errorData['message'] = err['message']; // because they are non enumerable props
        errorData['stack'] = err['stack'];
    }

    errorData['errorString'] = errorString;
    return errorData;
}

/**
 * @param {boolean} flag
 * @param {Object=} logger
 */
function assert(flag, logger) {
    if (!flag) {
        logger && logger.error((new Error('Assertion Failed')).stack);
        throw new Error('Assertion Failed');
    }
}


},{}],101:[function(require,module,exports){
/* global setTimeout, clearTimeout, console */

var EventEmitter = require(42).EventEmitter;
var type = require(102)({});
var MAX_REBUFFER_TIMEOUT = 2000;

/**
* @constructor
* getPts returns the current pts from the media object
* getSubtitles(pts) returns the all currently presenting subtitles, plus
* the first one starting after the input pts
*/
var SubtitleTimer = function SubtitleTimer(getPts, getSubtitles, logger) {
    if (!(this instanceof SubtitleTimer)) {
        return new SubtitleTimer(getPts, getSubtitles, logger);
    }

    EventEmitter.call(this);

    var self = this;

    self._getPts       = getPts;
    self._getSubtitles = getSubtitles;
    self._showing      = [];
    self._staging      = [];
    self._logger       = logger || console;
};

SubtitleTimer.prototype = Object.create(EventEmitter.prototype);

SubtitleTimer.prototype.stop = function stop () {
    var self = this;
    clearTimeout(self._timer);

    // remove all subtitles
    self._showing.forEach(function (entry) {
        self.emit("removesubtitle", entry);
    });
    self._showing = [];
};

SubtitleTimer.prototype.pause = function pause () {
    clearTimeout(this._timer);
};

SubtitleTimer.prototype.updatePts = function updatePts (eventPts, rebufferCount) {
    var self = this;
    var pts  = self._getPts();
    var entryToStage;
    var rebufferTimeout;

    clearTimeout(this._timer);

    var entries = self._getSubtitles(pts);

    rebufferCount = typeof rebufferCount === "number" ? rebufferCount : 0;

    // check for removal
    self._showing.forEach(function (entry) {
        if (!isPresenting(entry, pts)) {
            self._showing = removeItem(self._showing, entry);
            self.emit("removesubtitle", entry);
        }
    });

    if (entries !== null && entries.length > 0) {
        // check for show
        entries.forEach(function (entry) {
            if (isPresenting(entry, pts) && !isShowing(entry, self._showing)) {
                self.emit("showsubtitle", entry);
                self._showing = addItem(self._showing, entry);
                self._staging = removeItem(self._staging, entry);
            }
        });

        entryToStage = entries[entries.length - 1];
        if (!isShowing(entryToStage, self._showing) && !isShowing(entryToStage, self._staging)) {
            self.emit("stagesubtitle", entryToStage);
            self._staging = addItem(self._staging, entryToStage);
        }

        var nexts = nextEvents(pts, entries);

        if (nexts.length > 0) {
            self._timer = setTimeout(function () {
                // fire off updatePts again
                self.updatePts(self._getPts());
            }, nexts[0].timeout);
        }
    } else {
        // in this case, entries was null so it's rebuffering
        // we need to schedule another updatePts in case we're not
        // called again
        rebufferTimeout = Math.pow(2, rebufferCount) * 250 < MAX_REBUFFER_TIMEOUT ? Math.pow(2, rebufferCount) * 250 : MAX_REBUFFER_TIMEOUT;

        self._logger.warn("rebuffering subtitles, checking buffer again in " + rebufferTimeout + "ms");

        self._timer = setTimeout(function () {
            self.updatePts(self._getPts(), rebufferCount + 1);
        }, rebufferTimeout);
    }
};

// given a list of entries, find the next event or events if more than
// one happens at the same time; an event is defined as a subtitle being
// removed or a subtitle being shown
function nextEvents(currentPts, entries) {
    return entries.reduce(nextEventsForEntry.bind(this, currentPts), []);
}

// return the current timeout, or the next timeout associated with an
// entry's events -- whichever is sooner. This assumes the end for a
// subtitle will always be after the start time
function nextEventsForEntry (currentPts, nextEvent, entry) {
    var startDelta = entry["displayTime"] - currentPts;
    var endDelta = endPts(entry) - currentPts;
    var timeout = nextEvent.length > 0 ? nextEvent[0].timeout : Infinity;

    if (0 < startDelta && startDelta < timeout) {
        return [ createEvent("showsubtitle", entry, startDelta) ];
    } else if (startDelta === timeout) {
        return nextEvent.concat([ createEvent("showsubtitle", entry, startDelta) ]);
    } else if (0 < endDelta && endDelta < timeout) {
        return [ createEvent("removesubtitle", entry, endDelta) ];
    } else if (endDelta === timeout) {
        return nextEvent.concat([ createEvent("removesubtitle", entry, endDelta) ]);
    } else {
        return nextEvent;
    }
}

function createEvent(type, entry, timeout) {
    return {
        timeout : timeout,
        type    : type,
        entry   : entry
    };
}

function endPts(subtitle) {
    return subtitle["displayTime"] + subtitle.duration;
}

function isShowing(subtitle, showingList) {
    return showingList.map(function (subtitle) {
        return subtitle["id"];
    }).indexOf(subtitle["id"]) > - 1;
}

function isPresenting(subtitle, pts) {
    return subtitle["displayTime"] <= pts && pts < endPts(subtitle);
}

function removeItem(list, item) {
    return list.filter(function (entry) { return entry !== item; });
}

function addItem(list, item) {
    return list.concat([item]);
}

module.exports = type(["function", "function", "object"], SubtitleTimer);

},{"102":102,"42":42}],102:[function(require,module,exports){
module.exports = function (extensions) {
    var jsTypes = [ "number", "boolean", "string", "object", "function", "symbol" ],
        extendedTypes;

    extendedTypes = {
        "array": function (arg) {
            return Array.isArray(arg);
        }
    };

    if (typeof extensions !== "undefined") {
        if (typeof extensions !== "object" || !areExtensions(extensions)) {
            throw new TypeError("Types: extensions must be an object of type definitions");
        }

        Object.keys(extensions).forEach(function (key) {
            if (typeof extendedTypes[key] !== "undefined" || typeof jsTypes[key] !== "undefined") {
                throw new TypeError("Types: attempting to override a built in type with " + key);
            }
            extendedTypes[key] = extensions[key];
        });
    }

    var allTypes = Object.keys(extendedTypes).concat(jsTypes);

    var type = function (types, f) {
        var typedFunc,
            invalidTypes;

        invalidTypes = types.filter(function (type) {
            return typeof type !== "object" && allTypes.indexOf(type) === -1;
        });

        invalidTypes = invalidTypes.concat(types.filter(function (type) {
            return typeof type === "object";
        }).reduce(function (invalid, curr) {
            return invalid.concat(Object.keys(curr).map(function (key) {
                return curr[key];
            }).filter(function (key) {
                return allTypes.indexOf(key) === -1;
            }));
        }, []));

        if (invalidTypes.length > 0) {
            throw new Error(invalidTypes.join(",") + " are invalid types");
        }

        typedFunc = function () {
            var args = Array.prototype.slice.call(arguments);

            if (args.length !== types.length) {
                throw new TypeError("Types: unexpected number of arguments");
            }

            types.forEach(function (type, index) {
                var arg = args[index],
                    counts;

                if (typeof type === "string") {
                    checkType(type, arg, { index: index });
                } else if (typeof type === "object") {
                    Object.keys(type).forEach(function (key) {
                        checkType(type[key], arg[key], { key: key });
                    });
                } else {
                    throw new Error("Types: unexpected type in type array");
                }
            });

            return f.apply(this, args);
        };

        return typedFunc;
    };

    var checkType = function (type, arg, keyOrIndex) {
        var extendedType = extendedTypes[type];

        if (typeof extendedType !== "undefined") {
            if (!extendedType(arg)) {
                error(type, arg, keyOrIndex);
            }
        } else if (type !== typeof arg) {
            error(type, arg, keyOrIndex);
        }
    };

    var error = function (type, arg, keyOrIndex) {
        var errorStr;

        if (typeof keyOrIndex.key !== "undefined") {
            errorStr = "Types: expected " + keyOrIndex.key;
        } else {
            errorStr = "Types: expected argument " + keyOrIndex.index;
        }

        errorStr += " to be '" + type + "' but found '" + arg + "'";

        throw new TypeError(errorStr);
    };

    return type (["array", "function"], type);
};


function areExtensions(obj) {
    return Object.keys(obj).every(function (key) {
        return typeof obj[key] === "function";
    });
}

},{}],103:[function(require,module,exports){
var _ = {
    isNumber:       function(x) {return typeof x === 'number';},
    isObject:       function(x) {return typeof x === 'object';},
    isString:       function(x) {return typeof x === 'string';},
    isUndefined:    function(x) {return typeof x === 'undefined';},
    isBoolean:      function(x) {return typeof x === 'boolean';},
    isFunction:     function(x) {return typeof x === 'function';},
    isNull:         function(x) {return x === null;},
    isArray:        function(x) {return Object.prototype.toString.call(x) === '[object Array]';},
    isFinite:       function(x) {return isFinite(x) && !isNaN(parseFloat(x)); },

    has:            function(obj, key) { return obj !== null && typeof obj !== "undefined" && Object.prototype.hasOwnProperty.call(obj, key); }

};

_.pairs = function (object) {
    var key,
        result = [];

    if (!_.isObject(object)) throw new TypeError("Object.pairs called on non-object");

    for (key in object) {
        if (object.hasOwnProperty(key)) {
            result.push([key,object[key]]);
        }
    }
    return result;
};

_.each = _.forEach = function(obj, iterator, context) {
    if (obj === null || typeof obj === "undefined") return obj;
    if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        iterator.call(context, obj[i], i, obj);
      }
    } else {
      for ( var key in obj ) {
        if ( _.has( obj, key ) ) iterator.call(context, obj[key], key, obj);
      }
    }
    return obj;
};

module.exports = _;

},{}]},{},[1]);


